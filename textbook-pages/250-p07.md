---

## Common Mistakes

### Mistake 1: Forgetting to Unsubscribe

```typescript
// Wrong: memory leak
ngOnInit() {
  this.filters$.subscribe(filters => { /* ... */ });
}

// Right: cleanup on destroy
ngOnDestroy() {
  this.subscription.unsubscribe();
}
```

### Mistake 2: Nested Subscribes

```typescript
// Wrong: callback hell, hard to manage
this.filters$.subscribe(filters => {
  this.apiAdapter.fetchData(filters).subscribe(response => {
    this.results = response.results;
  });
});

// Right: use operators to flatten
this.results$ = this.filters$.pipe(
  switchMap(filters => this.apiAdapter.fetchData(filters)),
  map(response => response.results)
);
```

### Mistake 3: Missing shareReplay

```typescript
// Wrong: each subscriber triggers separate API calls
this.results$ = this.filters$.pipe(
  switchMap(filters => this.apiAdapter.fetchData(filters))
);

// Right: share the result
this.results$ = this.filters$.pipe(
  switchMap(filters => this.apiAdapter.fetchData(filters)),
  shareReplay(1)
);
```

---

## Key Takeaways

1. **Observables model change over time** — Perfect for UI state that updates
2. **`switchMap` cancels previous operations** — Use for API calls from user input
3. **`shareReplay(1)` prevents duplicate work** — Always use when multiple components subscribe

---

## Acceptance Criteria

This is a teaching section with no code changes. Criteria are conceptual:

- [ ] You can explain why Observables fit state management
- [ ] You know when to use `switchMap` vs other flattening operators
- [ ] You understand what `shareReplay(1)` does and why it matters
- [ ] You can implement proper cleanup with `takeUntil` or async pipe

---

## Next Step

Proceed to `301-url-state-service.md` to create the first framework service using the RxJS patterns you just learned.