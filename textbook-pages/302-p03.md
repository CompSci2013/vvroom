```typescript
// src/app/framework/services/api.service.ts
// VERSION 1 (Section 302) - Domain-agnostic HTTP wrapper

import { Injectable } from '@angular/core';
import { HttpClient, HttpParams, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { ApiResponse, StandardApiResponse } from '../models/api-response.interface';

/**
 * Options for API requests
 *
 * Provides a simplified interface for common HTTP options.
 */
export interface ApiRequestOptions {
  /**
   * Query parameters to append to the URL
   * Arrays are serialized as comma-separated values
   */
  params?: Record<string, any>;

  /**
   * HTTP headers to include in the request
   */
  headers?: Record<string, string>;

  /**
   * Whether to include credentials (cookies) in the request
   */
  withCredentials?: boolean;

  /**
   * Response type (default: 'json')
   */
  responseType?: 'json' | 'text' | 'blob' | 'arraybuffer';
}

/**
 * Domain-agnostic API service for making HTTP requests
 *
 * This service provides a thin, type-safe wrapper around Angular's HttpClient.
 * It handles common patterns like query parameter serialization and error handling.
 *
 * **Design Philosophy:**
 *
 * 1. **Thin wrapper** - Doesn't add unnecessary abstraction over HttpClient
 * 2. **Type-safe** - Generic methods return typed observables
 * 3. **Domain-agnostic** - No domain-specific logic here
 * 4. **Error transformation** - Converts HTTP errors to consistent Error objects
 *
 * Domain-specific logic (like URL construction, response transformation) belongs
 * in domain adapters (created in Phase 5), not here.
 *
 * @example
 * ```typescript
 * // GET request with pagination
 * this.api.get<VehicleResult>('/api/vehicles', {
 *   params: { page: 1, size: 20, manufacturer: ['Ford', 'Toyota'] }
 * }).subscribe(response => {
 *   console.log(response.results);
 * });
 *
 * // POST request
 * this.api.post<VehicleResult>('/api/vehicles', {
 *   manufacturer: 'Ford',
 *   model: 'F-150'
 * }).subscribe(vehicle => {
 *   console.log('Created:', vehicle);
 * });
 * ```
 */
@Injectable({
  providedIn: 'root'
})
export class ApiService {
  /**
   * Constructor - injects HttpClient
   *
   * Using `readonly` to ensure the dependency isn't reassigned.
   */
  constructor(private readonly http: HttpClient) {}

  /**
   * Execute a GET request
   *
   * Returns the standard paginated API response format.
   *
   * @template TData - The type of items in the response
   * @param endpoint - API endpoint (absolute or relative URL)
   * @param options - Request options (params, headers, etc.)
   * @returns Observable of paginated response
   *
   * @example
   * ```typescript
   * this.api.get<VehicleResult>('/api/vehicles', {
   *   params: { page: 1, manufacturer: 'Ford' }
   * }).subscribe(response => {
   *   console.log(`Found ${response.total} vehicles`);
   *   console.log('Results:', response.results);
   * });
   * ```
   */
  get<TData>(
    endpoint: string,
    options?: ApiRequestOptions
  ): Observable<ApiResponse<TData>> {
    const httpParams = this.buildHttpParams(options?.params);

    return this.http
      .get<ApiResponse<TData>>(endpoint, {
        params: httpParams,
        headers: options?.headers,
        withCredentials: options?.withCredentials
      })
      .pipe(catchError(this.handleError));
  }

  /**
   * Execute a POST request
   *
   * @template TData - The type of response data
   * @param endpoint - API endpoint (absolute or relative URL)
   * @param body - Request body
   * @param options - Request options (params, headers, etc.)
   * @returns Observable of response data
   */
  post<TData>(
    endpoint: string,
    body: any,
    options?: ApiRequestOptions
  ): Observable<TData> {
    const httpParams = this.buildHttpParams(options?.params);

    return this.http
      .post<TData>(endpoint, body, {
        params: httpParams,
        headers: options?.headers,
        withCredentials: options?.withCredentials
      })
      .pipe(catchError(this.handleError));
  }

  /**
   * Execute a PUT request
   *
   * @template TData - The type of response data
   * @param endpoint - API endpoint (absolute or relative URL)
   * @param body - Request body
   * @param options - Request options (params, headers, etc.)
   * @returns Observable of response data
   */
  put<TData>(
    endpoint: string,
    body: any,
    options?: ApiRequestOptions
  ): Observable<TData> {
    const httpParams = this.buildHttpParams(options?.params);

    return this.http
      .put<TData>(endpoint, body, {
        params: httpParams,
        headers: options?.headers,
        withCredentials: options?.withCredentials
      })
      .pipe(catchError(this.handleError));
  }

  /**
   * Execute a PATCH request
   *
   * @template TData - The type of response data
   * @param endpoint - API endpoint (absolute or relative URL)
   * @param body - Request body
   * @param options - Request options (params, headers, etc.)
   * @returns Observable of response data
   */
  patch<TData>(
    endpoint: string,
    body: any,
    options?: ApiRequestOptions
  ): Observable<TData> {
    const httpParams = this.buildHttpParams(options?.params);

    return this.http
      .patch<TData>(endpoint, body, {
        params: httpParams,
        headers: options?.headers,
        withCredentials: options?.withCredentials
      })
      .pipe(catchError(this.handleError));
  }

  /**
   * Execute a DELETE request
   *
   * @template TData - The type of response data
   * @param endpoint - API endpoint (absolute or relative URL)
   * @param options - Request options (params, headers, etc.)
   * @returns Observable of response data
   */
  delete<TData>(
    endpoint: string,
    options?: ApiRequestOptions
  ): Observable<TData> {
    const httpParams = this.buildHttpParams(options?.params);

    return this.http
      .delete<TData>(endpoint, {
        params: httpParams,
        headers: options?.headers,
        withCredentials: options?.withCredentials
      })
      .pipe(catchError(this.handleError));
  }

  /**
   * Execute a GET request that returns a standard success/error response
   *
   * Some APIs wrap responses in a success/error envelope:
   * ```json
   * { "success": true, "data": { ... } }
   * { "success": false, "error": { "message": "..." } }
   * ```
   *
   * This method unwraps successful responses and throws on error.
   *
   * @template TData - The type of data in the response
   * @param endpoint - API endpoint (absolute or relative URL)
   * @param options - Request options (params, headers, etc.)
   * @returns Observable of response data (unwrapped from success envelope)
   */
  getStandard<TData>(
    endpoint: string,
    options?: ApiRequestOptions
  ): Observable<TData> {
    const httpParams = this.buildHttpParams(options?.params);

    return this.http
      .get<StandardApiResponse<TData>>(endpoint, {
        params: httpParams,
        headers: options?.headers,
        withCredentials: options?.withCredentials
      })
      .pipe(
        map(response => {
          if (response.success) {
            return response.data;
          } else {
            throw new Error(response.error.message);
          }
        }),
        catchError(this.handleError)
      );
  }

  /**
   * Build HttpParams from a plain object
   *
   * Handles:
   * - Null/undefined value filtering (skipped)
   * - Array serialization (comma-separated)
   * - Boolean/number to string conversion
   *
   * @param params - Plain object of query parameters
   * @returns HttpParams instance
   *
   * @example
   * ```typescript
   * // Input
   * { page: 1, manufacturer: ['Ford', 'Toyota'], active: true, empty: null }
   *
   * // Output HttpParams
   * page=1&manufacturer=Ford,Toyota&active=true
   * // Note: 'empty' is skipped because it's null
   * ```
   */
  private buildHttpParams(params?: Record<string, any>): HttpParams {
    let httpParams = new HttpParams();

    if (!params) {
      return httpParams;
    }

    Object.keys(params).forEach(key => {
      const value = params[key];

      // Skip null/undefined values
      if (value === null || value === undefined) {
        return;
      }

      // Handle arrays (comma-separated)
      if (Array.isArray(value)) {
        httpParams = httpParams.set(key, value.join(','));
        return;
      }

      // Convert to string
      httpParams = httpParams.set(key, String(value));
    });

    return httpParams;
  }

  /**
   * Handle HTTP errors
   *
   * Transforms HttpErrorResponse into a consistent Error format.
   * Logs the error for debugging, then re-throws for upstream handling.
   *
   * @param error - HTTP error response
   * @returns Observable that throws a formatted error
   */
  private handleError(error: HttpErrorResponse): Observable<never> {
    let errorMessage = 'An unknown error occurred';

    if (error.error instanceof ErrorEvent) {
      // Client-side or network error
      errorMessage = `Network error: ${error.error.message}`;
    } else {
      // Backend error
      if (error.error?.error?.message) {
        // Structured error response: { error: { message: "..." } }
        errorMessage = error.error.error.message;
      } else if (error.error?.message) {
        // Simple error response: { message: "..." }
        errorMessage = error.error.message;
      } else if (error.message) {
        // HttpErrorResponse message
        errorMessage = error.message;
      } else {
        // Fallback to status
        errorMessage = `Server error: ${error.status} ${error.statusText}`;
      }
    }

    console.error('API Error:', errorMessage, error);

    return throwError(() => new Error(errorMessage));
  }
}
```