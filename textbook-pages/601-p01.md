# 601: Filter Definitions

**Status:** Planning
**Depends On:** 401-automobile-filters-model, 203-filter-definition-interface
**Blocks:** 604-query-control-filters, 607-domain-config-assembly

---

## Learning Objectives

After completing this section, you will:
- Understand how declarative filter definitions drive UI component generation
- Know how to configure different filter types (autocomplete, range, multiselect, text)
- Recognize the pattern of separating filter metadata from filter state

---

## Objective

Create the automobile filter definitions array that tells the Query Panel component which filters to display and how to configure them. These definitions are pure data — they describe what filters exist, not how to render them.

---

## Why

In traditional applications, you might create a separate component for each filter: ManufacturerFilterComponent, YearRangeFilterComponent, BodyClassFilterComponent. This approach leads to:

1. **Code duplication** — Each filter component has similar structure (label, input, validation)
2. **Tight coupling** — Adding a new filter requires writing new component code
3. **Inconsistent UX** — Different developers implement filters differently

The configuration-driven approach solves these problems:

1. **Single component, multiple instances** — One QueryPanelComponent renders all filters
2. **Loose coupling** — Adding a new filter means adding a new object to an array
3. **Consistent UX** — All filters use the same rendering logic

**This is the Phase 6 "Aha Moment":** Configuration is declarative code. You describe what you want, not how to get it. The filter definitions say "I need an autocomplete for manufacturer with these options" — they don't say "create an input element, attach a keyup listener, debounce for 300ms, call the API..."

### Angular Style Guide References

- [Style 03-01](https://angular.io/guide/styleguide#style-03-01): Use consistent naming for symbols
- Configuration objects are a recognized Angular pattern for customizing component behavior