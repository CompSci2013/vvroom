---

## Generic Constraints

Sometimes you need to limit what types can be used as a parameter.

### The Problem

```typescript
function getLength<T>(item: T): number {
  return item.length;  // Error: Property 'length' does not exist on type 'T'
}
```

TypeScript doesn't know that `T` has a `length` property. What if someone passes a number?

### The Solution: extends

```typescript
interface HasLength {
  length: number;
}

function getLength<T extends HasLength>(item: T): number {
  return item.length;  // Now TypeScript knows T has 'length'
}

getLength('hello');     // OK - strings have length
getLength([1, 2, 3]);   // OK - arrays have length
getLength(42);          // Error - numbers don't have length
```

The `extends` keyword constrains `T` to types that have a `length` property.

### Constraints in vvroom

In Phase 2, you'll see constraints like:

```typescript
interface IApiAdapter<TFilters, TData, TStatistics = any> {
  fetchData(filters: TFilters): Observable<ApiResponse<TData>>;
  // ...
}
```

The `= any` provides a default type. If you don't specify `TStatistics`, it defaults to `any`.

---

## Applying Generics: A Preview of Phase 2

Here's how vvroom uses generics. Don't memorize this â€” just recognize the patterns.

### The DomainConfig Interface

```typescript
export interface DomainConfig<TFilters, TData, TStatistics> {
  // Identity
  domainKey: string;
  displayName: string;

  // Type references (so the framework knows what types to expect)
  filterModel: Type<TFilters>;
  dataModel: Type<TData>;

  // Adapters (these use the same type parameters)
  apiAdapter: IApiAdapter<TFilters, TData, TStatistics>;
  urlMapper: IFilterUrlMapper<TFilters>;

  // UI configuration
  tableConfig: TableConfig<TData>;
}
```

**Reading this signature:**

1. `DomainConfig` takes three type parameters
2. `TFilters` flows through to `urlMapper` and `apiAdapter`
3. `TData` flows through to `apiAdapter` and `tableConfig`
4. `TStatistics` flows through to `apiAdapter`

### Using the Interface

When we create the automobile domain config:

```typescript
const AUTOMOBILE_CONFIG: DomainConfig<
  AutomobileFilters,    // TFilters = AutomobileFilters
  VehicleResult,        // TData = VehicleResult
  VehicleStatistics     // TStatistics = VehicleStatistics
> = {
  domainKey: 'automobile',
  displayName: 'Automobiles',
  filterModel: AutomobileFilters,
  dataModel: VehicleResult,
  apiAdapter: new AutomobileApiAdapter(),
  urlMapper: new AutomobileUrlMapper(),
  tableConfig: automobileTableConfig,
};
```

Now TypeScript knows:
- `urlMapper` must accept `AutomobileFilters`
- `tableConfig` must work with `VehicleResult`
- `apiAdapter` must return `VehicleStatistics`

If any of these are wrong, TypeScript catches the error at compile time.