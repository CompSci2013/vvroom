# 607: Domain Config Assembly

**Status:** Planning
**Depends On:** 201-domain-config-interface, 401-403 (models), 501-503 (adapters), 601-606 (configs)
**Blocks:** 608-domain-providers, 902-automobile-landing

---

## Learning Objectives

After completing this section, you will:
- Understand how the domain config factory pattern assembles all domain pieces
- Know how Angular's Injector enables runtime dependency resolution
- Recognize the complete structure of a DomainConfig object

---

## Objective

Create the automobile domain configuration factory function that assembles all models, adapters, and UI configurations into a single DomainConfig object. This is the central integration point for everything automobile-related.

---

## Why

Throughout Phase 4, 5, and 6, you created many separate pieces:

**Phase 4 (Models):**
- AutoSearchFilters
- VehicleResult
- VehicleStatistics

**Phase 5 (Adapters):**
- AutomobileUrlMapper
- AutomobileApiAdapter
- AutomobileCacheKeyBuilder

**Phase 6 (Configs):**
- AUTOMOBILE_FILTER_DEFINITIONS
- AUTOMOBILE_TABLE_CONFIG
- AUTOMOBILE_PICKER_CONFIGS (factory)
- AUTOMOBILE_QUERY_CONTROL_FILTERS
- AUTOMOBILE_HIGHLIGHT_FILTERS
- AUTOMOBILE_CHART_CONFIGS

Now you need to assemble these pieces into a single object that the framework can consume.

**Why a factory function instead of a constant?**

Some pieces need Angular services (like ApiService for the ApiAdapter and pickers). Angular's dependency injection provides services at runtime, not at module load time. A factory function receives the Injector and can resolve dependencies dynamically.

```typescript
// This won't work - ApiService isn't available at import time
export const DOMAIN_CONFIG = {
  apiAdapter: new AutomobileApiAdapter(apiService) // Error: apiService undefined
};

// This works - Injector provides ApiService at runtime
export function createAutomobileDomainConfig(injector: Injector) {
  const apiService = injector.get(ApiService);
  return {
    apiAdapter: new AutomobileApiAdapter(apiService)
  };
}
```