```typescript
// src/app/framework/services/url-state.service.ts
// VERSION 1 (Section 301) - URL-First state management foundation

import { Injectable, NgZone } from '@angular/core';
import { Router, ActivatedRoute, Params, NavigationEnd } from '@angular/router';
import { Observable, BehaviorSubject } from 'rxjs';
import { map, distinctUntilChanged, filter } from 'rxjs/operators';

/**
 * Domain-agnostic URL state management service
 *
 * Provides bidirectional synchronization between application state and URL query parameters.
 * The URL serves as the single source of truth for application state.
 *
 * **Key Design Decisions:**
 *
 * 1. Uses Router.events instead of ActivatedRoute.queryParams because this is a
 *    root-level singleton service. ActivatedRoute at root level doesn't receive
 *    query param updates from child routes (like /discover).
 *
 * 2. Uses Router.url and parseUrl() instead of ActivatedRoute.snapshot.queryParams
 *    for the same reason â€” to capture the full URL including child route params.
 *
 * 3. Uses BehaviorSubject to provide:
 *    - Synchronous access to current params via getParams()
 *    - Observable stream for reactive updates via watchParams()
 *    - Immediate value emission to new subscribers
 *
 * @example
 * ```typescript
 * // In a component
 * constructor(private urlState: UrlStateService) {
 *   // Watch for changes reactively
 *   this.urlState.watchParams<MyFilters>().subscribe(filters => {
 *     console.log('Filters changed:', filters);
 *   });
 *
 *   // Get current value synchronously
 *   const current = this.urlState.getParams<MyFilters>();
 *
 *   // Update URL (triggers navigation)
 *   this.urlState.setParams({ page: 2, search: 'ford' });
 * }
 * ```
 */
@Injectable({
  providedIn: 'root'
})
export class UrlStateService {
  /**
   * BehaviorSubject holding current URL query parameters
   *
   * BehaviorSubject is used instead of Subject because:
   * 1. It holds the current value, enabling synchronous getParams()
   * 2. New subscribers immediately receive the current value
   * 3. It requires an initial value (empty object)
   */
  private paramsSubject = new BehaviorSubject<Params>({});

  /**
   * Public observable stream of URL query parameters
   *
   * Components subscribe to this to react to URL changes.
   */
  public params$: Observable<Params> = this.paramsSubject.asObservable();

  /**
   * Constructor - sets up URL synchronization
   *
   * @param router - Angular Router for navigation and URL parsing
   * @param route - ActivatedRoute for relative navigation
   * @param ngZone - NgZone for ensuring change detection runs
   */
  constructor(
    private router: Router,
    private route: ActivatedRoute,
    private ngZone: NgZone
  ) {
    // Initialize from current URL on service creation
    this.initializeFromRoute();

    // Watch for all future URL changes
    this.watchRouteChanges();
  }

  /**
   * Get current URL query parameters as a typed object
   *
   * Provides synchronous access to the current URL state.
   * Use this when you need the current value without subscribing.
   *
   * @template TParams - The shape of the parameters object
   * @returns Current query parameters cast to TParams
   *
   * @example
   * ```typescript
   * interface MyFilters {
   *   search: string;
   *   page: number;
   * }
   *
   * const filters = urlState.getParams<MyFilters>();
   * console.log(filters.search); // Type-safe access
   * ```
   */
  getParams<TParams = Params>(): TParams {
    return this.paramsSubject.value as TParams;
  }

  /**
   * Update URL query parameters
   *
   * Performs a shallow merge with existing parameters and navigates to the new URL.
   * Use null or undefined to remove a parameter.
   *
   * @template TParams - The shape of the parameters object
   * @param params - Partial parameters to update
   * @param replaceUrl - If true, replaces current history entry instead of pushing
   * @returns Promise that resolves when navigation completes
   *
   * @example
   * ```typescript
   * // Update specific params
   * await urlState.setParams({ page: 2, search: 'test' });
   *
   * // Remove a param by setting to null
   * await urlState.setParams({ search: null });
   *
   * // Replace history entry (no new back button entry)
   * await urlState.setParams({ page: 1 }, true);
   * ```
   */
  async setParams<TParams = Params>(
    params: Partial<TParams>,
    replaceUrl = false
  ): Promise<boolean> {
    const currentParams = this.paramsSubject.value;
    const mergedParams = { ...currentParams };

    // Merge new params, removing null/undefined values
    Object.keys(params).forEach(key => {
      const value = (params as any)[key];
      if (value === null || value === undefined) {
        delete mergedParams[key];
      } else {
        mergedParams[key] = value;
      }
    });

    return await this.router.navigate([], {
      relativeTo: this.route,
      queryParams: mergedParams,
      replaceUrl,
      queryParamsHandling: '' // Use exact params, don't preserve
    });
  }

  /**
   * Watch URL query parameters as an observable stream
   *
   * Returns an observable that emits whenever URL query parameters change.
   * Uses distinctUntilChanged to prevent duplicate emissions.
   *
   * @template TParams - The shape of the parameters object
   * @returns Observable of query parameters
   *
   * @example
   * ```typescript
   * urlState.watchParams<MyFilters>().subscribe(filters => {
   *   console.log('URL changed:', filters);
   *   this.loadData(filters);
   * });
   * ```
   */
  watchParams<TParams = Params>(): Observable<TParams> {
    return this.params$.pipe(
      map(params => params as TParams),
      distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b))
    );
  }

  /**
   * Clear all URL query parameters
   *
   * Navigates to the current path with empty query string.
   *
   * @param replaceUrl - If true, replaces current history entry
   * @returns Promise that resolves when navigation completes
   */
  async clearParams(replaceUrl = false): Promise<boolean> {
    return this.router.navigate([], {
      relativeTo: this.route,
      queryParams: {},
      replaceUrl
    });
  }

  /**
   * Get a specific query parameter value
   *
   * @param key - Parameter key
   * @returns Parameter value or null if not found
   */
  getParam(key: string): any {
    return this.paramsSubject.value[key] || null;
  }

  /**
   * Set a specific query parameter
   *
   * Convenience method for updating a single parameter.
   *
   * @param key - Parameter key
   * @param value - Parameter value (null to remove)
   * @param replaceUrl - If true, replaces current history entry
   * @returns Promise that resolves when navigation completes
   */
  async setParam(
    key: string,
    value: any,
    replaceUrl = false
  ): Promise<boolean> {
    return this.setParams({ [key]: value } as any, replaceUrl);
  }

  /**
   * Check if a specific parameter exists in the URL
   *
   * @param key - Parameter key
   * @returns True if parameter exists
   */
  hasParam(key: string): boolean {
    return key in this.paramsSubject.value;
  }

  /**
   * Watch a specific parameter for changes
   *
   * @param key - Parameter key to watch
   * @returns Observable of parameter value
   */
  watchParam(key: string): Observable<any> {
    return this.params$.pipe(
      map(params => params[key] || null),
      distinctUntilChanged()
    );
  }

  /**
   * Serialize parameters to URL query string
   *
   * Utility method for converting params object to query string format.
   *
   * @param params - Parameters object
   * @returns Query string (without leading '?')
   */
  serializeParams(params: Params): string {
    const queryParams = new URLSearchParams();

    Object.keys(params).forEach(key => {
      const value = params[key];

      // Skip null/undefined
      if (value === null || value === undefined) {
        return;
      }

      // Handle arrays (comma-separated)
      if (Array.isArray(value)) {
        queryParams.set(key, value.join(','));
        return;
      }

      // Convert to string
      queryParams.set(key, String(value));
    });

    return queryParams.toString();
  }

  /**
   * Deserialize URL query string to parameters object
   *
   * Utility method for parsing query string to params object.
   * Automatically converts numeric and boolean strings.
   *
   * @param queryString - Query string (with or without leading '?')
   * @returns Parameters object
   */
  deserializeParams(queryString: string): Params {
    const params: Params = {};
    const urlParams = new URLSearchParams(
      queryString.startsWith('?') ? queryString.slice(1) : queryString
    );

    urlParams.forEach((value, key) => {
      // Try to parse as number
      if (!isNaN(Number(value)) && value !== '') {
        params[key] = Number(value);
        return;
      }

      // Try to parse as boolean
      if (value === 'true' || value === 'false') {
        params[key] = value === 'true';
        return;
      }

      // Check for comma-separated values (arrays)
      if (value.includes(',')) {
        params[key] = value.split(',');
        return;
      }

      // Keep as string
      params[key] = value;
    });

    return params;
  }

  /**
   * Initialize from current route
   *
   * Called once in constructor to set initial state from URL.
   *
   * IMPORTANT: Uses router.url instead of route.snapshot because UrlStateService
   * is a root singleton. Root-level ActivatedRoute.snapshot may not have query
   * params from child routes (like /discover). router.url contains the full URL.
   */
  private initializeFromRoute(): void {
    const params = this.extractQueryParams();
    this.ngZone.run(() => {
      this.paramsSubject.next(params);
    });
  }

  /**
   * Watch for route changes and update internal state
   *
   * Sets up subscription to Router.events for ongoing synchronization.
   *
   * IMPORTANT: Uses Router.events instead of ActivatedRoute.queryParams because
   * UrlStateService is a root singleton. Root-level ActivatedRoute doesn't receive
   * query param updates from child routes (like /discover). Router.events is global
   * and captures all navigation events including query parameter changes.
   */
  private watchRouteChanges(): void {
    this.router.events
      .pipe(
        // Only process NavigationEnd events (route change complete)
        filter((event): event is NavigationEnd => event instanceof NavigationEnd),
        // Extract query params from the new URL
        map(() => this.extractQueryParams()),
        // Only emit if params actually changed
        distinctUntilChanged((a, b) => JSON.stringify(a) === JSON.stringify(b))
      )
      .subscribe(params => {
        // Use NgZone.run to ensure change detection runs
        this.ngZone.run(() => {
          this.paramsSubject.next(params);
        });
      });
  }

  /**
   * Extract query parameters from current router state
   *
   * Uses router.parseUrl() to reliably extract query params
   * regardless of the route hierarchy.
   */
  private extractQueryParams(): Params {
    const urlTree = this.router.parseUrl(this.router.url);
    return urlTree.queryParams;
  }
}
```