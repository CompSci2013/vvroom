```typescript
// src/app/framework/components/column-manager/column-manager.component.ts
// VERSION 1 (Section 807) - Table column visibility manager

import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  EventEmitter,
  Input,
  OnDestroy,
  OnInit,
  Output
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';

import { DragDropModule, CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';
import { CheckboxModule } from 'primeng/checkbox';
import { ButtonModule } from 'primeng/button';
import { DialogModule } from 'primeng/dialog';
import { TooltipModule } from 'primeng/tooltip';

import { TableColumn } from '../../models/table-config.interface';
import { ColumnState, ColumnConfigEvent } from './column-manager.interface';

/**
 * Column Manager Component
 *
 * Provides UI for managing table column visibility and order.
 * Persists settings to localStorage.
 *
 * @example
 * ```html
 * <app-column-manager
 *   [columns]="tableConfig.columns"
 *   [domainId]="'automobile'"
 *   (columnConfigChange)="onColumnConfigChange($event)">
 * </app-column-manager>
 * ```
 */
@Component({
  selector: 'app-column-manager',
  templateUrl: './column-manager.component.html',
  styleUrls: ['./column-manager.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class ColumnManagerComponent implements OnInit, OnDestroy {

  /**
   * Available columns from table config
   */
  @Input() columns: TableColumn[] = [];

  /**
   * Domain ID for localStorage key
   */
  @Input() domainId = 'default';

  /**
   * Minimum number of visible columns required
   */
  @Input() minVisibleColumns = 1;

  /**
   * Emits when column configuration changes
   */
  @Output() columnConfigChange = new EventEmitter<ColumnConfigEvent>();

  /**
   * Whether the column manager dialog is visible
   */
  dialogVisible = false;

  /**
   * Column states for the manager UI
   */
  columnStates: ColumnState[] = [];

  private readonly STORAGE_KEY_PREFIX = 'vvroom_columns_';

  constructor(private readonly cdr: ChangeDetectorRef) {}

  // ============================================================================
  // Lifecycle
  // ============================================================================

  ngOnInit(): void {
    this.loadColumnStates();
    this.emitCurrentConfig();
  }

  ngOnDestroy(): void {
    // Save on destroy in case of unsaved changes
    this.saveColumnStates();
  }

  // ============================================================================
  // Dialog Management
  // ============================================================================

  /**
   * Open the column manager dialog
   */
  openDialog(): void {
    this.dialogVisible = true;
    this.cdr.markForCheck();
  }

  /**
   * Close the dialog and save changes
   */
  closeDialog(): void {
    this.saveColumnStates();
    this.emitCurrentConfig();
    this.dialogVisible = false;
    this.cdr.markForCheck();
  }

  // ============================================================================
  // Column State Management
  // ============================================================================

  /**
   * Load column states from localStorage or initialize from input columns
   */
  private loadColumnStates(): void {
    const storageKey = this.STORAGE_KEY_PREFIX + this.domainId;
    const savedStates = localStorage.getItem(storageKey);

    if (savedStates) {
      try {
        const parsed: ColumnState[] = JSON.parse(savedStates);

        // Merge saved states with current columns
        // (handles new columns added since last save)
        this.columnStates = this.mergeColumnStates(parsed);
      } catch {
        // Invalid JSON, initialize fresh
        this.initializeColumnStates();
      }
    } else {
      this.initializeColumnStates();
    }
  }

  /**
   * Initialize column states from input columns
   */
  private initializeColumnStates(): void {
    this.columnStates = this.columns.map((col, index) => ({
      field: col.field,
      visible: col.hidden !== true,
      order: index
    }));
  }

  /**
   * Merge saved states with current columns
   */
  private mergeColumnStates(savedStates: ColumnState[]): ColumnState[] {
    const savedByField = new Map(savedStates.map(s => [s.field, s]));
    const merged: ColumnState[] = [];

    // Add states for all current columns
    this.columns.forEach((col, index) => {
      const saved = savedByField.get(col.field);
      if (saved) {
        merged.push({ ...saved });
        savedByField.delete(col.field);
      } else {
        // New column not in saved states
        merged.push({
          field: col.field,
          visible: col.hidden !== true,
          order: index + 1000 // Put new columns at end
        });
      }
    });

    // Sort by order
    merged.sort((a, b) => a.order - b.order);

    // Normalize order values
    merged.forEach((state, index) => {
      state.order = index;
    });

    return merged;
  }

  /**
   * Save column states to localStorage
   */
  private saveColumnStates(): void {
    const storageKey = this.STORAGE_KEY_PREFIX + this.domainId;
    localStorage.setItem(storageKey, JSON.stringify(this.columnStates));
  }

  // ============================================================================
  // Event Handlers
  // ============================================================================

  /**
   * Handle visibility checkbox change
   */
  onVisibilityChange(state: ColumnState): void {
    // Enforce minimum visible columns
    const visibleCount = this.columnStates.filter(s => s.visible).length;
    if (!state.visible && visibleCount <= this.minVisibleColumns) {
      // Can't hide, restore visible state
      state.visible = true;
      this.cdr.markForCheck();
      return;
    }

    this.cdr.markForCheck();
  }

  /**
   * Handle drag-drop reordering
   */
  onColumnDrop(event: CdkDragDrop<ColumnState[]>): void {
    moveItemInArray(this.columnStates, event.previousIndex, event.currentIndex);

    // Update order values
    this.columnStates.forEach((state, index) => {
      state.order = index;
    });

    this.cdr.markForCheck();
  }

  /**
   * Show all columns
   */
  showAll(): void {
    this.columnStates.forEach(state => {
      state.visible = true;
    });
    this.cdr.markForCheck();
  }

  /**
   * Reset to default column configuration
   */
  resetToDefault(): void {
    this.initializeColumnStates();
    this.cdr.markForCheck();
  }

  // ============================================================================
  // Output
  // ============================================================================

  /**
   * Emit current column configuration
   */
  private emitCurrentConfig(): void {
    // Build visible columns in order
    const visibleColumns: TableColumn[] = [];
    const columnsByField = new Map(this.columns.map(c => [c.field, c]));

    this.columnStates
      .filter(state => state.visible)
      .forEach(state => {
        const column = columnsByField.get(state.field);
        if (column) {
          visibleColumns.push(column);
        }
      });

    const event: ColumnConfigEvent = {
      visibleColumns,
      allColumnStates: [...this.columnStates]
    };

    this.columnConfigChange.emit(event);
  }

  // ============================================================================
  // Template Helpers
  // ============================================================================

  /**
   * Get column definition for a state
   */
  getColumn(state: ColumnState): TableColumn | undefined {
    return this.columns.find(c => c.field === state.field);
  }

  /**
   * Check if a column can be hidden
   */
  canHide(state: ColumnState): boolean {
    const visibleCount = this.columnStates.filter(s => s.visible).length;
    return state.visible && visibleCount > this.minVisibleColumns;
  }
}
```