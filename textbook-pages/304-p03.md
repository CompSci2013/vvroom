```typescript
// src/app/framework/services/domain-config-registry.service.ts
// VERSION 1 (Section 304) - Domain configuration registry

import { Injectable, InjectionToken, Injector, Provider } from '@angular/core';
import { DomainConfig } from '../models/domain-config.interface';
import { DomainConfigValidator } from './domain-config-validator.service';

/**
 * Injection token for domain configuration
 *
 * Used to provide domain-specific configuration to components.
 * The value is typically retrieved from DomainConfigRegistry.
 *
 * @example
 * ```typescript
 * // In domain module providers
 * providers: [
 *   {
 *     provide: DOMAIN_CONFIG,
 *     useFactory: (registry: DomainConfigRegistry) => registry.getActive(),
 *     deps: [DomainConfigRegistry]
 *   }
 * ]
 *
 * // In component
 * constructor(
 *   @Inject(DOMAIN_CONFIG) private domainConfig: DomainConfig<any, any, any>
 * ) {}
 * ```
 */
export const DOMAIN_CONFIG = new InjectionToken<DomainConfig<any, any, any>>(
  'Domain Configuration'
);

/**
 * Domain configuration registry service
 *
 * Centralized registry for managing multiple domain configurations.
 * Supports registering, retrieving, and switching between domains.
 *
 * **Why a Registry?**
 *
 * 1. **Multi-domain support** — Register multiple domains, switch at runtime
 * 2. **Validation** — Catch configuration errors early
 * 3. **Type safety** — Generic methods preserve type information
 * 4. **Centralized access** — Single point for all domain config access
 *
 * **Typical Usage Flow:**
 *
 * 1. App initializes → Register domain configs
 * 2. User navigates → Framework gets active config
 * 3. User switches domain → Registry changes active
 * 4. Framework components → Inject DOMAIN_CONFIG token
 *
 * @example
 * ```typescript
 * // Register domains at app initialization
 * registry.register(AUTOMOBILE_DOMAIN_CONFIG);
 * registry.register(REAL_ESTATE_DOMAIN_CONFIG);
 *
 * // Get active domain config
 * const config = registry.getActive();
 *
 * // Switch active domain
 * registry.setActive('real-estate');
 *
 * // List all registered domains
 * const domains = registry.getAllDomainNames(); // ['automobile', 'real-estate']
 *
 * // Get specific domain by name
 * const autoConfig = registry.get<AutoFilters, AutoData>('automobile');
 * ```
 */
@Injectable({
  providedIn: 'root'
})
export class DomainConfigRegistry {
  /**
   * Storage for registered domain configurations
   *
   * Maps domain name (e.g., 'automobile') to DomainConfig instance.
   */
  private configs = new Map<string, DomainConfig<any, any, any>>();

  /**
   * Currently active domain name
   *
   * Set to first registered domain by default.
   * Can be changed via setActive().
   */
  private activeDomainName?: string;

  /**
   * Constructor - injects validator
   *
   * @param validator - Service for validating domain configurations
   */
  constructor(private validator: DomainConfigValidator) {}

  /**
   * Register a domain configuration
   *
   * Validates the configuration (unless disabled) and adds it to the registry.
   * First registered domain becomes the active domain.
   *
   * @template TFilters - Filter model type
   * @template TData - Data model type
   * @template TStatistics - Statistics model type
   * @param config - Domain configuration to register
   * @param validate - Whether to validate configuration (default: true)
   * @throws Error if configuration is invalid (when validate=true)
   *
   * @example
   * ```typescript
   * // Register with validation
   * registry.register(AUTOMOBILE_DOMAIN_CONFIG);
   *
   * // Register without validation (e.g., in tests)
   * registry.register(TEST_CONFIG, false);
   * ```
   */
  register<TFilters, TData, TStatistics>(
    config: DomainConfig<TFilters, TData, TStatistics>,
    validate: boolean = true
  ): void {
    // Validate if requested
    if (validate) {
      const sanitizedConfig = this.validator.validateAndSanitize(config);
      config = sanitizedConfig as DomainConfig<TFilters, TData, TStatistics>;
    }

    // Check for duplicate (warn but allow overwrite)
    if (this.configs.has(config.domainName)) {
      console.warn(
        `Domain '${config.domainName}' already registered. Overwriting.`
      );
    }

    // Register the config
    this.configs.set(config.domainName, config);

    // Set as active if first domain
    if (!this.activeDomainName) {
      this.activeDomainName = config.domainName;
    }

    console.log(`Domain '${config.domainName}' registered successfully`);
  }

  /**
   * Register multiple domain configurations
   *
   * Convenience method for registering several domains at once.
   *
   * @param configs - Array of domain configurations
   * @param validate - Whether to validate configurations (default: true)
   */
  registerMultiple(
    configs: DomainConfig<any, any, any>[],
    validate: boolean = true
  ): void {
    configs.forEach((config) => this.register(config, validate));
  }

  /**
   * Get domain configuration by name
   *
   * @template TFilters - Filter model type
   * @template TData - Data model type
   * @template TStatistics - Statistics model type
   * @param domainName - Domain name to retrieve
   * @returns Domain configuration
   * @throws Error if domain not found
   *
   * @example
   * ```typescript
   * const config = registry.get<AutoFilters, VehicleResult>('automobile');
   * // config is typed as DomainConfig<AutoFilters, VehicleResult, any>
   * ```
   */
  get<TFilters, TData, TStatistics>(
    domainName: string
  ): DomainConfig<TFilters, TData, TStatistics> {
    const config = this.configs.get(domainName);

    if (!config) {
      const available = this.getAllDomainNames().join(', ');
      throw new Error(
        `Domain '${domainName}' not found. Available domains: ${available}`
      );
    }

    return config as DomainConfig<TFilters, TData, TStatistics>;
  }

  /**
   * Get active domain configuration
   *
   * Returns the currently active domain's configuration.
   *
   * @template TFilters - Filter model type
   * @template TData - Data model type
   * @template TStatistics - Statistics model type
   * @returns Active domain configuration
   * @throws Error if no domain is active
   */
  getActive<TFilters, TData, TStatistics>(): DomainConfig<
    TFilters,
    TData,
    TStatistics
  > {
    if (!this.activeDomainName) {
      throw new Error('No active domain. Register a domain first.');
    }

    return this.get<TFilters, TData, TStatistics>(this.activeDomainName);
  }

  /**
   * Set active domain
   *
   * Changes which domain is returned by getActive().
   *
   * @param domainName - Domain name to activate
   * @throws Error if domain not found
   */
  setActive(domainName: string): void {
    if (!this.configs.has(domainName)) {
      const available = this.getAllDomainNames().join(', ');
      throw new Error(
        `Cannot activate domain '${domainName}'. Available domains: ${available}`
      );
    }

    this.activeDomainName = domainName;
    console.log(`Active domain set to '${domainName}'`);
  }

  /**
   * Get active domain name
   *
   * @returns Active domain name or undefined if none
   */
  getActiveDomainName(): string | undefined {
    return this.activeDomainName;
  }

  /**
   * Check if domain is registered
   *
   * @param domainName - Domain name to check
   * @returns True if domain is registered
   */
  has(domainName: string): boolean {
    return this.configs.has(domainName);
  }

  /**
   * Get all registered domain names
   *
   * @returns Array of domain names
   */
  getAllDomainNames(): string[] {
    return Array.from(this.configs.keys());
  }

  /**
   * Get all registered domain configurations
   *
   * @returns Array of domain configurations
   */
  getAll(): DomainConfig<any, any, any>[] {
    return Array.from(this.configs.values());
  }

  /**
   * Unregister a domain
   *
   * Removes domain from registry. If it was active, activates the next available.
   *
   * @param domainName - Domain name to unregister
   * @returns True if domain was unregistered, false if not found
   */
  unregister(domainName: string): boolean {
    const result = this.configs.delete(domainName);

    // Handle active domain removal
    if (this.activeDomainName === domainName) {
      this.activeDomainName = undefined;

      // Set first remaining domain as active
      const remaining = this.getAllDomainNames();
      if (remaining.length > 0) {
        this.setActive(remaining[0]);
      }
    }

    if (result) {
      console.log(`Domain '${domainName}' unregistered`);
    }

    return result;
  }

  /**
   * Clear all registered domains
   */
  clear(): void {
    this.configs.clear();
    this.activeDomainName = undefined;
    console.log('All domains cleared');
  }

  /**
   * Get count of registered domains
   *
   * @returns Number of registered domains
   */
  getCount(): number {
    return this.configs.size;
  }

  /**
   * Validate a domain configuration without registering
   *
   * Useful for pre-validation before registration.
   *
   * @template TFilters - Filter model type
   * @template TData - Data model type
   * @template TStatistics - Statistics model type
   * @param config - Domain configuration to validate
   * @returns Validation result
   */
  validate<TFilters, TData, TStatistics>(
    config: DomainConfig<TFilters, TData, TStatistics>
  ) {
    return this.validator.validate(config);
  }

  /**
   * Get human-readable validation summary for a domain
   *
   * @param domainName - Domain name
   * @returns Validation summary string
   */
  getValidationSummary(domainName: string): string {
    const config = this.get(domainName);
    const result = this.validator.validate(config);
    return this.validator.getValidationSummary(result);
  }
}
```