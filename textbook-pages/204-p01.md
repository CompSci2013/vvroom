# 204: Table Config Interface

**Status:** Planning
**Depends On:** 201-domain-config-interface
**Blocks:** 602-table-config, 803-basic-results-table

---

## Learning Objectives

After completing this section, you will:
- Understand how configuration objects can drive complex UI components like data tables
- Know how to use TypeScript generics for type-safe column definitions
- Recognize the benefits of configuration-driven tables versus custom table components

---

## Objective

Create the `TableConfig` interface that defines how data tables are configured for display. This interface specifies columns, pagination, sorting, and other table behaviors — allowing the framework to render domain-appropriate tables without custom code.

---

## Why

Data tables are central to vvroom's UI. Users browse automobile data in tables, sort columns, paginate through results, and expand rows for details. Instead of building a custom table component for automobiles, we use PrimeNG Table with **configuration-driven behavior**.

**The problem with custom table components:**

```typescript
// Anti-pattern: Custom component for each domain
@Component({
  selector: 'automobile-table',
  template: `
    <p-table [value]="vehicles">
      <ng-template pTemplate="header">
        <tr>
          <th pSortableColumn="manufacturer">Manufacturer</th>
          <th pSortableColumn="model">Model</th>
          <th pSortableColumn="year">Year</th>
          <!-- Hard-coded for automobiles -->
        </tr>
      </ng-template>
    </p-table>
  `
})
export class AutomobileTableComponent { }
```

If you add a real estate domain, you'd need a completely new `RealEstateTableComponent`.

**The configuration-driven approach:**

```typescript
// Better: Generic component reads configuration
@Component({
  selector: 'results-table',
  template: `
    <p-table [value]="data" [columns]="config.columns">
      <ng-template pTemplate="header">
        <tr>
          <th *ngFor="let col of config.columns" [pSortableColumn]="col.field">
            {{ col.header }}
          </th>
        </tr>
      </ng-template>
    </p-table>
  `
})
export class ResultsTableComponent {
  @Input() config: TableConfig<any>;
  @Input() data: any[];
}
```

Now the same component works for any domain — just provide different configuration.