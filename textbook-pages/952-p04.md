### Template Literal Types

Create types from string patterns:

```typescript
type FilterKey = 'manufacturer' | 'year' | 'model';
type HighlightKey = `h_${FilterKey}`;
// 'h_manufacturer' | 'h_year' | 'h_model'

// Used in URL state management
function isHighlightParam(key: string): key is HighlightKey {
  return key.startsWith('h_');
}
```

---

## Type Guards with Generics

### User-Defined Type Guards

Narrow types safely:

```typescript
interface ApiError {
  code: number;
  message: string;
}

interface ApiSuccess<T> {
  data: T;
}

type ApiResponse<T> = ApiError | ApiSuccess<T>;

function isSuccess<T>(response: ApiResponse<T>): response is ApiSuccess<T> {
  return 'data' in response;
}

// Usage
function handleResponse<T>(response: ApiResponse<T>): T | null {
  if (isSuccess(response)) {
    return response.data;  // TypeScript knows this is ApiSuccess<T>
  }
  console.error(response.message);  // TypeScript knows this is ApiError
  return null;
}
```

---

## Generic Constraints in Vvroom

### Constraining to Interfaces

```typescript
interface HasId {
  id: string;
}

function findById<T extends HasId>(items: T[], id: string): T | undefined {
  return items.find(item => item.id === id);
}

// Works with any type that has an 'id' property
const vehicle = findById(vehicles, 'VIN123');
const user = findById(users, 'USER456');
```

### Constraining to Keys

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const vehicle = { make: 'Toyota', year: 2022 };
const make = getProperty(vehicle, 'make');  // string
const year = getProperty(vehicle, 'year');  // number
const bad = getProperty(vehicle, 'color');  // Error: 'color' not in keyof vehicle
```

---

## Observable Generic Patterns

RxJS uses generics extensively:

```typescript
// Observable of specific type
statistics$: Observable<VehicleStatistics>;

// Subject with type parameter
private readonly state$ = new BehaviorSubject<ResourceState<TFilters, TData>>(initial);

// Operators preserve/transform types
this.state$.pipe(
  map(state => state.data),      // Observable<TData[] | undefined>
  filter((data): data is TData[] => data !== undefined),  // Observable<TData[]>
  map(data => data.length)       // Observable<number>
);
```