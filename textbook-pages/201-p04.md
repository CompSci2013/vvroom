---

### Step 201.3: Understand the Interface Structure

The `DomainConfig` interface is organized into logical sections:

| Section | Properties | Purpose |
|---------|------------|---------|
| **Identity** | `domainName`, `domainLabel`, `apiBaseUrl` | Identify the domain and where to fetch data |
| **Type Models** | `filterModel`, `dataModel`, `statisticsModel` | Runtime type information for instantiation |
| **Adapters** | `apiAdapter`, `urlMapper`, `cacheKeyBuilder` | Domain-specific data transformation logic |
| **UI Configuration** | `tableConfig`, `pickers`, `filters`, `charts` | Define how data is displayed |
| **Feature Flags** | `features` | Enable/disable framework capabilities |
| **Metadata** | `metadata`, `defaultFilters` | Optional additional information |

**Why so many forward declarations?**

The `DomainConfig` interface references types from other files we haven't created yet. The forward declarations at the bottom are temporary placeholders. As we create each interface file (documents 202-209), we'll update the imports to use the real definitions.

This is a common pattern when building a system in dependency order: you need to reference types that will exist later. TypeScript allows this through interface merging and forward declarations.

---

## The Aha Moment

**TypeScript interfaces are executable documentation.**

Look at the `DomainConfig` interface. It's not just code â€” it's a specification. This interface documents *exactly* what any domain must provide to work with the vvroom framework:

- An identity (`domainName`, `domainLabel`)
- A data source (`apiBaseUrl`, `apiAdapter`)
- A way to serialize state to URLs (`urlMapper`)
- UI configurations (`tableConfig`, `filters`, `charts`)
- Feature toggles (`features`)

When you create a new domain (like agriculture or real estate), the compiler becomes your guide. Try to create a `DomainConfig<AgricultureFilters, CropResult>` object, and TypeScript will tell you exactly what's missing.

This is why we invested time in the Generics Primer (Section 150). The generic parameters `TFilters`, `TData`, and `TStatistics` ensure that when you wire up an automobile domain, the `urlMapper` accepts `AutomobileFilters`, and the `tableConfig` works with `VehicleResult`. Type mismatches are caught at compile time, not runtime.

**The interface is the contract. TypeScript enforces it.**