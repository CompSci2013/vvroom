---

## Combining Operators: A Real Example

Here's how these operators work together in `ResourceManagementService`:

```typescript
// Setup: combine filters and highlights
private readonly combined$ = combineLatest([
  this.filters$,
  this.highlights$
]).pipe(
  // Skip if neither actually changed
  distinctUntilChanged((a, b) =>
    JSON.stringify(a) === JSON.stringify(b)
  )
);

// Fetch data when combined state changes
this.results$ = this.combined$.pipe(
  // Cancel previous request, start new one
  switchMap(([filters, highlights]) =>
    this.apiAdapter.fetchData(filters, highlights)
  ),
  // Extract just the results
  map(response => response.results),
  // Share with all subscribers, cache last value
  shareReplay(1)
);
```

**The flow:**

1. `combineLatest` — Whenever filters OR highlights change, emit both
2. `distinctUntilChanged` — Skip if the combined value is the same
3. `switchMap` — Cancel any in-flight request, start a new one
4. `map` — Extract the results from the response
5. `shareReplay(1)` — Share with all components, cache the latest

---

## Error Handling

Observables have built-in error handling with `catchError`:

```typescript
import { catchError, of } from 'rxjs';

this.results$ = this.filters$.pipe(
  switchMap(filters => this.apiAdapter.fetchData(filters).pipe(
    catchError(error => {
      // Log the error
      console.error('API Error:', error);

      // Notify the user
      this.errorService.notify(error);

      // Return empty results (don't break the stream)
      return of({ results: [], total: 0 });
    })
  )),
  map(response => response.results),
  shareReplay(1)
);
```

**Important:** `catchError` must return an Observable. Use `of()` to create an Observable from a static value.

**Where to put catchError:** Inside the `switchMap` callback, not after it. This way, errors in one request don't kill the entire stream — future filter changes will still trigger new requests.

---

## Cleanup Patterns

Observables can cause memory leaks if not properly cleaned up. Every `subscribe()` must eventually `unsubscribe()`.