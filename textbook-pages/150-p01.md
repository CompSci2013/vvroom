# 150: TypeScript Generics Primer

**Status:** Planning
**Depends On:** 104-environment-config
**Blocks:** 201-domain-config-interface

---

## Learning Objectives

After completing this section, you will:
- Understand why generics exist and what problem they solve
- Be able to read and interpret generic type signatures
- Know the difference between concrete types and type parameters

---

## Objective

Build foundational understanding of TypeScript generics before tackling the framework models in Phase 2. This is a teaching interlude, not a code implementation section â€” you won't modify the vvroom project here.

---

## Why This Interlude Exists

Phase 2 introduces interfaces like this:

```typescript
export interface DomainConfig<TFilters, TData, TStatistics> {
  urlMapper: IFilterUrlMapper<TFilters>;
  apiAdapter: IApiAdapter<TFilters, TData, TStatistics>;
  tableConfig: TableConfig<TData>;
  // ...
}
```

If you've never worked with generics, this looks intimidating. What are `TFilters`, `TData`, and `TStatistics`? Why are there angle brackets everywhere?

This primer answers those questions. By the end, you'll read generic signatures as fluently as regular TypeScript.

---

## What Are Generics?

### The Problem: Type Safety vs Code Reuse

Consider a function that returns the first element of an array:

```typescript
// Without generics - loses type information
function getFirst(arr: any[]): any {
  return arr[0];
}

const numbers = [1, 2, 3];
const first = getFirst(numbers);  // first is 'any', not 'number'
```

The `any` type works, but we've lost type safety. TypeScript can't help us if we try to call `first.toUpperCase()` on a number.

We could write separate functions for each type:

```typescript
// Type-safe but repetitive
function getFirstNumber(arr: number[]): number {
  return arr[0];
}

function getFirstString(arr: string[]): string {
  return arr[0];
}

function getFirstVehicle(arr: Vehicle[]): Vehicle {
  return arr[0];
}
```

This is type-safe, but we've duplicated the same logic three times. What if we need 50 types?