```typescript
// src/app/features/automobile/automobile-discover/automobile-discover.component.ts
// VERSION 1 (Section 903) - Main discovery page with framework component orchestration

import {
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  Inject,
  Injector,
  OnDestroy,
  OnInit
} from '@angular/core';
import { Params } from '@angular/router';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

import { DomainConfig } from '../../../../framework/models/domain-config.interface';
import { PopOutMessageType } from '../../../../framework/models/popout.interface';
import { DOMAIN_CONFIG } from '../../../../framework/services/domain-config-registry.service';
import { FilterOptionsService } from '../../../../framework/services/filter-options.service';
import { PickerConfigRegistry } from '../../../../framework/services/picker-config-registry.service';
import { PopOutManagerService } from '../../../../framework/services/popout-manager.service';
import { ResourceManagementService } from '../../../../framework/services/resource-management.service';
import { UrlStateService } from '../../../../framework/services/url-state.service';
import { UserPreferencesService } from '../../../../framework/services/user-preferences.service';
import { ChartDataSource } from '../../../../framework/components/base-chart/base-chart.component';
import { createAutomobilePickerConfigs } from '../../../../domain-config/automobile/configs/automobile.picker-configs';

/**
 * Automobile Discover Component
 *
 * Main discovery page for the Automobile domain. This component orchestrates
 * all framework components to provide a comprehensive data exploration experience.
 *
 * Responsibilities:
 * - Provides ResourceManagementService instance for URL-first state management
 * - Registers automobile-specific picker configurations
 * - Manages pop-out window communication
 * - Handles panel ordering and collapse state
 * - Coordinates events between child components
 *
 * Child Components:
 * - QueryControlComponent: Filter management UI
 * - BasePickerComponent: Manufacturer-model hierarchical picker
 * - StatisticsPanel2Component: Multi-chart statistics display
 * - DynamicResultsTableComponent: Paginated data table
 * - BaseChartComponent: Individual chart visualizations
 */
@Component({
  selector: 'app-automobile-discover',
  templateUrl: './automobile-discover.component.html',
  styleUrls: ['./automobile-discover.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush,
  providers: [ResourceManagementService, PopOutManagerService]
})
export class AutomobileDiscoverComponent implements OnInit, OnDestroy {

  /** Domain configuration injected from registry */
  domainConfig: DomainConfig<any, any, any>;

  /** Track which panels are collapsed */
  collapsedPanels = new Map<string, boolean>([
    ['manufacturer-model-picker', true]  // Start picker collapsed
  ]);

  /** Order of panels in the UI (user can reorder via drag-drop) */
  panelOrder: string[] = [
    'query-control',
    'statistics-1',
    'chart-body-class',
    'chart-year',
    'manufacturer-model-picker',
    'results-table'
  ];

  /** Unique picker configuration ID for this page instance */
  readonly pickerConfigId = 'automobile-discover-manufacturer-model-picker';

  private destroy$ = new Subject<void>();
  private readonly gridId = 'automobile-discover';

  constructor(
    @Inject(DOMAIN_CONFIG) domainConfig: DomainConfig<any, any, any>,
    public resourceService: ResourceManagementService<any, any, any>,
    private pickerRegistry: PickerConfigRegistry,
    private injector: Injector,
    private popOutManager: PopOutManagerService,
    private cdr: ChangeDetectorRef,
    private urlStateService: UrlStateService,
    private userPreferences: UserPreferencesService,
    private filterOptionsService: FilterOptionsService
  ) {
    this.domainConfig = domainConfig;
  }

  ngOnInit(): void {
    // Register picker configurations for this page
    const pickerConfigs = createAutomobilePickerConfigs(this.injector, 'automobile-discover');
    this.pickerRegistry.registerMultiple(pickerConfigs);

    // Initialize pop-out manager for this grid
    this.popOutManager.initialize(this.gridId);

    // Handle messages from pop-out windows
    this.popOutManager.messages$
      .pipe(takeUntil(this.destroy$))
      .subscribe(({ panelId, message }) => {
        this.handlePopOutMessage(panelId, message);
      });

    // Update UI when pop-out windows close
    this.popOutManager.closed$
      .pipe(takeUntil(this.destroy$))
      .subscribe(() => {
        this.cdr.markForCheck();
      });

    // Broadcast state changes to pop-out windows
    this.resourceService.state$
      .pipe(takeUntil(this.destroy$))
      .subscribe(state => {
        const filterOptionsCache = this.filterOptionsService.getCache();
        this.popOutManager.broadcastState(state, filterOptionsCache);
      });

    // Sync filter options cache to pop-outs when it changes
    this.filterOptionsService.getCache$()
      .pipe(takeUntil(this.destroy$))
      .subscribe(cache => {
        if (this.popOutManager.getPoppedOutPanels().length > 0) {
          const state = this.resourceService.getCurrentState();
          this.popOutManager.broadcastState(state, cache);
        }
      });
  }

  // ============================================================================
  // Panel State Management
  // ============================================================================

  /**
   * Check if a panel is currently popped out to a separate window
   */
  isPanelPoppedOut(panelId: string): boolean {
    return this.popOutManager.isPoppedOut(panelId);
  }

  /**
   * Check if a panel is collapsed
   */
  isPanelCollapsed(panelId: string): boolean {
    return this.collapsedPanels.get(panelId) ?? false;
  }

  /**
   * Toggle panel collapse state
   */
  togglePanelCollapse(panelId: string): void {
    const currentState = this.collapsedPanels.get(panelId) ?? false;
    this.collapsedPanels.set(panelId, !currentState);

    // Persist collapsed state
    const collapsedPanels = Array.from(this.collapsedPanels.entries())
      .filter(([_, isCollapsed]) => isCollapsed)
      .map(([id]) => id);
    this.userPreferences.saveCollapsedPanels(collapsedPanels);

    this.cdr.markForCheck();
  }

  /**
   * Handle panel drag-drop reordering
   */
  onPanelDrop(event: { previousIndex: number; currentIndex: number }): void {
    const item = this.panelOrder.splice(event.previousIndex, 1)[0];
    this.panelOrder.splice(event.currentIndex, 0, item);
    this.userPreferences.savePanelOrder(this.panelOrder);
    this.cdr.markForCheck();
  }

  /**
   * TrackBy function for panel ngFor
   */
  trackByPanelId(index: number, panelId: string): string {
    return panelId;
  }

  // ============================================================================
  // Panel Configuration
  // ============================================================================

  /**
   * Get human-readable title for a panel
   */
  getPanelTitle(panelId: string): string {
    const titleMap: { [key: string]: string } = {
      'query-control': 'Query Control',
      'manufacturer-model-picker': 'Manufacturer-Model Picker',
      'statistics-1': 'Statistics',
      'chart-body-class': 'Vehicles by Body Class',
      'chart-year': 'Vehicles by Year',
      'results-table': 'Results Table'
    };
    return titleMap[panelId] || panelId;
  }

  /**
   * Get component type for a panel (used for pop-out routing)
   */
  getPanelType(panelId: string): string {
    const typeMap: { [key: string]: string } = {
      'query-control': 'query-control',
      'manufacturer-model-picker': 'picker',
      'statistics-1': 'statistics-2',
      'chart-body-class': 'chart',
      'chart-year': 'chart',
      'results-table': 'basic-results'
    };
    return typeMap[panelId] || panelId;
  }

  /**
   * Get chart IDs for a statistics panel
   */
  getChartIdsForPanel(panelId: string): string[] {
    const chartIdMap: { [key: string]: string[] } = {
      'statistics-1': ['manufacturer', 'top-models']
    };
    return chartIdMap[panelId] || [];
  }

  /**
   * Get chart data source by ID
   */
  getChartDataSource(chartId: string): ChartDataSource | undefined {
    return this.domainConfig.chartDataSources?.[chartId];
  }

  // ============================================================================
  // Pop-Out Management
  // ============================================================================

  /**
   * Open a panel in a pop-out window
   */
  popOutPanel(panelId: string, panelType: string): void {
    this.popOutManager.openPopOut(panelId, panelType);
    this.cdr.markForCheck();
  }

  /**
   * Handle chart pop-out request
   */
  onChartPopOut(chartId: string): void {
    const panelId = `chart-${chartId}`;
    this.popOutManager.openPopOut(panelId, 'chart');
    this.cdr.markForCheck();
  }

  /**
   * Handle messages from pop-out windows
   */
  private async handlePopOutMessage(_panelId: string, message: any): Promise<void> {
    switch (message.type) {
      case PopOutMessageType.PANEL_READY:
        // Pop-out is ready, send current state
        const currentState = this.resourceService.getCurrentState();
        const currentCache = this.filterOptionsService.getCache();
        this.popOutManager.broadcastState(currentState, currentCache);
        break;

      case PopOutMessageType.URL_PARAMS_CHANGED:
        // Pop-out changed filters, update URL
        if (message.payload?.params) {
          await this.urlStateService.setParams(message.payload.params);
        }
        break;

      case PopOutMessageType.CLEAR_ALL_FILTERS:
        await this.urlStateService.clearParams();
        break;

      case PopOutMessageType.PICKER_SELECTION_CHANGE:
        if (message.payload) {
          await this.onPickerSelectionChangeAndUpdateUrl(message.payload);
        }
        break;

      case PopOutMessageType.FILTER_ADD:
        if (message.payload?.params) {
          await this.urlStateService.setParams({
            ...message.payload.params,
            page: 1
          });
        }
        break;

      case PopOutMessageType.FILTER_REMOVE:
        if (message.payload?.field) {
          await this.urlStateService.setParams({
            [message.payload.field]: null,
            page: 1
          });
        }
        break;

      case PopOutMessageType.CHART_CLICK:
        if (message.payload) {
          const dataSource = this.domainConfig.chartDataSources?.[message.payload.chartId];
          await this.onStandaloneChartClick(
            { value: message.payload.value, isHighlightMode: message.payload.isHighlightMode },
            dataSource
          );
        }
        break;
    }
  }

  // ============================================================================
  // Event Handlers
  // ============================================================================

  /**
   * Handle URL parameter changes from child components
   */
  async onUrlParamsChange(params: Params): Promise<void> {
    await this.urlStateService.setParams(params);
  }

  /**
   * Handle clear all filters request
   */
  async onClearAllFilters(): Promise<void> {
    await this.urlStateService.clearParams();
  }

  /**
   * Handle chart click events
   */
  async onStandaloneChartClick(
    event: { value: string; isHighlightMode: boolean },
    dataSource: ChartDataSource | undefined
  ): Promise<void> {
    if (!dataSource) return;

    const newParams = dataSource.toUrlParams(event.value, event.isHighlightMode);
    if (!event.isHighlightMode) {
      newParams['page'] = 1;
    }

    if (Object.keys(newParams).length > 0) {
      await this.urlStateService.setParams(newParams);
    }
  }

  /**
   * Handle picker selection changes
   */
  async onPickerSelectionChangeAndUpdateUrl(event: any): Promise<void> {
    const paramName = 'modelCombos';
    await this.urlStateService.setParams({
      [paramName]: event.urlValue || null,
      page: 1
    });
  }

  // ============================================================================
  // Lifecycle
  // ============================================================================

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```