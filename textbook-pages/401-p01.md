# 401: Base Model Interface

**Status:** Complete
**Depends On:** 201-domain-config-interface
**Blocks:** 402-domain-data-models, 403-domain-filter-statistics-models

---

## Learning Objectives

After completing this section, you will:
- Understand why domain models use classes instead of interfaces
- Know how to implement the class-with-partial-constructor pattern
- Recognize the benefits of `fromApiResponse()` static factory methods
- Be able to create domain-agnostic base patterns for data models

---

## Objective

Establish the base patterns for domain data models that all specific domain models will follow. This section defines the conventions for creating type-safe, API-aware data classes.

---

## Why

Domain models represent the data your application works with. In Vvroom, the primary domain is **automobiles** — vehicles, manufacturers, models, body classes, and VIN instances.

### The Interface vs Class Decision

TypeScript offers two ways to define data shapes:

**Interfaces:**
```typescript
interface Vehicle {
  vehicle_id: string;
  manufacturer: string;
  model: string;
  year: number;
}
```

**Classes:**
```typescript
class Vehicle {
  vehicle_id!: string;
  manufacturer!: string;
  model!: string;
  year!: number;
}
```

At first glance, interfaces seem simpler. But classes provide crucial advantages:

| Feature | Interface | Class |
|---------|-----------|-------|
| Runtime existence | No (erased) | Yes |
| Methods | No | Yes |
| Computed properties | No | Yes (getters) |
| Factory methods | No | Yes (static) |
| Type guard with `instanceof` | No | Yes |
| Partial initialization | Manual | Constructor pattern |
| API transformation | External function | `fromApiResponse()` |

For domain models that need methods, transformation logic, and computed properties, classes are the better choice.

### The Partial Constructor Pattern

Domain models often come from APIs with varied data. The partial constructor pattern handles this:

```typescript
class Vehicle {
  vehicle_id!: string;
  manufacturer!: string;
  model!: string;
  year!: number;

  constructor(partial?: Partial<Vehicle>) {
    if (partial) {
      Object.assign(this, partial);
    }
  }
}
```

Benefits:
1. **Optional initialization** — Create empty instances or full ones
2. **Flexible merging** — `new Vehicle({ ...existing, year: 2024 })`
3. **Type safety** — `Partial<Vehicle>` ensures only valid properties
4. **IDE support** — Autocomplete works for constructor params