# 305: Domain Config Validator

**Status:** Complete
**Depends On:** 201-domain-config-interface, 304-domain-config-registry
**Blocks:** 306-resource-management-service

---

## Learning Objectives

After completing this section, you will:
- Understand runtime validation patterns in TypeScript
- Know how to create comprehensive validation with error categorization
- Recognize the value of catching configuration errors early
- Be able to implement a reusable validation service

---

## Objective

Create the `DomainConfigValidator` service that validates domain configurations at runtime, ensuring all required fields are present and correctly typed before the framework attempts to use them.

---

## Why

TypeScript provides compile-time type checking, but it can't catch everything:

### What TypeScript Catches

```typescript
const config: DomainConfig<F, D, S> = {
  domainName: 123, // Error: Type 'number' is not assignable to type 'string'
  // Missing required properties - TypeScript error
};
```

### What TypeScript Misses

```typescript
const config: DomainConfig<any, any, any> = {
  domainName: '',        // Empty string - valid type, invalid value
  apiBaseUrl: 'not-url', // Not a valid URL - valid type, invalid value
  tableConfig: {
    tableId: 'test',
    columns: []          // Empty array - valid type, likely an error
  }
};
```

TypeScript checks types. It doesn't check:
- Empty strings vs meaningful strings
- Valid URLs vs arbitrary strings
- Empty arrays vs populated arrays
- Interface compliance (does `apiAdapter` have `fetchData`?)

### Why Not Just Trust TypeScript?

In a perfect world, every `DomainConfig` would be created with correct types and values. In practice:

1. **Dynamic data** — Configs may come from JSON files or APIs
2. **User error** — Developers make mistakes
3. **Refactoring** — Interface changes can break existing configs
4. **Third-party configs** — Can't trust external data

Runtime validation catches these issues **at registration time**, with clear error messages, instead of cryptic failures deep in framework code.