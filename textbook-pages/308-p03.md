```typescript
// src/app/framework/services/popout-manager.service.ts
// VERSION 1 (Section 308) - Pop-out window manager

import { Injectable, NgZone, OnDestroy } from '@angular/core';
import { Subject } from 'rxjs';
import {
  buildWindowFeatures,
  PopOutMessage,
  PopOutMessageType,
  PopOutWindowFeatures,
  PopOutWindowRef
} from '../models/popout.interface';
import { PopOutContextService } from './popout-context.service';

/**
 * Pop-out manager service
 *
 * Manages pop-out windows from the main window. Opens windows,
 * broadcasts state, and tracks lifecycle.
 *
 * **Important:** This is a component-level service, not a singleton.
 * Each component that needs pop-out management provides its own instance.
 *
 * **Lifecycle:**
 *
 * 1. Component creates → Manager injected
 * 2. Component calls initialize() with grid ID
 * 3. User clicks pop-out button → openPopOut() called
 * 4. Filter changes → broadcastState() called
 * 5. Pop-out closes → Manager detects and cleans up
 * 6. Component destroys → All pop-outs closed
 *
 * @example
 * ```typescript
 * @Component({
 *   providers: [PopOutManagerService]
 * })
 * export class DiscoverComponent implements OnInit, OnDestroy {
 *   constructor(
 *     private popOutManager: PopOutManagerService,
 *     private resources: ResourceManagementService
 *   ) {}
 *
 *   ngOnInit(): void {
 *     this.popOutManager.initialize('discover-grid');
 *
 *     // Broadcast state to pop-outs when it changes
 *     this.resources.state$.subscribe(state => {
 *       this.popOutManager.broadcastState(state);
 *     });
 *
 *     // Handle pop-out closure
 *     this.popOutManager.closed$.subscribe(panelId => {
 *       console.log(`Pop-out ${panelId} closed`);
 *     });
 *   }
 *
 *   onPopOutClick(panelId: string, panelType: string): void {
 *     this.popOutManager.openPopOut(panelId, panelType);
 *   }
 * }
 * ```
 */
@Injectable() // Component-level, not providedIn: 'root'
export class PopOutManagerService implements OnDestroy {
  /**
   * Grid ID for URL construction
   */
  private gridId = '';

  /**
   * Set of currently popped-out panel IDs
   */
  private poppedOutPanels = new Set<string>();

  /**
   * Map of panel ID to window reference/channel
   */
  private popoutWindows = new Map<string, PopOutWindowRef>();

  /**
   * Subject for messages from pop-outs
   */
  private messagesSubject = new Subject<{ panelId: string; message: PopOutMessage }>();

  /**
   * Subject for pop-out close events
   */
  private closedSubject = new Subject<string>();

  /**
   * Subject for blocked pop-up events (browser blocked window.open)
   */
  private blockedSubject = new Subject<string>();

  /**
   * Handler for beforeunload to close all pop-outs
   */
  private beforeUnloadHandler = () => this.closeAllPopOuts();

  /**
   * Initialization flag
   */
  private initialized = false;

  // Public observables
  readonly messages$ = this.messagesSubject.asObservable();
  readonly closed$ = this.closedSubject.asObservable();
  readonly blocked$ = this.blockedSubject.asObservable();

  /**
   * Constructor
   *
   * @param popOutContext - Context service for channel creation
   * @param ngZone - NgZone for change detection
   */
  constructor(
    private popOutContext: PopOutContextService,
    private ngZone: NgZone
  ) {}

  /**
   * Initialize the manager
   *
   * Must be called before any pop-out operations.
   *
   * @param gridId - Grid identifier for URL construction
   */
  initialize(gridId: string): void {
    if (this.initialized) {
      return;
    }

    this.gridId = gridId;
    this.initialized = true;

    // Initialize context as parent
    this.popOutContext.initializeAsParent();

    // Close all pop-outs when main window closes
    window.addEventListener('beforeunload', this.beforeUnloadHandler);

    // Subscribe to messages from pop-outs
    this.popOutContext.getMessages$().subscribe(message => {
      this.messagesSubject.next({ panelId: '', message });
    });
  }

  /**
   * Check if a panel is currently popped out
   *
   * @param panelId - Panel identifier
   * @returns True if panel is popped out
   */
  isPoppedOut(panelId: string): boolean {
    return this.poppedOutPanels.has(panelId);
  }

  /**
   * Get all currently popped-out panel IDs
   *
   * @returns Array of panel IDs
   */
  getPoppedOutPanels(): string[] {
    return Array.from(this.poppedOutPanels);
  }

  /**
   * Open a panel in a pop-out window
   *
   * @param panelId - Panel identifier
   * @param panelType - Panel type (e.g., 'statistics-panel-2')
   * @param features - Optional window features
   * @returns True if opened successfully, false if blocked or already open
   */
  openPopOut(
    panelId: string,
    panelType: string,
    features?: Partial<PopOutWindowFeatures>
  ): boolean {
    // Don't open if already popped out
    if (this.poppedOutPanels.has(panelId)) {
      console.log(`[PopOutManager] Panel ${panelId} already popped out`);
      return false;
    }

    // Construct URL: /popout/:gridId/:panelId/:panelType
    const url = `/popout/${this.gridId}/${panelId}/${panelType}`;

    // Build window features string
    const windowFeatures = buildWindowFeatures({
      width: 1200,
      height: 800,
      left: 100,
      top: 100,
      resizable: true,
      scrollbars: true,
      ...features
    });

    // Open the window
    const popoutWindow = window.open(url, `panel-${panelId}`, windowFeatures);

    // Handle blocked popup
    if (!popoutWindow) {
      console.warn(`[PopOutManager] Pop-up blocked for panel ${panelId}`);
      this.blockedSubject.next(panelId);
      return false;
    }

    // Track the pop-out
    this.poppedOutPanels.add(panelId);

    // Create channel for this panel
    const channel = this.popOutContext.createChannelForPanel(panelId);

    // Listen for messages from this panel
    channel.onmessage = event => {
      this.ngZone.run(() => {
        this.messagesSubject.next({ panelId, message: event.data });
      });
    };

    // Poll to detect when window closes
    const checkInterval = window.setInterval(() => {
      if (popoutWindow.closed) {
        this.ngZone.run(() => {
          this.handlePopOutClosed(panelId, channel, checkInterval);
        });
      }
    }, 500);

    // Store reference
    this.popoutWindows.set(panelId, {
      window: popoutWindow,
      channel,
      checkInterval,
      panelId,
      panelType
    });

    console.log(`[PopOutManager] Opened pop-out for panel ${panelId}`);
    return true;
  }

  /**
   * Broadcast state to all pop-out windows
   *
   * Call this whenever state changes in the main window.
   *
   * @param state - Application state from ResourceManagementService
   * @param filterOptionsCache - Optional cached filter options
   */
  broadcastState(state: any, filterOptionsCache?: any): void {
    if (this.popoutWindows.size === 0) {
      return; // No pop-outs to broadcast to
    }

    const message: PopOutMessage = {
      type: PopOutMessageType.STATE_UPDATE,
      payload: {
        state,
        filterOptionsCache: filterOptionsCache || null
      },
      timestamp: Date.now()
    };

    // Send to all pop-out channels
    this.popoutWindows.forEach(({ channel }) => {
      try {
        channel.postMessage(message);
      } catch {
        // Silently ignore posting errors (channel may be closed)
      }
    });
  }

  /**
   * Close a specific pop-out window
   *
   * @param panelId - Panel identifier
   */
  closePopOut(panelId: string): void {
    const ref = this.popoutWindows.get(panelId);
    if (ref) {
      // Send close message
      ref.channel.postMessage({
        type: PopOutMessageType.CLOSE_POPOUT,
        timestamp: Date.now()
      });
    }
  }

  /**
   * Close all pop-out windows
   *
   * Called when main window is closing.
   */
  closeAllPopOuts(): void {
    this.popoutWindows.forEach(({ channel }) => {
      channel.postMessage({
        type: PopOutMessageType.CLOSE_POPOUT,
        timestamp: Date.now()
      });
    });
  }

  /**
   * Handle pop-out window closed
   *
   * @param panelId - Panel that closed
   * @param channel - BroadcastChannel to close
   * @param checkInterval - Interval to clear
   */
  private handlePopOutClosed(
    panelId: string,
    channel: BroadcastChannel,
    checkInterval: number
  ): void {
    // Clear polling interval
    clearInterval(checkInterval);

    // Close channel
    channel.close();

    // Remove from tracking
    this.popoutWindows.delete(panelId);
    this.poppedOutPanels.delete(panelId);

    // Emit closed event
    this.closedSubject.next(panelId);

    console.log(`[PopOutManager] Pop-out ${panelId} closed`);
  }

  /**
   * Cleanup on service destroy
   */
  ngOnDestroy(): void {
    // Remove beforeunload listener
    window.removeEventListener('beforeunload', this.beforeUnloadHandler);

    // Close all pop-outs and cleanup
    this.popoutWindows.forEach(({ window: win, channel, checkInterval }) => {
      clearInterval(checkInterval);
      channel.close();
      if (win && !win.closed) {
        win.close();
      }
    });

    // Complete subjects
    this.messagesSubject.complete();
    this.closedSubject.complete();
    this.blockedSubject.complete();
  }
}
```