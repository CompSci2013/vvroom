---

## Common Mistakes

### Mistake 1: Missing Type Arguments

```typescript
// Wrong - Map needs type arguments
const cache = new Map();  // Map<any, any>

// Right
const cache = new Map<string, VehicleResult>();
```

### Mistake 2: Overly Narrow Constraints

```typescript
// Too restrictive - only works with AutomobileFilters
function process<T extends AutomobileFilters>(filters: T) { }

// Better - works with any filter type
function process<T>(filters: T) { }

// Or if you need specific properties
function process<T extends { page?: number }>(filters: T) { }
```

### Mistake 3: Ignoring Inference

```typescript
// Unnecessary - TypeScript infers T
const result = identity<string>('hello');

// Let TypeScript infer
const result = identity('hello');  // T is inferred as string
```

### Mistake 4: Using `any` Instead of Generics

```typescript
// Bad - loses type safety
function firstElement(arr: any[]): any {
  return arr[0];
}

// Good - preserves type
function firstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}
```

---

## Quick Reference Table: Vvroom Generic Types

| Type | Purpose | Type Parameters |
|------|---------|-----------------|
| `DomainConfig<F, D, S>` | Domain configuration | Filters, Data, Statistics |
| `IApiAdapter<F, D, S>` | API adapter interface | Filters, Data, Statistics |
| `IFilterUrlMapper<F>` | URL mapping interface | Filters |
| `TableConfig<D>` | Table configuration | Data row type |
| `ChartDataSource<S>` | Chart data transformation | Statistics type |
| `ResourceState<F, D, S>` | Service state | Filters, Data, Statistics |
| `ApiResponse<D>` | API response wrapper | Data type |
| `Observable<T>` | RxJS observable | Emitted value type |
| `BehaviorSubject<T>` | RxJS subject with initial value | Value type |

---

## Key Takeaways

1. **Generics flow through the architecture** — From DomainConfig through services to components
2. **Utility types reduce boilerplate** — Use Partial, Pick, Omit instead of redefining
3. **Constraints ensure type safety** — Use `extends` to require specific properties
4. **Let TypeScript infer when possible** — Don't over-annotate