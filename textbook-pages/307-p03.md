```typescript
// src/app/framework/services/popout-context.service.ts
// VERSION 2 (Section 307) - Full implementation with BroadcastChannel

import { Injectable, OnDestroy, NgZone } from '@angular/core';
import { Router } from '@angular/router';
import { Observable, ReplaySubject } from 'rxjs';
import {
  PopOutMessage,
  PopOutMessageType,
  PopOutContext,
  parsePopOutRoute
} from '../models/popout.interface';

/**
 * Pop-out context service
 *
 * Determines whether the current window is a pop-out and provides
 * messaging infrastructure for parent-child window communication.
 *
 * **Two Modes:**
 *
 * 1. **Pop-out mode** — Running in a pop-out window
 *    - `isInPopOut()` returns true
 *    - Sets up BroadcastChannel to receive state from main window
 *    - Sends PANEL_READY message when initialized
 *
 * 2. **Parent mode** — Running in main window
 *    - `isInPopOut()` returns false
 *    - Manages channels for each pop-out panel
 *    - Broadcasts state updates to all pop-outs
 *
 * **BroadcastChannel Pattern:**
 *
 * Each panel gets its own channel named `panel-{panelId}`.
 * This allows targeted messaging to specific panels.
 *
 * @example
 * ```typescript
 * // In pop-out window component
 * if (this.context.isInPopOut()) {
 *   const ctx = this.context.getContext();
 *   this.context.initializeAsPopOut(ctx.panelId);
 *
 *   this.context.getMessages$().subscribe(message => {
 *     if (message.type === PopOutMessageType.STATE_UPDATE) {
 *       this.handleStateUpdate(message.payload);
 *     }
 *   });
 * }
 *
 * // In main window
 * this.context.initializeAsParent();
 * ```
 */
@Injectable({
  providedIn: 'root'
})
export class PopOutContextService implements OnDestroy {
  /**
   * BroadcastChannel for this window
   *
   * In pop-out: channel for receiving messages from main window
   * In parent: may be null (uses per-panel channels via PopOutManager)
   */
  private channel: BroadcastChannel | null = null;

  /**
   * ReplaySubject for incoming messages
   *
   * ReplaySubject with buffer of 10 ensures late subscribers
   * can receive recent messages they might have missed.
   */
  private messagesSubject = new ReplaySubject<PopOutMessage>(10);

  /**
   * Parsed context from URL
   *
   * Contains isPopOut, gridId, panelId, panelType
   */
  private context: PopOutContext | null = null;

  /**
   * Initialization flag to prevent double-init
   */
  private initialized = false;

  /**
   * Constructor - parses URL to determine context
   *
   * @param router - Angular Router for URL access
   * @param ngZone - NgZone for ensuring change detection
   */
  constructor(
    private router: Router,
    private ngZone: NgZone
  ) {
    // Parse context from current URL
    this.context = parsePopOutRoute(this.router.url);
  }

  /**
   * Check if current window is a pop-out
   *
   * Determined by URL pattern: /popout/:gridId/:panelId/:panelType
   *
   * @returns True if in pop-out window
   */
  isInPopOut(): boolean {
    // Re-parse if context not set (defensive)
    if (!this.context) {
      this.context = parsePopOutRoute(this.router.url);
    }
    return this.context?.isPopOut || false;
  }

  /**
   * Get parsed pop-out context
   *
   * @returns Context object with gridId, panelId, panelType, or null
   */
  getContext(): PopOutContext | null {
    if (!this.context) {
      this.context = parsePopOutRoute(this.router.url);
    }
    return this.context;
  }

  /**
   * Initialize as pop-out window
   *
   * Sets up BroadcastChannel for receiving messages from main window.
   * Sends PANEL_READY message to notify main window.
   *
   * @param panelId - Panel identifier for channel naming
   */
  initializeAsPopOut(panelId: string): void {
    if (this.initialized) {
      return;
    }

    this.initialized = true;
    this.setupChannel(panelId);

    // Notify main window that pop-out is ready
    this.sendMessage({
      type: PopOutMessageType.PANEL_READY,
      timestamp: Date.now()
    });
  }

  /**
   * Initialize as parent window
   *
   * Called by main window to set initialized flag.
   * Actual channel management is handled by PopOutManagerService.
   */
  initializeAsParent(): void {
    if (this.initialized) {
      return;
    }

    this.initialized = true;
    // Parent doesn't set up a channel here - PopOutManager handles per-panel channels
  }

  /**
   * Set up BroadcastChannel for this panel
   *
   * @param panelId - Panel identifier for channel naming
   */
  private setupChannel(panelId: string): void {
    const channelName = `panel-${panelId}`;

    // Close existing channel if any
    if (this.channel) {
      this.channel.close();
    }

    // Create new channel
    this.channel = new BroadcastChannel(channelName);

    // Handle incoming messages
    this.channel.onmessage = (event: MessageEvent) => {
      const message = event.data as PopOutMessage;
      // Use NgZone to ensure Angular change detection runs
      this.ngZone.run(() => {
        this.messagesSubject.next(message);
      });
    };

    // Handle message errors (rare, but log them)
    this.channel.onmessageerror = () => {
      console.warn('[PopOutContextService] Message deserialization error');
    };
  }

  /**
   * Send message to channel
   *
   * Used by pop-out to send messages to main window.
   *
   * @template T - Payload type
   * @param message - Message to send
   */
  sendMessage<T = any>(message: PopOutMessage<T>): void {
    if (!this.channel) {
      console.warn('[PopOutContextService] No channel available for sending');
      return;
    }

    // Add timestamp if not present
    if (!message.timestamp) {
      message.timestamp = Date.now();
    }

    try {
      this.channel.postMessage(message);
    } catch (error) {
      console.error('[PopOutContextService] Failed to send message:', error);
    }
  }

  /**
   * Get observable of incoming messages
   *
   * @returns Observable of PopOutMessage
   */
  getMessages$(): Observable<PopOutMessage> {
    return this.messagesSubject.asObservable();
  }

  /**
   * Create a BroadcastChannel for a specific panel
   *
   * Used by PopOutManagerService to create channels for pop-out windows.
   *
   * @param panelId - Panel identifier
   * @returns New BroadcastChannel instance
   */
  createChannelForPanel(panelId: string): BroadcastChannel {
    const channelName = `panel-${panelId}`;
    return new BroadcastChannel(channelName);
  }

  /**
   * Close the channel
   *
   * Call when pop-out is closing or service is destroyed.
   */
  close(): void {
    if (this.channel) {
      this.channel.close();
      this.channel = null;
    }

    this.initialized = false;
  }

  /**
   * Cleanup on service destroy
   */
  ngOnDestroy(): void {
    this.close();
    this.messagesSubject.complete();
  }
}
```