```typescript
// src/app/framework/components/base-picker/base-picker.component.ts
// VERSION 1 (Section 802) - Configuration-driven multi-select table

import {
  AfterViewInit,
  ChangeDetectionStrategy,
  ChangeDetectorRef,
  Component,
  ElementRef,
  EventEmitter,
  Input,
  OnDestroy,
  OnInit,
  Output
} from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { Subject } from 'rxjs';
import { distinctUntilChanged, map, takeUntil } from 'rxjs/operators';

import { TableModule } from 'primeng/table';
import { ButtonModule } from 'primeng/button';
import { CheckboxModule } from 'primeng/checkbox';
import { InputTextModule } from 'primeng/inputtext';
import { SkeletonModule } from 'primeng/skeleton';
import { MessageModule } from 'primeng/message';

import { PickerConfig, PickerSelectionEvent, PickerApiParams } from '../../models/picker-config.interface';
import { PickerConfigRegistry } from '../../services/picker-config-registry.service';
import { UrlStateService } from '../../services/url-state.service';
import { ResourceManagementService } from '../../services/resource-management.service';
import { PickerState, getDefaultPickerState } from './picker-state.interface';

/**
 * Base Picker Component
 *
 * Configuration-driven multi-select table with:
 * - Server-side pagination and sorting
 * - Search filtering
 * - Selection persistence across pages
 * - URL parameter synchronization
 *
 * @template T - The data model type for table rows
 *
 * @example
 * ```html
 * <!-- Using config from registry -->
 * <app-base-picker
 *   [configId]="'vehicle-picker'"
 *   (selectionChange)="onSelectionChange($event)">
 * </app-base-picker>
 *
 * <!-- Using direct config object -->
 * <app-base-picker
 *   [config]="vehiclePickerConfig"
 *   (selectionChange)="onSelectionChange($event)">
 * </app-base-picker>
 * ```
 */
@Component({
  selector: 'app-base-picker',
  templateUrl: './base-picker.component.html',
  styleUrls: ['./base-picker.component.scss'],
  changeDetection: ChangeDetectionStrategy.OnPush
})
export class BasePickerComponent<T> implements OnInit, OnDestroy, AfterViewInit {

  /**
   * Picker configuration ID (loads from registry)
   * Either configId or config must be provided.
   */
  @Input() configId?: string;

  /**
   * Direct picker configuration object
   * Either configId or config must be provided.
   */
  @Input() config?: PickerConfig<T>;

  /**
   * Emits when user clicks "Apply" with selected items
   */
  @Output() selectionChange = new EventEmitter<PickerSelectionEvent<T>>();

  /**
   * Current picker state
   */
  state: PickerState<T> = getDefaultPickerState();

  /**
   * Active configuration (resolved from configId or config)
   */
  activeConfig?: PickerConfig<T>;

  private destroy$ = new Subject<void>();

  constructor(
    private registry: PickerConfigRegistry,
    private urlState: UrlStateService,
    private cdr: ChangeDetectorRef,
    private elementRef: ElementRef,
    private resourceService: ResourceManagementService<any, any, any>
  ) {}

  // ============================================================================
  // Lifecycle
  // ============================================================================

  ngOnInit(): void {
    this.loadConfiguration();

    if (!this.activeConfig) {
      throw new Error('BasePickerComponent requires either configId or config input');
    }

    this.initializeState();
    this.subscribeToUrlChanges();
    this.loadData();
  }

  ngAfterViewInit(): void {
    this.syncPaginatorWidth();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  // ============================================================================
  // Configuration
  // ============================================================================

  private loadConfiguration(): void {
    if (this.config) {
      this.activeConfig = this.config;
    } else if (this.configId) {
      this.activeConfig = this.registry.get<T>(this.configId);
    }
  }

  private initializeState(): void {
    const pageSize = this.activeConfig!.pagination.defaultPageSize || 20;
    this.state = getDefaultPickerState<T>(pageSize);
  }

  // ============================================================================
  // URL Synchronization
  // ============================================================================

  private subscribeToUrlChanges(): void {
    const urlParam = this.activeConfig!.selection.urlParam;

    this.resourceService.filters$
      .pipe(
        map(filters => (filters as any)[urlParam] || null),
        distinctUntilChanged(),
        takeUntil(this.destroy$)
      )
      .subscribe(filterValue => {
        if (filterValue) {
          this.hydrateFromUrl(String(filterValue));
        } else {
          // Clear selections
          this.state.selectedKeys = new Set<string>();
          this.state.selectedItems = [];
          this.state.pendingHydration = [];
          this.state.data = [...this.state.data];
          this.cdr.detectChanges();
        }
      });
  }

  private hydrateFromUrl(urlValue: string): void {
    const config = this.activeConfig!;
    const partialItems = config.selection.deserializer(urlValue);
    const keyGenerator = config.selection.keyGenerator || config.row.keyGenerator;
    const keys = partialItems.map(item => keyGenerator(item as T));

    if (this.state.dataLoaded) {
      this.hydrateSelections(keys);
    } else {
      this.state.pendingHydration = keys;
    }

    this.cdr.markForCheck();
  }

  private hydrateSelections(keys: string[]): void {
    const config = this.activeConfig!;
    this.state.selectedKeys = new Set<string>(keys);

    // Preserve items from other pages
    const existingItemsByKey = new Map<string, T>();
    this.state.selectedItems.forEach(item => {
      const key = config.row.keyGenerator(item);
      existingItemsByKey.set(key, item);
    });

    // Build new selectedItems array
    const newSelectedItems: T[] = [];
    keys.forEach(key => {
      const itemInCurrentPage = this.state.data.find(
        row => config.row.keyGenerator(row) === key
      );

      if (itemInCurrentPage) {
        newSelectedItems.push(itemInCurrentPage);
      } else if (existingItemsByKey.has(key)) {
        newSelectedItems.push(existingItemsByKey.get(key)!);
      }
    });

    this.state.selectedItems = newSelectedItems;
    this.cdr.markForCheck();
  }

  // ============================================================================
  // Data Loading
  // ============================================================================

  private loadData(): void {
    const config = this.activeConfig!;
    this.state.loading = true;
    this.state.error = null;
    this.cdr.markForCheck();

    const params: PickerApiParams = {
      page: this.state.currentPage,
      size: this.state.pageSize,
      search: this.state.searchTerm || undefined,
      sortField: this.state.sortField,
      sortOrder: this.state.sortOrder
    };

    const apiParams = config.api.paramMapper
      ? config.api.paramMapper(params)
      : params;

    config.api.fetchData(apiParams)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: response => {
          const transformed = config.api.responseTransformer(response);
          this.state.data = transformed.results;
          this.state.totalCount = transformed.total;
          this.state.loading = false;
          this.state.dataLoaded = true;

          // Hydrate pending selections
          if (this.state.pendingHydration.length > 0) {
            this.hydrateSelections(this.state.pendingHydration);
            this.state.pendingHydration = [];
          }

          this.cdr.markForCheck();
        },
        error: error => {
          this.state.loading = false;
          this.state.error = error;
          this.cdr.markForCheck();
        }
      });
  }

  // ============================================================================
  // Selection Handlers
  // ============================================================================

  onRowSelectionChange(row: T, checked: boolean): void {
    const key = this.activeConfig!.row.keyGenerator(row);

    if (checked) {
      this.state.selectedKeys.add(key);
      this.state.selectedItems.push(row);
    } else {
      this.state.selectedKeys.delete(key);
      this.state.selectedItems = this.state.selectedItems.filter(
        item => this.activeConfig!.row.keyGenerator(item) !== key
      );
    }

    this.cdr.markForCheck();
  }

  onSelectAll(checked: boolean): void {
    if (checked) {
      this.state.data.forEach(row => {
        const key = this.activeConfig!.row.keyGenerator(row);
        if (!this.state.selectedKeys.has(key)) {
          this.state.selectedKeys.add(key);
          this.state.selectedItems.push(row);
        }
      });
    } else {
      this.state.data.forEach(row => {
        const key = this.activeConfig!.row.keyGenerator(row);
        this.state.selectedKeys.delete(key);
      });
      this.state.selectedItems = this.state.selectedItems.filter(item => {
        const key = this.activeConfig!.row.keyGenerator(item);
        return this.state.selectedKeys.has(key);
      });
    }

    this.cdr.markForCheck();
  }

  isRowSelected(row: T): boolean {
    const key = this.activeConfig!.row.keyGenerator(row);
    return this.state.selectedKeys.has(key);
  }

  get allVisibleSelected(): boolean {
    if (this.state.data.length === 0) {
      return false;
    }
    return this.state.data.every(row => this.isRowSelected(row));
  }

  // ============================================================================
  // Pagination & Sorting
  // ============================================================================

  onLazyLoad(event: any): void {
    if (this.state.loading) {
      return;
    }

    this.state.currentPage = event.first / event.rows;
    this.state.pageSize = event.rows;
    this.state.sortField = event.sortField || undefined;
    this.state.sortOrder = event.sortOrder || 1;

    this.loadData();
  }

  onSearch(term: string): void {
    this.state.searchTerm = term;
    this.state.currentPage = 0;
    this.loadData();
  }

  // ============================================================================
  // Actions
  // ============================================================================

  applySelections(): void {
    const config = this.activeConfig!;
    const urlValue = config.selection.serializer(this.state.selectedItems);

    const event: PickerSelectionEvent<T> = {
      pickerId: config.id,
      selections: this.state.selectedItems,
      selectedKeys: Array.from(this.state.selectedKeys),
      urlValue
    };

    this.selectionChange.emit(event);
  }

  clearSelections(): void {
    this.state.selectedKeys = new Set<string>();
    this.state.selectedItems = [];
    this.state.data = [...this.state.data];
    this.cdr.markForCheck();

    // Emit empty selection
    const event: PickerSelectionEvent<T> = {
      pickerId: this.activeConfig!.id,
      selections: [],
      selectedKeys: [],
      urlValue: ''
    };
    this.selectionChange.emit(event);
  }

  // ============================================================================
  // Helpers
  // ============================================================================

  fieldToString(field: keyof T): string {
    return String(field);
  }

  private syncPaginatorWidth(): void {
    const nativeEl = this.elementRef.nativeElement;
    const table = nativeEl.querySelector('.p-datatable-table') as HTMLElement;
    const paginator = nativeEl.querySelector('.p-paginator') as HTMLElement;

    if (table && paginator) {
      paginator.style.width = `${table.offsetWidth}px`;
    }
  }
}
```