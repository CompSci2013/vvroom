---

## Common Problems

| Symptom | Cause | Solution |
|---------|-------|----------|
| Multiple HTTP requests despite deduplication | Different request keys | Ensure same key for same request |
| Cache never expires | TTL too high | Reduce cacheTTL value |
| Cache always misses | TTL too low | Increase cacheTTL value |
| Retries not working | retryAttempts set to 0 | Use default or positive number |
| Loading state stuck on true | Request never completes | Check for hung HTTP requests |
| `shareReplay` memory leak | Observable never completes | finalize() handles cleanup |

---

## Key Takeaways

1. **Three-layer processing prevents redundant requests** — Cache → Dedup → HTTP
2. **`shareReplay(1)` enables deduplication** — Multiple subscribers share one HTTP call
3. **Exponential backoff handles transient failures** — Each retry waits longer than the last

---

## Acceptance Criteria

- [ ] `src/app/framework/services/request-coordinator.service.ts` exists
- [ ] Barrel file exports the service
- [ ] Service is `@Injectable({ providedIn: 'root' })`
- [ ] `execute()` implements three-layer processing
- [ ] Response cache stores with TTL and expires correctly
- [ ] In-flight deduplication shares observable for duplicate requests
- [ ] Retry logic uses exponential backoff
- [ ] `getLoadingState$()` returns per-request loading observable
- [ ] `getGlobalLoading$()` returns any-loading observable
- [ ] Cache invalidation methods work correctly
- [ ] TypeScript compilation succeeds
- [ ] JSDoc comments document all public methods

---

## Next Step

Proceed to `304-domain-config-registry.md` to create the service that manages domain configurations.