---

### Record<K, V>

Creates an object type with keys of type K and values of type V:

```typescript
type ChartSourceMap = Record<string, ChartDataSource>;
// { [key: string]: ChartDataSource }

const sources: ChartSourceMap = {
  'manufacturer': new ManufacturerChartSource(),
  'year': new YearChartSource()
};
```

**Used in vvroom:** `chartDataSources`, URL parameters

---

### Extract<T, U>

Extracts types from T that are assignable to U:

```typescript
type EventTypes = 'click' | 'focus' | 'blur' | 'scroll' | 'resize';
type MouseEvents = Extract<EventTypes, 'click' | 'scroll'>;
// 'click' | 'scroll'
```

---

### Exclude<T, U>

Excludes types from T that are assignable to U:

```typescript
type EventTypes = 'click' | 'focus' | 'blur' | 'scroll' | 'resize';
type KeyboardEvents = Exclude<EventTypes, 'click' | 'scroll' | 'resize'>;
// 'focus' | 'blur'
```

---

### NonNullable<T>

Removes null and undefined from T:

```typescript
type MaybeString = string | null | undefined;
type DefinitelyString = NonNullable<MaybeString>;
// string
```

---

### ReturnType<T>

Gets the return type of a function type:

```typescript
function createFilters(): AutomobileFilters {
  return new AutomobileFilters();
}

type Filters = ReturnType<typeof createFilters>;
// AutomobileFilters
```

---

### Parameters<T>

Gets the parameter types of a function as a tuple:

```typescript
function fetchData(filters: AutomobileFilters, page: number): Promise<VehicleResult[]> {
  // ...
}

type FetchParams = Parameters<typeof fetchData>;
// [AutomobileFilters, number]
```

---

## Advanced Patterns

### Mapped Types

Transform properties of a type:

```typescript
// Make all properties nullable
type Nullable<T> = {
  [P in keyof T]: T[P] | null;
};

interface User {
  name: string;
  age: number;
}

type NullableUser = Nullable<User>;
// { name: string | null; age: number | null; }
```

### Conditional Types

Types that depend on conditions:

```typescript
type IsArray<T> = T extends any[] ? true : false;

type A = IsArray<string[]>;  // true
type B = IsArray<string>;    // false
```

**Practical example:**

```typescript
// Unwrap array types, leave others alone
type Unwrap<T> = T extends (infer U)[] ? U : T;

type A = Unwrap<string[]>;  // string
type B = Unwrap<number>;    // number
```