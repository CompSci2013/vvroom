### Observables vs Promises

| Promises | Observables |
|----------|-------------|
| Single value | Multiple values over time |
| Eager (starts immediately) | Lazy (starts on subscribe) |
| Not cancellable | Cancellable (unsubscribe) |
| No operators | Rich operator library |

Promises are great for one-time async operations. Observables are better for ongoing data streams like user input, WebSocket messages, or state changes.

---

## The Four Essential Operators

Vvroom uses many RxJS operators, but four are critical to understand:

### 1. `switchMap` — Cancel and Switch

**Problem:** When the URL changes rapidly (user clicking filters quickly), you don't want to process all intermediate requests — just the latest one.

```typescript
import { switchMap } from 'rxjs/operators';

// Without switchMap: every filter change triggers a request
// Results may arrive out of order, showing stale data

// With switchMap: previous request is cancelled when a new one starts
this.results$ = this.filters$.pipe(
  switchMap(filters => this.apiAdapter.fetchData(filters))
);
```

**How it works:**

```
filters$:    --A------B--C-------->
                \      \  \
fetchData(A):    ---X   |  |      (cancelled)
fetchData(B):          -X  |      (cancelled)
fetchData(C):              ----Y-->
results$:    ----------------Y--->

Only the result of the last request (C → Y) is emitted.
```

**When to use:** API calls triggered by user input where only the latest matters.

### 2. `combineLatest` — Combine Multiple Streams

**Problem:** You need to react when *any* of several values change, and you need all current values together.

```typescript
import { combineLatest } from 'rxjs';

// Combine filters and highlights into a single stream
const combined$ = combineLatest([
  this.filters$,
  this.highlights$
]);

combined$.subscribe(([filters, highlights]) => {
  // Called whenever either filters OR highlights change
  // Always has the latest value of both
  this.fetchData(filters, highlights);
});
```

**How it works:**

```
filters$:      --A----B---------->
highlights$:   ----1----2-------->
combined$:     ----[A,1][B,1][B,2]>

Emits when either changes, always with latest values.
```

**Important:** `combineLatest` doesn't emit until *all* source Observables have emitted at least once. If one never emits, combined never emits.

**When to use:** Combining multiple independent state sources.