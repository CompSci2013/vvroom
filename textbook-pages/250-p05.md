### Pattern 1: Store and Unsubscribe

```typescript
import { Subscription } from 'rxjs';

@Component({ /* ... */ })
export class MyComponent implements OnDestroy {
  private subscription: Subscription;

  ngOnInit() {
    this.subscription = this.filters$.subscribe(filters => {
      // Handle filters
    });
  }

  ngOnDestroy() {
    this.subscription.unsubscribe();
  }
}
```

### Pattern 2: Use `takeUntil` (Preferred)

```typescript
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

@Component({ /* ... */ })
export class MyComponent implements OnDestroy {
  private destroy$ = new Subject<void>();

  ngOnInit() {
    this.filters$.pipe(
      takeUntil(this.destroy$)
    ).subscribe(filters => {
      // Handle filters
    });

    // Multiple subscriptions can share the same destroy$
    this.results$.pipe(
      takeUntil(this.destroy$)
    ).subscribe(results => {
      // Handle results
    });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

### Pattern 3: Use the Async Pipe (Best)

The async pipe in templates automatically subscribes and unsubscribes:

```typescript
@Component({
  template: `
    <div *ngIf="filters$ | async as filters">
      Current manufacturer: {{ filters.manufacturer }}
    </div>
  `
})
export class MyComponent {
  filters$ = this.urlStateService.filters$;
}
```

**Why this is best:**
- No manual subscription management
- No memory leak risk
- Angular handles everything

Use the async pipe whenever possible. Fall back to `takeUntil` when you need the value in component code.

---

## The Aha Moment

**Observables model change over time. That's why they fit state management.**

In vvroom's URL-First architecture:
- The URL is state
- The URL changes over time (user navigates, clicks filters)
- Components need to react to those changes

Observables are the perfect fit:

```typescript
// URL changes over time
this.route.queryParams  // Observable<Params>

// Filters derived from URL, changing over time
this.filters$  // Observable<TFilters>

// Results derived from filters, changing over time
this.results$  // Observable<TData[]>

// Components react to changes
this.results$.subscribe(results => this.updateTable(results));
```

The entire data flow is modeled as Observables:

```
URL → queryParams → filters → API request → results → display
     (Observable)  (Observable)            (Observable)
```

When the URL changes, the entire chain reacts automatically. You don't manually trigger updates — you describe how data flows, and RxJS handles the rest.