<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Brownfield Companion: Integrating URL-First Architecture</title>
    <style>
        @page {
            size: letter;
            margin: 1in 0.75in;
            @top-center {
                content: "Brownfield Companion";
                font-size: 10pt;
                color: #666;
            }
            @bottom-center {
                content: counter(page);
                font-size: 10pt;
            }
        }

        @page:first {
            @top-center { content: none; }
        }

        @page toc {
            @top-center { content: "Table of Contents"; }
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            font-size: 11pt;
            line-height: 1.5;
            color: #333;
            max-width: 100%;
        }

        /* Title page */
        .title-page {
            page: title;
            text-align: center;
            padding-top: 2.5in;
            page-break-after: always;
        }

        .title-page h1 {
            font-size: 32pt;
            margin-bottom: 0.3in;
            color: #2d5016;
        }

        .title-page .subtitle {
            font-size: 16pt;
            color: #4a5568;
            margin-bottom: 0.5in;
        }

        .title-page .meta {
            font-size: 11pt;
            color: #718096;
            margin-top: 1in;
            line-height: 1.8;
        }

        .title-page .meta strong {
            color: #4a5568;
        }

        /* Table of Contents */
        .toc {
            page: toc;
            page-break-after: always;
        }

        .toc h1 {
            font-size: 24pt;
            margin-bottom: 0.5in;
            color: #2d5016;
            border-bottom: 2px solid #2d5016;
            padding-bottom: 0.25in;
        }

        .toc-entry {
            padding: 0.05in 0;
            font-size: 10pt;
        }

        .toc-entry a {
            color: #2b6cb0;
            text-decoration: none;
        }

        .toc-level-1 {
            font-weight: bold;
            font-size: 12pt;
            margin-top: 0.15in;
        }

        .toc-level-2 {
            padding-left: 0.2in;
        }

        .toc-level-3 {
            padding-left: 0.4in;
            font-size: 9pt;
        }

        /* Main content */
        .content {
            page-break-before: always;
        }

        /* Content headings */
        h1 {
            font-size: 22pt;
            color: #2d5016;
            margin-top: 0.4in;
            margin-bottom: 0.2in;
            page-break-after: avoid;
            border-bottom: 2px solid #2d5016;
            padding-bottom: 0.1in;
        }

        h2 {
            font-size: 16pt;
            color: #3d6b22;
            margin-top: 0.3in;
            margin-bottom: 0.15in;
            page-break-after: avoid;
        }

        h3 {
            font-size: 13pt;
            color: #4a5568;
            margin-top: 0.25in;
            margin-bottom: 0.1in;
            page-break-after: avoid;
        }

        h4 {
            font-size: 11pt;
            color: #4a5568;
            margin-top: 0.2in;
            margin-bottom: 0.1in;
            page-break-after: avoid;
        }

        /* Paragraphs */
        p {
            margin: 0.1in 0;
            text-align: justify;
        }

        /* Code blocks */
        pre.code-block {
            background: #1a202c;
            color: #e2e8f0;
            padding: 0.15in;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 8.5pt;
            line-height: 1.35;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            page-break-inside: avoid;
            margin: 0.12in 0;
            border-left: 3px solid #48bb78;
        }

        code.inline {
            background: #edf2f7;
            color: #22543d;
            padding: 0.02in 0.05in;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 9.5pt;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 0.15in 0;
            font-size: 9.5pt;
            page-break-inside: avoid;
        }

        th, td {
            border: 1px solid #cbd5e0;
            padding: 0.08in 0.12in;
            text-align: left;
        }

        th {
            background: #c6f6d5;
            font-weight: bold;
            color: #22543d;
        }

        tr:nth-child(even) {
            background: #f0fff4;
        }

        /* Lists */
        ul, ol {
            margin: 0.1in 0;
            padding-left: 0.3in;
        }

        li {
            margin: 0.03in 0;
        }

        li.checkbox {
            list-style: none;
            margin-left: -0.2in;
        }

        li.checkbox::before {
            content: "☐ ";
            color: #718096;
        }

        li.checkbox.checked::before {
            content: "☑ ";
            color: #48bb78;
        }

        /* Horizontal rules */
        hr {
            border: none;
            border-top: 1px solid #cbd5e0;
            margin: 0.2in 0;
        }

        hr.section-break {
            border-top: 2px solid #c6f6d5;
            margin: 0.3in 0;
        }

        /* Links */
        a {
            color: #2b6cb0;
            text-decoration: none;
        }

        /* Strong/emphasis */
        strong { font-weight: bold; }
        em { font-style: italic; }

        /* ASCII diagrams - preserve formatting */
        pre.code-block.text {
            background: #f7fafc;
            color: #2d3748;
            border-left-color: #a0aec0;
        }

        /* Special callout for key insights */
        p:has(strong:first-child) {
            background: #f0fff4;
            padding: 0.1in;
            border-left: 3px solid #48bb78;
            margin: 0.15in 0;
        }
    </style>
</head>
<body>
    <!-- Title Page -->
    <div class="title-page">
        <h1>Brownfield Companion</h1>
        <div class="subtitle">Integrating URL-First Architecture</div>
        <div class="meta">
            <p><strong>Document Type:</strong> Migration Guide</p>
            <p><strong>Audience:</strong> Developers with existing Angular 13 applications</p>
            <p><strong>Companion To:</strong> The VVRoom Angular Textbook (Greenfield)</p>
            <p><strong>Angular Version:</strong> 13.x (NgModule-based architecture)</p>
        </div>
    </div>

    <!-- Table of Contents -->
    <div class="toc">
<h1>Table of Contents</h1>
<div class="toc-entry toc-level-2">
<a href="#angular-version-compatibility">Angular Version Compatibility</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#key-angular-13-patterns-used">Key Angular 13 Patterns Used</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#modern-angular-adaptations">Modern Angular Adaptations</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#rxjs-import-patterns-angular-13">RxJS Import Patterns (Angular 13)</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#overview">Overview</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#table-of-contents">Table of Contents</a>
</div>
<div class="toc-entry toc-level-1">
<a href="#part-1-url-first-state-management-integration">Part 1: URL-First State Management Integration</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#assessment-where-does-your-state-live">Assessment: Where Does Your State Live?</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#state-location-audit">State Location Audit</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#state-flow-diagram-before-vs-after">State Flow Diagram: Before vs After</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#the-migration-strategy">The Migration Strategy</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#the-strangler-fig-pattern">The Strangler Fig Pattern</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#risk-mitigation">Risk Mitigation</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#step-1-install-the-url-state-service">Step 1: Install the URL State Service</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#create-the-service">Create the Service</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#verify-installation">Verify Installation</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#ngmodule-registration-angular-13">NgModule Registration (Angular 13)</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#step-2-create-your-domain-adapters">Step 2: Create Your Domain Adapters</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#the-adapter-pattern">The Adapter Pattern</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#create-the-url-mapper-interface">Create the URL Mapper Interface</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#example-migrating-an-existing-filter-model">Example: Migrating an Existing Filter Model</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#example-wrapping-your-existing-api-service">Example: Wrapping Your Existing API Service</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#step-3-wire-up-resourcemanagementservice">Step 3: Wire Up ResourceManagementService</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#install-the-service">Install the Service</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#create-the-domain-config">Create the Domain Config</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#step-4-migrate-components-incrementally">Step 4: Migrate Components Incrementally</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#the-strangler-pattern-for-components">The Strangler Pattern for Components</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#migration-checklist-per-component">Migration Checklist Per Component</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#common-brownfield-challenges">Common Brownfield Challenges</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#challenge-1-i-have-ngrx-for-state-management">Challenge 1: "I have NgRx for state management"</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#challenge-2-my-filter-values-are-complex-objects">Challenge 2: "My filter values are complex objects"</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#challenge-3-some-state-shouldnt-be-in-the-url">Challenge 3: "Some state shouldn't be in the URL"</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#challenge-4-i-need-to-migrate-20-components">Challenge 4: "I need to migrate 20+ components"</a>
</div>
<div class="toc-entry toc-level-1">
<a href="#part-2-framework-component-conversion">Part 2: Framework Component Conversion</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#assessment-what-components-do-you-have">Assessment: What Components Do You Have?</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#component-inventory">Component Inventory</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#why-convert">Why Convert?</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#setting-up-the-framework-module-angular-13">Setting Up the Framework Module (Angular 13)</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#converting-tables-to-basicresultstable">Converting Tables to BasicResultsTable</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#before-typical-custom-table">Before (Typical Custom Table)</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#after-using-basicresultstable">After (Using BasicResultsTable)</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#what-you-get-for-free">What You Get For Free</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#converting-pickers-to-basepicker">Converting Pickers to BasePicker</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#before-typical-custom-picker">Before (Typical Custom Picker)</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#after-using-basepicker">After (Using BasePicker)</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#selection-persistence-across-pages">Selection Persistence Across Pages</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#preserving-custom-behavior">Preserving Custom Behavior</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#extending-framework-components">Extending Framework Components</a>
</div>
<div class="toc-entry toc-level-3">
<a href="#custom-column-rendering">Custom Column Rendering</a>
</div>
<div class="toc-entry toc-level-1">
<a href="#migration-patterns-reference">Migration Patterns Reference</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#quick-reference-url-mapper-patterns">Quick Reference: URL Mapper Patterns</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#quick-reference-state-decision-tree">Quick Reference: State Decision Tree</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#migration-effort-estimates">Migration Effort Estimates</a>
</div>
<div class="toc-entry toc-level-2">
<a href="#success-criteria">Success Criteria</a>
</div>
</div>

    <!-- Main Content -->
    <div class="content">
        <h1 id="brownfield-companion-integrating-url-first-architecture">Brownfield Companion: Integrating URL-First Architecture</h1>

<p><strong>Document Type:</strong> Migration Guide <strong>Audience:</strong> Developers with existing Angular 13 applications <strong>Companion To:</strong> The Vroom Angular Textbook (Greenfield) <strong>Angular Version:</strong> 13.x (NgModule-based architecture)</p>

<hr class="section-break">

<h2 id="angular-version-compatibility">Angular Version Compatibility</h2>

<p>This guide is written for <strong>Angular 13</strong> applications using the <strong>NgModule-based architecture</strong> (the pattern used before standalone components became the default in Angular 15+).</p>

<table>
<p><thead><tr> <th>Angular Version</th> <th>Compatibility</th> <th>Notes</th></p>
</tr></thead>
<p><tbody> <tr> <td>13.x</td> <td>✅ Full</td> <td>This guide's target version</td></p>
</tr>
<p><tr> <td>14.x</td> <td>✅ Full</td> <td>NgModules still default</td></p>
</tr>
<p><tr> <td>15.x</td> <td>⚠️ Adapt</td> <td>Standalone components optional; NgModules work</td></p>
</tr>
<p><tr> <td>16.x+</td> <td>⚠️ Adapt</td> <td>See "Modern Angular Adaptations" section below</td></p>
</tr>
</tbody>
</table>

<h3 id="key-angular-13-patterns-used">Key Angular 13 Patterns Used</h3>

<p>This guide assumes your application uses:</p>

<ul><li><strong>NgModules</strong> (<code class="inline">@NgModule</code>) for organizing code, not standalone components</li>
<p><li><strong>Constructor injection</strong> for services, not the <code class="inline">inject()</code> function</li> <li><strong>Class-based services</strong> with <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li><strong>RxJS 7.x</strong> operators imported from <code class="inline">rxjs/operators</code></li> <li><strong>Router with <code class="inline">RouterModule.forRoot()</code></strong> configuration</li></p>
</ul>
<h3 id="modern-angular-adaptations">Modern Angular Adaptations</h3>

<p>If you're on Angular 15+, the patterns still work but you may prefer:</p>

<pre class="code-block typescript"><code>// Angular 13 style (used in this guide)
<p>@Component({ selector: 'app-discover', templateUrl: './discover.component.html', providers: [ResourceManagementService] }) export class DiscoverComponent { constructor( private resources: ResourceManagementService&lt;Filters, Data&gt;, private urlState: UrlStateService ) {} }</p>

<p>// Angular 15+ style (standalone components) @Component({ selector: 'app-discover', standalone: true, imports: [CommonModule, BasicResultsTableComponent], templateUrl: './discover.component.html', providers: [ResourceManagementService] }) export class DiscoverComponent { private resources = inject(ResourceManagementService&lt;Filters, Data&gt;); private urlState = inject(UrlStateService); }</p>
</code></pre>

<p>The URL-First concepts and service implementations are <strong>identical</strong> regardless of Angular version—only the component declaration syntax differs.</p>

<h3 id="rxjs-import-patterns-angular-13">RxJS Import Patterns (Angular 13)</h3>

<p>Angular 13 uses RxJS 7.x. Import operators from <code class="inline">rxjs/operators</code>:</p>

<pre class="code-block typescript"><code>// Correct for Angular 13 / RxJS 7.x
<p>import { Observable, BehaviorSubject, Subject } from 'rxjs'; import { map, filter, distinctUntilChanged, takeUntil, switchMap } from 'rxjs/operators';</p>

<p>// Usage with pipe() this.urlState.watchParams().pipe( map(params =&gt; this.mapper.fromUrlParams(params)), distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)), takeUntil(this.destroy$) ).subscribe(filters =&gt; { this.filters = filters; });</p>
</code></pre>

<hr class="section-break">

<h2 id="overview">Overview</h2>

<p>The Vroom textbook teaches URL-First architecture from scratch. This companion addresses a different challenge: <strong>How do I retrofit these patterns into an existing application?</strong></p>

<p>Brownfield development is messier than greenfield. You have:</p>
<ul><li>Existing state management (possibly NgRx, services, or component state)</li>
<p><li>Tables and pickers that already work</li> <li>Users who expect current behavior to continue</li> <li>Technical debt that can't all be addressed at once</li></p>
</ul>
<p>This guide provides a <strong>phased migration path</strong> that lets you adopt URL-First incrementally without breaking your application.</p>

<hr class="section-break">

<h2 id="table-of-contents">Table of Contents</h2>

<ul><li><a href="#part-1-url-first-state-management-integration">Part 1: URL-First State Management Integration</a></li>
</ul>   <ul><li><a href="#assessment-where-does-your-state-live">Assessment: Where Does Your State Live?</a></li>
</ul>   <ul><li><a href="#the-migration-strategy">The Migration Strategy</a></li>
</ul>   <ul><li><a href="#step-1-install-the-url-state-service">Step 1: Install the URL State Service</a></li>
</ul>   <ul><li><a href="#step-2-create-your-domain-adapters">Step 2: Create Your Domain Adapters</a></li>
</ul>   <ul><li><a href="#step-3-wire-up-resourcemanagementservice">Step 3: Wire Up ResourceManagementService</a></li>
</ul>   <ul><li><a href="#step-4-migrate-components-incrementally">Step 4: Migrate Components Incrementally</a></li>
</ul>   <ul><li><a href="#common-brownfield-challenges">Common Brownfield Challenges</a></li>
</ul>
<ul><li><a href="#part-2-framework-component-conversion">Part 2: Framework Component Conversion</a></li>
</ul>   <ul><li><a href="#assessment-what-components-do-you-have">Assessment: What Components Do You Have?</a></li>
</ul>   <ul><li><a href="#converting-tables-to-basicresultstable">Converting Tables to BasicResultsTable</a></li>
</ul>   <ul><li><a href="#converting-pickers-to-basepicker">Converting Pickers to BasePicker</a></li>
</ul>   <ul><li><a href="#preserving-custom-behavior">Preserving Custom Behavior</a></li>
</ul>
<ul><li><a href="#migration-patterns-reference">Migration Patterns Reference</a></li>
</ul>
<hr class="section-break">

<h1 id="part-1-url-first-state-management-integration">Part 1: URL-First State Management Integration</h1>

<h2 id="assessment-where-does-your-state-live">Assessment: Where Does Your State Live?</h2>

<p>Before migrating, understand your current state architecture.</p>

<h3 id="state-location-audit">State Location Audit</h3>

<table>
<p><thead><tr> <th>Question</th> <th>If Yes...</th></p>
</tr></thead>
<p><tbody> <tr> <td>Do components have local properties for filters/data?</td> <td>Component-level state (easiest to migrate)</td></p>
</tr>
<p><tr> <td>Do you have services with <code class="inline">BehaviorSubject</code> for filters?</td> <td>Service-level state (moderate migration)</td></p>
</tr>
<p><tr> <td>Do you use NgRx or similar for filter/results state?</td> <td>Store-based state (consider keeping for complex scenarios)</td></p>
</tr>
<p><tr> <td>Can users bookmark/share filtered views?</td> <td>You may already have partial URL state</td></p>
</tr>
<p><tr> <td>Do you have pop-out windows or multi-tab sync?</td> <td>URL-First provides this for free</td></p>
</tr>
</tbody>
</table>

<h3 id="state-flow-diagram-before-vs-after">State Flow Diagram: Before vs After</h3>

<p><strong>Before (Typical Brownfield):</strong></p>
<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────────────────┐
<p>│                           Component State                                    │ │                                                                             │ │  ┌──────────────┐    ┌──────────────┐    ┌──────────────┐                  │ │  │ FilterPanel  │    │  DataService │    │ ResultsTable │                  │ │  │              │───▶│              │───▶│              │                  │ │  │ filters: {}  │    │ BehaviorSubj │    │ data: []     │                  │ │  └──────────────┘    └──────────────┘    └──────────────┘                  │ │                                                                             │ │  Problems:                                                                  │ │  • State lost on refresh                                                    │ │  • Can't share filtered views via URL                                       │ │  • Browser back/forward doesn't work                                        │ │  • Multiple tabs can't sync                                                 │ └─────────────────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p><strong>After (URL-First):</strong></p>
<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────────────────┐
<p>│                              URL (Source of Truth)                           │ │                           ?manufacturer=Ford&amp;page=1                          │ └─────────────────────────────────────────────────────────────────────────────┘ │ ▼ watchParams() ┌─────────────────────────────────────────────────────────────────────────────┐ │                         ResourceManagementService                            │ │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │ │  │   filters$   │  │   results$   │  │   loading$   │  │    error$    │    │ │  │ {mfr: Ford}  │  │ [...data]    │  │    false     │  │    null      │    │ │  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘    │ └─────────────────────────────────────────────────────────────────────────────┘ │ ▼ subscribe() ┌─────────────────────────────────────────────────────────────────────────────┐ │                              UI Components                                   │ │         FilterPanel    ResultsTable    Charts    (All read-only)            │ └─────────────────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<hr class="section-break">

<h2 id="the-migration-strategy">The Migration Strategy</h2>

<h3 id="the-strangler-fig-pattern">The Strangler Fig Pattern</h3>

<p>Don't rewrite everything at once. Instead, wrap old functionality with new patterns and gradually migrate:</p>

<pre class="code-block text"><code>Phase 1: Add URL-First services alongside existing state
<p>Phase 2: Migrate one feature to URL-First (pilot) Phase 3: Migrate remaining features incrementally Phase 4: Remove legacy state management</p>
</code></pre>

<h3 id="risk-mitigation">Risk Mitigation</h3>

<table>
<p><thead><tr> <th>Risk</th> <th>Mitigation</th></p>
</tr></thead>
<p><tbody> <tr> <td>Breaking existing functionality</td> <td>Feature flags to toggle URL-First on/off</td></p>
</tr>
<p><tr> <td>Regression in edge cases</td> <td>Parallel testing: old and new side-by-side</td></p>
</tr>
<p><tr> <td>Team unfamiliarity</td> <td>Pilot with one feature before broad rollout</td></p>
</tr>
<p><tr> <td>Performance regression</td> <td>Profile before/after; URL parsing is cheap</td></p>
</tr>
</tbody>
</table>

<hr class="section-break">

<h2 id="step-1-install-the-url-state-service">Step 1: Install the URL State Service</h2>

<p>The foundation of URL-First is <code class="inline">UrlStateService</code>. Add it to your application.</p>

<h3 id="create-the-service">Create the Service</h3>

<p>Create <code class="inline">src/app/framework/services/url-state.service.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/url-state.service.ts
<p>// URL-First state management foundation</p>

<p>import { Injectable, NgZone } from '@angular/core'; import { Router, Params, NavigationEnd } from '@angular/router'; import { Observable, BehaviorSubject } from 'rxjs'; import { map, distinctUntilChanged, filter } from 'rxjs/operators';</p>

<p>/**</p>
 <ul><li>Domain-agnostic URL state management service</li>
</ul> *
 <ul><li>Provides bidirectional synchronization between application state</li>
</ul> <ul><li>and URL query parameters. The URL serves as the single source of truth.</li>
</ul> *
 <ul><li>KEY DESIGN DECISIONS:</li>
</ul> *
 <ul><li>1. Uses Router.events instead of ActivatedRoute.queryParams because this</li>
</ul> <ul><li>   is a root-level singleton. ActivatedRoute at root level doesn't receive</li>
</ul> <ul><li>   query param updates from child routes (like /discover).</li>
</ul> *
 <ul><li>2. Uses BehaviorSubject to provide:</li>
</ul> <ul><li>   - Synchronous access to current params via getParams()</li>
</ul> <ul><li>   - Observable stream for reactive updates via watchParams()</li>
</ul> <ul><li>   - Immediate value emission to new subscribers</li>
</ul> */
<p>@Injectable({ providedIn: 'root' }) export class UrlStateService { private paramsSubject = new BehaviorSubject&lt;Params&gt;({}); public params$: Observable&lt;Params&gt; = this.paramsSubject.asObservable();</p>

<p>constructor( private router: Router, private ngZone: NgZone ) { this.initializeFromRoute(); this.watchRouteChanges(); }</p>

<p>/**</p>
   <ul><li>Get current URL query parameters synchronously</li>
</ul>   */
<p>getParams&lt;TParams = Params&gt;(): TParams { return this.paramsSubject.value as TParams; }</p>

<p>/**</p>
   <ul><li>Update URL query parameters (shallow merge)</li>
</ul>   <ul><li>Use null to remove a parameter</li>
</ul>   */
<p>async setParams&lt;TParams = Params&gt;( params: Partial&lt;TParams&gt;, replaceUrl = false ): Promise&lt;boolean&gt; { const currentParams = this.paramsSubject.value; const mergedParams = { ...currentParams };</p>

<p>Object.keys(params).forEach(key =&gt; { const value = (params as any)[key]; if (value === null || value === undefined) { delete mergedParams[key]; } else { mergedParams[key] = value; } });</p>

<p>return await this.router.navigate([], { queryParams: mergedParams, replaceUrl, queryParamsHandling: '' }); }</p>

<p>/**</p>
   <ul><li>Watch URL query parameters as an observable stream</li>
</ul>   */
<p>watchParams&lt;TParams = Params&gt;(): Observable&lt;TParams&gt; { return this.params$.pipe( map(params =&gt; params as TParams), distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)) ); }</p>

<p>/**</p>
   <ul><li>Clear all URL query parameters</li>
</ul>   */
<p>async clearParams(replaceUrl = false): Promise&lt;boolean&gt; { return this.router.navigate([], { queryParams: {}, replaceUrl }); }</p>

<p>private initializeFromRoute(): void { const params = this.extractQueryParams(); this.ngZone.run(() =&gt; { this.paramsSubject.next(params); }); }</p>

<p>private watchRouteChanges(): void { this.router.events .pipe( filter((event): event is NavigationEnd =&gt; event instanceof NavigationEnd), map(() =&gt; this.extractQueryParams()), distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)) ) .subscribe(params =&gt; { this.ngZone.run(() =&gt; { this.paramsSubject.next(params); }); }); }</p>

<p>private extractQueryParams(): Params { const urlTree = this.router.parseUrl(this.router.url); return urlTree.queryParams; } }</p>
</code></pre>

<h3 id="verify-installation">Verify Installation</h3>

<p>Add a temporary test to any component:</p>

<pre class="code-block typescript"><code>import { UrlStateService } from './framework/services/url-state.service';

<p>// In constructor constructor(private urlState: UrlStateService) {}</p>

<p>// In ngOnInit ngOnInit(): void { this.urlState.watchParams().subscribe(params =&gt; { console.log('[URL-First] Params changed:', params); }); }</p>
</code></pre>

<p>Navigate to <code class="inline">http://localhost:4200?test=123</code> and verify console output.</p>

<h3 id="ngmodule-registration-angular-13">NgModule Registration (Angular 13)</h3>

<p>The <code class="inline">UrlStateService</code> uses <code class="inline">providedIn: 'root'</code>, so it's automatically available application-wide. No module registration needed.</p>

<p>If you prefer explicit module registration:</p>

<pre class="code-block typescript"><code>// src/app/app.module.ts

<p>import { UrlStateService } from './framework/services/url-state.service';</p>

<p>@NgModule({ providers: [ UrlStateService  // Optional: providedIn: 'root' handles this ] }) export class AppModule {}</p>
</code></pre>

<hr class="section-break">

<h2 id="step-2-create-your-domain-adapters">Step 2: Create Your Domain Adapters</h2>

<p>Adapters translate between your domain models and URL parameters.</p>

<h3 id="the-adapter-pattern">The Adapter Pattern</h3>

<pre class="code-block text"><code>┌──────────────────────────────────────────────────────────────────────────────┐
<p>│                         ResourceManagementService                             │ │                 (Generic: works with any TFilters, TData)                     │ └──────────────────────────────────────────────────────────────────────────────┘ │ │ uses interfaces ▼ ┌──────────────────────────────────────────────────────────────────────────────┐ │    IFilterUrlMapper          IApiAdapter             ICacheKeyBuilder         │ │    (interface)               (interface)             (interface)              │ └──────────────────────────────────────────────────────────────────────────────┘ │ │ implemented by YOUR domain ▼ ┌──────────────────────────────────────────────────────────────────────────────┐ │  YourDomainUrlMapper      YourDomainApiAdapter      YourDomainCacheKeyBuilder │ │  (concrete)               (concrete)                (concrete)                │ └──────────────────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<h3 id="create-the-url-mapper-interface">Create the URL Mapper Interface</h3>

<pre class="code-block typescript"><code>// src/app/framework/models/resource-management.interface.ts

<p>import { Params } from '@angular/router'; import { Observable } from 'rxjs';</p>

<p>/**</p>
 <ul><li>Adapter for mapping filters to/from URL parameters</li>
</ul> */
<p>export interface IFilterUrlMapper&lt;TFilters&gt; { /**</p>
   <ul><li>Convert domain filters to URL query parameters</li>
</ul>   */
<p>toUrlParams(filters: TFilters): Params;</p>

<p>/**</p>
   <ul><li>Convert URL query parameters to domain filters</li>
</ul>   */
<p>fromUrlParams(params: Params): TFilters;</p>

<p>/**</p>
   <ul><li>Extract highlight filters from URL parameters (optional)</li>
</ul>   */
<p>extractHighlights?(params: Params): any; }</p>

<p>/**</p>
 <ul><li>Adapter for fetching data from API</li>
</ul> */
<p>export interface IApiAdapter&lt;TFilters, TData, TStatistics = any&gt; { fetchData( filters: TFilters, highlights?: any ): Observable&lt;ApiAdapterResponse&lt;TData, TStatistics&gt;&gt;; }</p>

<p>export interface ApiAdapterResponse&lt;TData, TStatistics = any&gt; { results: TData[]; total: number; statistics?: TStatistics; }</p>
</code></pre>

<h3 id="example-migrating-an-existing-filter-model">Example: Migrating an Existing Filter Model</h3>

<p><strong>Before (your existing code):</strong></p>
<pre class="code-block typescript"><code>// Your existing filter service
<p>export interface ProductFilters { category: string; minPrice: number; maxPrice: number; inStock: boolean; page: number; pageSize: number; }</p>
</code></pre>

<p><strong>After (create an adapter):</strong></p>
<pre class="code-block typescript"><code>// src/app/domains/products/adapters/product-url-mapper.ts

<p>import { Params } from '@angular/router'; import { IFilterUrlMapper } from '../../../framework/models/resource-management.interface'; import { ProductFilters } from '../models/product-filters.model';</p>

<p>export class ProductUrlMapper implements IFilterUrlMapper&lt;ProductFilters&gt; {</p>

<p>toUrlParams(filters: ProductFilters): Params { const params: Params = {};</p>

<p>// Only include non-default values if (filters.category) params['category'] = filters.category; if (filters.minPrice &gt; 0) params['minPrice'] = String(filters.minPrice); if (filters.maxPrice &lt; 10000) params['maxPrice'] = String(filters.maxPrice); if (filters.inStock) params['inStock'] = 'true'; if (filters.page &gt; 1) params['page'] = String(filters.page); if (filters.pageSize !== 20) params['size'] = String(filters.pageSize);</p>

<p>return params; }</p>

<p>fromUrlParams(params: Params): ProductFilters { return { category: params['category'] || '', minPrice: params['minPrice'] ? Number(params['minPrice']) : 0, maxPrice: params['maxPrice'] ? Number(params['maxPrice']) : 10000, inStock: params['inStock'] === 'true', page: params['page'] ? Number(params['page']) : 1, pageSize: params['size'] ? Number(params['size']) : 20 }; } }</p>
</code></pre>

<h3 id="example-wrapping-your-existing-api-service">Example: Wrapping Your Existing API Service</h3>

<p><strong>Before (your existing API service):</strong></p>
<pre class="code-block typescript"><code>@Injectable({ providedIn: 'root' })
<p>export class ProductApiService { constructor(private http: HttpClient) {}</p>

<p>searchProducts(filters: ProductFilters): Observable&lt;ProductResponse&gt; { return this.http.get&lt;ProductResponse&gt;('/api/products', { params: this.buildParams(filters) }); } }</p>
</code></pre>

<p><strong>After (create an adapter that wraps it):</strong></p>
<pre class="code-block typescript"><code>// src/app/domains/products/adapters/product-api.adapter.ts

<p>import { Injectable } from '@angular/core'; import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { IApiAdapter, ApiAdapterResponse } from '../../../framework/models/resource-management.interface'; import { ProductFilters } from '../models/product-filters.model'; import { Product } from '../models/product.model'; import { ProductApiService } from '../services/product-api.service'; // YOUR EXISTING SERVICE</p>

<p>@Injectable({ providedIn: 'root' }) export class ProductApiAdapter implements IApiAdapter&lt;ProductFilters, Product&gt; {</p>

<p>constructor(private productApi: ProductApiService) {}</p>

<p>fetchData(filters: ProductFilters): Observable&lt;ApiAdapterResponse&lt;Product&gt;&gt; { // Delegate to your existing API service return this.productApi.searchProducts(filters).pipe( map(response =&gt; ({ results: response.products, total: response.totalCount, statistics: response.facets // optional })) ); } }</p>
</code></pre>

<p><strong>Key insight:</strong> You don't replace your existing API service. You <strong>wrap</strong> it with an adapter that conforms to the framework interface.</p>

<hr class="section-break">

<h2 id="step-3-wire-up-resourcemanagementservice">Step 3: Wire Up ResourceManagementService</h2>

<h3 id="install-the-service">Install the Service</h3>

<p>Create <code class="inline">src/app/framework/services/resource-management.service.ts</code> (see Section 306 in main textbook for full implementation).</p>

<p>The key points for brownfield integration:</p>

<pre class="code-block typescript"><code>@Injectable() // NOT providedIn: 'root' — component-level injection
<p>export class ResourceManagementService&lt;TFilters, TData, TStatistics = any&gt; implements OnDestroy {</p>

<p>// Observable streams for components to subscribe to public readonly filters$: Observable&lt;TFilters&gt;; public readonly results$: Observable&lt;TData[]&gt;; public readonly loading$: Observable&lt;boolean&gt;; public readonly error$: Observable&lt;Error | null&gt;;</p>

<p>constructor( private readonly urlState: UrlStateService, @Inject(DOMAIN_CONFIG) private readonly domainConfig: DomainConfig&lt;TFilters, TData, TStatistics&gt; ) { // Initialize from current URL this.initializeFromUrl(); // Watch for URL changes this.watchUrlChanges(); }</p>

<p>/**</p>
   <ul><li>Update filters → Updates URL → Triggers data fetch</li>
</ul>   */
<p>updateFilters(partial: Partial&lt;TFilters&gt;): void { // ... see full implementation this.urlState.setParams(newUrlParams); } }</p>
</code></pre>

<h3 id="create-the-domain-config">Create the Domain Config</h3>

<pre class="code-block typescript"><code>// src/app/domains/products/product-domain.config.ts

<p>import { InjectionToken } from '@angular/core'; import { DomainConfig } from '../../framework/models/domain-config.interface'; import { ProductFilters } from './models/product-filters.model'; import { Product } from './models/product.model'; import { ProductUrlMapper } from './adapters/product-url-mapper'; import { ProductApiAdapter } from './adapters/product-api.adapter';</p>

<p>export const PRODUCT_DOMAIN_CONFIG: DomainConfig&lt;ProductFilters, Product&gt; = { domainKey: 'products', displayName: 'Product Catalog', urlMapper: new ProductUrlMapper(), apiAdapter: null, // Injected at runtime (see provider) tableConfig: { columns: [ { field: 'name', header: 'Product Name', sortable: true }, { field: 'category', header: 'Category', sortable: true }, { field: 'price', header: 'Price', sortable: true, width: '100px' } ], dataKey: 'id' } };</p>

<p>// Provider factory export function productDomainConfigFactory(apiAdapter: ProductApiAdapter): DomainConfig&lt;ProductFilters, Product&gt; { return { ...PRODUCT_DOMAIN_CONFIG, apiAdapter }; }</p>

<p>export const DOMAIN_CONFIG = new InjectionToken&lt;DomainConfig&lt;any, any&gt;&gt;('DOMAIN_CONFIG');</p>

<p>export const PRODUCT_DOMAIN_PROVIDERS = [ { provide: DOMAIN_CONFIG, useFactory: productDomainConfigFactory, deps: [ProductApiAdapter] }, ResourceManagementService ];</p>
</code></pre>

<hr class="section-break">

<h2 id="step-4-migrate-components-incrementally">Step 4: Migrate Components Incrementally</h2>

<h3 id="the-strangler-pattern-for-components">The Strangler Pattern for Components</h3>

<p><strong>Phase A: Side-by-side</strong></p>
<pre class="code-block typescript"><code>@Component({
<p>template: <code class="inline"> &lt;!-- OLD: Your existing filter panel --&gt; &lt;app-old-filter-panel *ngIf="!useUrlFirst" [filters]="legacyFilters" (filtersChange)="onLegacyFilterChange($event)"&gt; &lt;/app-old-filter-panel&gt;</p>

<p>&lt;!-- NEW: URL-First version --&gt; &lt;app-new-filter-panel *ngIf="useUrlFirst" [filters]="resources.filters$ | async" (filtersChange)="resources.updateFilters($event)"&gt; &lt;/app-new-filter-panel&gt;</p>
  </code>
<p>}) export class DiscoverComponent { useUrlFirst = false; // Feature flag }</p>
</code></pre>

<p><strong>Phase B: Full migration</strong></p>
<pre class="code-block typescript"><code>@Component({
<p>providers: [...PRODUCT_DOMAIN_PROVIDERS], template: <code class="inline"> &lt;app-filter-panel [filters]="resources.filters$ | async" (filtersChange)="resources.updateFilters($event)"&gt; &lt;/app-filter-panel&gt;</p>

<p>&lt;app-results-table [data]="resources.results$ | async" [loading]="resources.loading$ | async"&gt; &lt;/app-results-table&gt;</p>
  </code>
<p>}) export class ProductDiscoverComponent { constructor(public resources: ResourceManagementService&lt;ProductFilters, Product&gt;) {} }</p>
</code></pre>

<h3 id="migration-checklist-per-component">Migration Checklist Per Component</h3>

<ul><li class="checkbox unchecked">Identify all state properties (filters, data, loading, etc.)</li>
<p><li class="checkbox unchecked">Determine which state should be URL-persisted</li> <li class="checkbox unchecked">Create domain adapter if not exists</li> <li class="checkbox unchecked">Add <code class="inline">ResourceManagementService</code> provider</li> <li class="checkbox unchecked">Replace direct state with observable subscriptions</li> <li class="checkbox unchecked">Replace state mutations with <code class="inline">updateFilters()</code></li> <li class="checkbox unchecked">Test: page refresh preserves state</li> <li class="checkbox unchecked">Test: browser back/forward works</li> <li class="checkbox unchecked">Test: URL can be copied and shared</li></p>
</ul>
<hr class="section-break">

<h2 id="common-brownfield-challenges">Common Brownfield Challenges</h2>

<h3 id="challenge-1-i-have-ngrx-for-state-management">Challenge 1: "I have NgRx for state management"</h3>

<p><strong>Solution:</strong> URL-First and NgRx can coexist.</p>

<pre class="code-block typescript"><code>// Use NgRx for complex state (shopping cart, user session)
<p>// Use URL-First for filter/search state (shareable, bookmarkable)</p>

<p>@Component({ providers: [ResourceManagementService] }) export class SearchComponent { // URL-First for search/filter state constructor( public resources: ResourceManagementService&lt;SearchFilters, SearchResult&gt;, private store: Store&lt;AppState&gt; // NgRx for other state ) {}</p>

<p>// Cart state from NgRx cart$ = this.store.select(selectCart);</p>

<p>// Search state from URL results$ = this.resources.results$; }</p>
</code></pre>

<h3 id="challenge-2-my-filter-values-are-complex-objects">Challenge 2: "My filter values are complex objects"</h3>

<p><strong>Solution:</strong> Serialize/deserialize in your URL mapper.</p>

<pre class="code-block typescript"><code>export class ComplexUrlMapper implements IFilterUrlMapper&lt;ComplexFilters&gt; {

<p>toUrlParams(filters: ComplexFilters): Params { return { // Simple values search: filters.search,</p>

<p>// Arrays: comma-separated categories: filters.categories?.join(',') || null,</p>

<p>// Objects: JSON (base64 if needed) dateRange: filters.dateRange ? <code class="inline">${filters.dateRange.start},${filters.dateRange.end}</code> : null,</p>

<p>// Nested: flatten with prefixes 'price.min': filters.priceRange?.min, 'price.max': filters.priceRange?.max }; }</p>

<p>fromUrlParams(params: Params): ComplexFilters { const dateRange = params['dateRange']?.split(','); return { search: params['search'] || '', categories: params['categories']?.split(',').filter(Boolean) || [], dateRange: dateRange ? { start: dateRange[0], end: dateRange[1] } : null, priceRange: { min: params['price.min'] ? Number(params['price.min']) : 0, max: params['price.max'] ? Number(params['price.max']) : 10000 } }; } }</p>
</code></pre>

<h3 id="challenge-3-some-state-shouldnt-be-in-the-url">Challenge 3: "Some state shouldn't be in the URL"</h3>

<p><strong>Solution:</strong> Only URL-map the shareable state.</p>

<pre class="code-block text"><code>URL State (Shareable):          Component State (Local):
<p>├── search query                ├── which accordion is expanded ├── selected filters            ├── tooltip visibility ├── current page                ├── form validation state ├── sort column/direction       └── temporary draft values └── selected item IDs</p>
</code></pre>

<pre class="code-block typescript"><code>@Component({...})
<p>export class DiscoverComponent { // URL-managed (survives refresh, shareable) filters$ = this.resources.filters$;</p>

<p>// Component-managed (local, transient) isAdvancedOpen = false; tooltipVisible = false; draftSearch = ''; }</p>
</code></pre>

<h3 id="challenge-4-i-need-to-migrate-20-components">Challenge 4: "I need to migrate 20+ components"</h3>

<p><strong>Solution:</strong> Prioritize by impact.</p>

<table>
<p><thead><tr> <th>Priority</th> <th>Criteria</th> <th>Action</th></p>
</tr></thead>
<p><tbody> <tr> <td>High</td> <td>Main search/filter pages</td> <td>Migrate first (highest user impact)</td></p>
</tr>
<p><tr> <td>Medium</td> <td>Secondary list views</td> <td>Migrate after validation</td></p>
</tr>
<p><tr> <td>Low</td> <td>Admin screens, modals</td> <td>Migrate opportunistically</td></p>
</tr>
<p><tr> <td>Skip</td> <td>Static pages, forms</td> <td>No URL state needed</td></p>
</tr>
</tbody>
</table>

<hr class="section-break">

<h1 id="part-2-framework-component-conversion">Part 2: Framework Component Conversion</h1>

<h2 id="assessment-what-components-do-you-have">Assessment: What Components Do You Have?</h2>

<h3 id="component-inventory">Component Inventory</h3>

<table>
<p><thead><tr> <th>Component Type</th> <th>Signs You Have It</th> <th>Framework Replacement</th></p>
</tr></thead>
<p><tbody> <tr> <td>Data Table</td> <td><code class="inline">&lt;p-table&gt;</code>, <code class="inline">&lt;mat-table&gt;</code>, custom <code class="inline">*ngFor</code> table</td> <td><code class="inline">BasicResultsTableComponent</code></td></p>
</tr>
<p><tr> <td>Multi-select Picker</td> <td>Dropdown/modal with checkboxes, "Apply" button</td> <td><code class="inline">BasePickerComponent</code></td></p>
</tr>
<p><tr> <td>Chart Display</td> <td>Plotly, Chart.js, or similar</td> <td><code class="inline">BaseChartComponent</code></td></p>
</tr>
<p><tr> <td>Filter Panel</td> <td>Form with multiple filter inputs</td> <td><code class="inline">QueryPanelComponent</code></td></p>
</tr>
<p><tr> <td>Active Filter Chips</td> <td>Tags showing current filters</td> <td><code class="inline">InlineFiltersComponent</code></td></p>
</tr>
</tbody>
</table>

<h3 id="why-convert">Why Convert?</h3>

<p>Converting existing components to framework components provides:</p>

<ul><li><strong>URL Synchronization</strong> - Selections persist in URL automatically</li>
<p><li><strong>Consistent UX</strong> - Unified behavior across your application</li> <li><strong>Less Code</strong> - Configuration replaces implementation</li> <li><strong>Pop-out Support</strong> - Works in pop-out windows with no extra code</li></p>
</ul>
<hr class="section-break">

<h2 id="setting-up-the-framework-module-angular-13">Setting Up the Framework Module (Angular 13)</h2>

<p>Before using framework components, create the module that declares and exports them:</p>

<pre class="code-block typescript"><code>// src/app/framework/framework.module.ts

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms';</p>

<p>// PrimeNG modules (or your UI library) import { TableModule } from 'primeng/table'; import { ButtonModule } from 'primeng/button'; import { CheckboxModule } from 'primeng/checkbox'; import { InputTextModule } from 'primeng/inputtext'; import { SkeletonModule } from 'primeng/skeleton';</p>

<p>// Framework components import { BasicResultsTableComponent } from './components/basic-results-table/basic-results-table.component'; import { BasePickerComponent } from './components/base-picker/base-picker.component';</p>

<p>@NgModule({ declarations: [ BasicResultsTableComponent, BasePickerComponent ], imports: [ CommonModule, FormsModule, TableModule, ButtonModule, CheckboxModule, InputTextModule, SkeletonModule ], exports: [ // Export components for use in feature modules BasicResultsTableComponent, BasePickerComponent ] }) export class FrameworkModule {}</p>
</code></pre>

<p>Feature modules import <code class="inline">FrameworkModule</code> to access these components:</p>

<pre class="code-block typescript"><code>// src/app/features/products/products.module.ts
<p>@NgModule({ imports: [ CommonModule, FrameworkModule  // &lt;-- Provides BasicResultsTableComponent, etc. ], declarations: [ProductDiscoverComponent] }) export class ProductsModule {}</p>
</code></pre>

<hr class="section-break">

<h2 id="converting-tables-to-basicresultstable">Converting Tables to BasicResultsTable</h2>

<h3 id="before-typical-custom-table">Before (Typical Custom Table)</h3>

<pre class="code-block typescript"><code>@Component({
<p>template: <code class="inline"> &lt;p-table [value]="products" [loading]="loading" [paginator]="true" [rows]="pageSize" [totalRecords]="totalCount" (onLazyLoad)="loadData($event)"&gt; &lt;ng-template pTemplate="header"&gt; &lt;tr&gt; &lt;th pSortableColumn="name"&gt;Name &lt;p-sortIcon field="name"&gt;&lt;/p-sortIcon&gt;&lt;/th&gt; &lt;th pSortableColumn="price"&gt;Price &lt;p-sortIcon field="price"&gt;&lt;/p-sortIcon&gt;&lt;/th&gt; &lt;th&gt;Category&lt;/th&gt; &lt;/tr&gt; &lt;/ng-template&gt; &lt;ng-template pTemplate="body" let-product&gt; &lt;tr&gt; &lt;td&gt;{{ product.name }}&lt;/td&gt; &lt;td&gt;{{ product.price | currency }}&lt;/td&gt; &lt;td&gt;{{ product.category }}&lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt; &lt;/p-table&gt;</p>
  </code>
<p>}) export class ProductTableComponent implements OnInit { products: Product[] = []; loading = false; totalCount = 0; pageSize = 20;</p>

<p>constructor(private productService: ProductService) {}</p>

<p>ngOnInit() { this.loadData({ first: 0, rows: 20 }); }</p>

<p>loadData(event: any) { this.loading = true; this.productService.search({ page: event.first / event.rows + 1, size: event.rows, sort: event.sortField, sortOrder: event.sortOrder }).subscribe(response =&gt; { this.products = response.products; this.totalCount = response.total; this.loading = false; }); } }</p>
</code></pre>

<h3 id="after-using-basicresultstable">After (Using BasicResultsTable)</h3>

<p><strong>Step 1: Create the table configuration</strong></p>
<pre class="code-block typescript"><code>// src/app/domains/products/config/table.config.ts

<p>import { TableConfig } from '../../../framework/models/table-config.interface'; import { Product } from '../models/product.model';</p>

<p>export const PRODUCT_TABLE_CONFIG: TableConfig&lt;Product&gt; = { columns: [ { field: 'name', header: 'Name', sortable: true }, { field: 'price', header: 'Price', sortable: true, width: '120px' }, { field: 'category', header: 'Category', sortable: false } ], dataKey: 'id', expandable: true, rowsPerPageOptions: [10, 20, 50, 100] };</p>
</code></pre>

<p><strong>Step 2: Include in domain config</strong></p>
<pre class="code-block typescript"><code>export const PRODUCT_DOMAIN_CONFIG: DomainConfig&lt;ProductFilters, Product&gt; = {
<p>domainKey: 'products', displayName: 'Products', urlMapper: new ProductUrlMapper(), apiAdapter: null, // injected tableConfig: PRODUCT_TABLE_CONFIG };</p>
</code></pre>

<p><strong>Step 3: Use the framework component</strong></p>
<pre class="code-block typescript"><code>@Component({
<p>selector: 'app-product-discover', templateUrl: './product-discover.component.html', providers: [...PRODUCT_DOMAIN_PROVIDERS] }) export class ProductDiscoverComponent { domainConfig = PRODUCT_DOMAIN_CONFIG;</p>

<p>constructor(public resources: ResourceManagementService&lt;ProductFilters, Product&gt;) { // ResourceManagementService wires up data loading automatically } }</p>
</code></pre>

<pre class="code-block html"><code>&lt;!-- product-discover.component.html --&gt;
<p>&lt;app-basic-results-table [domainConfig]="domainConfig"&gt; &lt;/app-basic-results-table&gt;</p>
</code></pre>

<p><strong>Step 4: Register in your feature module (Angular 13)</strong></p>
<pre class="code-block typescript"><code>// src/app/features/products/products.module.ts

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FrameworkModule } from '../../framework/framework.module'; import { ProductDiscoverComponent } from './product-discover.component'; import { ProductsRoutingModule } from './products-routing.module';</p>

<p>@NgModule({ declarations: [ ProductDiscoverComponent ], imports: [ CommonModule, FrameworkModule,  // Exports BasicResultsTableComponent ProductsRoutingModule ] }) export class ProductsModule {}</p>
</code></pre>

<h3 id="what-you-get-for-free">What You Get For Free</h3>

<table>
<p><thead><tr> <th>Feature</th> <th>Your Old Code</th> <th>Framework Component</th></p>
</tr></thead>
<p><tbody> <tr> <td>Pagination</td> <td>Manual <code class="inline">loadData()</code></td> <td>Automatic via URL state</td></p>
</tr>
<p><tr> <td>Sorting</td> <td>Manual sort state</td> <td>Automatic via URL state</td></p>
</tr>
<p><tr> <td>Loading skeleton</td> <td>Custom implementation</td> <td>Built-in</td></p>
</tr>
<p><tr> <td>Empty state</td> <td>Custom implementation</td> <td>Built-in</td></p>
</tr>
<p><tr> <td>Row expansion</td> <td>Custom implementation</td> <td>Config-driven</td></p>
</tr>
<p><tr> <td>Pop-out support</td> <td>Not available</td> <td>Built-in</td></p>
</tr>
</tbody>
</table>

<hr class="section-break">

<h2 id="converting-pickers-to-basepicker">Converting Pickers to BasePicker</h2>

<h3 id="before-typical-custom-picker">Before (Typical Custom Picker)</h3>

<pre class="code-block typescript"><code>@Component({
<p>template: <code class="inline"> &lt;p-dialog [(visible)]="visible"&gt; &lt;p-table [value]="categories" [loading]="loading" [(selection)]="selectedCategories" [paginator]="true" [rows]="10"&gt; &lt;ng-template pTemplate="header"&gt; &lt;tr&gt; &lt;th style="width: 3rem"&gt; &lt;p-tableHeaderCheckbox&gt;&lt;/p-tableHeaderCheckbox&gt; &lt;/th&gt; &lt;th&gt;Category Name&lt;/th&gt; &lt;/tr&gt; &lt;/ng-template&gt; &lt;ng-template pTemplate="body" let-cat&gt; &lt;tr&gt; &lt;td&gt; &lt;p-tableCheckbox [value]="cat"&gt;&lt;/p-tableCheckbox&gt; &lt;/td&gt; &lt;td&gt;{{ cat.name }}&lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt; &lt;/p-table&gt; &lt;button (click)="apply()"&gt;Apply&lt;/button&gt; &lt;/p-dialog&gt;</p>
  </code>
<p>}) export class CategoryPickerComponent { categories: Category[] = []; selectedCategories: Category[] = []; loading = false; visible = false;</p>

<p>@Output() selectionChange = new EventEmitter&lt;Category[]&gt;();</p>

<p>ngOnInit() { this.loadCategories(); }</p>

<p>loadCategories() { this.loading = true; this.categoryService.getAll().subscribe(cats =&gt; { this.categories = cats; this.loading = false; }); }</p>

<p>apply() { this.selectionChange.emit(this.selectedCategories); this.visible = false; } }</p>
</code></pre>

<h3 id="after-using-basepicker">After (Using BasePicker)</h3>

<p><strong>Step 1: Create the picker configuration</strong></p>
<pre class="code-block typescript"><code>// src/app/domains/products/config/category-picker.config.ts

<p>import { PickerConfig } from '../../../framework/models/picker-config.interface'; import { Category } from '../models/category.model';</p>

<p>export const CATEGORY_PICKER_CONFIG: PickerConfig&lt;Category&gt; = { id: 'category-picker',</p>

<p>columns: [ { field: 'name', header: 'Category Name', sortable: true } ],</p>

<p>api: { fetchData: (params) =&gt; { // Inject your service or use a factory return inject(CategoryService).getAll(params); }, responseTransformer: (response) =&gt; ({ results: response.categories, total: response.total }) },</p>

<p>pagination: { mode: 'server', defaultPageSize: 10, pageSizeOptions: [10, 25, 50] },</p>

<p>selection: { urlParam: 'categories', keyGenerator: (cat) =&gt; cat.id, serializer: (items) =&gt; items.map(c =&gt; c.id).join(','), deserializer: (value) =&gt; value.split(',').map(id =&gt; ({ id })) },</p>

<p>row: { keyGenerator: (cat) =&gt; cat.id },</p>

<p>showSearch: true, searchPlaceholder: 'Search categories...' };</p>
</code></pre>

<p><strong>Step 2: Register in picker registry</strong></p>
<pre class="code-block typescript"><code>// In your module or app initializer
<p>constructor(private pickerRegistry: PickerConfigRegistry) { this.pickerRegistry.register('category-picker', CATEGORY_PICKER_CONFIG); }</p>
</code></pre>

<p><strong>Step 3: Use the framework component</strong></p>
<pre class="code-block typescript"><code>@Component({
<p>template: <code class="inline"> &lt;app-base-picker configId="category-picker" (selectionChange)="onCategoryChange($event)"&gt; &lt;/app-base-picker&gt;</p>
  </code>
<p>}) export class FilterPanelComponent {</p>

<p>constructor(private resources: ResourceManagementService&lt;ProductFilters, Product&gt;) {}</p>

<p>onCategoryChange(event: PickerSelectionEvent&lt;Category&gt;) { // The picker already serializes to URL-friendly format this.resources.updateFilters({ categories: event.urlValue || null } as Partial&lt;ProductFilters&gt;); } }</p>
</code></pre>

<h3 id="selection-persistence-across-pages">Selection Persistence Across Pages</h3>

<p>The framework picker automatically handles:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────────────┐
<p>│ Page 1 Loaded                                                           │ │ ☑ Electronics     Selected items: [Electronics]                        │ │ ☐ Clothing                                                             │ │ ☐ Home                                                                 │ └─────────────────────────────────────────────────────────────────────────┘ │ │ Navigate to page 2 ▼ ┌─────────────────────────────────────────────────────────────────────────┐ │ Page 2 Loaded                                                           │ │ ☑ Sports          Selected items: [Electronics, Sports]               │ │ ☐ Books           (Electronics preserved even though not visible)     │ │ ☐ Toys                                                                 │ └─────────────────────────────────────────────────────────────────────────┘ │ │ Navigate back to page 1 ▼ ┌─────────────────────────────────────────────────────────────────────────┐ │ Page 1 Loaded                                                           │ │ ☑ Electronics     Selected items: [Electronics, Sports]               │ │ ☐ Clothing        (Both selections preserved!)                         │ │ ☐ Home                                                                 │ └─────────────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<hr class="section-break">

<h2 id="preserving-custom-behavior">Preserving Custom Behavior</h2>

<h3 id="extending-framework-components">Extending Framework Components</h3>

<p>If framework components don't cover your use case, extend them:</p>

<pre class="code-block typescript"><code>@Component({
<p>selector: 'app-product-table', template: <code class="inline"> &lt;!-- Wrapper with custom header --&gt; &lt;div class="product-table-wrapper"&gt; &lt;div class="custom-header"&gt; &lt;button (click)="exportCsv()"&gt;Export CSV&lt;/button&gt; &lt;button (click)="printView()"&gt;Print&lt;/button&gt; &lt;/div&gt;</p>

<p>&lt;!-- Framework component does the heavy lifting --&gt; &lt;app-basic-results-table [domainConfig]="domainConfig" (rowClick)="onProductClick($event)"&gt; &lt;/app-basic-results-table&gt; &lt;/div&gt;</p>
  </code>
<p>}) export class ProductTableWrapperComponent { @Input() domainConfig!: DomainConfig&lt;ProductFilters, Product&gt;;</p>

<p>constructor(private exportService: ExportService) {}</p>

<p>exportCsv() { // Your custom export logic this.exportService.exportTableToCsv(); }</p>

<p>onProductClick(product: Product) { // Your custom click handling this.router.navigate(['/products', product.id]); } }</p>
</code></pre>

<h3 id="custom-column-rendering">Custom Column Rendering</h3>

<p>For custom cell rendering, extend the table config:</p>

<pre class="code-block typescript"><code>// Custom pipe for complex formatting
<p>@Pipe({ name: 'productPrice' }) export class ProductPricePipe implements PipeTransform { transform(value: number, currency: string): string { return new Intl.NumberFormat('en-US', { style: 'currency', currency }).format(value); } }</p>

<p>// In table config export const PRODUCT_TABLE_CONFIG: TableConfig&lt;Product&gt; = { columns: [ { field: 'name', header: 'Name' }, { field: 'price', header: 'Price', // Custom template reference (if supported) template: 'priceTemplate' } ] };</p>
</code></pre>

<hr class="section-break">

<h1 id="migration-patterns-reference">Migration Patterns Reference</h1>

<h2 id="quick-reference-url-mapper-patterns">Quick Reference: URL Mapper Patterns</h2>

<table>
<p><thead><tr> <th>Data Type</th> <th>URL Representation</th> <th>Example</th></p>
</tr></thead>
<p><tbody> <tr> <td>String</td> <td>Direct</td> <td><code class="inline">search=laptop</code></td></p>
</tr>
<p><tr> <td>Number</td> <td>String</td> <td><code class="inline">page=2</code></td></p>
</tr>
<p><tr> <td>Boolean</td> <td><code class="inline">true</code>/<code class="inline">false</code> string</td> <td><code class="inline">inStock=true</code></td></p>
</tr>
<p><tr> <td>Array</td> <td>Comma-separated</td> <td><code class="inline">categories=elec,home,toys</code></td></p>
</tr>
<p><tr> <td>Date</td> <td>ISO string</td> <td><code class="inline">startDate=2024-01-15</code></td></p>
</tr>
<p><tr> <td>Date Range</td> <td>Comma-separated</td> <td><code class="inline">dates=2024-01-01,2024-01-31</code></td></p>
</tr>
<p><tr> <td>Object</td> <td>Flattened with dots</td> <td><code class="inline">price.min=10&amp;price.max=100</code></td></p>
</tr>
</tbody>
</table>

<h2 id="quick-reference-state-decision-tree">Quick Reference: State Decision Tree</h2>

<pre class="code-block text"><code>                    ┌─────────────────────────────┐
<p>│ Where should this state live?│ └─────────────────────────────┘ │ ┌──────────────┴──────────────┐ ▼                             ▼ Can users share this              Is this purely state via URL?                    UI/visual state? │                             │ ┌────────┴────────┐                    │ ▼                 ▼                    ▼ YES               NO              Component State │                 │              (isOpen, tooltipVisible) ▼                 ▼ URL State        Does it need to (filters, page,    survive refresh? sort, selection)       │ ┌───────┴───────┐ ▼               ▼ YES             NO │               │ ▼               ▼ Service State    Component State (BehaviorSubject)</p>
</code></pre>

<h2 id="migration-effort-estimates">Migration Effort Estimates</h2>

<table>
<p><thead><tr> <th>Scenario</th> <th>Complexity</th> <th>Typical Effort</th></p>
</tr></thead>
<p><tbody> <tr> <td>Simple filter page → URL-First</td> <td>Low</td> <td>1-2 days</td></p>
</tr>
<p><tr> <td>Complex filter page with pickers</td> <td>Medium</td> <td>3-5 days</td></p>
</tr>
<p><tr> <td>NgRx integration</td> <td>Medium-High</td> <td>5-10 days</td></p>
</tr>
<p><tr> <td>Full application migration</td> <td>High</td> <td>2-4 weeks</td></p>
</tr>
<p><tr> <td>Table → BasicResultsTable</td> <td>Low</td> <td>1 day</td></p>
</tr>
<p><tr> <td>Picker → BasePicker</td> <td>Medium</td> <td>2-3 days</td></p>
</tr>
</tbody>
</table>

<hr class="section-break">

<h2 id="success-criteria">Success Criteria</h2>

<p>Your URL-First migration is complete when:</p>

<ul><li class="checkbox unchecked">Users can bookmark any filtered view</li>
<p><li class="checkbox unchecked">Copying URL shares exact application state</li> <li class="checkbox unchecked">Browser back/forward navigates through filter history</li> <li class="checkbox unchecked">Page refresh preserves all filter state</li> <li class="checkbox unchecked">Multiple tabs can show different filter states</li> <li class="checkbox unchecked">Pop-out windows (if used) sync with main window</li> <li class="checkbox unchecked">No legacy filter state services remain</li></p>
</ul>
<hr class="section-break">

<p><em>This companion guide is maintained alongside the Vroom Angular Textbook. For greenfield projects, start with the main textbook. For brownfield migrations, use this guide to incrementally adopt URL-First patterns.</em></p>

    </div>

</body>
</html>
