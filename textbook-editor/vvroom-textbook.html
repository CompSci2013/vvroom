<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>VVRoom Textbook</title>
    <style>
        @page {
            size: letter;
            margin: 1in 0.75in;
            @top-center {
                content: string(chapter-title);
                font-size: 10pt;
                color: #666;
            }
            @bottom-center {
                content: counter(page);
                font-size: 10pt;
            }
        }

        @page:first {
            @top-center { content: none; }
        }

        @page toc {
            @top-center { content: "Table of Contents"; }
        }

        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', 'Times New Roman', serif;
            font-size: 11pt;
            line-height: 1.5;
            color: #333;
            max-width: 100%;
        }

        /* Title page */
        .title-page {
            page: title;
            text-align: center;
            padding-top: 3in;
            page-break-after: always;
        }

        .title-page h1 {
            font-size: 36pt;
            margin-bottom: 0.5in;
            color: #1a365d;
        }

        .title-page .subtitle {
            font-size: 18pt;
            color: #4a5568;
            margin-bottom: 2in;
        }

        .title-page .author {
            font-size: 14pt;
            color: #718096;
        }

        /* Table of Contents */
        .toc {
            page: toc;
            page-break-after: always;
        }

        .toc h1 {
            font-size: 24pt;
            margin-bottom: 0.5in;
            color: #1a365d;
            border-bottom: 2px solid #1a365d;
            padding-bottom: 0.25in;
        }

        .toc-category {
            margin-bottom: 0.3in;
        }

        .toc-category h2 {
            font-size: 14pt;
            color: #2d3748;
            margin-bottom: 0.1in;
            margin-top: 0.2in;
        }

        .toc-entry {
            display: flex;
            justify-content: space-between;
            padding: 0.05in 0 0.05in 0.2in;
            font-size: 10pt;
        }

        .toc-entry a {
            color: #2b6cb0;
            text-decoration: none;
        }

        .toc-pages {
            color: #718096;
            font-size: 9pt;
        }

        /* Chapter sections */
        .chapter {
            page-break-before: always;
        }

        .chapter-header {
            string-set: chapter-title content();
            background: linear-gradient(135deg, #1a365d 0%, #2d3748 100%);
            color: white;
            padding: 0.5in;
            margin: -1in -0.75in 0.5in -0.75in;
            page-break-after: avoid;
        }

        .chapter-header h1 {
            font-size: 24pt;
            margin: 0;
        }

        .chapter-header .chapter-category {
            font-size: 12pt;
            opacity: 0.8;
            margin-bottom: 0.1in;
        }

        /* Content headings */
        h1 { font-size: 20pt; color: #1a365d; margin-top: 0.3in; page-break-after: avoid; }
        h2 { font-size: 16pt; color: #2d3748; margin-top: 0.25in; page-break-after: avoid; }
        h3 { font-size: 13pt; color: #4a5568; margin-top: 0.2in; page-break-after: avoid; }
        h4 { font-size: 11pt; color: #4a5568; margin-top: 0.15in; page-break-after: avoid; }

        /* Paragraphs */
        p {
            margin: 0.1in 0;
            text-align: justify;
        }

        /* Code blocks */
        pre.code-block {
            background: #1a202c;
            color: #e2e8f0;
            padding: 0.15in;
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 9pt;
            line-height: 1.4;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            page-break-inside: avoid;
            margin: 0.15in 0;
        }

        code.inline {
            background: #edf2f7;
            color: #c53030;
            padding: 0.02in 0.05in;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 10pt;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 0.15in 0;
            font-size: 10pt;
            page-break-inside: avoid;
        }

        th, td {
            border: 1px solid #cbd5e0;
            padding: 0.08in 0.12in;
            text-align: left;
        }

        th {
            background: #edf2f7;
            font-weight: bold;
            color: #2d3748;
        }

        tr:nth-child(even) {
            background: #f7fafc;
        }

        /* Lists */
        ul, ol {
            margin: 0.1in 0;
            padding-left: 0.3in;
        }

        li {
            margin: 0.03in 0;
        }

        /* Horizontal rules */
        hr {
            border: none;
            border-top: 1px solid #cbd5e0;
            margin: 0.2in 0;
        }

        /* Links */
        a {
            color: #2b6cb0;
            text-decoration: none;
        }

        /* Page content wrapper */
        .page-content {
            margin-bottom: 0.3in;
        }

        /* Strong/emphasis */
        strong { font-weight: bold; }
        em { font-style: italic; }
    </style>
</head>
<body>

    <div class="title-page">
        <h1>VVRoom Textbook</h1>
        <div class="subtitle">Building a URL-First Angular Application</div>
        <div class="author">A Comprehensive Technical Guide</div>
    </div>
<div class="toc">
<h1>Table of Contents</h1>
<div class="toc-category">
<h2>Conventions</h2>
<div class="toc-entry">
<a href="#section-000">000: Book Conventions</a>
<span class="toc-pages">(4 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>API Contract</h2>
<div class="toc-entry">
<a href="#section-051">051: API Contract Overview</a>
<span class="toc-pages">(4 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-052">052: Automobile Endpoints</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-053">053: Naming Conventions</a>
<span class="toc-pages">(5 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Project Setup</h2>
<div class="toc-entry">
<a href="#section-101">101: Project Cleanup</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-102">102: App Shell</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-103">103: Routing</a>
<span class="toc-pages">(10 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-104">104: Environment Config</a>
<span class="toc-pages">(5 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Primers</h2>
<div class="toc-entry">
<a href="#section-150">150: TypeScript Generics Primer</a>
<span class="toc-pages">(6 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Interfaces</h2>
<div class="toc-entry">
<a href="#section-201">201: Domain Config Interface</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-202">202: Resource Management Interface</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-203">203: Filter Definition Interface</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-204">204: Table Config Interface</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-205">205: Picker Config Interface</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-206">206: API Response Interface</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-207">207: Pagination Interface</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-208">208: Popout Interface</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-209">209: Error Notification Interface</a>
<span class="toc-pages">(6 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Primers</h2>
<div class="toc-entry">
<a href="#section-250">250: RxJS Patterns Primer</a>
<span class="toc-pages">(7 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Services</h2>
<div class="toc-entry">
<a href="#section-301">301: URL State Service</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-302">302: API Service</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-303">303: Request Coordinator</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-304">304: Domain Config Registry</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-305">305: Domain Config Validator</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-306">306: Resource Management Service</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-307">307: Popout Context Service</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-308">308: Popout Manager Service</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-309">309: User Preferences Service</a>
<span class="toc-pages">(4 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-310">310: Filter Options Service</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-311">311: Picker Config Registry</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-312">312: Error Notification Service</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-313">313: HTTP Error Interceptor</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-314">314: Global Error Handler</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-315">315: Popout Token</a>
<span class="toc-pages">(5 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Models</h2>
<div class="toc-entry">
<a href="#section-401">401: Base Model Interface</a>
<span class="toc-pages">(4 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-402">402: Domain Data Models</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-403">403: Domain Filter Statistics Models</a>
<span class="toc-pages">(7 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Adapters</h2>
<div class="toc-entry">
<a href="#section-501">501: Domain Adapter Pattern</a>
<span class="toc-pages">(4 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-502">502: URL Mapper Adapter</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-503">503: API Adapter</a>
<span class="toc-pages">(7 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Domain Config</h2>
<div class="toc-entry">
<a href="#section-601">601: Filter Definitions</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-602">602: Table Config</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-603">603: Picker Configs</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-604">604: Query Control Filters</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-605">605: Highlight Filters</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-606">606: Chart Configs</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-607">607: Domain Config Assembly</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-608">608: Domain Providers</a>
<span class="toc-pages">(4 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Chart Sources</h2>
<div class="toc-entry">
<a href="#section-651">651: Manufacturer Chart Source</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-652">652: Year Chart Source</a>
<span class="toc-pages">(5 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-653">653: Body Class Chart Source</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-654">654: Top Models Chart Source</a>
<span class="toc-pages">(7 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Components</h2>
<div class="toc-entry">
<a href="#section-801">801: Base Chart Component</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-802">802: Base Picker Component</a>
<span class="toc-pages">(8 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-803">803: Basic Results Table</a>
<span class="toc-pages">(8 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-804">804: Statistics Panel Component</a>
<span class="toc-pages">(8 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-805">805: Inline Filters Component</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-806">806: Query Panel Component</a>
<span class="toc-pages">(9 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-807">807: Column Manager Component</a>
<span class="toc-pages">(8 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-808">808: Statistics Panel 2</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-809">809: Dockview Statistics Panel</a>
<span class="toc-pages">(8 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Pages</h2>
<div class="toc-entry">
<a href="#section-901">901: Home Component</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-902">902: Automobile Landing Component</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-903">903: Discover Page Component</a>
<span class="toc-pages">(9 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-904">904: Popout Component</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-905">905: App Routing Module</a>
<span class="toc-pages">(8 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-906">906: App Module</a>
<span class="toc-pages">(7 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-907">907: Final Integration</a>
<span class="toc-pages">(6 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Reference</h2>
<div class="toc-entry">
<a href="#section-951">951: RxJS Operator Reference</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-952">952: TypeScript Generics Reference</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-953">953: Debugging Guide</a>
<span class="toc-pages">(6 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-954">954: Glossary</a>
<span class="toc-pages">(6 pages)</span>
</div>
</div>
<div class="toc-category">
<h2>Appendix</h2>
<div class="toc-entry">
<a href="#section-A01">A01: Styling and Branding</a>
<span class="toc-pages">(2 pages)</span>
</div>
<div class="toc-entry">
<a href="#section-A02">A02: URL-First Testing Rubric</a>
<span class="toc-pages">(4 pages)</span>
</div>
</div>
</div>
    <div class="chapter" id="section-000">
        <div class="chapter-header">
            <div class="chapter-category">Conventions</div>
            <h1>000: Book Conventions</h1>
        </div>
<div class="page-content"><h1>000: Book Conventions</h1>

<p><strong>Document Type:</strong> Meta <strong>Purpose:</strong> Establish the style and structure for all textbook documents in this series</p>

<hr>

<h2>Overview</h2>

<p>This <code class="inline">textbook/</code> directory contains the manuscript for a comprehensive Angular 13 programming book. The book follows the style of Apress technical publications, with a focus on learning-by-doing through the incremental construction of a real application: <strong>vvroom</strong>, an automobile discovery platform.</p>

<p>The application implements the <strong>URL-First State Management</strong> pattern, documented in <code class="inline">docs/</code>.</p>

<hr>

<h2>Target Audience</h2>

<p>A junior developer who will:</p>
<ul><li>Type every line of code shown</li>
<p><li>Understand why each decision was made</li> <li>Have a working, testable application at every checkpoint</li></p>
</ul>
<hr>

<h2>Document Structure</h2>

<p>Each numbered document (<code class="inline">001-<em>.md</code>, <code class="inline">002-</em>.md</code>, etc.) represents a chapter or major section. Every document follows this structure:</p>

<h3>1. Header Block</h3>

<pre class="code-block markdown"><code># NNN: Title

<p><strong>Status:</strong> Planning | In Progress | Complete <strong>Depends On:</strong> List of prerequisite document numbers <strong>Blocks:</strong> List of documents that depend on this one</p>
</code></pre>

<h3>2. Objective</h3>

<p>A single paragraph stating what this section accomplishes.</p>

<h3>3. Why (Rationale)</h3>

<ul><li>Explain the reasoning behind the approach</li>
<p><li>Reference industry standards:</li></p>
</ul>  <ul><li>Angular Style Guide (https://angular.io/guide/styleguide)</li>
</ul>  <ul><li>URL-First pattern (see <code class="inline">docs/README.md</code>)</li>
</ul>  <ul><li>TypeScript best practices</li>
</ul>  <ul><li>RxJS patterns</li>
<p><li>Cite specific rules when applicable (e.g., "Style 04-10: Use redirects for default routes")</li></p>
</ul>
<h3>4. What (Implementation)</h3>

<p>Step-by-step instructions with:</p>
<ul><li><strong>Full absolute paths</strong> for every file (e.g., <code class="inline">src/app/features/home/home.component.ts</code>)</li>
<p><li><strong>Complete file contents</strong> — no ellipses, no "add similar code"</li> <li><strong>Every import statement</strong> — never assume the reader knows what to import</li> <li><strong>Terminal commands</strong> with expected output where applicable</li></p>
</ul>
<h3>5. Verification</h3>

<ul><li>How to confirm the step worked</li>
<p><li>What to see in the browser</li> <li>What to see in the console</li> <li>Any tests to run</li></ul></p></div><div class="page-content"><h3>6. Acceptance Criteria</h3>

<p>Checkbox list of requirements that must be met before proceeding.</p>

<h3>7. Next Step</h3>

<p>Pointer to the next document in the sequence.</p>

<hr>

<h2>File Path Conventions</h2>

<p>Always use paths relative to the project root (<code class="inline">~/projects/vvroom/</code>):</p>

<pre class="code-block text"><code>src/app/app.component.ts           # Root component
<p>src/app/app.routes.ts              # Route definitions src/app/features/home/             # Feature module directory src/app/features/discover/         # Feature module directory src/app/framework/services/        # Shared services src/app/framework/models/          # TypeScript interfaces</p>
</code></pre>

<p>When referencing files in prose, use backticks and the full path:</p>
<ul><li>Correct: "Open <code class="inline">src/app/app.component.ts</code>"</li>
<p><li>Incorrect: "Open the app component"</li></p>
</ul>
<hr>

<h2>Code Block Conventions</h2>

<h3>New Files</h3>

<p>When creating a new file, show the complete contents:</p>

<pre class="code-block typescript"><code>// src/app/features/home/home.component.ts

<p>import { Component } from '@angular/core';</p>

<p>@Component({ selector: 'app-home', template: <code class="inline">&lt;h1&gt;Home&lt;/h1&gt;</code> }) export class HomeComponent {}</p>
</code></pre>

<h3>Modifications to Existing Files</h3>

<p>When modifying an existing file, show:</p>
<ul><li>The file path</li>
<p><li>What to find (the existing code)</li> <li>What to replace it with (the new code)</li></p>
</ul>
<pre class="code-block typescript"><code>// src/app/app.routes.ts
<p>// REPLACE this: export const routes: Routes = [];</p>

<p>// WITH this: export const routes: Routes = [ { path: '', redirectTo: 'home', pathMatch: 'full' }, { path: 'home', component: HomeComponent } ];</p>
</code></pre>

<p>For additions, specify where to add the code:</p>

<pre class="code-block typescript"><code>// src/app/app.routes.ts
<p>// ADD after the existing imports: import { HomeComponent } from './features/home/home.component';</p>
</code></pre>

<hr>

<h2>Terminal Command Conventions</h2>

<p>Show commands with their expected output:</p>

<pre class="code-block bash"><code>$ ng serve --port 4228 --open

<p>✔ Browser application bundle generation complete.</p>

<p>Initial Chunk Files   | Names         |  Raw Size vendor.js             | vendor        |   2.05 MB | polyfills.js          | polyfills     | 339.16 kB | styles.css            | styles        |  95.54 kB | main.js               | main          |  47.42 kB | runtime.js            | runtime       |   6.54 kB |</p>

<p>Build at: 2026-02-11T20:00:00.000Z - Hash: abc123 - Time: 5000ms</p>

<p><strong> Angular Live Development Server is listening on localhost:4228 </strong></p>
</code></pre></div><div class="page-content"><hr>

<h2>Naming Schema</h2>

<p>Documents are numbered by phase:</p>

<table>
<p><thead><tr> <th>Number</th> <th>Phase</th></p>
</tr></thead>
<p><tbody> <tr> <td>000-049</td> <td>Meta documents (conventions, rubric)</td></p>
</tr>
<p><tr> <td>050-099</td> <td>Phase 0: API Contract &amp; Naming Conventions</td></p>
</tr>
<p><tr> <td>100-149</td> <td>Phase 1: Foundation</td></p>
</tr>
<p><tr> <td>150-199</td> <td>Interlude A: TypeScript Generics Primer</td></p>
</tr>
<p><tr> <td>200-249</td> <td>Phase 2: Framework Models</td></p>
</tr>
<p><tr> <td>250-299</td> <td>Interlude B: RxJS Patterns</td></p>
</tr>
<p><tr> <td>300-399</td> <td>Phase 3: Framework Services (3A: Core, 3B: Popout, 3C: Error Handling)</td></p>
</tr>
<p><tr> <td>400-499</td> <td>Phase 4: Domain Models</td></p>
</tr>
<p><tr> <td>500-599</td> <td>Phase 5: Domain Adapters</td></p>
</tr>
<p><tr> <td>600-649</td> <td>Phase 6: Domain Configs</td></p>
</tr>
<p><tr> <td>650-699</td> <td>Phase 7: Chart Data Sources</td></p>
</tr>
<p><tr> <td>800-899</td> <td>Phase 8: Framework Components</td></p>
</tr>
<p><tr> <td>900-949</td> <td>Phase 9: Feature Components</td></p>
</tr>
<p><tr> <td>950-999</td> <td>Appendices</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Reference Implementation</h2>

<p>The <strong>generic-prime</strong> project (branch <code class="inline">angular/13</code>) serves as the canonical reference for all code in this book:</p>

<table>
<p><thead><tr> <th>Property</th> <th>Value</th></p>
</tr></thead>
<p><tbody> <tr> <td>Location</td> <td><code class="inline">~/projects/generic-prime</code></td></p>
</tr>
<p><tr> <td>Branch</td> <td><code class="inline">angular/13</code></td></p>
</tr>
</tbody>
</table>

<p>When working on chapters:</p>
<ul><li>Ensure generic-prime is on the <code class="inline">angular/13</code> branch</li>
<p><li>Copy relevant code files to vvroom</li> <li>Adapt the textbook to accurately describe the copied code</li></p>
</ul>
<p>To access the reference implementation:</p>

<pre class="code-block bash"><code>cd ~/projects/generic-prime
<p>git checkout angular/13</p>
</code></pre>

<hr>

<h2>Reference Material</h2>

<table>
<p><thead><tr> <th>Resource</th> <th>Location</th></p>
</tr></thead>
<p><tbody> <tr> <td>URL-First Architecture</td> <td><code class="inline">docs/README.md</code></td></p>
</tr>
<p><tr> <td>Full Architecture Spec</td> <td><code class="inline">docs/ARCHITECTURE-OVERVIEW.md</code></td></p>
</tr>
<p><tr> <td>State Management Spec</td> <td><code class="inline">docs/STATE-MANAGEMENT-SPECIFICATION.md</code></td></p>
</tr>
<p><tr> <td>Pop-out Architecture</td> <td><code class="inline">docs/POPOUT-ARCHITECTURE.md</code></td></p>
</tr>
<p><tr> <td>Implementation Audit</td> <td><code class="inline">docs/URL-FIRST-AS-IMPLEMENTED.md</code></td></p>
</tr>
<p><tr> <td>Reference Implementation</td> <td><code class="inline">~/projects/generic-prime</code> @ <code class="inline">angular/13</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Principles</h2>

<ul><li><strong>No magic</strong> — Every line of code is explained or shown</li>
<p><li><strong>Compiles at every step</strong> — The application must build and run after each section</li> <li><strong>Why before what</strong> — Rationale precedes implementation</li> <li><strong>Full paths always</strong> — Never ambiguous file references</li> <li><strong>One concept per section</strong> — Don't combine unrelated changes</li> <li><strong>Test what you build</strong> — Verification steps after every implementation</li></ul></p></div><div class="page-content"><hr>

<h2>URL-First Compliance</h2>

<p>Every implementation step must adhere to the URL-First State Management paradigm:</p>

<pre class="code-block text"><code>User Action → URL Update → State Service → Components Re-render
</code></pre>

<p>See <code class="inline">instructions.md</code> for the complete URL-First Compliance Checklist.</p>

<hr>

<p><em>This document establishes the contract between author and reader. All subsequent documents in <code class="inline">textbook/</code> will adhere to these conventions.</em></p></div></div>
    <div class="chapter" id="section-051">
        <div class="chapter-header">
            <div class="chapter-category">API Contract</div>
            <h1>051: API Contract Overview</h1>
        </div>
<div class="page-content"><h1>051: API Contract Overview</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> None <strong>Blocks:</strong> 052, 053, all implementation phases</p>

<hr>

<h2>Objective</h2>

<p>Document the API contract that the vvroom application will consume. This includes base URL configuration, authentication requirements, pagination conventions, error formats, and general request/response patterns.</p>

<hr>

<h2>Why</h2>

<p>Before writing any code — models, services, or components — you must understand the shape of the data you're working with. The API contract is an <strong>input</strong> to the entire system:</p>

<ul><li><strong>Models</strong> are defined by what the API returns</li>
<p><li><strong>Adapters</strong> translate between API responses and models</li> <li><strong>Services</strong> call endpoints defined by the API</li> <li><strong>Components</strong> display data shaped by the API</li></p>
</ul>
<p>Without this document, developers would be guessing at data shapes, leading to runtime errors and constant refactoring.</p>

<hr>

<h2>API Overview</h2>

<h3>Base URL</h3>

<table>
<p><thead><tr> <th>Environment</th> <th>Base URL</th></p>
</tr></thead>
<p><tbody> <tr> <td>Development</td> <td><code class="inline">http://generic-prime.minilab/api/specs/v1</code></td></p>
</tr>
<p><tr> <td>Production</td> <td><code class="inline">http://generic-prime.minilab/api/specs/v1</code></td></p>
</tr>
</tbody>
</table>

<p>The API is accessed via Traefik ingress on the Kubernetes cluster. The hostname <code class="inline">generic-prime.minilab</code> resolves to the cluster ingress controller.</p>

<h3>Authentication</h3>

<p><strong>None required.</strong> The API is accessible without authentication for this internal application.</p>

<h3>Content Type</h3>

<p>All requests and responses use JSON:</p>

<pre class="code-block text"><code>Content-Type: application/json
<p>Accept: application/json</p>
</code></pre>

<hr>

<h2>Pagination Convention</h2>

<p>All list endpoints support pagination with these query parameters:</p>

<table>
<p><thead><tr> <th>Parameter</th> <th>Type</th> <th>Default</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">page</code></td> <td>number</td> <td>1</td> <td>Page number (1-indexed)</td></p>
</tr>
<p><tr> <td><code class="inline">size</code></td> <td>number</td> <td>20</td> <td>Items per page</td></p>
</tr>
</tbody>
</table>

<h3>Paginated Response Shape</h3>

<pre class="code-block typescript"><code>{
<p>"results": [...],      // Array of items for current page "total": 1234,         // Total items across all pages "page": 1,             // Current page number "size": 20,            // Items per page "totalPages": 62       // Total number of pages }</p>
</code></pre></div><div class="page-content"><hr>

<h2>Sorting Convention</h2>

<p>Sorting is controlled by these query parameters:</p>

<table>
<p><thead><tr> <th>Parameter</th> <th>Type</th> <th>Values</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">sortBy</code></td> <td>string</td> <td>field name</td> <td>Field to sort by</td></p>
</tr>
<p><tr> <td><code class="inline">sortOrder</code></td> <td>string</td> <td><code class="inline">asc</code>, <code class="inline">desc</code></td> <td>Sort direction</td></p>
</tr>
</tbody>
</table>

<p>Example: <code class="inline">?sortBy=manufacturer&amp;sortOrder=asc</code></p>

<hr>

<h2>Error Response Format</h2>

<p>When an error occurs, the API returns:</p>

<pre class="code-block typescript"><code>{
<p>"success": false, "error": { "code": "VALIDATION_ERROR",     // Error type identifier "message": "Invalid year range", // Human-readable message "details": {                     // Optional additional context "field": "yearMin", "reason": "must be less than yearMax" } } }</p>
</code></pre>

<h3>Common Error Codes</h3>

<table>
<p><thead><tr> <th>Code</th> <th>HTTP Status</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">VALIDATION_ERROR</code></td> <td>400</td> <td>Invalid request parameters</td></p>
</tr>
<p><tr> <td><code class="inline">NOT_FOUND</code></td> <td>404</td> <td>Resource not found</td></p>
</tr>
<p><tr> <td><code class="inline">INTERNAL_ERROR</code></td> <td>500</td> <td>Server error</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Highlight Parameters (h_* prefix)</h2>

<p>The API supports "highlight" parameters for segmented statistics. These are query parameters with an <code class="inline">h_</code> prefix that tell the backend to compute statistics with a highlighted subset.</p>

<p><strong>Purpose:</strong> Enable stacked bar charts showing "highlighted vs total" data.</p>

<p><strong>Example Request:</strong></p>
<pre class="code-block text"><code>GET /vehicles/details?manufacturer=Toyota&amp;h_yearMin=2020&amp;h_yearMax=2024
</code></pre>

<p><strong>Effect on Response:</strong> Statistics include <code class="inline">{total, highlighted}</code> objects instead of simple counts:</p>

<pre class="code-block json"><code>{
<p>"statistics": { "byManufacturer": { "Toyota": { "total": 665, "highlighted": 234 }, "Honda": { "total": 849, "highlighted": 0 } } } }</p>
</code></pre>

<p>Vehicles from Toyota are highlighted (234 of 665 match the year range 2020-2024), while Honda vehicles are not highlighted (0 of 849 match).</p>

<hr>

<h2>Request/Response Flow</h2></div><div class="page-content"><pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────────┐
<p>│                         Frontend Request                             │ │  GET /vehicles/details?manufacturer=Toyota&amp;page=1&amp;size=20           │ └──────────────────────────────────┬──────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────────┐ │                         Backend Processing                           │ │  1. Parse query parameters                                           │ │  2. Build Elasticsearch query                                        │ │  3. Execute search                                                   │ │  4. Compute statistics aggregations                                  │ │  5. Format response                                                  │ └──────────────────────────────────┬──────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────────┐ │                         API Response                                 │ │  {                                                                   │ │    "results": [{ vehicle_id, manufacturer, model, year, ... }],     │ │    "total": 234,                                                     │ │    "page": 1,                                                        │ │    "size": 20,                                                       │ │    "totalPages": 12,                                                 │ │    "statistics": { byManufacturer, byBodyClass, byYearRange, ... }  │ │  }                                                                   │ └─────────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<hr>

<h2>Implementation Files</h2>

<h3>1. API Response Interface (Framework-Level)</h3>

<p>This interface is <strong>domain-agnostic</strong> and lives in the framework:</p>

<p><strong>File:</strong> <code class="inline">src/app/framework/models/api-response.interface.ts</code></p>

<pre class="code-block typescript"><code>/**
 <ul><li>Generic API response interface for paginated endpoints</li>
</ul> <ul><li>@template TData - The type of data items in the results array</li>
</ul> */
<p>export interface ApiResponse&lt;TData&gt; { /<em>* Array of result items for the current page </em>/ results: TData[];</p>

<p>/<em>* Total number of items across all pages </em>/ total: number;</p>

<p>/<em>* Current page number (1-indexed) </em>/ page: number;</p>

<p>/<em>* Number of items per page </em>/ size: number;</p>

<p>/<em>* Total number of pages </em>/ totalPages: number;</p>

<p>/<em>* Optional statistics data (domain-specific) </em>/ statistics?: any; }</p>

<p>/**</p>
 <ul><li>Generic error response from API</li>
</ul> */
<p>export interface ApiErrorResponse { /<em>* Success flag (always false for errors) </em>/ success: false;</p>

<p>/<em>* Error details </em>/ error: { /<em>* Error code (e.g., 'VALIDATION_ERROR', 'NOT_FOUND') </em>/ code: string;</p>

<p>/<em>* Human-readable error message </em>/ message: string;</p>

<p>/<em>* Optional additional error details </em>/ details?: Record&lt;string, any&gt;; }; }</p>

<p>/**</p>
 <ul><li>Generic success response wrapper</li>
</ul> */
<p>export interface ApiSuccessResponse&lt;TData&gt; { /<em>* Success flag (always true for successful responses) </em>/ success: true;</p>

<p>/<em>* Response data </em>/ data: TData; }</p>

<p>/**</p>
 <ul><li>Standard API response type (success or error)</li>
</ul> */
<p>export type StandardApiResponse&lt;TData&gt; = ApiSuccessResponse&lt;TData&gt; | ApiErrorResponse;</p>
</code></pre></div><div class="page-content"><h3>2. Environment Configuration</h3>

<p><strong>File:</strong> <code class="inline">src/environments/environment.ts</code> (development)</p>

<pre class="code-block typescript"><code>export const environment = {
<p>production: false, apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1', includeTestIds: true };</p>
</code></pre>

<p><strong>File:</strong> <code class="inline">src/environments/environment.prod.ts</code> (production)</p>

<pre class="code-block typescript"><code>export const environment = {
<p>production: true, apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1', includeTestIds: false };</p>
</code></pre>

<hr>

<h2>Verification</h2>

<p>After implementing this section:</p>

<ul><li><strong>Check file exists:</strong></li>
</ul>   <pre class="code-block bash"><code>   ls -la src/app/framework/models/api-response.interface.ts
   </code></pre>

<ul><li><strong>Check environment files:</strong></li>
</ul>   <pre class="code-block bash"><code>   grep apiBaseUrl src/environments/environment*.ts
   </code></pre>

<ul><li><strong>Verify TypeScript compiles:</strong></li>
</ul>   <pre class="code-block bash"><code>   npx tsc --noEmit
   </code></pre>

<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[x] <code class="inline">ApiResponse&lt;TData&gt;</code> interface created in <code class="inline">src/app/framework/models/</code></li>
<p><li>[x] <code class="inline">ApiErrorResponse</code> interface created</li> <li>[x] <code class="inline">ApiSuccessResponse&lt;TData&gt;</code> interface created</li> <li>[x] <code class="inline">StandardApiResponse&lt;TData&gt;</code> type alias created</li> <li>[x] <code class="inline">environment.ts</code> includes <code class="inline">apiBaseUrl</code> property</li> <li>[x] <code class="inline">environment.prod.ts</code> includes <code class="inline">apiBaseUrl</code> property</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">052-automobile-endpoints.md</code> for detailed documentation of each automobile-specific endpoint with request/response examples.</p></div></div>
    <div class="chapter" id="section-052">
        <div class="chapter-header">
            <div class="chapter-category">API Contract</div>
            <h1>052: Automobile Endpoints</h1>
        </div>
<div class="page-content"><h1>052: Automobile Endpoints</h1>

<p><strong>Status:</strong> Reference <strong>Depends On:</strong> 051-api-contract-overview <strong>Blocks:</strong> 401-403 (Domain Models), 501-503 (Domain Adapters)</p>

<hr>

<h2>Objective</h2>

<p>Document every API endpoint used by the automobile domain, including:</p>
<ul><li>Request URL and method</li>
<p><li>Query parameters</li> <li>Complete response JSON shapes</li> <li>Example requests and responses</li></p>
</ul>
<p>This document is the source of truth for building TypeScript models and adapters.</p>

<hr>

<h2>Endpoints Summary</h2>

<table>
<p><thead><tr> <th>Endpoint</th> <th>Method</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">/vehicles/details</code></td> <td>GET</td> <td>Search vehicles with pagination and statistics</td></p>
</tr>
<p><tr> <td><code class="inline">/statistics</code></td> <td>GET</td> <td>Fetch statistics only (without vehicle data)</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Endpoint: GET /vehicles/details</h2>

<p>The primary endpoint for vehicle discovery. Returns paginated vehicle results with aggregated statistics.</p>

<h3>Request</h3>

<p><strong>URL:</strong> <code class="inline">{baseUrl}/vehicles/details</code></p>

<p><strong>Query Parameters:</strong></p>

<table>
<p><thead><tr> <th>Parameter</th> <th>Type</th> <th>Required</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">manufacturer</code></td> <td>string</td> <td>No</td> <td>Filter by manufacturer name (partial match)</td></p>
</tr>
<p><tr> <td><code class="inline">model</code></td> <td>string</td> <td>No</td> <td>Filter by model name (partial match)</td></p>
</tr>
<p><tr> <td><code class="inline">yearMin</code></td> <td>number</td> <td>No</td> <td>Minimum year (inclusive)</td></p>
</tr>
<p><tr> <td><code class="inline">yearMax</code></td> <td>number</td> <td>No</td> <td>Maximum year (inclusive)</td></p>
</tr>
<p><tr> <td><code class="inline">bodyClass</code></td> <td>string</td> <td>No</td> <td>Filter by body class (can be comma-separated for multiple)</td></p>
</tr>
<p><tr> <td><code class="inline">instanceCountMin</code></td> <td>number</td> <td>No</td> <td>Minimum VIN instance count</td></p>
</tr>
<p><tr> <td><code class="inline">instanceCountMax</code></td> <td>number</td> <td>No</td> <td>Maximum VIN instance count</td></p>
</tr>
<p><tr> <td><code class="inline">search</code></td> <td>string</td> <td>No</td> <td>Global search across all fields</td></p>
</tr>
<p><tr> <td><code class="inline">models</code></td> <td>string</td> <td>No</td> <td>Model combinations: <code class="inline">Manufacturer:Model,Manufacturer:Model</code></td></p>
</tr>
<p><tr> <td><code class="inline">page</code></td> <td>number</td> <td>No</td> <td>Page number (default: 1)</td></p>
</tr>
<p><tr> <td><code class="inline">size</code></td> <td>number</td> <td>No</td> <td>Items per page (default: 20)</td></p>
</tr>
<p><tr> <td><code class="inline">sortBy</code></td> <td>string</td> <td>No</td> <td>Sort field</td></p>
</tr>
<p><tr> <td><code class="inline">sortOrder</code></td> <td>string</td> <td>No</td> <td>Sort direction: <code class="inline">asc</code> or <code class="inline">desc</code></td></p>
</tr>
<p><tr> <td><code class="inline">h_yearMin</code></td> <td>number</td> <td>No</td> <td>Highlight: minimum year</td></p>
</tr>
<p><tr> <td><code class="inline">h_yearMax</code></td> <td>number</td> <td>No</td> <td>Highlight: maximum year</td></p>
</tr>
<p><tr> <td><code class="inline">h_manufacturer</code></td> <td>string</td> <td>No</td> <td>Highlight: manufacturer</td></p>
</tr>
<p><tr> <td><code class="inline">h_modelCombos</code></td> <td>string</td> <td>No</td> <td>Highlight: model combinations</td></p>
</tr>
<p><tr> <td><code class="inline">h_bodyClass</code></td> <td>string</td> <td>No</td> <td>Highlight: body class</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><h3>Example Request</h3>

<pre class="code-block text"><code>GET /vehicles/details?manufacturer=Toyota&amp;yearMin=2020&amp;yearMax=2024&amp;page=1&amp;size=20&amp;sortBy=year&amp;sortOrder=desc
</code></pre>

<h3>Response Shape</h3>

<pre class="code-block typescript"><code>{
<p>"results": VehicleResult[], "total": number, "page": number, "size": number, "totalPages": number, "statistics": VehicleStatistics }</p>
</code></pre>

<h3>Example Response</h3>

<pre class="code-block json"><code>{
<p>"results": [ { "vehicle_id": "TOY-CAM-2024-SED", "manufacturer": "Toyota", "model": "Camry", "year": 2024, "body_class": "Sedan", "instance_count": 156, "first_seen": "2024-01-15T10:30:00Z", "last_seen": "2024-11-20T14:22:00Z", "drive_type": "FWD", "engine": "I4", "transmission": "Automatic", "fuel_type": "Gasoline" }, { "vehicle_id": "TOY-RAV-2024-SUV", "manufacturer": "Toyota", "model": "RAV4", "year": 2024, "body_class": "SUV", "instance_count": 234, "first_seen": "2024-02-10T08:15:00Z", "last_seen": "2024-11-19T16:45:00Z", "drive_type": "AWD", "engine": "I4", "transmission": "Automatic", "fuel_type": "Hybrid" } ], "total": 234, "page": 1, "size": 20, "totalPages": 12, "statistics": { "totalCount": 234, "byManufacturer": { "Toyota": { "total": 234, "highlighted": 234 } }, "byBodyClass": { "Sedan": { "total": 89, "highlighted": 89 }, "SUV": { "total": 78, "highlighted": 78 }, "Truck": { "total": 45, "highlighted": 45 }, "Coupe": { "total": 22, "highlighted": 22 } }, "byYear": { "2024": { "total": 67, "highlighted": 67 }, "2023": { "total": 58, "highlighted": 58 }, "2022": { "total": 52, "highlighted": 52 }, "2021": { "total": 34, "highlighted": 34 }, "2020": { "total": 23, "highlighted": 23 } }, "modelsByManufacturer": { "Toyota": { "Camry": { "total": 45, "highlighted": 45 }, "RAV4": { "total": 52, "highlighted": 52 }, "Corolla": { "total": 38, "highlighted": 38 }, "Highlander": { "total": 29, "highlighted": 29 } } } } }</p>
</code></pre></div><div class="page-content"><hr>

<h2>VehicleResult Object</h2>

<p>Each item in the <code class="inline">results</code> array has this shape:</p>

<pre class="code-block typescript"><code>interface VehicleResult {
<p>// Required fields vehicle_id: string;      // Unique ID: "MANUFACTURER-MODEL-YEAR-BODYCLASS" manufacturer: string;    // e.g., "Toyota", "Honda", "Ford" model: string;           // e.g., "Camry", "Accord", "F-150" year: number;            // e.g., 2024 body_class: string;      // e.g., "Sedan", "SUV", "Truck" instance_count: number;  // Number of VINs for this vehicle config</p>

<p>// Optional fields first_seen?: string;     // ISO 8601 datetime last_seen?: string;      // ISO 8601 datetime drive_type?: string;     // e.g., "FWD", "RWD", "AWD", "4WD" engine?: string;         // e.g., "V6", "I4", "V8", "Electric" transmission?: string;   // e.g., "Automatic", "Manual", "CVT" fuel_type?: string;      // e.g., "Gasoline", "Diesel", "Electric", "Hybrid" vehicle_class?: string;  // e.g., "Passenger Car", "Light Truck" }</p>
</code></pre>

<h3>Field Notes</h3>

<table>
<p><thead><tr> <th>Field</th> <th>Format</th> <th>Example</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">vehicle_id</code></td> <td><code class="inline">{MFR}-{MODEL}-{YEAR}-{BODY}</code></td> <td><code class="inline">TOY-CAM-2024-SED</code></td></p>
</tr>
<p><tr> <td><code class="inline">year</code></td> <td>4-digit integer</td> <td><code class="inline">2024</code></td></p>
</tr>
<p><tr> <td><code class="inline">instance_count</code></td> <td>Non-negative integer</td> <td><code class="inline">156</code></td></p>
</tr>
<p><tr> <td><code class="inline">first_seen</code></td> <td>ISO 8601</td> <td><code class="inline">2024-01-15T10:30:00Z</code></td></p>
</tr>
<p><tr> <td><code class="inline">body_class</code></td> <td>Title case</td> <td><code class="inline">Sedan</code>, <code class="inline">SUV</code>, <code class="inline">Truck</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Statistics Object</h2>

<p>The <code class="inline">statistics</code> field in the response contains aggregated data for charts and summaries.</p>

<h3>Structure</h3>

<pre class="code-block typescript"><code>interface VehicleStatistics {
<p>// Total count of vehicles matching filters totalCount: number;</p>

<p>// Segmented by manufacturer: { "Toyota": { total, highlighted }, ... } byManufacturer: Record&lt;string, { total: number; highlighted: number }&gt;;</p>

<p>// Segmented by body class: { "Sedan": { total, highlighted }, ... } byBodyClass: Record&lt;string, { total: number; highlighted: number }&gt;;</p>

<p>// Segmented by year: { "2024": { total, highlighted }, ... } byYear: Record&lt;string, { total: number; highlighted: number }&gt;;</p>

<p>// Models nested under manufacturers modelsByManufacturer: Record&lt;string, Record&lt;string, { total: number; highlighted: number }&gt;&gt;; }</p>
</code></pre></div><div class="page-content"><h3>Segmented Statistics Explained</h3>

<p>Each statistic entry contains:</p>
<ul><li><code class="inline">total</code>: Count of all items in this category</li>
<p><li><code class="inline">highlighted</code>: Count of items matching highlight filters (h_* parameters)</li></p>
</ul>
<p><strong>Example without highlights:</strong></p>
<pre class="code-block json"><code>{
<p>"byManufacturer": { "Toyota": { "total": 234, "highlighted": 234 }, "Honda": { "total": 187, "highlighted": 187 } } }</p>
</code></pre>
<p>When no highlight filters are applied, <code class="inline">highlighted</code> equals <code class="inline">total</code>.</p>

<p><strong>Example with highlights (<code class="inline">h_yearMin=2022&amp;h_yearMax=2024</code>):</strong></p>
<pre class="code-block json"><code>{
<p>"byManufacturer": { "Toyota": { "total": 234, "highlighted": 156 }, "Honda": { "total": 187, "highlighted": 98 } } }</p>
</code></pre>
<p>Only 156 of Toyota's 234 vehicles fall within 2022-2024.</p>

<hr>

<h2>Endpoint: GET /statistics</h2>

<p>Fetches statistics only, without vehicle data. Useful for refreshing charts without reloading the table.</p>

<h3>Request</h3>

<p><strong>URL:</strong> <code class="inline">{baseUrl}/statistics</code></p>

<p><strong>Query Parameters:</strong> Same filter parameters as <code class="inline">/vehicles/details</code> (excluding <code class="inline">page</code>, <code class="inline">size</code>, <code class="inline">sortBy</code>, <code class="inline">sortOrder</code>)</p>

<h3>Example Request</h3>

<pre class="code-block text"><code>GET /statistics?manufacturer=Toyota&amp;yearMin=2020
</code></pre>

<h3>Response Shape</h3>

<p>Same as the <code class="inline">statistics</code> object from <code class="inline">/vehicles/details</code>.</p>

<hr>

<h2>URL Parameter Mapping</h2>

<p>This table maps URL query parameters to filter object properties:</p>

<table>
<p><thead><tr> <th>URL Parameter</th> <th>Filter Property</th> <th>Type</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">manufacturer</code></td> <td><code class="inline">manufacturer</code></td> <td>string</td></p>
</tr>
<p><tr> <td><code class="inline">model</code></td> <td><code class="inline">model</code></td> <td>string</td></p>
</tr>
<p><tr> <td><code class="inline">yearMin</code></td> <td><code class="inline">yearMin</code></td> <td>number</td></p>
</tr>
<p><tr> <td><code class="inline">yearMax</code></td> <td><code class="inline">yearMax</code></td> <td>number</td></p>
</tr>
<p><tr> <td><code class="inline">bodyClass</code></td> <td><code class="inline">bodyClass</code></td> <td>string</td></p>
</tr>
<p><tr> <td><code class="inline">instanceCountMin</code></td> <td><code class="inline">instanceCountMin</code></td> <td>number</td></p>
</tr>
<p><tr> <td><code class="inline">instanceCountMax</code></td> <td><code class="inline">instanceCountMax</code></td> <td>number</td></p>
</tr>
<p><tr> <td><code class="inline">search</code></td> <td><code class="inline">search</code></td> <td>string</td></p>
</tr>
<p><tr> <td><code class="inline">models</code></td> <td><code class="inline">modelCombos</code></td> <td>string</td></p>
</tr>
<p><tr> <td><code class="inline">page</code></td> <td><code class="inline">page</code></td> <td>number</td></p>
</tr>
<p><tr> <td><code class="inline">size</code></td> <td><code class="inline">size</code></td> <td>number</td></p>
</tr>
<p><tr> <td><code class="inline">sortBy</code></td> <td><code class="inline">sort</code></td> <td>string</td></p>
</tr>
<p><tr> <td><code class="inline">sortOrder</code></td> <td><code class="inline">sortDirection</code></td> <td>string</td></p>
</tr>
</tbody>
</table>

<p><strong>Note:</strong> The URL uses <code class="inline">models</code> but the filter object uses <code class="inline">modelCombos</code>. The adapter handles this translation.</p>

<hr>

<h2>Model Combinations Format</h2>

<p>The <code class="inline">models</code> parameter (and <code class="inline">h_modelCombos</code> highlight parameter) uses a specific format:</p>

<pre class="code-block text"><code>Manufacturer:Model,Manufacturer:Model,...
</code></pre>

<p><strong>Examples:</strong></p>
<ul><li>Single model: <code class="inline">Ford:F-150</code></li>
<p><li>Multiple models: <code class="inline">Ford:F-150,Toyota:Camry,Honda:Accord</code></li> <li>Same manufacturer, different models: <code class="inline">Toyota:Camry,Toyota:Corolla</code></li></ul></p></div><div class="page-content"><hr>

<h2>Field Name Conventions</h2>

<p>The API uses <strong>snake_case</strong> for field names:</p>
<ul><li><code class="inline">vehicle_id</code>, <code class="inline">body_class</code>, <code class="inline">instance_count</code>, <code class="inline">first_seen</code>, <code class="inline">last_seen</code></li>
<p><li><code class="inline">fuel_type</code>, <code class="inline">drive_type</code>, <code class="inline">vehicle_class</code></li></p>
</ul>
<p>The frontend models use <strong>camelCase</strong> internally, with adapters handling the translation.</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">053-naming-conventions.md</code> to understand which code is framework (reusable across domains) vs domain-specific (automobile only).</p></div></div>
    <div class="chapter" id="section-053">
        <div class="chapter-header">
            <div class="chapter-category">API Contract</div>
            <h1>053: Naming Conventions</h1>
        </div>
<div class="page-content"><h1>053: Naming Conventions — Framework vs Domain</h1>

<p><strong>Status:</strong> Reference <strong>Depends On:</strong> 051, 052 <strong>Blocks:</strong> All implementation phases</p>

<hr>

<h2>Objective</h2>

<p>Establish a clear distinction between <strong>framework code</strong> (domain-agnostic, reusable) and <strong>domain code</strong> (automobile-specific). This separation enables:</p>

<ul><li>A smaller companion book for adding new domains (e.g., "Adding Agriculture to Vroom")</li>
<p><li>Clear understanding of which code changes when adding a new domain</li> <li>Proper placement of new code during development</li></p>
</ul>
<hr>

<h2>Why This Matters</h2>

<p>The vroom application is built on a <strong>configuration-driven architecture</strong>. The framework provides generic capabilities, and domain configuration tells it how to behave for a specific data domain.</p>

<p><strong>To add a new domain (e.g., agriculture), you only implement the right column.</strong></p>

<p>The framework code (left column) remains untouched.</p>

<hr>

<h2>Framework vs Domain: Complete Reference</h2>

<h3>Services</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">ResourceManagementService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">UrlStateService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">ApiService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">RequestCoordinatorService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">DomainConfigRegistry</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">DomainConfigValidator</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">PopOutContextService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">PopOutManagerService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">UserPreferencesService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">FilterOptionsService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">PickerConfigRegistry</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">ErrorNotificationService</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">HttpErrorInterceptor</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">GlobalErrorHandler</code></td> <td>—</td></p>
</tr>
</tbody>
</table>

<p><strong>Note:</strong> Services are 100% framework. Domains don't create new services.</p>

<hr>

<h3>Interfaces</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">DomainConfig&lt;TFilters, TData, TStats&gt;</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">IApiAdapter&lt;TFilters, TData, TStats&gt;</code></td> <td><code class="inline">AutomobileApiAdapter</code> (implements)</td></p>
</tr>
<p><tr> <td><code class="inline">IFilterUrlMapper&lt;TFilters&gt;</code></td> <td><code class="inline">AutomobileUrlMapper</code> (implements)</td></p>
</tr>
<p><tr> <td><code class="inline">ICacheKeyBuilder&lt;TFilters&gt;</code></td> <td><code class="inline">AutomobileCacheKeyBuilder</code> (implements)</td></p>
</tr>
<p><tr> <td><code class="inline">ResourceState&lt;TFilters, TData, TStats&gt;</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">ApiResponse&lt;TData&gt;</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">FilterDefinition</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">TableConfig</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">PickerConfig</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">ChartConfig</code></td> <td>—</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h3>Models</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td>—</td> <td><code class="inline">AutoSearchFilters</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">HighlightFilters</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">VehicleResult</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">VinInstance</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">VehicleStatistics</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">ManufacturerStat</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">ModelStat</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">BodyClassStat</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">YearStat</code></td></p>
</tr>
</tbody>
</table>

<p><strong>Note:</strong> Models are 100% domain-specific. Each domain defines its own data shapes.</p>

<hr>

<h3>Adapters</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td>Interface: <code class="inline">IApiAdapter</code></td> <td><code class="inline">AutomobileApiAdapter</code></td></p>
</tr>
<p><tr> <td>Interface: <code class="inline">IFilterUrlMapper</code></td> <td><code class="inline">AutomobileUrlMapper</code></td></p>
</tr>
<p><tr> <td>Interface: <code class="inline">ICacheKeyBuilder</code></td> <td><code class="inline">AutomobileCacheKeyBuilder</code></td></p>
</tr>
</tbody>
</table>

<p><strong>Pattern:</strong> Framework defines interfaces. Domains implement them.</p>

<hr>

<h3>Configurations</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td>—</td> <td><code class="inline">automobile.filter-definitions.ts</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">automobile.table-config.ts</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">automobile.picker-configs.ts</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">automobile.query-control-filters.ts</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">automobile.highlight-filters.ts</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">automobile.chart-configs.ts</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">automobile.domain-config.ts</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Chart Data Sources</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td>Interface: <code class="inline">ChartDataSource</code></td> <td><code class="inline">ManufacturerChartSource</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">YearChartSource</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">BodyClassChartSource</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">TopModelsChartSource</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Components</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">BaseChartComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">BasePickerComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">BasicResultsTableComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">ResultsTableComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">DynamicResultsTableComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">QueryPanelComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">QueryControlComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">StatisticsPanel2Component</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">DockviewStatisticsPanelComponent</code></td> <td>—</td></p>
</tr>
</tbody>
</table>

<p><strong>Note:</strong> UI components are 100% framework. They render based on configuration.</p></div><div class="page-content"><hr>

<h3>Feature Components</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">HomeComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">PopoutComponent</code></td> <td>—</td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">AutomobileComponent</code> (landing)</td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">AutomobileDiscoverComponent</code> (main page)</td></p>
</tr>
</tbody>
</table>

<p><strong>Pattern:</strong> The discover page is domain-specific because it wires up domain configuration. Popout is framework because it renders any domain's panels.</p>

<hr>

<h3>Routes</h3>

<table>
<p><thead><tr> <th>Framework (Never Changes)</th> <th>Domain-Specific (Per Domain)</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">/</code> (redirect)</td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">/home</code></td> <td>—</td></p>
</tr>
<p><tr> <td><code class="inline">/popout/:gridId/:componentId</code></td> <td>—</td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">/automobiles</code></td></p>
</tr>
<p><tr> <td>—</td> <td><code class="inline">/automobiles/discover</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Directory Structure</h2>

<pre class="code-block text"><code>src/
<p>├── app/ │   ├── app.component.ts           # Framework │   ├── app.config.ts              # Framework │   ├── app.routes.ts              # Framework + Domain routes │   └── features/ │       ├── home/                  # Framework │       ├── popout/                # Framework │       └── automobile/            # DOMAIN-SPECIFIC │           ├── automobile.component.ts │           └── automobile-discover/ │ ├── framework/                     # ALL FRAMEWORK │   ├── components/ │   ├── models/ │   ├── services/ │   └── tokens/ │ ├── domain-config/                 # ALL DOMAIN-SPECIFIC │   ├── domain-providers.ts        # Registers all domains │   └── automobile/ │       ├── adapters/ │       ├── chart-sources/ │       ├── configs/ │       ├── models/ │       ├── automobile.domain-config.ts │       └── index.ts │ └── environments/                  # Framework</p>
</code></pre>

<hr>

<h2>Observable Streams (Framework)</h2>

<p>These observable names are <strong>framework conventions</strong> — they don't change per domain:</p>

<table>
<p><thead><tr> <th>Observable</th> <th>Type</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">state$</code></td> <td><code class="inline">Observable&lt;ResourceState&gt;</code></td> <td>Complete state object</td></p>
</tr>
<p><tr> <td><code class="inline">filters$</code></td> <td><code class="inline">Observable&lt;TFilters&gt;</code></td> <td>Current filter values</td></p>
</tr>
<p><tr> <td><code class="inline">results$</code></td> <td><code class="inline">Observable&lt;TData[]&gt;</code></td> <td>Current page results</td></p>
</tr>
<p><tr> <td><code class="inline">totalResults$</code></td> <td><code class="inline">Observable&lt;number&gt;</code></td> <td>Total count</td></p>
</tr>
<p><tr> <td><code class="inline">loading$</code></td> <td><code class="inline">Observable&lt;boolean&gt;</code></td> <td>Loading state</td></p>
</tr>
<p><tr> <td><code class="inline">error$</code></td> <td><code class="inline">Observable&lt;Error \</td> <td>null&gt;</code></td> <td>Error state</td></p>
</tr>
<p><tr> <td><code class="inline">statistics$</code></td> <td><code class="inline">Observable&lt;TStats&gt;</code></td> <td>Statistics data</td></p>
</tr>
<p><tr> <td><code class="inline">highlights$</code></td> <td><code class="inline">Observable&lt;any&gt;</code></td> <td>Highlight filters</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Methods (Framework)</h2>

<p>These method names are <strong>framework conventions</strong>:</p>

<table>
<p><thead><tr> <th>Method</th> <th>Signature</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">updateFilters()</code></td> <td><code class="inline">(partial: Partial&lt;TFilters&gt;) =&gt; void</code></td> <td>Update filters via URL</td></p>
</tr>
<p><tr> <td><code class="inline">clearFilters()</code></td> <td><code class="inline">() =&gt; void</code></td> <td>Reset to defaults</td></p>
</tr>
<p><tr> <td><code class="inline">refresh()</code></td> <td><code class="inline">() =&gt; void</code></td> <td>Re-fetch with current filters</td></p>
</tr>
<p><tr> <td><code class="inline">getCurrentState()</code></td> <td><code class="inline">() =&gt; ResourceState</code></td> <td>Get state snapshot</td></p>
</tr>
<p><tr> <td><code class="inline">getCurrentFilters()</code></td> <td><code class="inline">() =&gt; TFilters</code></td> <td>Get filters snapshot</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Injection Tokens (Framework)</h2>

<table>
<p><thead><tr> <th>Token</th> <th>Type</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">DOMAIN_CONFIG</code></td> <td><code class="inline">InjectionToken&lt;DomainConfig&gt;</code></td> <td>Provides domain configuration</td></p>
</tr>
<p><tr> <td><code class="inline">IS_POPOUT_TOKEN</code></td> <td><code class="inline">InjectionToken&lt;boolean&gt;</code></td> <td>Indicates pop-out context</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>What Changes When Adding a New Domain?</h2>

<p>To add agriculture support to vroom, you would create:</p>

<pre class="code-block text"><code>src/domain-config/agriculture/
<p>├── adapters/ │   ├── agriculture-url-mapper.ts      # Implements IFilterUrlMapper │   ├── agriculture-api.adapter.ts     # Implements IApiAdapter │   └── agriculture-cache-key-builder.ts ├── chart-sources/ │   ├── region-chart-source.ts │   └── crop-chart-source.ts ├── configs/ │   ├── agriculture.filter-definitions.ts │   ├── agriculture.table-config.ts │   └── agriculture.chart-configs.ts ├── models/ │   ├── agriculture.filters.ts │   ├── agriculture.data.ts │   └── agriculture.statistics.ts ├── agriculture.domain-config.ts └── index.ts</p>

<p>src/app/features/agriculture/ ├── agriculture.component.ts └── agriculture-discover/ └── agriculture-discover.component.ts</p>
</code></pre>

<p>And update:</p>
<ul><li><code class="inline">src/domain-config/domain-providers.ts</code> (register the new domain)</li>
<p><li><code class="inline">src/app/app.routes.ts</code> (add agriculture routes)</li></p>
</ul>
<p><strong>No changes to framework code.</strong></p>

<hr>

<h2>Naming Patterns</h2>

<h3>Domain Config Files</h3>

<p>Pattern: <code class="inline">{domain}.{type}.ts</code></p>

<p>Examples:</p>
<ul><li><code class="inline">automobile.filter-definitions.ts</code></li>
<p><li><code class="inline">automobile.table-config.ts</code></li> <li><code class="inline">agriculture.filter-definitions.ts</code></li></p>
</ul>
<h3>Adapter Classes</h3>

<p>Pattern: <code class="inline">{Domain}{Type}</code> (PascalCase)</p>

<p>Examples:</p>
<ul><li><code class="inline">AutomobileApiAdapter</code></li>
<p><li><code class="inline">AutomobileUrlMapper</code></li> <li><code class="inline">AgricultureApiAdapter</code></li></ul></p></div><div class="page-content"><h3>Model Classes</h3>

<p>Pattern: <code class="inline">{DomainEntity}</code> (domain-meaningful names)</p>

<p>Examples:</p>
<ul><li><code class="inline">VehicleResult</code> (not <code class="inline">AutomobileResult</code>)</li>
<p><li><code class="inline">AutoSearchFilters</code> (not <code class="inline">AutomobileFilters</code>)</li> <li><code class="inline">CropYield</code> (for agriculture)</li></p>
</ul>
<h3>Feature Components</h3>

<p>Pattern: <code class="inline">{Domain}DiscoverComponent</code></p>

<p>Examples:</p>
<ul><li><code class="inline">AutomobileDiscoverComponent</code></li>
<p><li><code class="inline">AgricultureDiscoverComponent</code></li></p>
</ul>
<hr>

<h2>Companion Book Scope</h2>

<p>A companion book "Adding Agriculture to Vroom" would cover only:</p>

<table>
<p><thead><tr> <th>Phase</th> <th>Documents</th> <th>Content</th></p>
</tr></thead>
<p><tbody> <tr> <td>API Contract</td> <td>1</td> <td>Agriculture endpoints</td></p>
</tr>
<p><tr> <td>Domain Models</td> <td>3</td> <td>Filters, Data, Statistics</td></p>
</tr>
<p><tr> <td>Domain Adapters</td> <td>3</td> <td>URL Mapper, API Adapter, Cache Key Builder</td></p>
</tr>
<p><tr> <td>Domain Configs</td> <td>6</td> <td>Filter definitions, table, charts, etc.</td></p>
</tr>
<p><tr> <td>Chart Sources</td> <td>2-4</td> <td>Domain-specific chart transformations</td></p>
</tr>
<p><tr> <td>Feature Components</td> <td>2</td> <td>Landing page, Discover page</td></p>
</tr>
<p><tr> <td>Routes</td> <td>1</td> <td>Add routes to app.routes.ts</td></p>
</tr>
<p><tr> <td><strong>Total</strong></td> <td>~18</td> <td>~150 pages</td></p>
</tr>
</tbody>
</table>

<p>Compare to the full vroom book: <strong>65 documents, ~525 pages</strong>.</p>

<p>The companion book is <strong>~70% smaller</strong> because all framework code is reused.</p>

<hr>

<h2>Summary</h2>

<table>
<p><thead><tr> <th>Category</th> <th>Framework</th> <th>Domain</th></p>
</tr></thead>
<p><tbody> <tr> <td>Services</td> <td>14</td> <td>0</td></p>
</tr>
<p><tr> <td>Interfaces</td> <td>10</td> <td>0 (implement them)</td></p>
</tr>
<p><tr> <td>Models</td> <td>0</td> <td>9</td></p>
</tr>
<p><tr> <td>Adapters</td> <td>0</td> <td>3</td></p>
</tr>
<p><tr> <td>Configs</td> <td>0</td> <td>7</td></p>
</tr>
<p><tr> <td>Chart Sources</td> <td>0</td> <td>4</td></p>
</tr>
<p><tr> <td>UI Components</td> <td>9</td> <td>0</td></p>
</tr>
<p><tr> <td>Feature Components</td> <td>2</td> <td>2</td></p>
</tr>
<p><tr> <td><strong>Effort to add domain</strong></td> <td>0%</td> <td>100%</td></p>
</tr>
</tbody>
</table>

<hr>

<p><em>This document is the key to understanding vroom's architecture. Consult it whenever uncertain about where new code belongs.</em></p></div></div>
    <div class="chapter" id="section-101">
        <div class="chapter-header">
            <div class="chapter-category">Project Setup</div>
            <h1>101: Project Cleanup</h1>
        </div>
<div class="page-content"><h1>101: Project Cleanup</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 000-book-conventions, 051-api-contract-overview <strong>Blocks:</strong> 102-app-shell</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand why removing boilerplate establishes ownership of your codebase</li>
<p><li>Know how Angular environment files enable configuration without code changes</li> <li>Recognize the directory structure that separates framework code from domain code</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Remove Angular CLI boilerplate and establish the directory structure that will support our URL-First architecture. After this section, you will have a clean foundation ready for building the vvroom application.</p>

<hr>

<h2>Why</h2>

<p>When you generate a new Angular project with <code class="inline">ng new</code>, the CLI creates placeholder content designed to help newcomers verify their setup works. This placeholder content includes:</p>

<ul><li>A welcome message with the Angular logo</li>
<p><li>Links to Angular documentation</li> <li>Sample text that has nothing to do with your application</li></p>
</ul>
<p><strong>This is noise.</strong> Every line of code in your project should serve a purpose. Removing boilerplate immediately establishes a professional mindset: you own every line of code in this project, and you understand why it's there.</p>

<p>Additionally, we need to:</p>

<ul><li><strong>Configure the environment</strong> — Set the API base URL so our services know where to fetch data</li>
<p><li><strong>Establish the directory structure</strong> — Create folders that match our architecture before we need them</li> <li><strong>Update the HTML title</strong> — Small detail, but professionalism shows in the details</li></p>
</ul>
<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-04-06">Style 04-06</a>: Create sub-folders for feature areas</li>
<p><li><a href="https://angular.io/guide/styleguide#style-04-07">Style 04-07</a>: Create a folder for each feature module</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 101.1: Understand the Current State</h3>

<p>Before making changes, examine what the Angular CLI generated. Open a terminal and navigate to your project:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ls -la src/app/</p>
</code></pre>

<p>You should see:</p>

<pre class="code-block text"><code>total 16
<p>drwxr-xr-x 2 user user 4096 Feb  9 10:00 . drwxr-xr-x 5 user user 4096 Feb  9 10:00 .. -rw-r--r-- 1 user user 1234 Feb  9 10:00 app.component.ts -rw-r--r-- 1 user user  345 Feb  9 10:00 app.module.ts</p>
</code></pre>

<p>The current <code class="inline">src/app/app.component.ts</code> contains placeholder content with an inline template showing a welcome message, the Angular logo, and documentation links. This is what we'll clean up.</p></div><div class="page-content"><hr>

<h3>Step 101.2: Clean Up AppComponent</h3>

<p>Open <code class="inline">src/app/app.component.ts</code> and replace its entire contents with:</p>

<pre class="code-block typescript"><code>// src/app/app.component.ts
<p>// VERSION 1 (Section 101) - Minimal placeholder // This will be replaced with the full shell in Section 102</p>

<p>import { Component } from '@angular/core';</p>

<p>@Component({ selector: 'app-root', template: <code class="inline"> &lt;h1&gt;vvroom&lt;/h1&gt; &lt;p&gt;Automobile Discovery Platform&lt;/p&gt;</p>
  </code>,
<p>styles: [] }) export class AppComponent {}</p>
</code></pre>

<p><strong>What changed:</strong></p>

<table>
<p><thead><tr> <th>Before</th> <th>After</th></p>
</tr></thead>
<p><tbody> <tr> <td>32 lines with placeholder content</td> <td>13 lines of clean code</td></p>
</tr>
<p><tr> <td><code class="inline">title</code> property (unused baggage)</td> <td>No unnecessary properties</td></p>
</tr>
<p><tr> <td>Inline Angular logo (base64 SVG)</td> <td>Removed</td></p>
</tr>
<p><tr> <td>Documentation links</td> <td>Removed</td></p>
</tr>
</tbody>
</table>

<p><strong>Why this template?</strong></p>

<p>The simple heading and tagline serve as a "smoke test" — when you run the app, you'll immediately see whether your changes worked. We're not adding navigation or routing yet; that comes in document 102.</p>

<hr>

<h3>Step 101.3: Configure Environment for API Access</h3>

<p>Our application will fetch data from the automobile API. Configure the base URL in the environment file.</p>

<p>Open <code class="inline">src/environments/environment.ts</code> and replace its contents with:</p>

<pre class="code-block typescript"><code>// src/environments/environment.ts

<p>export const environment = { production: false, apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1' };</p>
</code></pre>

<p>Now create the production environment file. Open <code class="inline">src/environments/environment.prod.ts</code> and replace its contents with:</p>

<pre class="code-block typescript"><code>// src/environments/environment.prod.ts

<p>export const environment = { production: true, apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1' };</p>
</code></pre>

<p><strong>Why the same URL for both?</strong></p>

<p>In this application, development and production use the same API server. In a typical enterprise environment, you might have:</p>

<ul><li>Development: <code class="inline">http://localhost:3000/api</code></li>
<p><li>Production: <code class="inline">https://api.yourcompany.com/v1</code></li></p>
</ul>
<p>The environment file pattern allows this flexibility without changing application code.</p>

<hr>

<h3>Step 101.4: Create Directory Structure</h3>

<p>Create the directories that will hold our framework and domain-specific code:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom

<h1>Framework directories (domain-agnostic, reusable)</h1>
<p>$ mkdir -p src/app/framework/services $ mkdir -p src/app/framework/models $ mkdir -p src/app/framework/components $ mkdir -p src/app/framework/tokens</p>

<h1>Feature directories (page-level components)</h1>
<p>$ mkdir -p src/app/features/home $ mkdir -p src/app/features/discover $ mkdir -p src/app/features/popout</p>

<h1>Domain configuration (automobile-specific)</h1>
<p>$ mkdir -p src/app/domain-config/automobile/models $ mkdir -p src/app/domain-config/automobile/adapters $ mkdir -p src/app/domain-config/automobile/configs $ mkdir -p src/app/domain-config/automobile/chart-sources</p>
</code></pre>

<p>Verify the structure:</p>

<pre class="code-block bash"><code>$ find src/app -type d | sort
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>src/app
<p>src/app/domain-config src/app/domain-config/automobile src/app/domain-config/automobile/adapters src/app/domain-config/automobile/chart-sources src/app/domain-config/automobile/configs src/app/domain-config/automobile/models src/app/features src/app/features/discover src/app/features/home src/app/features/popout src/app/framework src/app/framework/components src/app/framework/models src/app/framework/services src/app/framework/tokens</p>
</code></pre>

<p><strong>What do these directories mean?</strong></p></div><div class="page-content"><table>
<p><thead><tr> <th>Directory</th> <th>Purpose</th> <th>Examples</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">framework/services</code></td> <td>Domain-agnostic services</td> <td><code class="inline">UrlStateService</code>, <code class="inline">ApiService</code></td></p>
</tr>
<p><tr> <td><code class="inline">framework/models</code></td> <td>TypeScript interfaces for framework</td> <td><code class="inline">DomainConfig</code>, <code class="inline">ApiResponse</code></td></p>
</tr>
<p><tr> <td><code class="inline">framework/components</code></td> <td>Reusable UI components</td> <td><code class="inline">BaseChartComponent</code>, <code class="inline">ResultsTableComponent</code></td></p>
</tr>
<p><tr> <td><code class="inline">framework/tokens</code></td> <td>Angular injection tokens</td> <td><code class="inline">DOMAIN_CONFIG</code>, <code class="inline">IS_POPOUT_TOKEN</code></td></p>
</tr>
<p><tr> <td><code class="inline">features/*</code></td> <td>Page-level components</td> <td><code class="inline">HomeComponent</code>, <code class="inline">DiscoverComponent</code></td></p>
</tr>
<p><tr> <td><code class="inline">domain-config/automobile/*</code></td> <td>Automobile-specific configuration</td> <td>Filters, adapters, chart sources</td></p>
</tr>
</tbody>
</table>

<p>This structure directly reflects the architecture described in <code class="inline">053-naming-conventions.md</code>. Framework code never changes when you add a new domain; only <code class="inline">domain-config/</code> grows.</p>

<hr>

<h3>Step 101.5: Add Placeholder Files</h3>

<p>Empty directories are ignored by git. Add <code class="inline">.gitkeep</code> files to preserve the structure:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom

<h1>Add .gitkeep to each empty directory</h1>
<p>$ touch src/app/framework/services/.gitkeep $ touch src/app/framework/models/.gitkeep $ touch src/app/framework/components/.gitkeep $ touch src/app/framework/tokens/.gitkeep $ touch src/app/features/home/.gitkeep $ touch src/app/features/discover/.gitkeep $ touch src/app/features/popout/.gitkeep $ touch src/app/domain-config/automobile/models/.gitkeep $ touch src/app/domain-config/automobile/adapters/.gitkeep $ touch src/app/domain-config/automobile/configs/.gitkeep $ touch src/app/domain-config/automobile/chart-sources/.gitkeep</p>
</code></pre>

<p><strong>Note:</strong> These <code class="inline">.gitkeep</code> files are a convention, not a git feature. They're empty files that exist solely to make git track otherwise-empty directories. We'll delete them as we add real files to each directory.</p>

<hr>

<h3>Step 101.6: Update Page Title</h3>

<p>Open <code class="inline">src/index.html</code> and verify it has a meaningful title:</p>

<pre class="code-block html"><code>&lt;!doctype html&gt;
<p>&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Vvroom - Automobile Discovery&lt;/title&gt; &lt;base href="/"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;link rel="icon" type="image/x-icon" href="favicon.ico"&gt; &lt;/head&gt; &lt;body&gt; &lt;app-root&gt;&lt;/app-root&gt; &lt;/body&gt; &lt;/html&gt;</p>
</code></pre>

<p>The only change is the <code class="inline">&lt;title&gt;</code> tag: from "Vvroom" to "Vvroom - Automobile Discovery".</p></div><div class="page-content"><hr>

<h3>Step 101.7: Add Base Styles</h3>

<p>Open <code class="inline">src/styles.css</code> and add minimal global styles:</p>

<pre class="code-block css"><code>/<em> src/styles.css </em>/

<p>/<em> Reset and base styles </em>/ <em>, </em>::before, *::after { box-sizing: border-box; }</p>

<p>body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; font-size: 16px; line-height: 1.5; color: #333; background-color: #f5f5f5; }</p>

<p>h1, h2, h3, h4, h5, h6 { margin-top: 0; margin-bottom: 0.5rem; font-weight: 500; line-height: 1.2; }</p>

<p>a { color: #1976d2; text-decoration: none; }</p>

<p>a:hover { text-decoration: underline; }</p>
</code></pre>

<p><strong>Why these styles?</strong></p>

<ul><li><code class="inline">box-sizing: border-box</code> — Makes width/height calculations predictable (padding included)</li>
<p><li>System font stack — Uses the operating system's native font for fast loading and native feel</li> <li>Reset margins — Browsers have inconsistent defaults; we normalize them</li> <li>Link color — A professional blue that's accessible and familiar</li></p>
</ul>
<p>These styles provide a clean foundation. We'll add component-specific styles as we build the UI.</p>

<hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected output (no errors):</p>

<pre class="code-block text"><code>✔ Browser application bundle generation complete.
<p>✔ Copying assets complete. ✔ Index html generation complete.</p>

<p>Initial Chunk Files           | Names         |  Raw Size main.js                       | main          |  47.42 kB | polyfills.js                  | polyfills     | 339.16 kB | runtime.js                    | runtime       |   6.54 kB | styles.css                    | styles        |   1.23 kB |</p>

<p>Build at: 2026-02-09T17:00:00.000Z - Hash: abc123 - Time: 5000ms</p>
</code></pre>

<h3>2. Serve the Application</h3>

<pre class="code-block bash"><code>$ ng serve --open
</code></pre>

<p>Your browser should open to <code class="inline">http://localhost:4200</code> showing:</p>

<pre class="code-block text"><code>vvroom
<p>Automobile Discovery Platform</p>
</code></pre>

<p>If you see the Angular logo and "Welcome to vvroom!" links, you missed Step 101.2. Go back and update <code class="inline">app.component.ts</code>.</p>

<h3>3. Check the Browser Tab</h3>

<p>The browser tab should show "Vvroom - Automobile Discovery" (not just "Vvroom").</p></div><div class="page-content"><h3>4. Verify Directory Structure</h3>

<pre class="code-block bash"><code>$ find src/app -type d | wc -l
</code></pre>

<p>Expected: <code class="inline">16</code> (the app directory plus 15 subdirectories we created)</p>

<h3>5. Check Environment Configuration</h3>

<pre class="code-block bash"><code>$ grep -r "apiBaseUrl" src/environments/
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>src/environments/environment.ts:  apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1'
<p>src/environments/environment.prod.ts:  apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1'</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">ng build</code> fails with "Cannot find module '@angular/core'"</td> <td>Node modules not installed</td> <td>Run <code class="inline">npm install</code> in the project root</td></p>
</tr>
<p><tr> <td>Browser shows blank page</td> <td>Template syntax error in <code class="inline">app.component.ts</code></td> <td>Check for missing backticks or quotes in the template</td></p>
</tr>
<p><tr> <td>"Vvroom" title instead of "Vvroom - Automobile Discovery"</td> <td>Didn't save <code class="inline">index.html</code></td> <td>Save the file and refresh the browser</td></p>
</tr>
<p><tr> <td>Directories not created</td> <td>Typo in <code class="inline">mkdir</code> command</td> <td>Re-run the commands carefully; use tab completion</td></p>
</tr>
<p><tr> <td><code class="inline">ng serve</code> shows "Port 4200 is already in use"</td> <td>Another process using the port</td> <td>Kill the other process or use <code class="inline">ng serve --port 4201</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Own your code</strong> — Remove boilerplate so every line serves a purpose you understand</li>
<p><li><strong>Environment files separate configuration from code</strong> — Change URLs without changing TypeScript</li> <li><strong>Directory structure reflects architecture</strong> — Framework code in <code class="inline">framework/</code>, domain code in <code class="inline">domain-config/</code></li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/app.component.ts</code> contains only the clean template (no Angular logo, no links)</li>
<p><li>[ ] Application displays "vvroom" heading and "Automobile Discovery Platform" tagline</li> <li>[ ] <code class="inline">src/environments/environment.ts</code> includes <code class="inline">apiBaseUrl</code> property</li> <li>[ ] <code class="inline">src/environments/environment.prod.ts</code> includes <code class="inline">apiBaseUrl</code> property</li> <li>[ ] Directory structure created: <code class="inline">framework/</code>, <code class="inline">features/</code>, <code class="inline">domain-config/</code></li> <li>[ ] All directories contain <code class="inline">.gitkeep</code> placeholder files</li> <li>[ ] Browser tab shows "Vvroom - Automobile Discovery"</li> <li>[ ] <code class="inline">src/styles.css</code> contains base reset styles</li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li> <li>[ ] <code class="inline">ng serve</code> shows the clean application</li></ul></p></div><div class="page-content"><hr>

<h2>What We Accomplished</h2>

<table>
<p><thead><tr> <th>Item</th> <th>Before</th> <th>After</th></p>
</tr></thead>
<p><tbody> <tr> <td>AppComponent</td> <td>32 lines of boilerplate</td> <td>13 lines of clean code</td></p>
</tr>
<p><tr> <td>Environment config</td> <td>No API URL</td> <td>API URL configured</td></p>
</tr>
<p><tr> <td>Directory structure</td> <td>Flat <code class="inline">src/app/</code></td> <td>Organized by architecture</td></p>
</tr>
<p><tr> <td>Page title</td> <td>Generic "Vvroom"</td> <td>Descriptive "Vvroom - Automobile Discovery"</td></p>
</tr>
<p><tr> <td>Global styles</td> <td>Empty</td> <td>Professional base styles</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">102-app-shell.md</code> to build the application shell with navigation layout.</p></div></div>
    <div class="chapter" id="section-102">
        <div class="chapter-header">
            <div class="chapter-category">Project Setup</div>
            <h1>102: App Shell</h1>
        </div>
<div class="page-content"><h1>102: App Shell</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 101-project-cleanup <strong>Blocks:</strong> 103-routing</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the container/presentational component pattern for application layout</li>
<p><li>Know how to use the <code class="inline">:host</code> CSS selector to style Angular components</li> <li>Be able to create a flexbox-based full-viewport layout</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build the application shell — the outermost structural component that provides consistent navigation and layout across all pages. After this section, you'll have a header with navigation links and a content area where routed components will render.</p>

<hr>

<h2>Why</h2>

<p>Every web application needs a shell: a consistent frame that surrounds page content. The shell typically includes:</p>

<ul><li><strong>Header</strong> — Application name/logo and primary navigation</li>
<p><li><strong>Content area</strong> — Where page-specific content renders</li> <li><strong>Optional footer</strong> — Copyright, links, version info</li></p>
</ul>
<p>Building the shell before routing has practical benefits:</p>

<ul><li><strong>Visual confirmation</strong> — You see the navigation structure before wiring it up</li>
<p><li><strong>Router outlet placement</strong> — You know exactly where routed content will appear</li> <li><strong>Separation of concerns</strong> — Layout logic stays in AppComponent; page logic stays in feature components</li></p>
</ul>
<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-02-01">Style 02-01</a>: Use consistent naming for components</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-03">Style 05-03</a>: Put presentation logic in the component class</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>The shell is framework code — it doesn't change when you add new domains. The navigation links will eventually include domain-specific routes, but the shell structure remains constant.</p>

<hr>

<h2>What</h2>

<h3>Step 102.1: Design the Shell Layout</h3>

<p>Before writing code, understand what we're building:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│  HEADER                                                          │ │  ┌─────────┐  ┌──────────────────────────────────────────────┐  │ │  │  vvroom  │  │  Home  │  Discover  │                        │  │ │  └─────────┘  └──────────────────────────────────────────────┘  │ ├─────────────────────────────────────────────────────────────────┤ │                                                                  │ │  CONTENT AREA (router-outlet renders here)                       │ │                                                                  │ │                                                                  │ │                                                                  │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>The shell has two parts:</p>
<ul><li><strong>Header</strong> — Fixed at the top, contains logo and navigation</li>
<p><li><strong>Main content</strong> — Takes remaining vertical space, contains <code class="inline">&lt;router-outlet&gt;</code></li></ul></p></div><div class="page-content"><hr>

<h3>Step 102.2: Update AppComponent with Shell Structure</h3>

<p>Open <code class="inline">src/app/app.component.ts</code> and replace its contents with:</p>

<pre class="code-block typescript"><code>// src/app/app.component.ts
<p>// VERSION 2 (Section 102) - Shell with navigation // Replaces VERSION 1 from Section 101</p>

<p>import { Component } from '@angular/core';</p>

<p>@Component({ selector: 'app-root', template: <code class="inline"> &lt;header class="app-header"&gt; &lt;div class="app-header-brand"&gt; &lt;span class="app-header-logo"&gt;🚗&lt;/span&gt; &lt;span class="app-header-title"&gt;vvroom&lt;/span&gt; &lt;/div&gt; &lt;nav class="app-header-nav"&gt; &lt;a class="nav-link" href="/home"&gt;Home&lt;/a&gt; &lt;a class="nav-link" href="/discover"&gt;Discover&lt;/a&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main class="app-content"&gt; &lt;p&gt;Content will appear here once routing is configured.&lt;/p&gt; &lt;/main&gt;</p>
  </code>,
<p>styles: [<code class="inline"> :host { display: flex; flex-direction: column; min-height: 100vh; }</p>

<p>.app-header { display: flex; align-items: center; justify-content: space-between; padding: 0 1.5rem; height: 56px; background-color: #1976d2; color: white; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }</p>

<p>.app-header-brand { display: flex; align-items: center; gap: 0.5rem; }</p>

<p>.app-header-logo { font-size: 1.5rem; }</p>

<p>.app-header-title { font-size: 1.25rem; font-weight: 600; letter-spacing: -0.5px; }</p>

<p>.app-header-nav { display: flex; gap: 0.5rem; }</p>

<p>.nav-link { padding: 0.5rem 1rem; color: rgba(255, 255, 255, 0.9); text-decoration: none; border-radius: 4px; transition: background-color 0.2s; }</p>

<p>.nav-link:hover { background-color: rgba(255, 255, 255, 0.1); text-decoration: none; }</p>

<p>.app-content { flex: 1; padding: 1.5rem; }</p>
  </code>]
<p>}) export class AppComponent {}</p>
</code></pre>

<p><strong>What this code does:</strong></p>

<table>
<p><thead><tr> <th>Element</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">:host</code></td> <td>Styles the component itself as a flex column taking full viewport height</td></p>
</tr>
<p><tr> <td><code class="inline">.app-header</code></td> <td>Blue header bar with flexbox layout</td></p>
</tr>
<p><tr> <td><code class="inline">.app-header-brand</code></td> <td>Logo and title grouped together</td></p>
</tr>
<p><tr> <td><code class="inline">.app-header-nav</code></td> <td>Navigation links aligned to the right</td></p>
</tr>
<p><tr> <td><code class="inline">.nav-link</code></td> <td>Styled anchor tags with hover effect</td></p>
</tr>
<p><tr> <td><code class="inline">.app-content</code></td> <td>Main content area with <code class="inline">flex: 1</code> to fill remaining space</td></p>
</tr>
</tbody>
</table>

<p><strong>Why inline styles?</strong></p>

<p>For small components, inline styles in the <code class="inline">styles</code> array keep everything in one file. This follows Angular's recommendation for simple components. We'll extract styles to separate files for larger components later.</p>

<p><strong>Note on the emoji:</strong> We're using 🚗 as a temporary logo. In a production application, you'd use an SVG or image file. The emoji works fine for learning.</p></div><div class="page-content"><hr>

<h3>Step 102.3: Understand the Navigation Links (Temporary)</h3>

<p>Notice the navigation links use plain <code class="inline">href</code> attributes:</p>

<pre class="code-block html"><code>&lt;a class="nav-link" href="/home"&gt;Home&lt;/a&gt;
<p>&lt;a class="nav-link" href="/discover"&gt;Discover&lt;/a&gt;</p>
</code></pre>

<p><strong>This is intentional but temporary.</strong> These are standard HTML links that cause a full page reload. In the next document (103-routing), we'll:</p>

<ul><li>Import <code class="inline">RouterModule</code></li>
<p><li>Replace <code class="inline">href</code> with <code class="inline">routerLink</code></li> <li>Add <code class="inline">routerLinkActive</code> for highlighting the current route</li></p>
</ul>
<p>For now, clicking these links will show a 404 or reload the app — that's expected.</p>

<hr>

<h3>Step 102.4: Update AppModule to Import Required Modules</h3>

<p>The current <code class="inline">AppModule</code> is minimal. We don't need any additional imports yet, but let's verify it's correct.</p>

<p>Open <code class="inline">src/app/app.module.ts</code> and confirm it contains:</p>

<pre class="code-block typescript"><code>// src/app/app.module.ts

<p>import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser';</p>

<p>import { AppComponent } from './app.component';</p>

<p>@NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule {}</p>
</code></pre>

<p>No changes needed yet. We'll add <code class="inline">RouterModule</code> in document 103.</p>

<hr>

<h3>Step 102.5: Understanding the Flex Layout</h3>

<p>The shell uses flexbox for layout. Here's how it works:</p>

<pre class="code-block css"><code>:host {
<p>display: flex; flex-direction: column; min-height: 100vh; }</p>
</code></pre>

<p>This makes the component a vertical flex container that's at least viewport height.</p>

<pre class="code-block css"><code>.app-header {
<p>height: 56px; /<em> ... other styles ... </em>/ }</p>
</code></pre>

<p>The header has a fixed height of 56px (a common Material Design height).</p>

<pre class="code-block css"><code>.app-content {
<p>flex: 1; /<em> ... other styles ... </em>/ }</p>
</code></pre>

<p>The content area uses <code class="inline">flex: 1</code> to expand and fill all remaining vertical space.</p>

<p><strong>Visual result:</strong></p>

<pre class="code-block text"><code>┌────────────────────────────────────┐
<p>│ Header (fixed 56px)                │ ├────────────────────────────────────┤ │                                    │ │ Content (flexible, fills rest)     │ │                                    │ │                                    │ │                                    │ └────────────────────────────────────┘</p>
</code></pre>

<p>This ensures the app always fills the viewport, even with little content.</p></div><div class="page-content"><hr>

<h3>Step 102.6: The Host Element Pattern</h3>

<p>Notice we style <code class="inline">:host</code> rather than adding a wrapper div:</p>

<pre class="code-block css"><code>:host {
<p>display: flex; flex-direction: column; min-height: 100vh; }</p>
</code></pre>

<p><code class="inline">:host</code> is a CSS pseudo-class that targets the component's host element — in this case, <code class="inline">&lt;app-root&gt;</code>. This is an Angular best practice:</p>

<p><strong>Without :host (anti-pattern):</strong></p>
<pre class="code-block html"><code>&lt;app-root&gt;
<p>&lt;div class="wrapper"&gt;  &lt;!-- Unnecessary wrapper --&gt; &lt;header&gt;...&lt;/header&gt; &lt;main&gt;...&lt;/main&gt; &lt;/div&gt; &lt;/app-root&gt;</p>
</code></pre>

<p><strong>With :host (correct):</strong></p>
<pre class="code-block html"><code>&lt;app-root&gt;  &lt;!-- app-root IS the flex container --&gt;
<p>&lt;header&gt;...&lt;/header&gt; &lt;main&gt;...&lt;/main&gt; &lt;/app-root&gt;</p>
</code></pre>

<p>One less DOM element, cleaner structure, same result.</p>

<hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Serve the Application</h3>

<pre class="code-block bash"><code>$ ng serve --open
</code></pre>

<p>Expected: Browser opens to <code class="inline">http://localhost:4200</code></p>

<h3>3. Visual Check</h3>

<p>You should see:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│  🚗 vvroom                                    Home    Discover   │ ├─────────────────────────────────────────────────────────────────┤ │                                                                  │ │  Content will appear here once routing is configured.            │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<ul><li>Blue header with white text</li>
<p><li>Logo emoji and "vvroom" title on the left</li> <li>"Home" and "Discover" links on the right</li> <li>Gray background in the content area</li> <li>Links change background on hover</li></p>
</ul>
<h3>4. Test Navigation Links (Expected Behavior)</h3>

<p>Click "Home" or "Discover":</p>
<ul><li>The page will reload or show an error</li>
<p><li>This is expected — we haven't configured routing yet</li></p>
</ul>
<h3>5. Responsive Check</h3>

<p>Resize your browser window:</p>
<ul><li>The header should stay at the top</li>
<p><li>The content area should resize fluidly</li> <li>Navigation links should remain visible (no responsive menu yet)</li></ul></p></div><div class="page-content"><h3>6. Inspect the DOM</h3>

<p>Open browser developer tools (F12) and inspect the HTML:</p>

<pre class="code-block html"><code>&lt;app-root&gt;
<p>&lt;header class="app-header"&gt;...&lt;/header&gt; &lt;main class="app-content"&gt;...&lt;/main&gt; &lt;/app-root&gt;</p>
</code></pre>

<p>Notice there's no wrapper div — the <code class="inline">&lt;app-root&gt;</code> element itself is the flex container.</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Header not full width</td> <td>Missing <code class="inline">:host</code> styles</td> <td>Ensure <code class="inline">:host { display: flex; }</code> is present</td></p>
</tr>
<p><tr> <td>Content area doesn't fill viewport</td> <td>Missing <code class="inline">min-height: 100vh</code> on <code class="inline">:host</code></td> <td>Add the missing style</td></p>
</tr>
<p><tr> <td>Emoji not displaying</td> <td>System font doesn't support emoji</td> <td>This is rare; try a different browser</td></p>
</tr>
<p><tr> <td>Styles not applying</td> <td>Syntax error in <code class="inline">styles</code> array</td> <td>Check for missing backticks or brackets</td></p>
</tr>
<p><tr> <td>White gap at bottom of page</td> <td><code class="inline">flex: 1</code> not on <code class="inline">.app-content</code></td> <td>Add <code class="inline">flex: 1</code> to the content area</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>The shell is the application frame</strong> — It provides consistent structure across all pages</li>
<p><li><strong><code class="inline">:host</code> styles the component element</strong> — No wrapper divs needed</li> <li><strong><code class="inline">flex: 1</code> fills remaining space</strong> — Combined with <code class="inline">min-height: 100vh</code>, creates full-viewport layouts</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/app.component.ts</code> contains the shell template with header and content area</li>
<p><li>[ ] Header displays logo (🚗), title (vvroom), and navigation links (Home, Discover)</li> <li>[ ] Header has blue background (#1976d2) with white text</li> <li>[ ] Navigation links have hover effect</li> <li>[ ] Content area fills remaining viewport height</li> <li>[ ] <code class="inline">:host</code> selector is used for component-level layout</li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li> <li>[ ] <code class="inline">ng serve</code> shows the shell correctly in the browser</li></p>
</ul>
<hr>

<h2>What We Accomplished</h2>

<table>
<p><thead><tr> <th>Item</th> <th>Before</th> <th>After</th></p>
</tr></thead>
<p><tbody> <tr> <td>AppComponent template</td> <td>Simple heading</td> <td>Full shell with header and content</td></p>
</tr>
<p><tr> <td>Layout</td> <td>None</td> <td>Flexbox-based full-height layout</td></p>
</tr>
<p><tr> <td>Navigation</td> <td>None</td> <td>Placeholder links (non-functional)</td></p>
</tr>
<p><tr> <td>Styling</td> <td>None</td> <td>Professional header with hover effects</td></p>
</tr>
<p><tr> <td>Component pattern</td> <td>Basic</td> <td>Uses <code class="inline">:host</code> for layout</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Architecture Note</h2>

<p>The app shell follows the <strong>container/presentational pattern</strong>:</p>

<ul><li><strong>AppComponent (container)</strong> — Provides structure and layout</li>
<p><li><strong>Feature components (presentational)</strong> — Render inside the content area</li></p>
</ul>
<p>This separation means:</p>
<ul><li>Layout changes happen in one place (AppComponent)</li>
<p><li>Feature components focus on their specific functionality</li> <li>The shell is framework code — it works for any domain</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">103-routing.md</code> to configure Angular Router and make the navigation links functional.</p></div></div>
    <div class="chapter" id="section-103">
        <div class="chapter-header">
            <div class="chapter-category">Project Setup</div>
            <h1>103: Routing</h1>
        </div>
<div class="page-content"><h1>103: Routing</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 102-app-shell <strong>Blocks:</strong> 104-environment-config</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how Angular Router maps URLs to components</li>
<p><li>Know how to use <code class="inline">routerLink</code> for navigation without full page reloads</li> <li>Be able to highlight the current route using <code class="inline">routerLinkActive</code></li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Configure Angular Router with routes for Home, Discover, and Popout pages. Replace the placeholder <code class="inline">href</code> links with Angular's <code class="inline">routerLink</code> directive so navigation updates the URL without reloading the page.</p>

<hr>

<h2>Why</h2>

<p>The URL is the foundation of our application's state management. Before we build any features, we need the routing skeleton in place. Here's why routing comes early:</p>

<h3>URLs Are State</h3>

<p>In traditional web applications, the server generates each page. In a single-page application (SPA), the client handles navigation — but the URL remains the source of truth. When a user bookmarks <code class="inline">/discover?make=Toyota</code>, they expect to return to that exact view.</p>

<p>This is the core insight of <strong>URL-First State Management</strong>: the URL isn't just an address; it's a serialized representation of application state.</p>

<h3>Why Not Just Use <code class="inline">href</code>?</h3>

<p>Standard HTML links (<code class="inline">&lt;a href="/home"&gt;</code>) work, but they cause problems:</p>

<table>
<p><thead><tr> <th><code class="inline">href</code> Behavior</th> <th>Problem</th></p>
</tr></thead>
<p><tbody> <tr> <td>Full page reload</td> <td>Loses JavaScript state</td></p>
</tr>
<p><tr> <td>Server request</td> <td>Slower navigation</td></p>
</tr>
<p><tr> <td>Flash of white</td> <td>Poor user experience</td></p>
</tr>
</tbody>
</table>

<p>Angular's <code class="inline">routerLink</code> directive intercepts clicks and updates the URL without reloading. The Router then renders the appropriate component. This is faster, smoother, and preserves application state.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-04-10">Style 04-10</a>: Use redirects for default routes</li>
<p><li><a href="https://angular.io/guide/styleguide#style-02-05">Style 02-05</a>: Suffix routing modules with <code class="inline">-routing</code></li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>See <code class="inline">docs/README.md</code> for the full URL-First pattern. This section establishes the routing foundation that later sections will build upon.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 103.1: Create the Home Component</h3>

<p>The Home component is a simple landing page. Create the file <code class="inline">src/app/features/home/home.component.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/home/home.component.ts
<p>// VERSION 1 (Section 103) - Placeholder component</p>

<p>import { Component } from '@angular/core';</p>

<p>@Component({ selector: 'app-home', template: <code class="inline"> &lt;div class="home-container"&gt; &lt;h1&gt;Welcome to Vvroom&lt;/h1&gt; &lt;p&gt;Your automobile discovery platform.&lt;/p&gt; &lt;p&gt;Use the navigation above to explore vehicles.&lt;/p&gt; &lt;/div&gt;</p>
  </code>,
<p>styles: [<code class="inline"> .home-container { max-width: 600px; margin: 2rem auto; text-align: center; }</p>

<p>h1 { color: #1976d2; margin-bottom: 1rem; }</p>

<p>p { color: #666; margin-bottom: 0.5rem; }</p>
  </code>]
<p>}) export class HomeComponent {}</p>
</code></pre>

<p>Delete the <code class="inline">.gitkeep</code> file since the directory now has real content:</p>

<pre class="code-block bash"><code>$ rm src/app/features/home/.gitkeep
</code></pre>

<hr>

<h3>Step 103.2: Create the Discover Component</h3>

<p>The Discover component will eventually display vehicle search results. For now, it's a placeholder. Create <code class="inline">src/app/features/discover/discover.component.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/discover/discover.component.ts
<p>// VERSION 1 (Section 103) - Placeholder component // This will be replaced with the full discover page in Phase 9</p>

<p>import { Component } from '@angular/core';</p>

<p>@Component({ selector: 'app-discover', template: <code class="inline"> &lt;div class="discover-container"&gt; &lt;h1&gt;Discover Vehicles&lt;/h1&gt; &lt;p&gt;Vehicle search and filtering will appear here.&lt;/p&gt; &lt;p class="hint"&gt;Watch the URL bar as you navigate — this is where state will live.&lt;/p&gt; &lt;/div&gt;</p>
  </code>,
<p>styles: [<code class="inline"> .discover-container { max-width: 800px; margin: 2rem auto; }</p>

<p>h1 { color: #1976d2; margin-bottom: 1rem; }</p>

<p>p { color: #666; margin-bottom: 0.5rem; }</p>

<p>.hint { margin-top: 2rem; padding: 1rem; background-color: #e3f2fd; border-left: 4px solid #1976d2; color: #1565c0; }</p>
  </code>]
<p>}) export class DiscoverComponent {}</p>
</code></pre>

<p>Delete the <code class="inline">.gitkeep</code> file:</p>

<pre class="code-block bash"><code>$ rm src/app/features/discover/.gitkeep
</code></pre></div><div class="page-content"><hr>

<h3>Step 103.3: Create the Popout Component</h3>

<p>The Popout component renders in a separate browser window. It will display panels that users can pop out from the main interface. Create <code class="inline">src/app/features/popout/popout.component.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/popout/popout.component.ts
<p>// VERSION 1 (Section 103) - Placeholder component // This will be replaced with the full popout implementation in Phase 3B</p>

<p>import { Component } from '@angular/core';</p>

<p>@Component({ selector: 'app-popout', template: <code class="inline"> &lt;div class="popout-container"&gt; &lt;h1&gt;Popout Window&lt;/h1&gt; &lt;p&gt;This component renders in a separate browser window.&lt;/p&gt; &lt;p&gt;It will display charts and panels that communicate with the main window.&lt;/p&gt; &lt;/div&gt;</p>
  </code>,
<p>styles: [<code class="inline"> .popout-container { padding: 1rem; }</p>

<p>h1 { color: #1976d2; margin-bottom: 1rem; }</p>

<p>p { color: #666; margin-bottom: 0.5rem; }</p>
  </code>]
<p>}) export class PopoutComponent {}</p>
</code></pre>

<p>Delete the <code class="inline">.gitkeep</code> file:</p>

<pre class="code-block bash"><code>$ rm src/app/features/popout/.gitkeep
</code></pre>

<hr>

<h3>Step 103.4: Create the Routing Module</h3>

<p>Angular 13 uses a routing module to configure routes. Create <code class="inline">src/app/app-routing.module.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/app-routing.module.ts
<p>// VERSION 1 (Section 103) - Basic routing configuration</p>

<p>import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router';</p>

<p>import { HomeComponent } from './features/home/home.component'; import { DiscoverComponent } from './features/discover/discover.component'; import { PopoutComponent } from './features/popout/popout.component';</p>

<p>const routes: Routes = [ { path: '', redirectTo: 'home', pathMatch: 'full' }, { path: 'home', component: HomeComponent }, { path: 'discover', component: DiscoverComponent }, { path: 'popout', component: PopoutComponent } ];</p>

<p>@NgModule({ imports: [RouterModule.forRoot(routes)], exports: [RouterModule] }) export class AppRoutingModule {}</p>
</code></pre>

<p><strong>What each route does:</strong></p>

<table>
<p><thead><tr> <th>Path</th> <th>Component</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">''</code></td> <td>(redirect)</td> <td>Redirects root URL to <code class="inline">/home</code></td></p>
</tr>
<p><tr> <td><code class="inline">home</code></td> <td>HomeComponent</td> <td>Landing page</td></p>
</tr>
<p><tr> <td><code class="inline">discover</code></td> <td>DiscoverComponent</td> <td>Vehicle search (placeholder)</td></p>
</tr>
<p><tr> <td><code class="inline">popout</code></td> <td>PopoutComponent</td> <td>Pop-out window content</td></p>
</tr>
</tbody>
</table>

<p><strong>Why <code class="inline">pathMatch: 'full'</code>?</strong></p>

<p>Without <code class="inline">pathMatch: 'full'</code>, the empty path <code class="inline">''</code> would match every URL (since every URL starts with nothing). The <code class="inline">pathMatch: 'full'</code> option ensures the redirect only triggers when the entire URL path is empty.</p></div><div class="page-content"><hr>

<h3>Step 103.5: Update AppModule</h3>

<p>Import the routing module and declare the new components. Open <code class="inline">src/app/app.module.ts</code> and replace its contents with:</p>

<pre class="code-block typescript"><code>// src/app/app.module.ts
<p>// VERSION 2 (Section 103) - With routing and feature components // Replaces VERSION 1 from Section 101</p>

<p>import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser';</p>

<p>import { AppRoutingModule } from './app-routing.module'; import { AppComponent } from './app.component'; import { HomeComponent } from './features/home/home.component'; import { DiscoverComponent } from './features/discover/discover.component'; import { PopoutComponent } from './features/popout/popout.component';</p>

<p>@NgModule({ declarations: [ AppComponent, HomeComponent, DiscoverComponent, PopoutComponent ], imports: [ BrowserModule, AppRoutingModule ], providers: [], bootstrap: [AppComponent] }) export class AppModule {}</p>
</code></pre>

<p><strong>What changed:</strong></p>

<table>
<p><thead><tr> <th>Before</th> <th>After</th></p>
</tr></thead>
<p><tbody> <tr> <td>Only <code class="inline">AppComponent</code> declared</td> <td>Four components declared</td></p>
</tr>
<p><tr> <td>Only <code class="inline">BrowserModule</code> imported</td> <td><code class="inline">AppRoutingModule</code> also imported</td></p>
</tr>
</tbody>
</table>

<p><strong>Why declare components in AppModule?</strong></p>

<p>In Angular 13 with NgModules, every component must be declared in exactly one module. Since we don't have feature modules yet, all components go in <code class="inline">AppModule</code>. Later, as the application grows, we might create <code class="inline">HomeModule</code>, <code class="inline">DiscoverModule</code>, etc.</p>

<hr>

<h3>Step 103.6: Add Router Outlet to AppComponent</h3>

<p>The Router needs a place to render components. Update <code class="inline">src/app/app.component.ts</code> to add <code class="inline">&lt;router-outlet&gt;</code> and replace <code class="inline">href</code> with <code class="inline">routerLink</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/app.component.ts
<p>// VERSION 3 (Section 103) - With router outlet and routerLink // Replaces VERSION 2 from Section 102</p>

<p>import { Component } from '@angular/core';</p>

<p>@Component({ selector: 'app-root', template: <code class="inline"> &lt;header class="app-header"&gt; &lt;div class="app-header-brand"&gt; &lt;span class="app-header-logo"&gt;🚗&lt;/span&gt; &lt;span class="app-header-title"&gt;vvroom&lt;/span&gt; &lt;/div&gt; &lt;nav class="app-header-nav"&gt; &lt;a class="nav-link" routerLink="/home" routerLinkActive="nav-link-active"&gt;Home&lt;/a&gt; &lt;a class="nav-link" routerLink="/discover" routerLinkActive="nav-link-active"&gt;Discover&lt;/a&gt; &lt;/nav&gt; &lt;/header&gt; &lt;main class="app-content"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;/main&gt;</p>
  </code>,
<p>styles: [<code class="inline"> :host { display: flex; flex-direction: column; min-height: 100vh; }</p>

<p>.app-header { display: flex; align-items: center; justify-content: space-between; padding: 0 1.5rem; height: 56px; background-color: #1976d2; color: white; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }</p>

<p>.app-header-brand { display: flex; align-items: center; gap: 0.5rem; }</p>

<p>.app-header-logo { font-size: 1.5rem; }</p>

<p>.app-header-title { font-size: 1.25rem; font-weight: 600; letter-spacing: -0.5px; }</p>

<p>.app-header-nav { display: flex; gap: 0.5rem; }</p>

<p>.nav-link { padding: 0.5rem 1rem; color: rgba(255, 255, 255, 0.9); text-decoration: none; border-radius: 4px; transition: background-color 0.2s; }</p>

<p>.nav-link:hover { background-color: rgba(255, 255, 255, 0.1); text-decoration: none; }</p>

<p>.nav-link-active { background-color: rgba(255, 255, 255, 0.2); color: white; }</p>

<p>.app-content { flex: 1; padding: 1.5rem; }</p>
  </code>]
<p>}) export class AppComponent {}</p>
</code></pre>

<p><strong>What changed from VERSION 2:</strong></p>

<table>
<p><thead><tr> <th>Before</th> <th>After</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">href="/home"</code></td> <td><code class="inline">routerLink="/home"</code></td></p>
</tr>
<p><tr> <td><code class="inline">href="/discover"</code></td> <td><code class="inline">routerLink="/discover"</code></td></p>
</tr>
<p><tr> <td>Static placeholder text</td> <td><code class="inline">&lt;router-outlet&gt;&lt;/router-outlet&gt;</code></td></p>
</tr>
<p><tr> <td>No active link style</td> <td><code class="inline">.nav-link-active</code> class with <code class="inline">routerLinkActive</code></td></p>
</tr>
</tbody>
</table>

<p><strong>Understanding the new directives:</strong></p>

<table>
<p><thead><tr> <th>Directive</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">routerLink="/home"</code></td> <td>Navigate to <code class="inline">/home</code> without page reload</td></p>
</tr>
<p><tr> <td><code class="inline">routerLinkActive="nav-link-active"</code></td> <td>Add CSS class when this route is active</td></p>
</tr>
<p><tr> <td><code class="inline">&lt;router-outlet&gt;</code></td> <td>Placeholder where routed components render</td></p>
</tr>
</tbody>
</table>

<p><strong>Why <code class="inline">routerLinkActive</code>?</strong></p>

<p>Users need visual feedback about their current location. The <code class="inline">routerLinkActive</code> directive automatically adds a CSS class when the link's route matches the current URL. When you navigate to <code class="inline">/home</code>, the Home link gets the <code class="inline">nav-link-active</code> class, giving it a slightly different background.</p></div><div class="page-content"><hr>

<h3>Step 103.7: Understanding Router Outlet</h3>

<p>The <code class="inline">&lt;router-outlet&gt;</code> is a placeholder directive. When the URL changes, Angular:</p>

<ul><li>Matches the URL against the routes array</li>
<p><li>Creates an instance of the matching component</li> <li>Inserts the component's view after <code class="inline">&lt;router-outlet&gt;</code></li></p>
</ul>
<p><strong>Visual representation:</strong></p>

<p>When URL is <code class="inline">/home</code>:</p>
<pre class="code-block html"><code>&lt;main class="app-content"&gt;
<p>&lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;app-home&gt; &lt;div class="home-container"&gt; &lt;h1&gt;Welcome to Vvroom&lt;/h1&gt; ... &lt;/div&gt; &lt;/app-home&gt; &lt;/main&gt;</p>
</code></pre>

<p>When URL is <code class="inline">/discover</code>:</p>
<pre class="code-block html"><code>&lt;main class="app-content"&gt;
<p>&lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;app-discover&gt; &lt;div class="discover-container"&gt; &lt;h1&gt;Discover Vehicles&lt;/h1&gt; ... &lt;/div&gt; &lt;/app-discover&gt; &lt;/main&gt;</p>
</code></pre>

<p>The component renders as a sibling <em>after</em> the outlet, not inside it. This is why we styled <code class="inline">.app-content</code> rather than <code class="inline">router-outlet</code> — the outlet itself has no dimensions.</p>

<hr>

<h2>The Aha Moment</h2>

<p><strong>Routes are the skeleton. The URL is where state lives.</strong></p>

<p>Right now, our routes are simple: <code class="inline">/home</code>, <code class="inline">/discover</code>, <code class="inline">/popout</code>. But watch what happens when you click the navigation links:</p>

<ul><li>The URL in your browser's address bar changes</li>
<p><li>The page does <em>not</em> reload</li> <li>The content area updates instantly</li></p>
</ul>
<p>This is the foundation of URL-First architecture. In later sections, we'll add query parameters to the URL:</p>

<pre class="code-block text"><code>/discover?make=Toyota&amp;year=2023&amp;page=2
</code></pre>

<p>Every piece of state — the selected make, the year filter, the current page — will be encoded in the URL. Users can:</p>
<ul><li>Bookmark their exact search</li>
<p><li>Share the URL with colleagues</li> <li>Use the browser's back button to undo filter changes</li> <li>Refresh without losing their place</li></p>
</ul>
<p>The URL becomes a serialized snapshot of application state. This section establishes the routing skeleton that makes all of this possible.</p>

<hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected output (no errors):</p>

<pre class="code-block text"><code>✔ Browser application bundle generation complete.
<p>✔ Copying assets complete. ✔ Index html generation complete.</p>

<p>Initial Chunk Files           | Names         |  Raw Size main.js                       | main          |  52.18 kB | polyfills.js                  | polyfills     | 339.16 kB | runtime.js                    | runtime       |   6.54 kB | styles.css                    | styles        |   1.23 kB |</p>

<p>Build at: 2026-02-09T17:00:00.000Z - Hash: abc123 - Time: 5000ms</p>
</code></pre>

<p>Note: <code class="inline">main.js</code> is slightly larger now because it includes the Router and three new components.</p></div><div class="page-content"><h3>2. Serve the Application</h3>

<pre class="code-block bash"><code>$ ng serve --open
</code></pre>

<p>Browser opens to <code class="inline">http://localhost:4200</code></p>

<h3>3. Verify Redirect</h3>

<p>When you first load <code class="inline">http://localhost:4200</code>, you should be redirected to <code class="inline">http://localhost:4200/home</code>. Check the URL bar — it should show <code class="inline">/home</code>, not just <code class="inline">/</code>.</p>

<h3>4. Test Navigation</h3>

<p>Click "Discover" in the navigation:</p>
<ul><li>URL changes to <code class="inline">http://localhost:4200/discover</code></li>
<p><li>Page does NOT reload (no white flash)</li> <li>Content area shows "Discover Vehicles" heading</li> <li>"Discover" link is highlighted (slightly brighter background)</li></p>
</ul>
<p>Click "Home":</p>
<ul><li>URL changes to <code class="inline">http://localhost:4200/home</code></li>
<p><li>Content shows "Welcome to Vvroom"</li> <li>"Home" link is highlighted</li></p>
</ul>
<h3>5. Test Browser History</h3>

<ul><li>Navigate to Home</li>
<p><li>Navigate to Discover</li> <li>Click the browser's back button</li></p>
</ul>
<p>Expected: You return to Home without a page reload. The URL updates and the content changes instantly.</p>

<h3>6. Test Direct URL Access</h3>

<p>Open a new browser tab and navigate directly to:</p>
<ul><li><code class="inline">http://localhost:4200/discover</code></li>
</ul>
<p>Expected: The Discover page loads directly, with the navigation showing Discover as active.</p>

<h3>7. Test Popout Route</h3>

<p>Navigate to <code class="inline">http://localhost:4200/popout</code> by typing it in the address bar:</p>

<p>Expected: The Popout placeholder component renders.</p>

<h3>8. Inspect Active Link Styling</h3>

<p>Open browser developer tools (F12), navigate to Home, and inspect the Home link:</p>

<pre class="code-block html"><code>&lt;a class="nav-link nav-link-active" ...&gt;Home&lt;/a&gt;
</code></pre>

<p>The <code class="inline">nav-link-active</code> class should be present.</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">ng build</code> fails with "Cannot find module './features/home/home.component'"</td> <td>Component file not created or wrong path</td> <td>Verify file exists at <code class="inline">src/app/features/home/home.component.ts</code></td></p>
</tr>
<p><tr> <td>"Error: No component factory found for HomeComponent"</td> <td>Component not declared in AppModule</td> <td>Add <code class="inline">HomeComponent</code> to the <code class="inline">declarations</code> array</td></p>
</tr>
<p><tr> <td>Links still cause full page reload</td> <td>Still using <code class="inline">href</code> instead of <code class="inline">routerLink</code></td> <td>Replace <code class="inline">href="/home"</code> with <code class="inline">routerLink="/home"</code></td></p>
</tr>
<p><tr> <td>"Error: Cannot find primary outlet to load 'HomeComponent'"</td> <td>Missing <code class="inline">&lt;router-outlet&gt;</code> in template</td> <td>Add <code class="inline">&lt;router-outlet&gt;&lt;/router-outlet&gt;</code> to AppComponent template</td></p>
</tr>
<p><tr> <td>Active link style not showing</td> <td>Typo in <code class="inline">routerLinkActive</code> class name</td> <td>Ensure the class name matches: <code class="inline">routerLinkActive="nav-link-active"</code> and <code class="inline">.nav-link-active</code> in styles</td></p>
</tr>
<p><tr> <td>Navigating to <code class="inline">/</code> shows blank content</td> <td>Redirect not working</td> <td>Ensure route has <code class="inline">pathMatch: 'full'</code> on the redirect</td></p>
</tr>
<p><tr> <td>"NullInjectorError: No provider for Router"</td> <td><code class="inline">AppRoutingModule</code> not imported</td> <td>Add <code class="inline">AppRoutingModule</code> to the <code class="inline">imports</code> array in <code class="inline">AppModule</code></td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong><code class="inline">routerLink</code> replaces <code class="inline">href</code></strong> — For SPA navigation without page reloads</li>
<p><li><strong><code class="inline">&lt;router-outlet&gt;</code> is a placeholder</strong> — Routed components render after it, not inside it</li> <li><strong><code class="inline">routerLinkActive</code> provides visual feedback</strong> — Automatically adds a CSS class when the route matches</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/features/home/home.component.ts</code> exists with placeholder content</li>
<p><li>[ ] <code class="inline">src/app/features/discover/discover.component.ts</code> exists with placeholder content</li> <li>[ ] <code class="inline">src/app/features/popout/popout.component.ts</code> exists with placeholder content</li> <li>[ ] <code class="inline">src/app/app-routing.module.ts</code> configures routes for home, discover, and popout</li> <li>[ ] Root path (<code class="inline">/</code>) redirects to <code class="inline">/home</code></li> <li>[ ] <code class="inline">src/app/app.module.ts</code> declares all components and imports <code class="inline">AppRoutingModule</code></li> <li>[ ] <code class="inline">AppComponent</code> uses <code class="inline">routerLink</code> instead of <code class="inline">href</code></li> <li>[ ] <code class="inline">AppComponent</code> uses <code class="inline">routerLinkActive</code> for current route highlighting</li> <li>[ ] <code class="inline">AppComponent</code> includes <code class="inline">&lt;router-outlet&gt;</code> in the template</li> <li>[ ] Navigation works without page reload</li> <li>[ ] Browser back/forward buttons work correctly</li> <li>[ ] Active link has visual distinction (<code class="inline">.nav-link-active</code> style applied)</li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li> <li>[ ] <code class="inline">ng serve</code> shows working navigation</li> <li>[ ] Pop-out button on Discover page opens <code class="inline">/popout</code> in a new window</li></p>
</ul>
<hr>

<h2>What We Accomplished</h2>

<table>
<p><thead><tr> <th>Item</th> <th>Before</th> <th>After</th></p>
</tr></thead>
<p><tbody> <tr> <td>Routes</td> <td>None</td> <td>Home, Discover, Popout configured</td></p>
</tr>
<p><tr> <td>Navigation</td> <td><code class="inline">href</code> (full reload)</td> <td><code class="inline">routerLink</code> (SPA navigation)</td></p>
</tr>
<p><tr> <td>Active state</td> <td>None</td> <td>Visual highlight on current route</td></p>
</tr>
<p><tr> <td>Content area</td> <td>Static text</td> <td>Dynamic <code class="inline">&lt;router-outlet&gt;</code></td></p>
</tr>
<p><tr> <td>Components</td> <td>1 (AppComponent)</td> <td>4 (App, Home, Discover, Popout)</td></p>
</tr>
<p><tr> <td>URL behavior</td> <td>Ignored</td> <td>Foundation for state management</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Architecture Note</h2>

<p>All three feature components (Home, Discover, Popout) are <strong>framework components</strong> — they exist regardless of the domain. When we add automobile-specific functionality later:</p>

<ul><li><code class="inline">HomeComponent</code> will remain a generic landing page</li>
<p><li><code class="inline">DiscoverComponent</code> will become <code class="inline">AutomobileDiscoverComponent</code> (domain-specific)</li> <li><code class="inline">PopoutComponent</code> will remain generic (renders any domain's panels)</li></p>
</ul>
<p>This separation follows the naming conventions in <code class="inline">053-naming-conventions.md</code>.</p></div><div class="page-content"><hr>

<hr>

<h2>Bonus: Pop-Outs Are Just Routes in New Windows</h2>

<p>Before moving on, let's demonstrate something important: a pop-out window is nothing more than a route opened in a separate browser window. No special framework features are required — just <code class="inline">window.open()</code>.</p>

<h3>Step 103.8: Add a Pop-Out Button to Discover</h3>

<p>Update <code class="inline">src/app/features/discover/discover.component.ts</code> to add a button that opens the popout route in a new window:</p>

<pre class="code-block typescript"><code>// src/app/features/discover/discover.component.ts
<p>// VERSION 2 (Section 103) - With pop-out button // Replaces VERSION 1 from earlier in this section</p>

<p>import { Component } from '@angular/core';</p>

<p>@Component({ selector: 'app-discover', template: <code class="inline"> &lt;div class="discover-container"&gt; &lt;h1&gt;Discover Vehicles&lt;/h1&gt; &lt;p&gt;Vehicle search and filtering will appear here.&lt;/p&gt; &lt;p class="hint"&gt;Watch the URL bar as you navigate — this is where state will live.&lt;/p&gt;</p>

<p>&lt;div class="popout-demo"&gt; &lt;h2&gt;Pop-Out Demo&lt;/h2&gt; &lt;p&gt;Click the button below to open the popout route in a new window:&lt;/p&gt; &lt;button class="popout-button" (click)="openPopout()"&gt; Open Pop-Out Window &lt;/button&gt; &lt;p class="note"&gt; Notice: the pop-out is just &lt;code&gt;/popout&lt;/code&gt; opened in a new window. Same Angular app, same routes, different window. &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;</p>
  </code>,
<p>styles: [<code class="inline"> .discover-container { max-width: 800px; margin: 2rem auto; }</p>

<p>h1 { color: #1976d2; margin-bottom: 1rem; }</p>

<p>h2 { color: #1976d2; margin-bottom: 0.5rem; font-size: 1.25rem; }</p>

<p>p { color: #666; margin-bottom: 0.5rem; }</p>

<p>.hint { margin-top: 2rem; padding: 1rem; background-color: #e3f2fd; border-left: 4px solid #1976d2; color: #1565c0; }</p>

<p>.popout-demo { margin-top: 2rem; padding: 1.5rem; background-color: #f5f5f5; border-radius: 8px; }</p>

<p>.popout-button { padding: 0.75rem 1.5rem; font-size: 1rem; background-color: #1976d2; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.2s; }</p>

<p>.popout-button:hover { background-color: #1565c0; }</p>

<p>.note { margin-top: 1rem; font-size: 0.875rem; color: #888; }</p>

<p>code { background-color: #e8e8e8; padding: 0.125rem 0.375rem; border-radius: 3px; font-family: monospace; }</p>
  </code>]
<p>}) export class DiscoverComponent { openPopout(): void { const popoutUrl = <code class="inline">${window.location.origin}/popout</code>; window.open( popoutUrl, 'vvroomPopout', 'width=600,height=400,menubar=no,toolbar=no,location=no,status=no' ); } }</p>
</code></pre>

<p><strong>What the <code class="inline">openPopout()</code> method does:</strong></p>

<table>
<p><thead><tr> <th>Line</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">window.location.origin</code></td> <td>Gets the base URL (e.g., <code class="inline">http://localhost:4200</code>)</td></p>
</tr>
<p><tr> <td><code class="inline">'/popout'</code></td> <td>The route we defined earlier</td></p>
</tr>
<p><tr> <td><code class="inline">'vvroomPopout'</code></td> <td>Window name (reuses same window if already open)</td></p>
</tr>
<p><tr> <td><code class="inline">'width=600,height=400,...'</code></td> <td>Window features (size, no browser chrome)</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><h3>Verification: Test the Pop-Out</h3>

<ul><li>Navigate to <code class="inline">http://localhost:4200/discover</code></li>
<p><li>Click the "Open Pop-Out Window" button</li> <li>A new browser window opens showing the Popout component</li> <li>The URL in the new window is <code class="inline">http://localhost:4200/popout</code></li></p>
</ul>
<p><strong>Key observation:</strong> The pop-out window runs the same Angular application. It just happens to be displaying a different route in a separate window.</p>

<h3>Why This Matters</h3>

<p>This simple demonstration reveals the core insight behind pop-out windows:</p>

<p>&gt; <strong>Pop-outs are not special. They're just routes rendered in separate windows.</strong></p>

<p>In Phase 3B (documents 307-308), we'll add services that enable the main window and pop-out windows to communicate. But the foundation is what you see here: <code class="inline">window.open()</code> pointing to a route in your application.</p>

<p>When you understand this, the complexity of pop-out panels dissolves. A "pop-out chart" is just:</p>
<ul><li>A route that renders a chart component</li>
<p><li>Opened in a new window</li> <li>With a service that syncs state between windows</li></p>
</ul>
<p>Steps 1 and 2 are already working. Step 3 comes later.</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">104-environment-config.md</code> to configure environment settings and verify API connectivity.</p></div></div>
    <div class="chapter" id="section-104">
        <div class="chapter-header">
            <div class="chapter-category">Project Setup</div>
            <h1>104: Environment Config</h1>
        </div>
<div class="page-content"><h1>104: Environment Config Verification</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 103-routing <strong>Blocks:</strong> 150-typescript-generics-primer</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how Angular's environment files enable build-time configuration</li>
<p><li>Know how to verify your project compiles and runs correctly</li> <li>Recognize that Phase 1 establishes the foundation for all subsequent work</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Verify the environment configuration from Section 101 and confirm the Phase 1 foundation is complete. This section is a consolidation checkpoint — ensuring everything from Sections 101-103 works together before proceeding to framework development.</p>

<hr>

<h2>Why</h2>

<h3>Checkpoints Prevent Cascading Errors</h3>

<p>Before building framework services and components, we must confirm the foundation is solid. A misconfigured environment or broken route will cause confusing errors later. It's easier to diagnose problems in isolation than to debug a broken service that depends on three other broken things.</p>

<h3>The Phase 1 Checkpoint</h3>

<p>Document 002 (Dissection Rubric) defines this checkpoint:</p>

<p>&gt; <strong>Phase 1 Checkpoint:</strong> Navigation between empty pages works. Browser history works. Readers observe URL changes in dev tools.</p>

<p>This section verifies we've achieved that checkpoint.</p>

<hr>

<h2>What</h2>

<h3>Step 104.1: Verify Environment Files</h3>

<p>The environment files should already exist from Section 101. Confirm their contents.</p>

<p>Open <code class="inline">src/environments/environment.ts</code> and verify it contains:</p>

<pre class="code-block typescript"><code>// src/environments/environment.ts

<p>export const environment = { production: false, apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1' };</p>
</code></pre>

<p>Open <code class="inline">src/environments/environment.prod.ts</code> and verify it contains:</p>

<pre class="code-block typescript"><code>// src/environments/environment.prod.ts

<p>export const environment = { production: true, apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1' };</p>
</code></pre>

<p>If these files don't match, update them now. The <code class="inline">apiBaseUrl</code> property will be used by services in Phase 3.</p></div><div class="page-content"><hr>

<h3>Step 104.2: Understand Build-Time File Replacement</h3>

<p>Angular's build system replaces environment files at build time. This is configured in <code class="inline">angular.json</code>:</p>

<pre class="code-block json"><code>"configurations": {
<p>"production": { "fileReplacements": [ { "replace": "src/environments/environment.ts", "with": "src/environments/environment.prod.ts" } ] } }</p>
</code></pre>

<p>When you run <code class="inline">ng build --configuration=production</code>, Angular swaps <code class="inline">environment.ts</code> for <code class="inline">environment.prod.ts</code>. Your code always imports from <code class="inline">environment.ts</code>, but the actual values come from the appropriate file.</p>

<p><strong>This is not runtime configuration.</strong> The values are baked into the compiled JavaScript bundle. To change the API URL, you must rebuild.</p>

<hr>

<h3>Step 104.3: Verify Project Structure</h3>

<p>Run the following command to confirm the directory structure from Section 101:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ find src/app -type d | sort</p>
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>src/app
<p>src/app/domain-config src/app/domain-config/automobile src/app/domain-config/automobile/adapters src/app/domain-config/automobile/chart-sources src/app/domain-config/automobile/configs src/app/domain-config/automobile/models src/app/features src/app/features/discover src/app/features/home src/app/features/popout src/app/framework src/app/framework/components src/app/framework/models src/app/framework/services src/app/framework/tokens</p>
</code></pre>

<p>If directories are missing, create them using the commands from Section 101.</p>

<hr>

<h3>Step 104.4: Verify Component Files</h3>

<p>Confirm the feature components from Section 103 exist:</p>

<pre class="code-block bash"><code>$ ls -la src/app/features/*/
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>src/app/features/discover/:
<p>discover.component.ts</p>

<p>src/app/features/home/: home.component.ts</p>

<p>src/app/features/popout/: popout.component.ts</p>
</code></pre>

<hr>

<h3>Step 104.5: Build and Serve</h3>

<p>Run the build to confirm everything compiles:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<p>Start the development server:</p>

<pre class="code-block bash"><code>$ ng serve
</code></pre>

<p>Open your browser to <code class="inline">http://localhost:4200</code>.</p></div><div class="page-content"><hr>

<h3>Step 104.6: Execute Phase 1 Checkpoint Tests</h3>

<p>Perform each test manually:</p>

<p><strong>Test 1: Root Redirect</strong></p>
<ul><li>Navigate to <code class="inline">http://localhost:4200</code></li>
<p><li>Observe: URL changes to <code class="inline">http://localhost:4200/home</code></li> <li>Observe: Home component content displays</li></p>
</ul>
<p><strong>Test 2: Navigation Without Reload</strong></p>
<ul><li>Click "Discover" in the navigation</li>
<p><li>Observe: URL changes to <code class="inline">/discover</code></li> <li>Observe: Page does NOT reload (no white flash)</li> <li>Observe: Discover component content displays</li></p>
</ul>
<p><strong>Test 3: Active Link Highlighting</strong></p>
<ul><li>While on <code class="inline">/discover</code>, observe: "Discover" link has brighter background</li>
<p><li>Click "Home"</li> <li>Observe: "Home" link now has brighter background</li></p>
</ul>
<p><strong>Test 4: Browser History</strong></p>
<ul><li>Navigate: Home → Discover → Home → Discover</li>
<p><li>Click browser back button</li> <li>Observe: Returns to Home without reload</li> <li>Click browser forward button</li> <li>Observe: Returns to Discover without reload</li></p>
</ul>
<p><strong>Test 5: Direct URL Access</strong></p>
<ul><li>Open new tab</li>
<p><li>Navigate directly to <code class="inline">http://localhost:4200/discover</code></li> <li>Observe: Discover page loads correctly</li> <li>Observe: "Discover" link is highlighted</li></p>
</ul>
<p><strong>Test 6: Popout Route</strong></p>
<ul><li>Navigate to <code class="inline">http://localhost:4200/popout</code></li>
<p><li>Observe: Popout component content displays</li></p>
</ul>
<hr>

<h2>Phase 1 Complete</h2>

<p>You have successfully completed Phase 1: Foundation. Your application now has:</p>

<table>
<p><thead><tr> <th>Capability</th> <th>Status</th></p>
</tr></thead>
<p><tbody> <tr> <td>Clean project structure</td> <td>Ready for framework and domain code</td></p>
</tr>
<p><tr> <td>Environment configuration</td> <td>API URL configured for both dev and prod</td></p>
</tr>
<p><tr> <td>App shell with navigation</td> <td>Header, content area, flexbox layout</td></p>
</tr>
<p><tr> <td>Angular Router</td> <td>Routes for Home, Discover, Popout</td></p>
</tr>
<p><tr> <td>SPA navigation</td> <td>No page reloads when clicking links</td></p>
</tr>
<p><tr> <td>Browser history integration</td> <td>Back/forward buttons work</td></p>
</tr>
<p><tr> <td>Active route highlighting</td> <td>Visual feedback for current location</td></p>
</tr>
</tbody>
</table>

<h3>The Phase 1 Aha Moment</h3>

<p><strong>Routes are the skeleton. The URL is where state lives.</strong></p>

<p>Right now, your URLs are simple paths: <code class="inline">/home</code>, <code class="inline">/discover</code>, <code class="inline">/popout</code>. In Phase 3, we'll add services that read and write query parameters:</p>

<pre class="code-block text"><code>/discover?make=Toyota&amp;year=2023&amp;bodyClass=SUV&amp;page=2
</code></pre>

<p>Every filter selection, every page navigation, every user choice will be encoded in the URL. This is URL-First State Management — and Phase 1 established the routing skeleton that makes it possible.</p></div><div class="page-content"><hr>

<h2>Verification</h2>

<p>All verification is covered in Step 104.6. If any test fails, review the relevant section:</p>

<table>
<p><thead><tr> <th>Failed Test</th> <th>Review Section</th></p>
</tr></thead>
<p><tbody> <tr> <td>Root redirect</td> <td>103, Step 103.4 (routes)</td></p>
</tr>
<p><tr> <td>Navigation reloads page</td> <td>103, Step 103.6 (routerLink)</td></p>
</tr>
<p><tr> <td>Active link not highlighted</td> <td>103, Step 103.6 (routerLinkActive)</td></p>
</tr>
<p><tr> <td>Browser history broken</td> <td>103, Step 103.5 (AppRoutingModule)</td></p>
</tr>
<p><tr> <td>Direct URL access fails</td> <td>103, Step 103.4 (routes)</td></p>
</tr>
<p><tr> <td>Build errors</td> <td>101, 102, 103 (various)</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Build fails with environment error</td> <td><code class="inline">apiBaseUrl</code> not added to environment files</td> <td>Update both environment files per Step 104.1</td></p>
</tr>
<p><tr> <td>Missing directories</td> <td>Section 101 steps skipped</td> <td>Run mkdir commands from Section 101</td></p>
</tr>
<p><tr> <td>Component files missing</td> <td>Section 103 steps skipped</td> <td>Create components per Section 103</td></p>
</tr>
<p><tr> <td>Tests pass locally but not described here</td> <td>You're ahead of the manuscript</td> <td>Great! Continue to the next section</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Environment files are build-time configuration</strong> — Values are baked into the bundle, not loaded at runtime</li>
<p><li><strong>Checkpoints prevent cascading errors</strong> — Verify the foundation before building on it</li> <li><strong>Phase 1 establishes the routing skeleton</strong> — All URL-First state management builds on this foundation</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/environments/environment.ts</code> contains <code class="inline">apiBaseUrl</code></li>
<p><li>[ ] <code class="inline">src/environments/environment.prod.ts</code> contains <code class="inline">apiBaseUrl</code></li> <li>[ ] Directory structure matches expected layout</li> <li>[ ] All three feature components exist (Home, Discover, Popout)</li> <li>[ ] <code class="inline">ng build</code> succeeds with no errors</li> <li>[ ] <code class="inline">ng serve</code> starts without errors</li> <li>[ ] Root URL redirects to <code class="inline">/home</code></li> <li>[ ] Navigation works without page reload</li> <li>[ ] Active links are visually highlighted</li> <li>[ ] Browser back/forward buttons work</li> <li>[ ] Direct URL access works for all routes</li></p>
</ul>
<hr>

<h2>What We Accomplished</h2>

<table>
<p><thead><tr> <th>Phase 1 Document</th> <th>Content</th></p>
</tr></thead>
<p><tbody> <tr> <td>101: Project Cleanup</td> <td>Removed boilerplate, created directories, configured environment</td></p>
</tr>
<p><tr> <td>102: App Shell</td> <td>Built header, navigation, content area with flexbox layout</td></p>
</tr>
<p><tr> <td>103: Routing</td> <td>Configured Router, created components, added routerLink</td></p>
</tr>
<p><tr> <td>104: Verification</td> <td>Confirmed all pieces work together</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">150-typescript-generics-primer.md</code> (Interlude A) to build foundational understanding of TypeScript generics before tackling the framework models in Phase 2.</p></div></div>
    <div class="chapter" id="section-150">
        <div class="chapter-header">
            <div class="chapter-category">Primers</div>
            <h1>150: TypeScript Generics Primer</h1>
        </div>
<div class="page-content"><h1>150: TypeScript Generics Primer</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 104-environment-config <strong>Blocks:</strong> 201-domain-config-interface</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand why generics exist and what problem they solve</li>
<p><li>Be able to read and interpret generic type signatures</li> <li>Know the difference between concrete types and type parameters</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build foundational understanding of TypeScript generics before tackling the framework models in Phase 2. This is a teaching interlude, not a code implementation section — you won't modify the vvroom project here.</p>

<hr>

<h2>Why This Interlude Exists</h2>

<p>Phase 2 introduces interfaces like this:</p>

<pre class="code-block typescript"><code>export interface DomainConfig&lt;TFilters, TData, TStatistics&gt; {
<p>urlMapper: IFilterUrlMapper&lt;TFilters&gt;; apiAdapter: IApiAdapter&lt;TFilters, TData, TStatistics&gt;; tableConfig: TableConfig&lt;TData&gt;; // ... }</p>
</code></pre>

<p>If you've never worked with generics, this looks intimidating. What are <code class="inline">TFilters</code>, <code class="inline">TData</code>, and <code class="inline">TStatistics</code>? Why are there angle brackets everywhere?</p>

<p>This primer answers those questions. By the end, you'll read generic signatures as fluently as regular TypeScript.</p>

<hr>

<h2>What Are Generics?</h2>

<h3>The Problem: Type Safety vs Code Reuse</h3>

<p>Consider a function that returns the first element of an array:</p>

<pre class="code-block typescript"><code>// Without generics - loses type information
<p>function getFirst(arr: any[]): any { return arr[0]; }</p>

<p>const numbers = [1, 2, 3]; const first = getFirst(numbers);  // first is 'any', not 'number'</p>
</code></pre>

<p>The <code class="inline">any</code> type works, but we've lost type safety. TypeScript can't help us if we try to call <code class="inline">first.toUpperCase()</code> on a number.</p>

<p>We could write separate functions for each type:</p>

<pre class="code-block typescript"><code>// Type-safe but repetitive
<p>function getFirstNumber(arr: number[]): number { return arr[0]; }</p>

<p>function getFirstString(arr: string[]): string { return arr[0]; }</p>

<p>function getFirstVehicle(arr: Vehicle[]): Vehicle { return arr[0]; }</p>
</code></pre>

<p>This is type-safe, but we've duplicated the same logic three times. What if we need 50 types?</p></div><div class="page-content"><h3>The Solution: Generics</h3>

<p>Generics let us write one function that works with any type while preserving type information:</p>

<pre class="code-block typescript"><code>// With generics - type-safe AND reusable
<p>function getFirst&lt;T&gt;(arr: T[]): T { return arr[0]; }</p>

<p>const numbers = [1, 2, 3]; const first = getFirst(numbers);  // first is 'number'</p>

<p>const names = ['Alice', 'Bob']; const name = getFirst(names);     // name is 'string'</p>

<p>const vehicles: Vehicle[] = [/<em> ... </em>/]; const vehicle = getFirst(vehicles); // vehicle is 'Vehicle'</p>
</code></pre>

<p>The <code class="inline">&lt;T&gt;</code> is a <strong>type parameter</strong>. When you call <code class="inline">getFirst(numbers)</code>, TypeScript infers that <code class="inline">T</code> is <code class="inline">number</code>. The function returns <code class="inline">T</code>, so the return type is also <code class="inline">number</code>.</p>

<p><strong>This is the Aha Moment: Generics give us type safety without code duplication.</strong></p>

<hr>

<h2>Reading Generic Signatures</h2>

<h3>The Anatomy of a Generic Type</h3>

<pre class="code-block typescript"><code>interface Container&lt;T&gt; {
<p>value: T; getValue(): T; }</p>
</code></pre>

<table>
<p><thead><tr> <th>Part</th> <th>Meaning</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Container</code></td> <td>The interface name</td></p>
</tr>
<p><tr> <td><code class="inline">&lt;T&gt;</code></td> <td>Type parameter declaration</td></p>
</tr>
<p><tr> <td><code class="inline">value: T</code></td> <td>Property of type T</td></p>
</tr>
<p><tr> <td><code class="inline">getValue(): T</code></td> <td>Method returning type T</td></p>
</tr>
</tbody>
</table>

<p>The <code class="inline">T</code> is a placeholder. When you use <code class="inline">Container&lt;string&gt;</code>, every <code class="inline">T</code> becomes <code class="inline">string</code>:</p>

<pre class="code-block typescript"><code>const box: Container&lt;string&gt; = {
<p>value: 'hello', getValue() { return this.value; } };</p>

<p>box.value;       // type is 'string' box.getValue();  // returns 'string'</p>
</code></pre>

<h3>Multiple Type Parameters</h3>

<p>Generics can have multiple parameters:</p>

<pre class="code-block typescript"><code>interface Pair&lt;K, V&gt; {
<p>key: K; value: V; }</p>

<p>const entry: Pair&lt;string, number&gt; = { key: 'age', value: 30 };</p>
</code></pre>

<p>Here <code class="inline">K</code> becomes <code class="inline">string</code> and <code class="inline">V</code> becomes <code class="inline">number</code>.</p>

<h3>Conventional Type Parameter Names</h3>

<table>
<p><thead><tr> <th>Name</th> <th>Convention</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">T</code></td> <td>General "Type"</td></p>
</tr>
<p><tr> <td><code class="inline">K</code></td> <td>Key type (in maps/objects)</td></p>
</tr>
<p><tr> <td><code class="inline">V</code></td> <td>Value type (in maps/objects)</td></p>
</tr>
<p><tr> <td><code class="inline">E</code></td> <td>Element type (in collections)</td></p>
</tr>
<p><tr> <td><code class="inline">R</code></td> <td>Return type</td></p>
</tr>
</tbody>
</table>

<p>These are conventions, not requirements. In vvroom, we use descriptive names:</p>

<table>
<p><thead><tr> <th>Name</th> <th>Meaning in vvroom</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">TFilters</code></td> <td>Filter model type (e.g., <code class="inline">AutomobileFilters</code>)</td></p>
</tr>
<p><tr> <td><code class="inline">TData</code></td> <td>Data model type (e.g., <code class="inline">VehicleResult</code>)</td></p>
</tr>
<p><tr> <td><code class="inline">TStats</code></td> <td>Statistics model type (e.g., <code class="inline">VehicleStatistics</code>)</td></p>
</tr>
</tbody>
</table>

<p>The <code class="inline">T</code> prefix indicates "this is a Type parameter, not a concrete type."</p></div><div class="page-content"><hr>

<h2>Concrete Types vs Type Parameters</h2>

<h3>Concrete Types</h3>

<p>A <strong>concrete type</strong> is a specific, known type:</p>

<pre class="code-block typescript"><code>// Concrete types - we know exactly what these are
<p>let name: string; let count: number; let vehicle: Vehicle; let filters: AutomobileFilters;</p>
</code></pre>

<h3>Type Parameters</h3>

<p>A <strong>type parameter</strong> is a placeholder filled in later:</p>

<pre class="code-block typescript"><code>// Type parameters - placeholders
<p>interface Container&lt;T&gt; {     // T is a parameter value: T; }</p>

<p>// Now we fill in the parameter with a concrete type const box: Container&lt;string&gt; = { value: 'hello' };</p>
</code></pre>

<p>Think of type parameters like function parameters:</p>

<pre class="code-block typescript"><code>// Function parameter: x is filled in when called
<p>function double(x: number): number { return x * 2; } double(5);  // x = 5</p>

<p>// Type parameter: T is filled in when used interface Container&lt;T&gt; { value: T; } const box: Container&lt;string&gt; = { value: 'hello' };  // T = string</p>
</code></pre>

<hr>

<h2>Built-in Generic Types</h2>

<p>You've already used generics — TypeScript's built-in types use them extensively.</p>

<h3>Array&lt;T&gt;</h3>

<pre class="code-block typescript"><code>// These are equivalent
<p>const numbers: number[] = [1, 2, 3]; const numbers: Array&lt;number&gt; = [1, 2, 3];</p>
</code></pre>

<p><code class="inline">Array&lt;number&gt;</code> means "an array where every element is a number."</p>

<h3>Promise&lt;T&gt;</h3>

<pre class="code-block typescript"><code>// A promise that resolves to a string
<p>const greeting: Promise&lt;string&gt; = Promise.resolve('hello');</p>

<p>// A promise that resolves to a Vehicle const vehiclePromise: Promise&lt;Vehicle&gt; = fetchVehicle(id);</p>
</code></pre>

<p><code class="inline">Promise&lt;Vehicle&gt;</code> means "a promise that, when resolved, gives you a Vehicle."</p>

<h3>Map&lt;K, V&gt;</h3>

<pre class="code-block typescript"><code>// A map from string keys to number values
<p>const ages: Map&lt;string, number&gt; = new Map(); ages.set('Alice', 30); ages.set('Bob', 25);</p>

<p>ages.get('Alice');  // returns number | undefined</p>
</code></pre>

<h3>Partial&lt;T&gt;</h3>

<pre class="code-block typescript"><code>interface Vehicle {
<p>make: string; model: string; year: number; }</p>

<p>// All properties become optional const partial: Partial&lt;Vehicle&gt; = { make: 'Toyota' // model and year are optional };</p>
</code></pre>

<p><code class="inline">Partial&lt;Vehicle&gt;</code> creates a new type where all properties of <code class="inline">Vehicle</code> are optional. This is useful for update operations where you only change some fields.</p></div><div class="page-content"><hr>

<h2>Generic Constraints</h2>

<p>Sometimes you need to limit what types can be used as a parameter.</p>

<h3>The Problem</h3>

<pre class="code-block typescript"><code>function getLength&lt;T&gt;(item: T): number {
<p>return item.length;  // Error: Property 'length' does not exist on type 'T' }</p>
</code></pre>

<p>TypeScript doesn't know that <code class="inline">T</code> has a <code class="inline">length</code> property. What if someone passes a number?</p>

<h3>The Solution: extends</h3>

<pre class="code-block typescript"><code>interface HasLength {
<p>length: number; }</p>

<p>function getLength&lt;T extends HasLength&gt;(item: T): number { return item.length;  // Now TypeScript knows T has 'length' }</p>

<p>getLength('hello');     // OK - strings have length getLength([1, 2, 3]);   // OK - arrays have length getLength(42);          // Error - numbers don't have length</p>
</code></pre>

<p>The <code class="inline">extends</code> keyword constrains <code class="inline">T</code> to types that have a <code class="inline">length</code> property.</p>

<h3>Constraints in vvroom</h3>

<p>In Phase 2, you'll see constraints like:</p>

<pre class="code-block typescript"><code>interface IApiAdapter&lt;TFilters, TData, TStatistics = any&gt; {
<p>fetchData(filters: TFilters): Observable&lt;ApiResponse&lt;TData&gt;&gt;; // ... }</p>
</code></pre>

<p>The <code class="inline">= any</code> provides a default type. If you don't specify <code class="inline">TStatistics</code>, it defaults to <code class="inline">any</code>.</p>

<hr>

<h2>Applying Generics: A Preview of Phase 2</h2>

<p>Here's how vvroom uses generics. Don't memorize this — just recognize the patterns.</p>

<h3>The DomainConfig Interface</h3>

<pre class="code-block typescript"><code>export interface DomainConfig&lt;TFilters, TData, TStatistics&gt; {
<p>// Identity domainKey: string; displayName: string;</p>

<p>// Type references (so the framework knows what types to expect) filterModel: Type&lt;TFilters&gt;; dataModel: Type&lt;TData&gt;;</p>

<p>// Adapters (these use the same type parameters) apiAdapter: IApiAdapter&lt;TFilters, TData, TStatistics&gt;; urlMapper: IFilterUrlMapper&lt;TFilters&gt;;</p>

<p>// UI configuration tableConfig: TableConfig&lt;TData&gt;; }</p>
</code></pre>

<p><strong>Reading this signature:</strong></p>

<ul><li><code class="inline">DomainConfig</code> takes three type parameters</li>
<p><li><code class="inline">TFilters</code> flows through to <code class="inline">urlMapper</code> and <code class="inline">apiAdapter</code></li> <li><code class="inline">TData</code> flows through to <code class="inline">apiAdapter</code> and <code class="inline">tableConfig</code></li> <li><code class="inline">TStatistics</code> flows through to <code class="inline">apiAdapter</code></li></p>
</ul>
<h3>Using the Interface</h3>

<p>When we create the automobile domain config:</p>

<pre class="code-block typescript"><code>const AUTOMOBILE_CONFIG: DomainConfig&lt;
<p>AutomobileFilters,    // TFilters = AutomobileFilters VehicleResult,        // TData = VehicleResult VehicleStatistics     // TStatistics = VehicleStatistics &gt; = { domainKey: 'automobile', displayName: 'Automobiles', filterModel: AutomobileFilters, dataModel: VehicleResult, apiAdapter: new AutomobileApiAdapter(), urlMapper: new AutomobileUrlMapper(), tableConfig: automobileTableConfig, };</p>
</code></pre>

<p>Now TypeScript knows:</p>
<ul><li><code class="inline">urlMapper</code> must accept <code class="inline">AutomobileFilters</code></li>
<p><li><code class="inline">tableConfig</code> must work with <code class="inline">VehicleResult</code></li> <li><code class="inline">apiAdapter</code> must return <code class="inline">VehicleStatistics</code></li></p>
</ul>
<p>If any of these are wrong, TypeScript catches the error at compile time.</p></div><div class="page-content"><hr>

<h2>Practice Exercises</h2>

<p>Try these in your editor or the TypeScript Playground (https://www.typescriptlang.org/play).</p>

<h3>Exercise 1: Read the Signature</h3>

<p>What type is <code class="inline">result</code> in each case?</p>

<pre class="code-block typescript"><code>function identity&lt;T&gt;(value: T): T {
<p>return value; }</p>

<p>const result1 = identity('hello'); const result2 = identity(42); const result3 = identity({ name: 'Alice' });</p>
</code></pre>

<p>&lt;details&gt; &lt;summary&gt;Answer&lt;/summary&gt;</p>

<ul><li><code class="inline">result1</code> is <code class="inline">string</code></li>
<p><li><code class="inline">result2</code> is <code class="inline">number</code></li> <li><code class="inline">result3</code> is <code class="inline">{ name: string }</code></li></p>
</ul>
<p>TypeScript infers <code class="inline">T</code> from the argument type. &lt;/details&gt;</p>

<h3>Exercise 2: Write a Generic Function</h3>

<p>Write a function <code class="inline">wrapInArray</code> that takes any value and returns it wrapped in an array.</p>

<pre class="code-block typescript"><code>// Your code here

<p>wrapInArray('hello');  // should be ['hello'] with type string[] wrapInArray(42);       // should be [42] with type number[]</p>
</code></pre>

<p>&lt;details&gt; &lt;summary&gt;Answer&lt;/summary&gt;</p>

<pre class="code-block typescript"><code>function wrapInArray&lt;T&gt;(value: T): T[] {
<p>return [value]; }</p>
</code></pre>
<p>&lt;/details&gt;</p>

<h3>Exercise 3: Multiple Type Parameters</h3>

<p>What are the types of <code class="inline">key</code> and <code class="inline">value</code>?</p>

<pre class="code-block typescript"><code>interface Entry&lt;K, V&gt; {
<p>key: K; value: V; }</p>

<p>const entry: Entry&lt;string, number&gt; = { key: 'count', value: 42 };</p>

<p>const { key, value } = entry;</p>
</code></pre>

<p>&lt;details&gt; &lt;summary&gt;Answer&lt;/summary&gt;</p>

<ul><li><code class="inline">key</code> is <code class="inline">string</code> (K = string)</li>
<p><li><code class="inline">value</code> is <code class="inline">number</code> (V = number)</li></p>
</ul>&lt;/details&gt;

<hr>

<h2>Common Mistakes</h2>

<h3>Mistake 1: Forgetting Type Parameters</h3>

<pre class="code-block typescript"><code>// Wrong - DomainConfig needs type parameters
<p>const config: DomainConfig = { /<em> ... </em>/ };</p>

<p>// Right const config: DomainConfig&lt;AutomobileFilters, VehicleResult, VehicleStatistics&gt; = { /<em> ... </em>/ };</p>
</code></pre>

<h3>Mistake 2: Mismatched Types</h3>

<pre class="code-block typescript"><code>interface Container&lt;T&gt; {
<p>value: T; }</p>

<p>// Wrong - value type doesn't match const box: Container&lt;string&gt; = { value: 42  // Error: number is not assignable to string };</p>
</code></pre>

<h3>Mistake 3: Confusing Type Parameters with Values</h3>

<pre class="code-block typescript"><code>// Wrong - TFilters is a type, not a value
<p>function processFilters&lt;TFilters&gt;(filters: TFilters) { console.log(TFilters);  // Error: 'TFilters' only refers to a type }</p>

<p>// Right - use the parameter, not the type function processFilters&lt;TFilters&gt;(filters: TFilters) { console.log(filters);  // OK }</p>
</code></pre></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Generics provide type safety without code duplication</strong> — Write once, use with any type</li>
<p><li><strong>Type parameters are placeholders</strong> — They're filled in when you use the generic type</li> <li><strong>T-prefixed names indicate type parameters</strong> — <code class="inline">TFilters</code>, <code class="inline">TData</code>, <code class="inline">TStats</code> are conventions, not requirements</li></p>
</ul>
<hr>

<h2>The Aha Moment</h2>

<p><strong>Generics give us type safety without code duplication.</strong></p>

<p>In Phase 2, you'll create interfaces with generic parameters. These interfaces define contracts that work with <em>any</em> domain:</p>

<ul><li><code class="inline">DomainConfig&lt;TFilters, TData, TStats&gt;</code> works for automobiles, real estate, or any future domain</li>
<p><li>The framework code uses these interfaces without knowing the specific types</li> <li>Domain-specific code provides concrete types (<code class="inline">AutomobileFilters</code>, <code class="inline">VehicleResult</code>)</li> <li>TypeScript ensures everything matches up at compile time</li></p>
</ul>
<p>Without generics, we'd either:</p>
<ul><li>Lose type safety (use <code class="inline">any</code> everywhere)</li>
<p><li>Duplicate code for each domain</li></p>
</ul>
<p>Generics give us both type safety and reusability. That's why they're foundational to vvroom's architecture.</p>

<hr>

<h2>Acceptance Criteria</h2>

<p>This is a teaching section with no code changes. Criteria are conceptual:</p>

<ul><li>[ ] You can explain what problem generics solve</li>
<p><li>[ ] You can read <code class="inline">Interface&lt;T, U&gt;</code> and understand T and U are type parameters</li> <li>[ ] You can identify the difference between <code class="inline">string</code> (concrete type) and <code class="inline">T</code> (type parameter)</li> <li>[ ] You can explain what <code class="inline">DomainConfig&lt;TFilters, TData, TStats&gt;</code> means conceptually</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">201-domain-config-interface.md</code> to create the central configuration interface using the generic patterns you just learned.</p></div></div>
    <div class="chapter" id="section-201">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>201: Domain Config Interface</h1>
        </div>
<div class="page-content"><h1>201: Domain Config Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 150-typescript-generics-primer <strong>Blocks:</strong> 202-resource-management-interface, 304-domain-config-registry</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how a single interface can define the contract for an entire domain's behavior</li>
<p><li>Know how TypeScript generics enable type-safe domain configurations</li> <li>Recognize the relationship between configuration interfaces and framework services</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">DomainConfig</code> interface that serves as the central configuration schema for any domain in the vvroom application. This interface defines all adapters, UI configurations, and feature flags required for the framework to operate with domain-specific data.</p>

<hr>

<h2>Why</h2>

<p>The <code class="inline">DomainConfig</code> interface is the cornerstone of vvroom's architecture. It answers a critical question: <em>How do we make the framework work with any domain (automobiles, real estate, inventory) without changing framework code?</em></p>

<p>The answer is <strong>configuration-driven design</strong>. Instead of hard-coding domain-specific behavior into services and components, we define a configuration interface that each domain must implement. The framework reads this configuration and adapts its behavior accordingly.</p>

<p><strong>This is the Phase 2 Aha Moment in action:</strong> TypeScript interfaces are executable documentation. The <code class="inline">DomainConfig</code> interface documents <em>exactly</em> what any domain must provide to work with the framework. TypeScript enforces this contract at compile time.</p>

<h3>Benefits of Configuration-Driven Design</h3>

<table>
<p><thead><tr> <th>Approach</th> <th>Adding a New Domain Requires</th></p>
</tr></thead>
<p><tbody> <tr> <td>Hard-coded</td> <td>Modifying framework services, components, routes</td></p>
</tr>
<p><tr> <td>Configuration-driven</td> <td>Creating one configuration file that implements DomainConfig</td></p>
</tr>
</tbody>
</table>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-01">Style 03-01</a>: Use interfaces for type definitions</li>
<p><li><a href="https://angular.io/guide/styleguide#style-07-04">Style 07-04</a>: Create service interfaces for complex services</li></ul></p></div><div class="page-content"><h3>TypeScript Best Practices</h3>

<p>This interface uses several TypeScript features you learned in the generics primer:</p>

<ul><li><strong>Generic type parameters</strong> (<code class="inline">TFilters</code>, <code class="inline">TData</code>, <code class="inline">TStatistics</code>) — Allow type-safe domain configuration</li>
<p><li><strong><code class="inline">Type&lt;T&gt;</code></strong> — Angular's type for class constructors, enabling runtime instantiation</li> <li><strong>Optional properties</strong> — Features like <code class="inline">highlightFilters</code> and <code class="inline">metadata</code> are not required for every domain</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 201.1: Create the Framework Models Directory Index</h3>

<p>Before creating individual interface files, create a barrel export file that will aggregate all model exports.</p>

<p>Create the file <code class="inline">src/app/framework/models/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts
<p>// VERSION 1 (Section 201) - Barrel file for framework models</p>

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface';</p>
</code></pre>

<p>Delete the <code class="inline">.gitkeep</code> file since the directory now has real content:</p>

<pre class="code-block bash"><code>$ rm src/app/framework/models/.gitkeep
</code></pre>

<p><strong>Why a barrel file?</strong></p>

<p>Barrel files simplify imports throughout the application:</p>

<pre class="code-block typescript"><code>// Without barrel file (verbose):
<p>import { DomainConfig } from './framework/models/domain-config.interface'; import { TableConfig } from './framework/models/table-config.interface';</p>

<p>// With barrel file (clean): import { DomainConfig, TableConfig } from './framework/models';</p>
</code></pre>

<p>We'll add more exports as we create additional interface files.</p>

<hr>

<h3>Step 201.2: Create the Domain Config Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/domain-config.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/domain-config.interface.ts
<p>// VERSION 1 (Section 201) - Core domain configuration interface</p>

<p>import { Type } from '@angular/core';</p>

<p>/**</p>
 <ul><li>Domain configuration interface</li>
</ul> *
 <ul><li>Complete configuration schema for a domain-specific implementation.</li>
</ul> <ul><li>Defines all adapters, UI configurations, and feature flags required</li>
</ul> <ul><li>for the framework to operate with domain-specific data.</li>
</ul> *
 <ul><li>@template TFilters - Domain-specific filter model type</li>
</ul> <ul><li>@template TData - Domain-specific data model type</li>
</ul> <ul><li>@template TStatistics - Domain-specific statistics model type (optional)</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const AUTOMOBILE_DOMAIN_CONFIG: DomainConfig&lt;</li>
</ul> <ul><li>  AutomobileFilters,</li>
</ul> <ul><li>  VehicleResult,</li>
</ul> <ul><li>  VehicleStatistics</li>
</ul> <ul><li>&gt; = {</li>
</ul> <ul><li>  domainName: 'automobile',</li>
</ul> <ul><li>  domainLabel: 'Automobile Discovery',</li>
</ul> <ul><li>  apiBaseUrl: 'http://auto-discovery.minilab/api/v1',</li>
</ul> <ul><li>  filterModel: AutomobileFilters,</li>
</ul> <ul><li>  dataModel: VehicleResult,</li>
</ul> <ul><li>  statisticsModel: VehicleStatistics,</li>
</ul> <ul><li>  apiAdapter: new AutomobileApiAdapter(),</li>
</ul> <ul><li>  urlMapper: new AutomobileUrlMapper(),</li>
</ul> <ul><li>  cacheKeyBuilder: new AutomobileCacheKeyBuilder(),</li>
</ul> <ul><li>  tableConfig: AUTOMOBILE_TABLE_CONFIG,</li>
</ul> <ul><li>  pickers: AUTOMOBILE_PICKER_CONFIGS,</li>
</ul> <ul><li>  filters: AUTOMOBILE_FILTER_DEFINITIONS,</li>
</ul> <ul><li>  queryControlFilters: AUTOMOBILE_QUERY_CONTROL_FILTERS,</li>
</ul> <ul><li>  charts: AUTOMOBILE_CHART_CONFIGS,</li>
</ul> <ul><li>  features: {</li>
</ul> <ul><li>    highlights: true,</li>
</ul> <ul><li>    popOuts: true,</li>
</ul> <ul><li>    rowExpansion: true</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface DomainConfig&lt;TFilters, TData, TStatistics = any&gt; { /**</p>
   <ul><li>Unique domain identifier (lowercase, no spaces)</li>
</ul>   <ul><li>Used for routing, storage keys, and internal identification</li>
</ul>   *
   <ul><li>@example 'automobile', 'real-estate', 'inventory'</li>
</ul>   */
<p>domainName: string;</p>

<p>/**</p>
   <ul><li>Human-readable domain label</li>
</ul>   <ul><li>Used for display in UI (page titles, navigation, etc.)</li>
</ul>   *
   <ul><li>@example 'Automobile Discovery', 'Real Estate Listings'</li>
</ul>   */
<p>domainLabel: string;</p>

<p>/**</p>
   <ul><li>Base URL for domain-specific API</li>
</ul>   <ul><li>All API requests will be prefixed with this URL</li>
</ul>   *
   <ul><li>@example 'http://auto-discovery.minilab/api/v1'</li>
</ul>   */
<p>apiBaseUrl: string;</p>

<p>/**</p>
   <ul><li>Filter model class/constructor</li>
</ul>   <ul><li>Used for type checking and instantiation</li>
</ul>   */
<p>filterModel: Type&lt;TFilters&gt;;</p>

<p>/**</p>
   <ul><li>Data model class/constructor</li>
</ul>   <ul><li>Used for type checking and instantiation</li>
</ul>   */
<p>dataModel: Type&lt;TData&gt;;</p>

<p>/**</p>
   <ul><li>Statistics model class/constructor (optional)</li>
</ul>   <ul><li>Used for type checking and instantiation</li>
</ul>   */
<p>statisticsModel?: Type&lt;TStatistics&gt;;</p>

<p>/**</p>
   <ul><li>API adapter for data fetching</li>
</ul>   <ul><li>Implements domain-specific API calls and response transformation</li>
</ul>   */
<p>apiAdapter: IApiAdapter&lt;TFilters, TData, TStatistics&gt;;</p>

<p>/**</p>
   <ul><li>URL mapper for filter serialization</li>
</ul>   <ul><li>Converts between filter objects and URL parameters</li>
</ul>   */
<p>urlMapper: IFilterUrlMapper&lt;TFilters&gt;;</p>

<p>/**</p>
   <ul><li>Cache key builder for request coordination</li>
</ul>   <ul><li>Generates unique cache keys from filter objects</li>
</ul>   */
<p>cacheKeyBuilder: ICacheKeyBuilder&lt;TFilters&gt;;</p>

<p>/**</p>
   <ul><li>Table configuration for main data display</li>
</ul>   <ul><li>Defines columns, pagination, sorting, etc.</li>
</ul>   */
<p>tableConfig: TableConfig&lt;TData&gt;;</p>

<p>/**</p>
   <ul><li>Picker configurations</li>
</ul>   <ul><li>Array of picker configs for multi-select data pickers</li>
</ul>   */
<p>pickers: PickerConfig&lt;any&gt;[];</p>

<p>/**</p>
   <ul><li>Inline filter definitions for results table</li>
</ul>   <ul><li>Defines inline filter controls displayed above the results table</li>
</ul>   */
<p>filters: FilterDefinition[];</p>

<p>/**</p>
   <ul><li>Query Control filter definitions</li>
</ul>   <ul><li>Defines filters available in the Query Control component dialogs</li>
</ul>   */
<p>queryControlFilters: QueryFilterDefinition&lt;TFilters&gt;[];</p>

<p>/**</p>
   <ul><li>Highlight filter definitions (optional)</li>
</ul>   <ul><li>Defines highlight filters available in the Query Control component</li>
</ul>   <em> These filters add h_</em> URL parameters for segmented statistics in charts
<p>*/ highlightFilters?: QueryFilterDefinition&lt;any&gt;[];</p>

<p>/**</p>
   <ul><li>Chart configurations</li>
</ul>   <ul><li>Defines available charts and their data sources</li>
</ul>   */
<p>charts: ChartConfig[];</p>

<p>/**</p>
   <ul><li>Chart data sources map</li>
</ul>   <ul><li>Maps dataSourceId to ChartDataSource instances</li>
</ul>   <ul><li>Used by StatisticsPanelComponent to instantiate charts</li>
</ul>   */
<p>chartDataSources?: Record&lt;string, any&gt;;</p>

<p>/**</p>
   <ul><li>Feature flags</li>
</ul>   <ul><li>Controls which framework features are enabled for this domain</li>
</ul>   */
<p>features: DomainFeatures;</p>

<p>/**</p>
   <ul><li>Optional metadata</li>
</ul>   <ul><li>Additional domain-specific information</li>
</ul>   */
<p>metadata?: DomainMetadata;</p>

<p>/**</p>
   <ul><li>Default filters for the domain (optional)</li>
</ul>   <ul><li>These filters are applied when the application first loads or when filters are cleared.</li>
</ul>   */
<p>defaultFilters?: Partial&lt;TFilters&gt;; }</p>

<p>/**</p>
 <ul><li>Domain feature flags</li>
</ul> *
 <ul><li>Controls which framework features are enabled/disabled for a specific domain</li>
</ul> */
<p>export interface DomainFeatures { /**</p>
   <ul><li>Enable/disable highlight system</li>
</ul>   <ul><li>Allows users to highlight specific data subsets</li>
</ul>   */
<p>highlights: boolean;</p>

<p>/**</p>
   <ul><li>Enable/disable pop-out window system</li>
</ul>   <ul><li>Allows panels to be moved to separate browser windows</li>
</ul>   */
<p>popOuts: boolean;</p>

<p>/**</p>
   <ul><li>Enable/disable row expansion in tables</li>
</ul>   <ul><li>Allows rows to be expanded to show additional details</li>
</ul>   */
<p>rowExpansion: boolean;</p>

<p>/**</p>
   <ul><li>Enable/disable statistics panel</li>
</ul>   <ul><li>Shows aggregated statistics and charts</li>
</ul>   */
<p>statistics?: boolean;</p>

<p>/**</p>
   <ul><li>Enable/disable export functionality</li>
</ul>   <ul><li>Allows users to export data to CSV, Excel, etc.</li>
</ul>   */
<p>export?: boolean;</p>

<p>/**</p>
   <ul><li>Enable/disable column management</li>
</ul>   <ul><li>Allows users to show/hide and reorder columns</li>
</ul>   */
<p>columnManagement?: boolean;</p>

<p>/**</p>
   <ul><li>Enable/disable state persistence</li>
</ul>   <ul><li>Saves user preferences to local storage</li>
</ul>   */
<p>statePersistence?: boolean; }</p>

<p>/**</p>
 <ul><li>Domain metadata</li>
</ul> *
 <ul><li>Additional information about the domain</li>
</ul> */
<p>export interface DomainMetadata { /**</p>
   <ul><li>Domain version (semantic versioning)</li>
</ul>   */
<p>version?: string;</p>

<p>/**</p>
   <ul><li>Domain description</li>
</ul>   */
<p>description?: string;</p>

<p>/**</p>
   <ul><li>Domain author/maintainer</li>
</ul>   */
<p>author?: string;</p>

<p>/**</p>
   <ul><li>Creation date</li>
</ul>   */
<p>createdAt?: string;</p>

<p>/**</p>
   <ul><li>Last update date</li>
</ul>   */
<p>updatedAt?: string;</p>

<p>/**</p>
   <ul><li>Custom metadata fields</li>
</ul>   */
<p>[key: string]: any; }</p>

<p>/**</p>
 <ul><li>Filter format configuration</li>
</ul> *
 <ul><li>Controls how filter values are displayed and processed.</li>
</ul> */
<p>export interface FilterFormat { /**</p>
   <ul><li>Number formatting options</li>
</ul>   */
<p>number?: FilterNumberFormat;</p>

<p>/**</p>
   <ul><li>Date formatting options</li>
</ul>   */
<p>date?: FilterDateFormat;</p>

<p>/**</p>
   <ul><li>Whether string matching is case-sensitive</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>caseSensitive?: boolean;</p>

<p>/**</p>
   <ul><li>Text transformation to apply before sending to API</li>
</ul>   */
<p>transform?: 'lowercase' | 'uppercase' | 'titlecase' | 'trim' | 'none';</p>

<p>/**</p>
   <ul><li>Custom formatting function for display</li>
</ul>   */
<p>displayFormatter?: (value: any) =&gt; string;</p>

<p>/**</p>
   <ul><li>Custom parsing function for input</li>
</ul>   */
<p>valueParser?: (input: string) =&gt; any; }</p>

<p>/**</p>
 <ul><li>Number formatting options</li>
</ul> *
 <ul><li>Based on Intl.NumberFormat options for consistency with browser standards</li>
</ul> */
<p>export interface FilterNumberFormat { /**</p>
   <ul><li>Use thousand separators (commas)</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>useGrouping?: boolean;</p>

<p>/**</p>
   <ul><li>Minimum decimal places</li>
</ul>   <ul><li>@default 0</li>
</ul>   */
<p>minimumFractionDigits?: number;</p>

<p>/**</p>
   <ul><li>Maximum decimal places</li>
</ul>   <ul><li>@default 0 for integers, 2 for decimals</li>
</ul>   */
<p>maximumFractionDigits?: number;</p>

<p>/**</p>
   <ul><li>Locale for number formatting</li>
</ul>   <ul><li>@default 'en-US'</li>
</ul>   */
<p>locale?: string;</p>

<p>/**</p>
   <ul><li>Custom format pattern</li>
</ul>   */
<p>pattern?: string; }</p>

<p>/**</p>
 <ul><li>Date formatting options</li>
</ul> */
<p>export interface FilterDateFormat { /**</p>
   <ul><li>Date format pattern</li>
</ul>   <ul><li>@default 'YYYY-MM-DD'</li>
</ul>   */
<p>pattern?: string;</p>

<p>/**</p>
   <ul><li>Locale for date formatting</li>
</ul>   <ul><li>@default 'en-US'</li>
</ul>   */
<p>locale?: string;</p>

<p>/**</p>
   <ul><li>Whether to show time component</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>includeTime?: boolean; }</p>

<p>/**</p>
 <ul><li>Filter control types</li>
</ul> */
<p>export type FilterType =</p>
<table>
<p><thead><tr></p>
</tr></thead>
<p><tbody> <tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
</tbody>
</table>

<p>/**</p>
 <ul><li>Filter operators</li>
</ul> */
<p>export type FilterOperator =</p>
<table>
<p><thead><tr></p>
</tr></thead>
<p><tbody> <tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
</tbody>
</table>

<p>/**</p>
 <ul><li>Filter option for select/multiselect</li>
</ul> */
<p>export interface FilterOption { value: any; label: string; icon?: string; disabled?: boolean; }</p>

<p>/**</p>
 <ul><li>Filter validation rules</li>
</ul> */
<p>export interface FilterValidation { minLength?: number; maxLength?: number; pattern?: RegExp | string; custom?: (value: any) =&gt; boolean | string; }</p>

<p>/**</p>
 <ul><li>Chart configuration interface</li>
</ul> */
<p>export interface ChartConfig { id: string; title: string; type: ChartType; dataSourceId: string; options?: any; height?: number; width?: number | string; visible?: boolean; collapsible?: boolean; }</p>

<p>/**</p>
 <ul><li>Chart types</li>
</ul> */
<p>export type ChartType =</p>
<table>
<p><thead><tr></p>
</tr></thead>
<p><tbody> <tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
</tbody>
</table>

<p>/**</p>
 <ul><li>Configuration validation error</li>
</ul> */
<p>export interface ConfigValidationError { type: ConfigErrorType; field: string; message: string; expected?: string; actual?: any; }</p>

<p>/**</p>
 <ul><li>Configuration error types</li>
</ul> */
<p>export enum ConfigErrorType { MISSING_REQUIRED = 'MISSING_REQUIRED', INVALID_TYPE = 'INVALID_TYPE', INVALID_VALUE = 'INVALID_VALUE', EMPTY_ARRAY = 'EMPTY_ARRAY', DUPLICATE_ID = 'DUPLICATE_ID' }</p>

<p>/**</p>
 <ul><li>Configuration validation result</li>
</ul> */
<p>export interface ConfigValidationResult { valid: boolean; errors: ConfigValidationError[]; warnings?: ConfigValidationError[]; }</p>

<p>/**</p>
 <ul><li>Default domain features</li>
</ul> <ul><li>Used when features object is not fully specified</li>
</ul> */
<p>export const DEFAULT_DOMAIN_FEATURES: DomainFeatures = { highlights: true, popOuts: true, rowExpansion: true, statistics: true, export: true, columnManagement: true, statePersistence: true };</p>

<p>/**</p>
 <ul><li>Merge partial domain features with defaults</li>
</ul> */
<p>export function mergeDomainFeatures( features: Partial&lt;DomainFeatures&gt; ): DomainFeatures { return { ...DEFAULT_DOMAIN_FEATURES, ...features }; }</p>

<p>// Forward declarations for interfaces defined in other files // These will be properly imported once those files are created</p>

<p>/**</p>
 <ul><li>API adapter interface (defined in resource-management.interface.ts)</li>
</ul> */
<p>export interface IApiAdapter&lt;TFilters, TData, TStatistics = any&gt; { fetchData(filters: TFilters, highlights?: any): any; }</p>

<p>/**</p>
 <ul><li>Filter URL mapper interface (defined in resource-management.interface.ts)</li>
</ul> */
<p>export interface IFilterUrlMapper&lt;TFilters&gt; { toUrlParams(filters: TFilters): any; fromUrlParams(params: any): TFilters; extractHighlights?(params: any): any; }</p>

<p>/**</p>
 <ul><li>Cache key builder interface (defined in resource-management.interface.ts)</li>
</ul> */
<p>export interface ICacheKeyBuilder&lt;TFilters&gt; { buildKey(filters: TFilters, highlights?: any): string; }</p>

<p>/**</p>
 <ul><li>Table config interface (defined in table-config.interface.ts)</li>
</ul> */
<p>export interface TableConfig&lt;T&gt; { tableId: string; stateKey: string; columns: any[]; dataKey: keyof T; [key: string]: any; }</p>

<p>/**</p>
 <ul><li>Picker config interface (defined in picker-config.interface.ts)</li>
</ul> */
<p>export interface PickerConfig&lt;T&gt; { id: string; displayName: string; columns: any[]; [key: string]: any; }</p>

<p>/**</p>
 <ul><li>Filter definition interface (defined in filter-definition.interface.ts)</li>
</ul> */
<p>export interface FilterDefinition { id: string; label: string; type: FilterType; [key: string]: any; }</p>

<p>/**</p>
 <ul><li>Query filter definition interface (defined in filter-definition.interface.ts)</li>
</ul> */
<p>export interface QueryFilterDefinition&lt;T&gt; { field: keyof T; label: string; type: string; [key: string]: any; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 201.3: Understand the Interface Structure</h3>

<p>The <code class="inline">DomainConfig</code> interface is organized into logical sections:</p>

<table>
<p><thead><tr> <th>Section</th> <th>Properties</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><strong>Identity</strong></td> <td><code class="inline">domainName</code>, <code class="inline">domainLabel</code>, <code class="inline">apiBaseUrl</code></td> <td>Identify the domain and where to fetch data</td></p>
</tr>
<p><tr> <td><strong>Type Models</strong></td> <td><code class="inline">filterModel</code>, <code class="inline">dataModel</code>, <code class="inline">statisticsModel</code></td> <td>Runtime type information for instantiation</td></p>
</tr>
<p><tr> <td><strong>Adapters</strong></td> <td><code class="inline">apiAdapter</code>, <code class="inline">urlMapper</code>, <code class="inline">cacheKeyBuilder</code></td> <td>Domain-specific data transformation logic</td></p>
</tr>
<p><tr> <td><strong>UI Configuration</strong></td> <td><code class="inline">tableConfig</code>, <code class="inline">pickers</code>, <code class="inline">filters</code>, <code class="inline">charts</code></td> <td>Define how data is displayed</td></p>
</tr>
<p><tr> <td><strong>Feature Flags</strong></td> <td><code class="inline">features</code></td> <td>Enable/disable framework capabilities</td></p>
</tr>
<p><tr> <td><strong>Metadata</strong></td> <td><code class="inline">metadata</code>, <code class="inline">defaultFilters</code></td> <td>Optional additional information</td></p>
</tr>
</tbody>
</table>

<p><strong>Why so many forward declarations?</strong></p>

<p>The <code class="inline">DomainConfig</code> interface references types from other files we haven't created yet. The forward declarations at the bottom are temporary placeholders. As we create each interface file (documents 202-209), we'll update the imports to use the real definitions.</p>

<p>This is a common pattern when building a system in dependency order: you need to reference types that will exist later. TypeScript allows this through interface merging and forward declarations.</p>

<hr>

<h2>The Aha Moment</h2>

<p><strong>TypeScript interfaces are executable documentation.</strong></p>

<p>Look at the <code class="inline">DomainConfig</code> interface. It's not just code — it's a specification. This interface documents <em>exactly</em> what any domain must provide to work with the vvroom framework:</p>

<ul><li>An identity (<code class="inline">domainName</code>, <code class="inline">domainLabel</code>)</li>
<p><li>A data source (<code class="inline">apiBaseUrl</code>, <code class="inline">apiAdapter</code>)</li> <li>A way to serialize state to URLs (<code class="inline">urlMapper</code>)</li> <li>UI configurations (<code class="inline">tableConfig</code>, <code class="inline">filters</code>, <code class="inline">charts</code>)</li> <li>Feature toggles (<code class="inline">features</code>)</li></p>
</ul>
<p>When you create a new domain (like agriculture or real estate), the compiler becomes your guide. Try to create a <code class="inline">DomainConfig&lt;AgricultureFilters, CropResult&gt;</code> object, and TypeScript will tell you exactly what's missing.</p>

<p>This is why we invested time in the Generics Primer (Section 150). The generic parameters <code class="inline">TFilters</code>, <code class="inline">TData</code>, and <code class="inline">TStatistics</code> ensure that when you wire up an automobile domain, the <code class="inline">urlMapper</code> accepts <code class="inline">AutomobileFilters</code>, and the <code class="inline">tableConfig</code> works with <code class="inline">VehicleResult</code>. Type mismatches are caught at compile time, not runtime.</p>

<p><strong>The interface is the contract. TypeScript enforces it.</strong></p></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/
</code></pre>

<p>Expected output shows both files:</p>

<pre class="code-block text"><code>total 16
<p>drwxr-xr-x 2 user user 4096 Feb  9 12:00 . drwxr-xr-x 5 user user 4096 Feb  9 12:00 .. -rw-r--r-- 1 user user  123 Feb  9 12:00 index.ts -rw-r--r-- 1 user user 8234 Feb  9 12:00 domain-config.interface.ts</p>
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/domain-config.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "export" src/app/framework/models/domain-config.interface.ts | head -5
</code></pre>

<p>Expected output shows multiple exports:</p>

<pre class="code-block text"><code>export interface DomainConfig&lt;TFilters, TData, TStatistics = any&gt; {
<p>export interface DomainFeatures { export interface DomainMetadata { export interface FilterFormat { export interface FilterNumberFormat {</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module '@angular/core'</code></td> <td>Angular not installed or wrong path</td> <td>Run <code class="inline">npm install</code> in project root</td></p>
</tr>
<p><tr> <td><code class="inline">Type 'X' is not generic</code></td> <td>Forgot generic parameters</td> <td>Add type parameters: <code class="inline">DomainConfig&lt;TFilters, TData&gt;</code></td></p>
</tr>
<p><tr> <td><code class="inline">Property 'X' does not exist on type 'DomainConfig'</code></td> <td>Using wrong property name</td> <td>Check interface definition for exact property names</td></p>
</tr>
<p><tr> <td>Red squiggles on forward declarations</td> <td>Expected — these are temporary</td> <td>Will be resolved in subsequent documents</td></p>
</tr>
<p><tr> <td><code class="inline">Duplicate identifier 'FilterOption'</code></td> <td>Name collision with another file</td> <td>Use unique names or namespaces</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>TypeScript interfaces are executable documentation</strong> — The <code class="inline">DomainConfig</code> interface documents exactly what any domain must provide to work with the framework</li>
<p><li><strong>Generic type parameters enable type safety</strong> — <code class="inline">TFilters</code>, <code class="inline">TData</code>, and <code class="inline">TStatistics</code> ensure type-safe configuration</li> <li><strong>Configuration-driven design enables extensibility</strong> — New domains require only configuration, not framework changes</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/domain-config.interface.ts</code> exists with complete interface definition</li>
<p><li>[ ] <code class="inline">src/app/framework/models/index.ts</code> exports the domain config interface</li> <li>[ ] Interface includes all required properties: <code class="inline">domainName</code>, <code class="inline">domainLabel</code>, <code class="inline">apiBaseUrl</code>, etc.</li> <li>[ ] Interface uses TypeScript generics for type-safe configuration</li> <li>[ ] <code class="inline">DomainFeatures</code> interface defines all feature flags</li> <li>[ ] <code class="inline">DomainMetadata</code> interface provides extensible metadata structure</li> <li>[ ] Helper function <code class="inline">mergeDomainFeatures</code> is implemented</li> <li>[ ] <code class="inline">DEFAULT_DOMAIN_FEATURES</code> constant is defined</li> <li>[ ] TypeScript compilation succeeds with no errors</li> <li>[ ] JSDoc comments document all public interfaces and properties</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">202-resource-management-interface.md</code> to define the adapters that <code class="inline">DomainConfig</code> references.</p></div></div>
    <div class="chapter" id="section-202">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>202: Resource Management Interface</h1>
        </div>
<div class="page-content"><h1>202: Resource Management Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 301-url-state-service, 306-resource-management-service</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the adapter pattern and why it isolates domain-specific logic from framework code</li>
<p><li>Know how to define interfaces that different domains can implement</li> <li>Recognize the relationship between URL state, API requests, and caching</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the resource management interfaces that define how domains interact with URLs, APIs, and caching. These interfaces establish the contract that domain-specific adapters must fulfill for the framework's URL-First architecture to function.</p>

<hr>

<h2>Why</h2>

<p>The URL-First architecture requires three key operations:</p>

<ul><li><strong>URL &lt;-&gt; Filters</strong>: Convert between URL query parameters and domain filter objects</li>
<p><li><strong>Filters -&gt; API</strong>: Fetch data from the API based on current filters</li> <li><strong>Filters -&gt; Cache Key</strong>: Generate cache keys to prevent duplicate requests</li></p>
</ul>
<p>Each domain (automobiles, real estate, inventory) has different filter structures and API endpoints. The resource management interfaces define the contract that each domain's adapters must implement.</p>

<p><strong>This is the Adapter Pattern in action:</strong></p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│                     Framework Services                           │ │  (UrlStateService, ResourceManagementService, RequestCoordinator)│ └─────────────────────────────────────────────────────────────────┘ │ │ Uses interfaces ▼ ┌─────────────────────────────────────────────────────────────────┐ │              Adapter Interfaces (This Document)                  │ │        IFilterUrlMapper, IApiAdapter, ICacheKeyBuilder           │ └─────────────────────────────────────────────────────────────────┘ │ │ Implemented by ▼ ┌─────────────────────────────────────────────────────────────────┐ │                   Domain-Specific Adapters                       │ │   AutomobileUrlMapper, AutomobileApiAdapter, etc.                │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>Framework services depend on <em>interfaces</em>, not concrete implementations. This means:</p>
<ul><li>Framework code never changes when adding new domains</li>
<p><li>Each domain provides its own adapter implementations</li> <li>Type safety is maintained throughout</li></ul></p></div><div class="page-content"><h3>URL-First Architecture Reference</h3>

<p>The resource management interfaces directly support the URL-First pattern (see <code class="inline">docs/README.md</code>):</p>

<ul><li><code class="inline">IFilterUrlMapper</code> enables the URL to be the single source of truth</li>
<p><li><code class="inline">IApiAdapter</code> transforms URL-derived filters into API requests</li> <li><code class="inline">ICacheKeyBuilder</code> prevents duplicate API calls when URL doesn't change</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 202.1: Create the Resource Management Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/resource-management.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/resource-management.interface.ts
<p>// VERSION 1 (Section 202) - Adapter interfaces for URL-First architecture</p>

<p>import { Observable } from 'rxjs'; import { Params } from '@angular/router';</p>

<p>/**</p>
 <ul><li>Adapter for mapping filters to/from URL parameters</li>
</ul> *
 <ul><li>This interface defines how a domain converts between its filter model</li>
</ul> <ul><li>and URL query parameters. Implementing this interface enables the</li>
</ul> <ul><li>URL-First architecture where the URL is the single source of truth.</li>
</ul> *
 <ul><li>@template TFilters - The shape of the filter object</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>class AutomobileUrlMapper implements IFilterUrlMapper&lt;AutomobileFilters&gt; {</li>
</ul> <ul><li>  toUrlParams(filters: AutomobileFilters): Params {</li>
</ul> <ul><li>    const params: Params = {};</li>
</ul> <ul><li>    if (filters.manufacturer?.length) {</li>
</ul> <ul><li>      params['manufacturer'] = filters.manufacturer.join(',');</li>
</ul> <ul><li>    }</li>
</ul> <ul><li>    if (filters.yearMin) {</li>
</ul> <ul><li>      params['yearMin'] = filters.yearMin.toString();</li>
</ul> <ul><li>    }</li>
</ul> <ul><li>    return params;</li>
</ul> <ul><li>  }</li>
</ul> *
 <ul><li>  fromUrlParams(params: Params): AutomobileFilters {</li>
</ul> <ul><li>    return {</li>
</ul> <ul><li>      manufacturer: params['manufacturer']?.split(',') || [],</li>
</ul> <ul><li>      yearMin: params['yearMin'] ? parseInt(params['yearMin'], 10) : null,</li>
</ul> <ul><li>      yearMax: params['yearMax'] ? parseInt(params['yearMax'], 10) : null</li>
</ul> <ul><li>    };</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface IFilterUrlMapper&lt;TFilters&gt; { /**</p>
   <ul><li>Convert filters to URL query parameters</li>
</ul>   *
   <ul><li>Takes a domain filter object and converts it to URL-safe query parameters.</li>
</ul>   <ul><li>Empty or null values should be omitted from the result.</li>
</ul>   *
   <ul><li>@param filters - Filter object</li>
</ul>   <ul><li>@returns URL query parameters</li>
</ul>   */
<p>toUrlParams(filters: TFilters): Params;</p>

<p>/**</p>
   <ul><li>Convert URL query parameters to filters</li>
</ul>   *
   <ul><li>Takes URL query parameters and constructs a domain filter object.</li>
</ul>   <ul><li>Missing parameters should result in null/empty values in the filter object.</li>
</ul>   *
   <ul><li>@param params - URL query parameters</li>
</ul>   <ul><li>@returns Filter object</li>
</ul>   */
<p>fromUrlParams(params: Params): TFilters;</p>

<p>/**</p>
   <ul><li>Extract highlight filters from URL parameters (optional)</li>
</ul>   *
   <ul><li>Domain-specific strategy for identifying "highlight" parameters.</li>
</ul>   <em> Highlight filters use h_</em> prefix and provide segmented statistics.
   <ul><li>If not implemented, the framework assumes no highlights are present.</li>
</ul>   *
   <ul><li>@param params - URL query parameters</li>
</ul>   <ul><li>@returns Highlight filters object (domain-specific structure)</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>extractHighlights(params: Params): AutomobileHighlights {</li>
</ul>   <ul><li>  return {</li>
</ul>   <ul><li>    manufacturer: params['h_manufacturer']?.split(',') || [],</li>
</ul>   <ul><li>    yearMin: params['h_yearMin'] ? parseInt(params['h_yearMin'], 10) : null</li>
</ul>   <ul><li>  };</li>
</ul>   <ul><li>}</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>extractHighlights?(params: Params): any; }</p>

<p>/**</p>
 <ul><li>Response from API adapter</li>
</ul> *
 <ul><li>Standardized response format that all API adapters must return.</li>
</ul> <ul><li>This allows framework services to work with any domain's API.</li>
</ul> *
 <ul><li>@template TData - The type of individual data items</li>
</ul> <ul><li>@template TStatistics - The type of statistics object (optional)</li>
</ul> */
<p>export interface ApiAdapterResponse&lt;TData, TStatistics = any&gt; { /**</p>
   <ul><li>Array of data results</li>
</ul>   */
<p>results: TData[];</p>

<p>/**</p>
   <ul><li>Total count of results (unpaginated)</li>
</ul>   <ul><li>Used for pagination display ("Showing 1-20 of 1,234 results")</li>
</ul>   */
<p>total: number;</p>

<p>/**</p>
   <ul><li>Optional statistics/aggregations</li>
</ul>   <ul><li>Domain-specific summary data (e.g., manufacturer counts, year distribution)</li>
</ul>   */
<p>statistics?: TStatistics; }</p>

<p>/**</p>
 <ul><li>Adapter for fetching data from API</li>
</ul> *
 <ul><li>This interface defines how a domain fetches data from its API.</li>
</ul> <ul><li>The adapter is responsible for:</li>
</ul> <ul><li>- Constructing API requests from filters</li>
</ul> <ul><li>- Transforming API responses to the standardized format</li>
</ul> <ul><li>- Handling domain-specific API quirks</li>
</ul> *
 <ul><li>@template TFilters - The shape of the filter object</li>
</ul> <ul><li>@template TData - The shape of individual data items</li>
</ul> <ul><li>@template TStatistics - The shape of statistics object (optional)</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>class AutomobileApiAdapter implements IApiAdapter&lt;AutomobileFilters, Vehicle, VehicleStats&gt; {</li>
</ul> <ul><li>  constructor(private http: HttpClient, private baseUrl: string) {}</li>
</ul> *
 <ul><li>  fetchData(</li>
</ul> <ul><li>    filters: AutomobileFilters,</li>
</ul> <ul><li>    highlights?: AutomobileHighlights</li>
</ul> <ul><li>  ): Observable&lt;ApiAdapterResponse&lt;Vehicle, VehicleStats&gt;&gt; {</li>
</ul> <ul><li>    const params = this.buildParams(filters, highlights);</li>
</ul> <ul><li>    return this.http.get&lt;ApiResponse&gt;(<code class="inline">${this.baseUrl}/vehicles</code>, { params }).pipe(</li>
</ul> <ul><li>      map(response =&gt; ({</li>
</ul> <ul><li>        results: response.data,</li>
</ul> <ul><li>        total: response.meta.total,</li>
</ul> <ul><li>        statistics: response.stats</li>
</ul> <ul><li>      }))</li>
</ul> <ul><li>    );</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface IApiAdapter&lt;TFilters, TData, TStatistics = any&gt; { /**</p>
   <ul><li>Fetch data from API based on filters</li>
</ul>   *
   <ul><li>@param filters - Filter object derived from URL parameters</li>
</ul>   <em> @param highlights - Optional highlight filters (h_</em> parameters for segmented statistics)
   <ul><li>@returns Observable of API response with results, total count, and optional statistics</li>
</ul>   */
<p>fetchData( filters: TFilters, highlights?: any ): Observable&lt;ApiAdapterResponse&lt;TData, TStatistics&gt;&gt;; }</p>

<p>/**</p>
 <ul><li>Adapter for building cache keys from filters</li>
</ul> *
 <ul><li>This interface defines how a domain generates cache keys.</li>
</ul> <ul><li>Cache keys are used by the RequestCoordinator to:</li>
</ul> <ul><li>- Prevent duplicate in-flight requests</li>
</ul> <ul><li>- Enable response caching for identical filter combinations</li>
</ul> *
 <ul><li>@template TFilters - The shape of the filter object</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>class AutomobileCacheKeyBuilder implements ICacheKeyBuilder&lt;AutomobileFilters&gt; {</li>
</ul> <ul><li>  buildKey(filters: AutomobileFilters, highlights?: AutomobileHighlights): string {</li>
</ul> <ul><li>    const filterParts = [</li>
</ul> <ul><li>      filters.manufacturer?.join(',') || '',</li>
</ul> <ul><li>      filters.yearMin?.toString() || '',</li>
</ul> <ul><li>      filters.yearMax?.toString() || ''</li>
</ul> <ul><li>    ];</li>
</ul> *
 <ul><li>    const highlightParts = highlights ? [</li>
</ul> <ul><li>      highlights.manufacturer?.join(',') || ''</li>
</ul> <ul><li>    ] : [];</li>
</ul> *
 <ul><li>    return [...filterParts, ...highlightParts].join('|');</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface ICacheKeyBuilder&lt;TFilters&gt; { /**</p>
   <ul><li>Build a unique cache key from filters</li>
</ul>   *
   <ul><li>The key must be unique for each distinct filter combination.</li>
</ul>   <ul><li>Highlight filters must be included to ensure segmented statistics</li>
</ul>   <ul><li>are cached separately from non-highlighted requests.</li>
</ul>   *
   <ul><li>@param filters - Filter object</li>
</ul>   <ul><li>@param highlights - Optional highlight filters (must be included in cache key)</li>
</ul>   <ul><li>@returns Cache key string</li>
</ul>   */
<p>buildKey(filters: TFilters, highlights?: any): string; }</p>

<p>/**</p>
 <ul><li>Configuration for ResourceManagementService</li>
</ul> *
 <ul><li>This interface bundles all the adapters and settings needed</li>
</ul> <ul><li>to initialize the ResourceManagementService for a specific domain.</li>
</ul> *
 <ul><li>@template TFilters - The shape of the filter object</li>
</ul> <ul><li>@template TData - The shape of individual data items</li>
</ul> <ul><li>@template TStatistics - The shape of statistics object (optional)</li>
</ul> */
<p>export interface ResourceManagementConfig&lt;TFilters, TData, TStatistics = any&gt; { /**</p>
   <ul><li>Filter to URL parameter mapper</li>
</ul>   */
<p>filterMapper: IFilterUrlMapper&lt;TFilters&gt;;</p>

<p>/**</p>
   <ul><li>API data fetcher</li>
</ul>   */
<p>apiAdapter: IApiAdapter&lt;TFilters, TData, TStatistics&gt;;</p>

<p>/**</p>
   <ul><li>Cache key builder</li>
</ul>   */
<p>cacheKeyBuilder: ICacheKeyBuilder&lt;TFilters&gt;;</p>

<p>/**</p>
   <ul><li>Default filter values</li>
</ul>   <ul><li>Applied when application first loads or filters are cleared</li>
</ul>   */
<p>defaultFilters: TFilters;</p>

<p>/**</p>
   <ul><li>Whether to enable automatic data fetching on filter changes</li>
</ul>   <ul><li>When true, changing the URL automatically triggers API requests</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>autoFetch?: boolean;</p>

<p>/**</p>
   <ul><li>Cache TTL in milliseconds</li>
</ul>   <ul><li>How long cached responses are considered valid</li>
</ul>   <ul><li>@default 30000 (30 seconds)</li>
</ul>   */
<p>cacheTTL?: number; }</p>

<p>/**</p>
 <ul><li>State managed by ResourceManagementService</li>
</ul> *
 <ul><li>This interface represents the complete state of a domain's data</li>
</ul> <ul><li>as managed by the ResourceManagementService.</li>
</ul> *
 <ul><li>@template TFilters - The shape of the filter object</li>
</ul> <ul><li>@template TData - The shape of individual data items</li>
</ul> <ul><li>@template TStatistics - The shape of statistics object (optional)</li>
</ul> */
<p>export interface ResourceState&lt;TFilters, TData, TStatistics = any&gt; { /**</p>
   <ul><li>Current filter values</li>
</ul>   <ul><li>Derived from URL query parameters</li>
</ul>   */
<p>filters: TFilters;</p>

<p>/**</p>
   <ul><li>Data results from the API</li>
</ul>   */
<p>results: TData[];</p>

<p>/**</p>
   <ul><li>Total count of results (unpaginated)</li>
</ul>   */
<p>totalResults: number;</p>

<p>/**</p>
   <ul><li>Loading state</li>
</ul>   <ul><li>True while API request is in progress</li>
</ul>   */
<p>loading: boolean;</p>

<p>/**</p>
   <ul><li>Error state</li>
</ul>   <ul><li>Contains error object if last request failed, null otherwise</li>
</ul>   */
<p>error: Error | null;</p>

<p>/**</p>
   <ul><li>Optional statistics/aggregations from API</li>
</ul>   */
<p>statistics?: TStatistics;</p>

<p>/** <em> Optional highlight filters (h_</em> parameters)</p>
   <ul><li>Used for data segmentation in charts</li>
</ul>   */
<p>highlights?: any; }</p>

<p>/**</p>
 <ul><li>Default values for ResourceManagementConfig optional fields</li>
</ul> */
<p>export const RESOURCE_MANAGEMENT_DEFAULTS = { autoFetch: true, cacheTTL: 30000 // 30 seconds };</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 202.2: Update the Barrel Export</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code> to include the new interface:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts
<p>// VERSION 2 (Section 202) - Added resource management exports // Replaces VERSION 1 from Section 201</p>

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface'; export * from './resource-management.interface';</p>
</code></pre>

<hr>

<h3>Step 202.3: Understand the Adapter Pattern</h3>

<p>The three adapter interfaces form a cohesive system:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│                        URL Changes                               │ │                   ?manufacturer=Ford&amp;yearMin=2020                │ └─────────────────────────────────────────────────────────────────┘ │ │ (1) Parse URL ▼ ┌─────────────────────────────────────────────────────────────────┐ │                     IFilterUrlMapper                             │ │              fromUrlParams(params) → TFilters                    │ └─────────────────────────────────────────────────────────────────┘ │ │ (2) Build cache key ▼ ┌─────────────────────────────────────────────────────────────────┐ │                    ICacheKeyBuilder                              │ │              buildKey(filters) → "Ford|2020|"                    │ └─────────────────────────────────────────────────────────────────┘ │ │ (3) Check cache, then fetch ▼ ┌─────────────────────────────────────────────────────────────────┐ │                       IApiAdapter                                │ │         fetchData(filters) → Observable&lt;Response&gt;                │ └─────────────────────────────────────────────────────────────────┘ │ │ (4) Update state ▼ ┌─────────────────────────────────────────────────────────────────┐ │                      ResourceState                               │ │           { filters, results, totalResults, loading, ... }       │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p><strong>Why three separate interfaces?</strong></p>

<p>Single Responsibility Principle. Each interface does one thing:</p>

<table>
<p><thead><tr> <th>Interface</th> <th>Responsibility</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">IFilterUrlMapper</code></td> <td>URL serialization/deserialization</td></p>
</tr>
<p><tr> <td><code class="inline">IApiAdapter</code></td> <td>API communication</td></p>
</tr>
<p><tr> <td><code class="inline">ICacheKeyBuilder</code></td> <td>Cache key generation</td></p>
</tr>
</tbody>
</table>

<p>This separation means you can:</p>
<ul><li>Change URL format without touching API code</li>
<p><li>Switch APIs without changing URL handling</li> <li>Modify caching strategy independently</li></ul></p></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/resource-management.interface.ts
</code></pre>

<p>Expected output shows the file exists:</p>

<pre class="code-block text"><code>-rw-r--r-- 1 user user 6543 Feb  9 12:30 src/app/framework/models/resource-management.interface.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/resource-management.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export" src/app/framework/models/resource-management.interface.ts
</code></pre>

<p>Expected output shows interface exports:</p>

<pre class="code-block text"><code>export interface IFilterUrlMapper&lt;TFilters&gt; {
<p>export interface ApiAdapterResponse&lt;TData, TStatistics = any&gt; { export interface IApiAdapter&lt;TFilters, TData, TStatistics = any&gt; { export interface ICacheKeyBuilder&lt;TFilters&gt; { export interface ResourceManagementConfig&lt;TFilters, TData, TStatistics = any&gt; { export interface ResourceState&lt;TFilters, TData, TStatistics = any&gt; { export const RESOURCE_MANAGEMENT_DEFAULTS = {</p>
</code></pre>

<h3>4. Verify Barrel Export</h3>

<pre class="code-block bash"><code>$ grep "resource-management" src/app/framework/models/index.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export * from './resource-management.interface';
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module 'rxjs'</code></td> <td>RxJS not installed</td> <td>Run <code class="inline">npm install rxjs</code></td></p>
</tr>
<p><tr> <td><code class="inline">Cannot find module '@angular/router'</code></td> <td>Angular Router not installed</td> <td>Included with Angular core</td></p>
</tr>
<p><tr> <td><code class="inline">Observable is not generic</code></td> <td>Wrong RxJS import</td> <td>Use <code class="inline">import { Observable } from 'rxjs';</code></td></p>
</tr>
<p><tr> <td><code class="inline">Params is not defined</code></td> <td>Missing router import</td> <td>Add <code class="inline">import { Params } from '@angular/router';</code></td></p>
</tr>
<p><tr> <td>Interface properties showing as errors</td> <td>Domain config using wrong types</td> <td>Update domain-config.interface.ts to import from here</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>The adapter pattern isolates domain-specific logic</strong> — Framework services depend on interfaces, not implementations</li>
<p><li><strong>Three adapters form a cohesive system</strong> — URL mapping, API fetching, and cache key building work together</li> <li><strong>ResourceState represents the complete data state</strong> — Loading, results, errors, and filters in one place</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/resource-management.interface.ts</code> exists with all interfaces</li>
<p><li>[ ] <code class="inline">IFilterUrlMapper&lt;TFilters&gt;</code> defines <code class="inline">toUrlParams</code>, <code class="inline">fromUrlParams</code>, and optional <code class="inline">extractHighlights</code></li> <li>[ ] <code class="inline">IApiAdapter&lt;TFilters, TData, TStatistics&gt;</code> defines <code class="inline">fetchData</code> returning Observable</li> <li>[ ] <code class="inline">ICacheKeyBuilder&lt;TFilters&gt;</code> defines <code class="inline">buildKey</code> method</li> <li>[ ] <code class="inline">ApiAdapterResponse&lt;TData, TStatistics&gt;</code> defines standard response format</li> <li>[ ] <code class="inline">ResourceManagementConfig</code> bundles all adapters with configuration</li> <li>[ ] <code class="inline">ResourceState</code> captures complete domain data state</li> <li>[ ] Barrel file (<code class="inline">index.ts</code>) exports all resource management interfaces</li> <li>[ ] TypeScript compilation succeeds with no errors</li> <li>[ ] All interfaces have JSDoc documentation with examples</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">203-filter-definition-interface.md</code> to define the filter configuration interfaces used in Query Control components.</p></div></div>
    <div class="chapter" id="section-203">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>203: Filter Definition Interface</h1>
        </div>
<div class="page-content"><h1>203: Filter Definition Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 601-filter-definitions, 806-query-panel-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how configuration objects define UI behavior without custom components</li>
<p><li>Know how to use TypeScript generics to create type-safe filter definitions</li> <li>Recognize the relationship between filter definitions and URL state synchronization</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">FilterDefinition</code> interface that defines how filters appear in the Query Control component. This interface specifies filter types, labels, URL parameter mappings, and range configurations — everything the framework needs to render appropriate filter UI.</p>

<hr>

<h2>Why</h2>

<p>The vvroom application has a powerful Query Control component that lets users filter data. But instead of hard-coding filter types for automobiles, we use <strong>configuration-driven UI</strong>.</p>

<p>Consider these automobile filters:</p>
<ul><li><strong>Manufacturer</strong>: Multi-select dropdown (Toyota, Ford, Honda...)</li>
<p><li><strong>Year Range</strong>: Two number inputs (min/max)</li> <li><strong>Body Class</strong>: Multi-select dropdown (Sedan, SUV, Truck...)</li> <li><strong>Model Search</strong>: Text input with autocomplete</li></p>
</ul>
<p>Each filter type requires different UI rendering. The <code class="inline">FilterDefinition</code> interface describes each filter's characteristics, and the Query Control component reads this configuration to render the appropriate UI.</p>

<p><strong>This is declarative programming:</strong></p>

<pre class="code-block typescript"><code>// Declarative: describe WHAT you want
<p>const yearFilter: FilterDefinition&lt;AutomobileFilters&gt; = { field: 'year', label: 'Model Year', type: 'range', urlParams: { min: 'yearMin', max: 'yearMax' }, rangeConfig: { valueType: 'integer', minLabel: 'Start Year', maxLabel: 'End Year', defaultRange: { min: 1900, max: 2025 } } };</p>

<p>// The framework figures out HOW to render it</p>
</code></pre>

<p>Compare to imperative code where you'd write custom component logic for each filter type.</p>

<h3>URL-First Integration</h3>

<p>Each <code class="inline">FilterDefinition</code> includes <code class="inline">urlParams</code> — the URL query parameter name(s) for this filter. This directly supports the URL-First architecture:</p>

<table>
<p><thead><tr> <th>Filter Type</th> <th>urlParams Value</th> <th>URL Example</th></p>
</tr></thead>
<p><tbody> <tr> <td>Multiselect</td> <td><code class="inline">'manufacturer'</code></td> <td><code class="inline">?manufacturer=Ford,Toyota</code></td></p>
</tr>
<p><tr> <td>Range</td> <td><code class="inline">{ min: 'yearMin', max: 'yearMax' }</code></td> <td><code class="inline">?yearMin=2020&amp;yearMax=2024</code></td></p>
</tr>
<p><tr> <td>Text</td> <td><code class="inline">'model'</code></td> <td><code class="inline">?model=Camry</code></td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 203.1: Create the Filter Definition Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/filter-definition.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/filter-definition.interface.ts
<p>// VERSION 1 (Section 203) - Filter definition interfaces for Query Control</p>

<p>/**</p>
 <ul><li>Filter Definition Interface</li>
</ul> *
 <ul><li>Defines the structure for filterable fields in the Query Control component.</li>
</ul> <ul><li>This is domain-agnostic and works with any domain configuration.</li>
</ul> */

<p>/**</p>
 <ul><li>Configuration for range-type filters</li>
</ul> *
 <ul><li>Supports integer, decimal, and datetime ranges with flexible formatting.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Year range (integer, no grouping)</li>
</ul> <ul><li>rangeConfig: {</li>
</ul> <ul><li>  valueType: 'integer',</li>
</ul> <ul><li>  minLabel: 'Start Year',</li>
</ul> <ul><li>  maxLabel: 'End Year',</li>
</ul> <ul><li>  minPlaceholder: 'e.g., 1980',</li>
</ul> <ul><li>  maxPlaceholder: 'e.g., 2023',</li>
</ul> <ul><li>  step: 1,</li>
</ul> <ul><li>  useGrouping: false,</li>
</ul> <ul><li>  defaultRange: { min: 1900, max: new Date().getFullYear() }</li>
</ul> <ul><li>}</li>
</ul> *
 <ul><li>// Price range (decimal, with grouping)</li>
</ul> <ul><li>rangeConfig: {</li>
</ul> <ul><li>  valueType: 'decimal',</li>
</ul> <ul><li>  minLabel: 'Min Price',</li>
</ul> <ul><li>  maxLabel: 'Max Price',</li>
</ul> <ul><li>  step: 0.01,</li>
</ul> <ul><li>  decimalPlaces: 2,</li>
</ul> <ul><li>  useGrouping: true,</li>
</ul> <ul><li>  defaultRange: { min: 0, max: 1000000 }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface RangeConfig { /**</p>
   <ul><li>The type of values in the range</li>
</ul>   <ul><li>- 'integer': Whole numbers (years, counts)</li>
</ul>   <ul><li>- 'decimal': Floating point numbers (prices, measurements)</li>
</ul>   <ul><li>- 'datetime': Date/time values (ISO 8601 format)</li>
</ul>   */
<p>valueType: 'integer' | 'decimal' | 'datetime';</p>

<p>/**</p>
   <ul><li>Label for the minimum value input</li>
</ul>   <ul><li>@example "Start Year", "Min Price"</li>
</ul>   */
<p>minLabel: string;</p>

<p>/**</p>
   <ul><li>Label for the maximum value input</li>
</ul>   <ul><li>@example "End Year", "Max Price"</li>
</ul>   */
<p>maxLabel: string;</p>

<p>/**</p>
   <ul><li>Placeholder text for min input</li>
</ul>   <ul><li>@example "e.g., 1980"</li>
</ul>   */
<p>minPlaceholder?: string;</p>

<p>/**</p>
   <ul><li>Placeholder text for max input</li>
</ul>   <ul><li>@example "e.g., 2023"</li>
</ul>   */
<p>maxPlaceholder?: string;</p>

<p>/**</p>
   <ul><li>Step increment for numeric inputs</li>
</ul>   <ul><li>@default 1 for integer, 0.01 for decimal</li>
</ul>   */
<p>step?: number;</p>

<p>/**</p>
   <ul><li>Number of decimal places for 'decimal' type</li>
</ul>   <ul><li>@default 2</li>
</ul>   */
<p>decimalPlaces?: number;</p>

<p>/**</p>
   <ul><li>Whether to use thousand separators in display</li>
</ul>   <ul><li>Set to false for years to avoid "2,024"</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>useGrouping?: boolean;</p>

<p>/**</p>
   <ul><li>Default min/max values when API doesn't provide them</li>
</ul>   */
<p>defaultRange?: { min: number; max: number }; }</p>

<p>/**</p>
 <ul><li>Defines a filterable field in the domain</li>
</ul> *
 <ul><li>This interface is used in DomainConfig.queryControlFilters array</li>
</ul> <ul><li>to define all available filters for the Query Control component.</li>
</ul> *
 <ul><li>@template T - The filter model type that contains these fields</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Multiselect filter for manufacturer</li>
</ul> <ul><li>const manufacturerFilter: FilterDefinition&lt;AutomobileFilters&gt; = {</li>
</ul> <ul><li>  field: 'manufacturer',</li>
</ul> <ul><li>  label: 'Manufacturer',</li>
</ul> <ul><li>  type: 'multiselect',</li>
</ul> <ul><li>  optionsEndpoint: '/agg/manufacturers',</li>
</ul> <ul><li>  urlParams: 'manufacturer',</li>
</ul> <ul><li>  searchPlaceholder: 'Search manufacturers...',</li>
</ul> <ul><li>  dialogTitle: 'Select Manufacturers'</li>
</ul> <ul><li>};</li>
</ul> *
 <ul><li>// Range filter for year</li>
</ul> <ul><li>const yearFilter: FilterDefinition&lt;AutomobileFilters&gt; = {</li>
</ul> <ul><li>  field: 'year',</li>
</ul> <ul><li>  label: 'Model Year',</li>
</ul> <ul><li>  type: 'range',</li>
</ul> <ul><li>  urlParams: { min: 'yearMin', max: 'yearMax' },</li>
</ul> <ul><li>  rangeConfig: {</li>
</ul> <ul><li>    valueType: 'integer',</li>
</ul> <ul><li>    minLabel: 'Start Year',</li>
</ul> <ul><li>    maxLabel: 'End Year',</li>
</ul> <ul><li>    useGrouping: false,</li>
</ul> <ul><li>    defaultRange: { min: 1900, max: 2025 }</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface FilterDefinition&lt;T = any&gt; { /**</p>
   <ul><li>Unique field identifier matching a property in the filter model</li>
</ul>   <ul><li>Uses keyof T for type safety</li>
</ul>   */
<p>field: keyof T;</p>

<p>/**</p>
   <ul><li>Display label for the filter shown in Query Control component</li>
</ul>   */
<p>label: string;</p>

<p>/**</p>
   <ul><li>Filter type determines the UI component rendered</li>
</ul>   <ul><li>- 'multiselect': Dropdown with checkboxes</li>
</ul>   <ul><li>- 'range': Two inputs for min/max values</li>
</ul>   <ul><li>- 'text': Single text input</li>
</ul>   <ul><li>- 'date': Date picker</li>
</ul>   */
<p>type: 'multiselect' | 'range' | 'text' | 'date';</p>

<p>/**</p>
   <ul><li>API endpoint for fetching multiselect filter options</li>
</ul>   <ul><li>Relative to the domain's apiBaseUrl</li>
</ul>   *
   <ul><li>@example 'agg/manufacturers'</li>
</ul>   <ul><li>Fetches from: {apiBaseUrl}/agg/manufacturers</li>
</ul>   */
<p>optionsEndpoint?: string;</p>

<p>/**</p>
   <ul><li>Transformer function to convert API response to FilterOption[]</li>
</ul>   <ul><li>Required when API response doesn't match expected format</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>optionsTransformer: (response) =&gt; response.values.map(v =&gt; ({</li>
</ul>   <ul><li>  value: v.name,</li>
</ul>   <ul><li>  label: v.name,</li>
</ul>   <ul><li>  count: v.count</li>
</ul>   <ul><li>}))</li>
</ul>   */
<p>optionsTransformer?: (response: any) =&gt; FilterOption[];</p>

<p>/**</p>
   <ul><li>URL parameter name(s) for state synchronization</li>
</ul>   *
   <ul><li>For simple filters (text, multiselect): string</li>
</ul>   <ul><li>For range filters: object with min and max keys</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>urlParams: 'manufacturer'           // ?manufacturer=Ford,Toyota</li>
</ul>   <ul><li>urlParams: { min: 'yearMin', max: 'yearMax' }  // ?yearMin=2020&amp;yearMax=2024</li>
</ul>   */
<p>urlParams: string | { min: string; max: string };</p>

<p>/**</p>
   <ul><li>Placeholder text for search box in multiselect dialogs</li>
</ul>   */
<p>searchPlaceholder?: string;</p>

<p>/**</p>
   <ul><li>Subtitle text shown in filter dialog/modal</li>
</ul>   */
<p>dialogSubtitle?: string;</p>

<p>/**</p>
   <ul><li>Title for the filter dialog</li>
</ul>   <ul><li>@default "Select {label}"</li>
</ul>   */
<p>dialogTitle?: string;</p>

<p>/**</p>
   <ul><li>Configuration for type='range' filters</li>
</ul>   <ul><li>Required when type is 'range'</li>
</ul>   */
<p>rangeConfig?: RangeConfig; }</p>

<p>/**</p>
 <ul><li>Option for multiselect filters</li>
</ul> *
 <ul><li>Represents a single selectable option in a multiselect dropdown.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// API response format (from /agg/manufacturers endpoint)</li>
</ul> <ul><li>{</li>
</ul> <ul><li>  field: "manufacturer",</li>
</ul> <ul><li>  values: [</li>
</ul> <ul><li>    { value: "Toyota", label: "Toyota", count: 1543 },</li>
</ul> <ul><li>    { value: "Honda", label: "Honda", count: 1234 },</li>
</ul> <ul><li>    { value: "Ford", label: "Ford", count: 987 }</li>
</ul> <ul><li>  ]</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface FilterOption { /**</p>
   <ul><li>The actual value used when filter is selected</li>
</ul>   <ul><li>Sent to API and stored in URL</li>
</ul>   */
<p>value: string | number;</p>

<p>/**</p>
   <ul><li>Display text shown to user in dropdown</li>
</ul>   */
<p>label: string;</p>

<p>/**</p>
   <ul><li>Optional count of items matching this option</li>
</ul>   <ul><li>Displayed as badge: "Toyota (1,543)"</li>
</ul>   */
<p>count?: number; }</p>

<p>/**</p>
 <ul><li>Default transformer for standard API aggregation responses</li>
</ul> *
 <ul><li>Converts the standard aggregation response format to FilterOption[].</li>
</ul> <ul><li>Use this when your API returns the expected format.</li>
</ul> *
 <ul><li>@param response - API response with { field, values } structure</li>
</ul> <ul><li>@returns Array of FilterOption objects</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// API response:</li>
</ul> <ul><li>{ field: "manufacturer", values: [{ value: "Ford", count: 100 }] }</li>
</ul> *
 <ul><li>// Result:</li>
</ul> <ul><li>[{ value: "Ford", label: "Ford", count: 100 }]</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function defaultOptionsTransformer(response: { field: string; values: Array&lt;{ value: string | number; count?: number }&gt;; }): FilterOption[] { return response.values.map((v) =&gt; ({ value: v.value, label: String(v.value), count: v.count })); }</p>

<p>/**</p>
 <ul><li>Get URL parameter names from a filter definition</li>
</ul> *
 <ul><li>Utility function to extract URL parameter names regardless of format.</li>
</ul> *
 <ul><li>@param filter - Filter definition</li>
</ul> <ul><li>@returns Array of URL parameter names</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>getUrlParamNames({ urlParams: 'manufacturer' }) // ['manufacturer']</li>
</ul> <ul><li>getUrlParamNames({ urlParams: { min: 'yearMin', max: 'yearMax' } }) // ['yearMin', 'yearMax']</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function getUrlParamNames(filter: FilterDefinition): string[] { if (typeof filter.urlParams === 'string') { return [filter.urlParams]; } return [filter.urlParams.min, filter.urlParams.max]; }</p>

<p>/**</p>
 <ul><li>Check if a filter definition is a range filter</li>
</ul> *
 <ul><li>@param filter - Filter definition</li>
</ul> <ul><li>@returns True if filter type is 'range'</li>
</ul> */
<p>export function isRangeFilter(filter: FilterDefinition): boolean { return filter.type === 'range'; }</p>

<p>/**</p>
 <ul><li>Check if a filter definition has URL range params</li>
</ul> *
 <ul><li>@param urlParams - URL params from filter definition</li>
</ul> <ul><li>@returns True if urlParams is a min/max object</li>
</ul> */
<p>export function hasRangeUrlParams( urlParams: string | { min: string; max: string } ): urlParams is { min: string; max: string } { return typeof urlParams === 'object' &amp;&amp; 'min' in urlParams &amp;&amp; 'max' in urlParams; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 203.2: Update the Barrel Export</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code> to include the new interface:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface'; export * from './resource-management.interface'; export * from './filter-definition.interface';</p>
</code></pre>

<hr>

<h3>Step 203.3: Understand Filter Types</h3>

<p>The <code class="inline">FilterDefinition</code> interface supports four filter types:</p>

<table>
<p><thead><tr> <th>Type</th> <th>UI Component</th> <th>URL Example</th> <th>Use Case</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">multiselect</code></td> <td>Dropdown with checkboxes</td> <td><code class="inline">?manufacturer=Ford,Toyota</code></td> <td>Categorical data with known options</td></p>
</tr>
<p><tr> <td><code class="inline">range</code></td> <td>Two number inputs</td> <td><code class="inline">?yearMin=2020&amp;yearMax=2024</code></td> <td>Numeric or date ranges</td></p>
</tr>
<p><tr> <td><code class="inline">text</code></td> <td>Single text input</td> <td><code class="inline">?model=Camry</code></td> <td>Free-form text search</td></p>
</tr>
<p><tr> <td><code class="inline">date</code></td> <td>Date picker</td> <td><code class="inline">?date=2024-01-15</code></td> <td>Single date selection</td></p>
</tr>
</tbody>
</table>

<p><strong>Multiselect filters</strong> fetch options from an API endpoint. The <code class="inline">optionsEndpoint</code> specifies where to get the list, and <code class="inline">optionsTransformer</code> converts the response to <code class="inline">FilterOption[]</code> format.</p>

<p><strong>Range filters</strong> require <code class="inline">rangeConfig</code> to specify:</p>
<ul><li>Value type (integer, decimal, datetime)</li>
<p><li>Labels for min/max inputs</li> <li>Formatting options (decimal places, grouping)</li> <li>Default range when API doesn't provide bounds</li></p>
</ul>
<hr>

<h3>Step 203.4: Example Automobile Filter Configuration</h3>

<p>Here's how automobile filters would be configured (you'll create this in Phase 6):</p>

<pre class="code-block typescript"><code>// Preview: src/app/domain-config/automobile/configs/automobile.query-control-filters.ts

<p>import { FilterDefinition } from '@app/framework/models'; import { AutomobileFilters } from '../models/automobile.filters';</p>

<p>export const AUTOMOBILE_QUERY_CONTROL_FILTERS: FilterDefinition&lt;AutomobileFilters&gt;[] = [ { field: 'manufacturer', label: 'Manufacturer', type: 'multiselect', optionsEndpoint: 'agg/manufacturer', urlParams: 'manufacturer', searchPlaceholder: 'Search manufacturers...', dialogTitle: 'Select Manufacturers' }, { field: 'year', label: 'Model Year', type: 'range', urlParams: { min: 'yearMin', max: 'yearMax' }, rangeConfig: { valueType: 'integer', minLabel: 'Start Year', maxLabel: 'End Year', minPlaceholder: 'e.g., 1980', maxPlaceholder: 'e.g., 2024', step: 1, useGrouping: false, defaultRange: { min: 1900, max: new Date().getFullYear() } } }, { field: 'bodyClass', label: 'Body Class', type: 'multiselect', optionsEndpoint: 'agg/body_class', urlParams: 'bodyClass', searchPlaceholder: 'Search body types...' } ];</p>
</code></pre>

<p>This configuration tells the Query Control component exactly what to render without any custom code.</p></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/filter-definition.interface.ts
</code></pre>

<p>Expected output shows the file exists.</p>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/filter-definition.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export" src/app/framework/models/filter-definition.interface.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export interface RangeConfig {
<p>export interface FilterDefinition&lt;T = any&gt; { export interface FilterOption { export function defaultOptionsTransformer(response: { export function getUrlParamNames(filter: FilterDefinition): string[] { export function isRangeFilter(filter: FilterDefinition): boolean { export function hasRangeUrlParams(</p>
</code></pre>

<h3>4. Verify Barrel Export</h3>

<pre class="code-block bash"><code>$ grep "filter-definition" src/app/framework/models/index.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export * from './filter-definition.interface';
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Type 'keyof T' cannot be used</code></td> <td>TypeScript version too old</td> <td>Ensure TypeScript 4.x or higher</td></p>
</tr>
<p><tr> <td>Range filter not rendering</td> <td>Missing <code class="inline">rangeConfig</code> property</td> <td>Add <code class="inline">rangeConfig</code> when <code class="inline">type: 'range'</code></td></p>
</tr>
<p><tr> <td>Options not loading</td> <td>Wrong <code class="inline">optionsEndpoint</code> value</td> <td>Check API endpoint path is correct</td></p>
</tr>
<p><tr> <td>Filter not updating URL</td> <td>Wrong <code class="inline">urlParams</code> value</td> <td>Verify URL param name matches expected</td></p>
</tr>
<p><tr> <td>Type error on <code class="inline">urlParams</code></td> <td>Using wrong format</td> <td>Use string for simple, object for range</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Configuration-driven UI eliminates custom components</strong> — Define filter behavior in configuration, not code</li>
<p><li><strong>TypeScript generics ensure type safety</strong> — <code class="inline">FilterDefinition&lt;T&gt;</code> validates that <code class="inline">field</code> matches a property in T</li> <li><strong>URL parameter mapping enables URL-First architecture</strong> — Each filter knows exactly which URL params it controls</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/filter-definition.interface.ts</code> exists</li>
<p><li>[ ] <code class="inline">FilterDefinition&lt;T&gt;</code> interface is generic with type-safe <code class="inline">field</code> property</li> <li>[ ] <code class="inline">RangeConfig</code> interface defines all range filter options</li> <li>[ ] <code class="inline">FilterOption</code> interface defines multiselect option structure</li> <li>[ ] <code class="inline">urlParams</code> property supports both string and min/max object formats</li> <li>[ ] Utility functions <code class="inline">getUrlParamNames</code>, <code class="inline">isRangeFilter</code>, <code class="inline">hasRangeUrlParams</code> are implemented</li> <li>[ ] <code class="inline">defaultOptionsTransformer</code> function handles standard API response format</li> <li>[ ] Barrel file exports all filter definition types</li> <li>[ ] TypeScript compilation succeeds with no errors</li> <li>[ ] All interfaces have JSDoc documentation with examples</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">204-table-config-interface.md</code> to define the table configuration interface for displaying results.</p></div></div>
    <div class="chapter" id="section-204">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>204: Table Config Interface</h1>
        </div>
<div class="page-content"><h1>204: Table Config Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 602-table-config, 803-basic-results-table</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how configuration objects can drive complex UI components like data tables</li>
<p><li>Know how to use TypeScript generics for type-safe column definitions</li> <li>Recognize the benefits of configuration-driven tables versus custom table components</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">TableConfig</code> interface that defines how data tables are configured for display. This interface specifies columns, pagination, sorting, and other table behaviors — allowing the framework to render domain-appropriate tables without custom code.</p>

<hr>

<h2>Why</h2>

<p>Data tables are central to vvroom's UI. Users browse automobile data in tables, sort columns, paginate through results, and expand rows for details. Instead of building a custom table component for automobiles, we use PrimeNG Table with <strong>configuration-driven behavior</strong>.</p>

<p><strong>The problem with custom table components:</strong></p>

<pre class="code-block typescript"><code>// Anti-pattern: Custom component for each domain
<p>@Component({ selector: 'automobile-table', template: <code class="inline"> &lt;p-table [value]="vehicles"&gt; &lt;ng-template pTemplate="header"&gt; &lt;tr&gt; &lt;th pSortableColumn="manufacturer"&gt;Manufacturer&lt;/th&gt; &lt;th pSortableColumn="model"&gt;Model&lt;/th&gt; &lt;th pSortableColumn="year"&gt;Year&lt;/th&gt; &lt;!-- Hard-coded for automobiles --&gt; &lt;/tr&gt; &lt;/ng-template&gt; &lt;/p-table&gt;</p>
  </code>
<p>}) export class AutomobileTableComponent { }</p>
</code></pre>

<p>If you add a real estate domain, you'd need a completely new <code class="inline">RealEstateTableComponent</code>.</p>

<p><strong>The configuration-driven approach:</strong></p>

<pre class="code-block typescript"><code>// Better: Generic component reads configuration
<p>@Component({ selector: 'results-table', template: <code class="inline"> &lt;p-table [value]="data" [columns]="config.columns"&gt; &lt;ng-template pTemplate="header"&gt; &lt;tr&gt; &lt;th *ngFor="let col of config.columns" [pSortableColumn]="col.field"&gt; {{ col.header }} &lt;/th&gt; &lt;/tr&gt; &lt;/ng-template&gt; &lt;/p-table&gt;</p>
  </code>
<p>}) export class ResultsTableComponent { @Input() config: TableConfig&lt;any&gt;; @Input() data: any[]; }</p>
</code></pre>

<p>Now the same component works for any domain — just provide different configuration.</p></div><div class="page-content"><h3>PrimeNG Integration</h3>

<p>The <code class="inline">TableConfig</code> interface is designed to work with PrimeNG Table. Column definitions map directly to PrimeNG's expectations:</p>

<table>
<p><thead><tr> <th>TableConfig Property</th> <th>PrimeNG Feature</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">columns[].sortable</code></td> <td><code class="inline">pSortableColumn</code> directive</td></p>
</tr>
<p><tr> <td><code class="inline">columns[].filterable</code></td> <td>Column filter templates</td></p>
</tr>
<p><tr> <td><code class="inline">paginator</code>, <code class="inline">rows</code></td> <td><code class="inline">[paginator]</code>, <code class="inline">[rows]</code> bindings</td></p>
</tr>
<p><tr> <td><code class="inline">stateStorage</code>, <code class="inline">stateKey</code></td> <td>State persistence features</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>What</h2>

<h3>Step 204.1: Create the Table Config Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/table-config.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/table-config.interface.ts
<p>// VERSION 1 (Section 204) - Table configuration for PrimeNG Table</p>

<p>/**</p>
 <ul><li>Table Configuration Interfaces</li>
</ul> *
 <ul><li>Configuration-driven approach for PrimeNG Table.</li>
</ul> <ul><li>These interfaces provide type-safe table configuration without</li>
</ul> <ul><li>requiring custom table wrapper components.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const vehicleTableConfig: TableConfig&lt;Vehicle&gt; = {</li>
</ul> <ul><li>  tableId: 'vehicle-table',</li>
</ul> <ul><li>  stateKey: 'vehicle-table-state',</li>
</ul> <ul><li>  dataKey: 'id',</li>
</ul> <ul><li>  columns: [</li>
</ul> <ul><li>    { field: 'manufacturer', header: 'Manufacturer', sortable: true },</li>
</ul> <ul><li>    { field: 'model', header: 'Model', sortable: true, filterable: true }</li>
</ul> <ul><li>  ],</li>
</ul> <ul><li>  expandable: true,</li>
</ul> <ul><li>  selectable: false,</li>
</ul> <ul><li>  paginator: true,</li>
</ul> <ul><li>  rows: 20,</li>
</ul> <ul><li>  lazy: true,</li>
</ul> <ul><li>  stateStorage: 'local'</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/

<p>/**</p>
 <ul><li>PrimeNG column configuration</li>
</ul> *
 <ul><li>Defines a single column in a PrimeNG Table with type-safe field reference.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface PrimeNGColumn&lt;T&gt; { /**</p>
   <ul><li>Field name from data model (type-safe via keyof T)</li>
</ul>   */
<p>field: keyof T;</p>

<p>/**</p>
   <ul><li>Display header text</li>
</ul>   */
<p>header: string;</p>

<p>/**</p>
   <ul><li>Enable column sorting</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>sortable?: boolean;</p>

<p>/**</p>
   <ul><li>Enable column filtering</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>filterable?: boolean;</p>

<p>/**</p>
   <ul><li>Filter match mode for PrimeNG</li>
</ul>   <ul><li>@default 'contains'</li>
</ul>   */
<p>filterMatchMode?:</p>
<table>
<p><thead><tr></p>
</tr></thead>
<p><tbody> <tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
<p><tr></p>
</tr>
</tbody>
</table>

<p>/**</p>
   <ul><li>Enable column reordering</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>reorderable?: boolean;</p>

<p>/**</p>
   <ul><li>Column width (CSS value: '100px', '20%', etc.)</li>
</ul>   */
<p>width?: string;</p>

<p>/**</p>
   <ul><li>Frozen column (stick to left/right during horizontal scroll)</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>frozen?: boolean;</p>

<p>/**</p>
   <ul><li>Alignment of column content</li>
</ul>   <ul><li>@default 'left'</li>
</ul>   */
<p>align?: 'left' | 'center' | 'right';</p>

<p>/**</p>
   <ul><li>Custom CSS classes for column</li>
</ul>   */
<p>styleClass?: string;</p>

<p>/**</p>
   <ul><li>Data type for better filtering/sorting</li>
</ul>   */
<p>dataType?: 'text' | 'numeric' | 'date' | 'boolean'; }</p>

<p>/**</p>
 <ul><li>Table configuration for PrimeNG Table</li>
</ul> *
 <ul><li>Comprehensive configuration object that drives PrimeNG Table behavior.</li>
</ul> <ul><li>Use this instead of creating custom table wrapper components.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface TableConfig&lt;T&gt; { /**</p>
   <ul><li>Unique identifier for this table instance</li>
</ul>   <ul><li>Used for debugging and state management</li>
</ul>   */
<p>tableId: string;</p>

<p>/**</p>
   <ul><li>State storage key for PrimeNG's stateStorage feature</li>
</ul>   <ul><li>Used to persist column order, filters, etc. in local/session storage</li>
</ul>   */
<p>stateKey: string;</p>

<p>/**</p>
   <ul><li>Column definitions</li>
</ul>   */
<p>columns: PrimeNGColumn&lt;T&gt;[];</p>

<p>/**</p>
   <ul><li>Unique key field for row tracking (required for expandable/selectable)</li>
</ul>   <ul><li>Should be a unique identifier field like 'id' or 'vin'</li>
</ul>   */
<p>dataKey: keyof T;</p>

<p>/**</p>
   <ul><li>Enable row expansion</li>
</ul>   <ul><li>When true, rows can be expanded to show additional details</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>expandable?: boolean;</p>

<p>/**</p>
   <ul><li>Enable row selection</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>selectable?: boolean;</p>

<p>/**</p>
   <ul><li>Selection mode if selectable is true</li>
</ul>   <ul><li>@default 'multiple'</li>
</ul>   */
<p>selectionMode?: 'single' | 'multiple';</p>

<p>/**</p>
   <ul><li>Enable paginator</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>paginator?: boolean;</p>

<p>/**</p>
   <ul><li>Number of rows per page</li>
</ul>   <ul><li>@default 20</li>
</ul>   */
<p>rows?: number;</p>

<p>/**</p>
   <ul><li>Rows per page options for paginator dropdown</li>
</ul>   <ul><li>@default [10, 20, 50, 100]</li>
</ul>   */
<p>rowsPerPageOptions?: number[];</p>

<p>/**</p>
   <ul><li>Enable lazy loading mode (server-side pagination/sorting/filtering)</li>
</ul>   <ul><li>When true, table emits events instead of handling data locally</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>lazy?: boolean;</p>

<p>/**</p>
   <ul><li>State storage mode for persisting table state</li>
</ul>   <ul><li>- 'local': localStorage (persists across sessions)</li>
</ul>   <ul><li>- 'session': sessionStorage (cleared on browser close)</li>
</ul>   <ul><li>- null: no persistence</li>
</ul>   <ul><li>@default 'local'</li>
</ul>   */
<p>stateStorage?: 'local' | 'session' | null;</p>

<p>/**</p>
   <ul><li>Enable responsive mode</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>responsive?: boolean;</p>

<p>/**</p>
   <ul><li>Responsive layout mode</li>
</ul>   <ul><li>- 'scroll': Horizontal scrollbar on small screens</li>
</ul>   <ul><li>- 'stack': Stack columns vertically on small screens</li>
</ul>   <ul><li>@default 'scroll'</li>
</ul>   */
<p>responsiveLayout?: 'scroll' | 'stack';</p>

<p>/**</p>
   <ul><li>Enable column resizing</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>resizableColumns?: boolean;</p>

<p>/**</p>
   <ul><li>Column resize mode</li>
</ul>   <ul><li>- 'fit': Resizing a column adjusts adjacent columns</li>
</ul>   <ul><li>- 'expand': Resizing a column expands table width</li>
</ul>   <ul><li>@default 'fit'</li>
</ul>   */
<p>columnResizeMode?: 'fit' | 'expand';</p>

<p>/**</p>
   <ul><li>Enable column reordering via drag-and-drop</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>reorderableColumns?: boolean;</p>

<p>/**</p>
   <ul><li>CSS style classes for table element</li>
</ul>   */
<p>styleClass?: string;</p>

<p>/**</p>
   <ul><li>Show gridlines between cells</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>gridlines?: boolean;</p>

<p>/**</p>
   <ul><li>Alternate row colors (zebra striping)</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>stripedRows?: boolean;</p>

<p>/**</p>
   <ul><li>Show table caption/header</li>
</ul>   */
<p>showCaption?: boolean;</p>

<p>/**</p>
   <ul><li>Caption text</li>
</ul>   */
<p>caption?: string;</p>

<p>/**</p>
   <ul><li>Enable virtual scrolling for large datasets</li>
</ul>   <ul><li>When true, only visible rows are rendered</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>virtualScroll?: boolean;</p>

<p>/**</p>
   <ul><li>Virtual scroll item size (height in pixels)</li>
</ul>   <ul><li>Required if virtualScroll is true</li>
</ul>   */
<p>virtualScrollItemSize?: number;</p>

<p>/**</p>
   <ul><li>Show loading indicator</li>
</ul>   <ul><li>Typically bound to loading state from service</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>loading?: boolean; }</p>

<p>/**</p>
 <ul><li>Table state for managing table UI state</li>
</ul> *
 <ul><li>Represents the runtime state of a table instance.</li>
</ul> <ul><li>Used by components to track selection, expansion, pagination, etc.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface TableState&lt;T&gt; { /**</p>
   <ul><li>Currently selected rows</li>
</ul>   */
<p>selection: T[];</p>

<p>/**</p>
   <ul><li>Expanded row keys</li>
</ul>   <ul><li>Key is the value of dataKey field, value is boolean</li>
</ul>   */
<p>expandedRowKeys: { [key: string]: boolean };</p>

<p>/**</p>
   <ul><li>First row index (for pagination, 0-indexed)</li>
</ul>   */
<p>first: number;</p>

<p>/**</p>
   <ul><li>Rows per page</li>
</ul>   */
<p>rows: number;</p>

<p>/**</p>
   <ul><li>Total records (for pagination display)</li>
</ul>   */
<p>totalRecords: number;</p>

<p>/**</p>
   <ul><li>Current sort field</li>
</ul>   */
<p>sortField?: keyof T;</p>

<p>/**</p>
   <ul><li>Sort order (1 = ascending, -1 = descending)</li>
</ul>   */
<p>sortOrder?: 1 | -1;</p>

<p>/**</p>
   <ul><li>Active filters (PrimeNG filter format)</li>
</ul>   */
<p>filters?: { [key: string]: any }; }</p>

<p>/**</p>
 <ul><li>Create default table configuration</li>
</ul> *
 <ul><li>Utility function that provides sensible defaults for common table setups.</li>
</ul> <ul><li>Override specific properties as needed.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> <ul><li>@param tableId - Unique table identifier</li>
</ul> <ul><li>@param dataKey - Unique key field for row tracking</li>
</ul> <ul><li>@param columns - Column definitions</li>
</ul> <ul><li>@returns Complete TableConfig with defaults applied</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const config = getDefaultTableConfig&lt;Vehicle&gt;(</li>
</ul> <ul><li>  'vehicle-table',</li>
</ul> <ul><li>  'vin',</li>
</ul> <ul><li>  [</li>
</ul> <ul><li>    { field: 'manufacturer', header: 'Manufacturer', sortable: true },</li>
</ul> <ul><li>    { field: 'model', header: 'Model', sortable: true }</li>
</ul> <ul><li>  ]</li>
</ul> <ul><li>);</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function getDefaultTableConfig&lt;T&gt;( tableId: string, dataKey: keyof T, columns: PrimeNGColumn&lt;T&gt;[] ): TableConfig&lt;T&gt; { return { tableId, stateKey: <code class="inline">${tableId}-state</code>, columns, dataKey, expandable: false, selectable: false, selectionMode: 'multiple', paginator: true, rows: 20, rowsPerPageOptions: [10, 20, 50, 100], lazy: true, stateStorage: 'local', responsive: true, responsiveLayout: 'scroll', resizableColumns: false, columnResizeMode: 'fit', reorderableColumns: true, styleClass: 'p-datatable-striped p-datatable-gridlines', gridlines: true, stripedRows: true, showCaption: false, virtualScroll: false, loading: false }; }</p>

<p>/**</p>
 <ul><li>Get visible columns from configuration</li>
</ul> *
 <ul><li>Filters out hidden columns and returns array suitable for template iteration.</li>
</ul> <ul><li>Currently returns all columns; extend to support column visibility.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> <ul><li>@param config - Table configuration</li>
</ul> <ul><li>@returns Array of visible columns</li>
</ul> */
<p>export function getVisibleColumns&lt;T&gt;( config: TableConfig&lt;T&gt; ): PrimeNGColumn&lt;T&gt;[] { return config.columns; }</p>

<p>/**</p>
 <ul><li>Extract PrimeNG Table bindings from config</li>
</ul> *
 <ul><li>Converts TableConfig to object suitable for PrimeNG Table attribute binding.</li>
</ul> <ul><li>Use with spread operator: <code class="inline">&lt;p-table ...getTableBindings(config)&gt;</code></li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> <ul><li>@param config - Table configuration</li>
</ul> <ul><li>@returns Object with PrimeNG Table bindings</li>
</ul> */
<p>export function getTableBindings&lt;T&gt;(config: TableConfig&lt;T&gt;): { dataKey: keyof T; stateStorage: 'local' | 'session' | null; stateKey: string; paginator: boolean; rows: number; rowsPerPageOptions: number[]; lazy: boolean; reorderableColumns: boolean; resizableColumns: boolean; columnResizeMode: 'fit' | 'expand'; responsive: boolean; responsiveLayout: 'scroll' | 'stack'; styleClass: string; } { return { dataKey: config.dataKey, stateStorage: config.stateStorage ?? 'local', stateKey: config.stateKey, paginator: config.paginator ?? true, rows: config.rows ?? 20, rowsPerPageOptions: config.rowsPerPageOptions ?? [10, 20, 50, 100], lazy: config.lazy ?? true, reorderableColumns: config.reorderableColumns ?? true, resizableColumns: config.resizableColumns ?? false, columnResizeMode: config.columnResizeMode ?? 'fit', responsive: config.responsive ?? true, responsiveLayout: config.responsiveLayout ?? 'scroll', styleClass: config.styleClass ?? 'p-datatable-striped p-datatable-gridlines' }; }</p>

<p>/**</p>
 <ul><li>Create default table state</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> <ul><li>@param rows - Initial rows per page</li>
</ul> <ul><li>@returns Default TableState</li>
</ul> */
<p>export function getDefaultTableState&lt;T&gt;(rows: number = 20): TableState&lt;T&gt; { return { selection: [], expandedRowKeys: {}, first: 0, rows, totalRecords: 0, sortField: undefined, sortOrder: undefined, filters: undefined }; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 204.2: Update the Barrel Export</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code> to include the new interface:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface'; export * from './resource-management.interface'; export * from './filter-definition.interface'; export * from './table-config.interface';</p>
</code></pre>

<hr>

<h3>Step 204.3: Example Automobile Table Configuration</h3>

<p>Here's how an automobile table would be configured (you'll create this in Phase 6):</p>

<pre class="code-block typescript"><code>// Preview: src/app/domain-config/automobile/configs/automobile.table-config.ts

<p>import { TableConfig, getDefaultTableConfig } from '@app/framework/models'; import { VehicleResult } from '../models/automobile.data';</p>

<p>export const AUTOMOBILE_TABLE_CONFIG: TableConfig&lt;VehicleResult&gt; = { ...getDefaultTableConfig&lt;VehicleResult&gt;('automobile-results', 'vin', []), columns: [ { field: 'manufacturer', header: 'Manufacturer', sortable: true, width: '150px' }, { field: 'model', header: 'Model', sortable: true, width: '150px' }, { field: 'year', header: 'Year', sortable: true, width: '80px', align: 'center' }, { field: 'bodyClass', header: 'Body Class', sortable: true }, { field: 'engineCylinders', header: 'Cylinders', sortable: true, width: '100px', align: 'center' }, { field: 'fuelType', header: 'Fuel Type', sortable: true } ], expandable: true, rows: 25 };</p>
</code></pre>

<p>The <code class="inline">getDefaultTableConfig</code> helper provides sensible defaults, and we override only what's specific to automobiles.</p>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/table-config.interface.ts
</code></pre>

<p>Expected output shows the file exists.</p>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/table-config.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export" src/app/framework/models/table-config.interface.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export interface PrimeNGColumn&lt;T&gt; {
<p>export interface TableConfig&lt;T&gt; { export interface TableState&lt;T&gt; { export function getDefaultTableConfig&lt;T&gt;( export function getVisibleColumns&lt;T&gt;( export function getTableBindings&lt;T&gt;(config: TableConfig&lt;T&gt;): { export function getDefaultTableState&lt;T&gt;(rows: number = 20): TableState&lt;T&gt; {</p>
</code></pre></div><div class="page-content"><h3>4. Verify Barrel Export</h3>

<pre class="code-block bash"><code>$ grep "table-config" src/app/framework/models/index.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export * from './table-config.interface';
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">keyof T</code> shows error</td> <td>TypeScript strict mode issue</td> <td>Ensure T extends object type</td></p>
</tr>
<p><tr> <td>Column field not recognized</td> <td>Field name typo</td> <td>Use IDE autocomplete for <code class="inline">field</code> property</td></p>
</tr>
<p><tr> <td>Sorting not working</td> <td><code class="inline">sortable: true</code> missing</td> <td>Add <code class="inline">sortable: true</code> to column definition</td></p>
</tr>
<p><tr> <td>State not persisting</td> <td><code class="inline">stateStorage</code> is null</td> <td>Set <code class="inline">stateStorage: 'local'</code> or <code class="inline">'session'</code></td></p>
</tr>
<p><tr> <td>Virtual scroll not working</td> <td>Missing <code class="inline">virtualScrollItemSize</code></td> <td>Set item height when using virtual scroll</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Configuration replaces custom components</strong> — One generic table component serves all domains</li>
<p><li><strong>Type-safe column definitions</strong> — <code class="inline">keyof T</code> ensures field names match data model properties</li> <li><strong>Utility functions reduce boilerplate</strong> — <code class="inline">getDefaultTableConfig</code> provides sensible defaults</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/table-config.interface.ts</code> exists</li>
<p><li>[ ] <code class="inline">PrimeNGColumn&lt;T&gt;</code> interface defines type-safe column configuration</li> <li>[ ] <code class="inline">TableConfig&lt;T&gt;</code> interface includes all PrimeNG Table options</li> <li>[ ] <code class="inline">TableState&lt;T&gt;</code> interface captures runtime table state</li> <li>[ ] <code class="inline">getDefaultTableConfig</code> utility function is implemented</li> <li>[ ] <code class="inline">getTableBindings</code> utility function is implemented</li> <li>[ ] <code class="inline">getVisibleColumns</code> utility function is implemented</li> <li>[ ] <code class="inline">getDefaultTableState</code> utility function is implemented</li> <li>[ ] Barrel file exports all table configuration types</li> <li>[ ] TypeScript compilation succeeds with no errors</li> <li>[ ] All interfaces have JSDoc documentation with examples</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">205-picker-config-interface.md</code> to define the picker configuration interface for multi-select data pickers.</p></div></div>
    <div class="chapter" id="section-205">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>205: Picker Config Interface</h1>
        </div>
<div class="page-content"><h1>205: Picker Config Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 204-table-config-interface <strong>Blocks:</strong> 603-picker-configs, 311-picker-config-registry, 802-base-picker-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how pickers extend table functionality with selection and URL synchronization</li>
<p><li>Know how to configure row key generation and serialization for URL state</li> <li>Recognize the relationship between picker selections and URL query parameters</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">PickerConfig</code> interface that defines how selection pickers work. Pickers are specialized tables with checkboxes that let users select items and synchronize those selections with URL parameters — supporting the URL-First architecture.</p>

<hr>

<h2>Why</h2>

<p>Pickers are tables with selection capabilities. In vvroom, users might:</p>
<ul><li>Select specific VINs to compare</li>
<p><li>Choose manufacturers to focus on</li> <li>Pick models for detailed analysis</li></p>
</ul>
<p>These selections must be:</p>
<ul><li><strong>Persisted in the URL</strong> — Sharing a URL shares the selection</li>
<p><li><strong>Restored from URL</strong> — Loading a URL restores the selection</li> <li><strong>Type-safe</strong> — The framework knows what types are being selected</li></p>
</ul>
<p><strong>The picker flow:</strong></p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│  User selects rows in picker table                               │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  serializer(selectedItems) → URL string                          │ │  Example: ["Ford", "Toyota"] → "Ford,Toyota"                     │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  URL updated: ?selectedManufacturers=Ford,Toyota                 │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p><strong>Restoring from URL:</strong></p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│  URL: ?selectedManufacturers=Ford,Toyota                         │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  deserializer("Ford,Toyota") → [{manufacturer: "Ford"}, ...]     │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  Picker shows Ford, Toyota as selected                           │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>The <code class="inline">PickerConfig</code> interface defines the serialization/deserialization logic, API endpoints, and column configurations for each picker.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 205.1: Create the Picker Config Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/picker-config.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/picker-config.interface.ts
<p>// VERSION 1 (Section 205) - Picker configuration for selection tables</p>

<p>import { Observable } from 'rxjs'; import { PrimeNGColumn } from './table-config.interface';</p>

<p>/**</p>
 <ul><li>Picker Configuration Interfaces</li>
</ul> *
 <ul><li>Configuration-driven approach for selection pickers (multi-select tables).</li>
</ul> <ul><li>Pickers use PrimeNG Table with checkboxes for row selection and</li>
</ul> <ul><li>synchronize selections with URL query parameters.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const manufacturerPickerConfig: PickerConfig&lt;Manufacturer&gt; = {</li>
</ul> <ul><li>  id: 'manufacturer-picker',</li>
</ul> <ul><li>  displayName: 'Select Manufacturers',</li>
</ul> <ul><li>  columns: [</li>
</ul> <ul><li>    { field: 'name', header: 'Manufacturer', sortable: true },</li>
</ul> <ul><li>    { field: 'country', header: 'Country', sortable: true }</li>
</ul> <ul><li>  ],</li>
</ul> <ul><li>  api: {</li>
</ul> <ul><li>    fetchData: (params) =&gt; http.get('/api/manufacturers', { params }),</li>
</ul> <ul><li>    responseTransformer: (r) =&gt; ({ results: r.data, total: r.total })</li>
</ul> <ul><li>  },</li>
</ul> <ul><li>  row: {</li>
</ul> <ul><li>    keyGenerator: (row) =&gt; row.id,</li>
</ul> <ul><li>    keyParser: (key) =&gt; ({ id: key })</li>
</ul> <ul><li>  },</li>
</ul> <ul><li>  selection: {</li>
</ul> <ul><li>    mode: 'multiple',</li>
</ul> <ul><li>    urlParam: 'manufacturers',</li>
</ul> <ul><li>    serializer: (items) =&gt; items.map(i =&gt; i.id).join(','),</li>
</ul> <ul><li>    deserializer: (url) =&gt; url.split(',').map(id =&gt; ({ id }))</li>
</ul> <ul><li>  },</li>
</ul> <ul><li>  pagination: {</li>
</ul> <ul><li>    mode: 'server',</li>
</ul> <ul><li>    defaultPageSize: 20</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/

<p>/**</p>
 <ul><li>Picker API configuration</li>
</ul> *
 <ul><li>Defines how the picker fetches data from the API.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface PickerApiConfig&lt;T&gt; { /**</p>
   <ul><li>Function to fetch data from API</li>
</ul>   <ul><li>Receives pagination/filter params, returns Observable of raw response</li>
</ul>   */
<p>fetchData: (params: PickerApiParams) =&gt; Observable&lt;any&gt;;</p>

<p>/**</p>
   <ul><li>Transform API response to standard format</li>
</ul>   <ul><li>Required because different APIs have different response shapes</li>
</ul>   */
<p>responseTransformer: (response: any) =&gt; PickerApiResponse&lt;T&gt;;</p>

<p>/**</p>
   <ul><li>Optional parameter mapper</li>
</ul>   <ul><li>Maps internal picker params to API-specific format</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>paramMapper: (params) =&gt; ({</li>
</ul>   <em>   offset: params.page </em> params.size,
   <ul><li>  limit: params.size,</li>
</ul>   <ul><li>  sort: params.sortField</li>
</ul>   <ul><li>})</li>
</ul>   */
<p>paramMapper?: (params: PickerApiParams) =&gt; any; }</p>

<p>/**</p>
 <ul><li>Picker API request parameters</li>
</ul> *
 <ul><li>Standard parameters sent to the API fetch function.</li>
</ul> */
<p>export interface PickerApiParams { /**</p>
   <ul><li>Current page (0-indexed)</li>
</ul>   */
<p>page: number;</p>

<p>/**</p>
   <ul><li>Page size (rows per page)</li>
</ul>   */
<p>size: number;</p>

<p>/**</p>
   <ul><li>Sort field name</li>
</ul>   */
<p>sortField?: string;</p>

<p>/**</p>
   <ul><li>Sort order (1 = ascending, -1 = descending)</li>
</ul>   */
<p>sortOrder?: 1 | -1;</p>

<p>/**</p>
   <ul><li>Search/filter term from search box</li>
</ul>   */
<p>search?: string;</p>

<p>/**</p>
   <ul><li>Additional filters (domain-specific)</li>
</ul>   */
<p>filters?: { [key: string]: any }; }</p>

<p>/**</p>
 <ul><li>Picker API response format</li>
</ul> *
 <ul><li>Standard response format that all pickers expect.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface PickerApiResponse&lt;T&gt; { /**</p>
   <ul><li>Array of result items for current page</li>
</ul>   */
<p>results: T[];</p>

<p>/**</p>
   <ul><li>Total number of items (for pagination)</li>
</ul>   */
<p>total: number;</p>

<p>/**</p>
   <ul><li>Current page number (optional, for verification)</li>
</ul>   */
<p>page?: number;</p>

<p>/**</p>
   <ul><li>Page size (optional, for verification)</li>
</ul>   */
<p>size?: number;</p>

<p>/**</p>
   <ul><li>Total pages (optional, computed from total/size)</li>
</ul>   */
<p>totalPages?: number; }</p>

<p>/**</p>
 <ul><li>Picker row configuration</li>
</ul> *
 <ul><li>Defines how to generate unique keys for rows and parse them back.</li>
</ul> <ul><li>Keys are used for selection tracking and URL serialization.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface PickerRowConfig&lt;T&gt; { /**</p>
   <ul><li>Generate unique key from row data</li>
</ul>   <ul><li>Used for selection tracking and URL serialization</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>// Simple ID-based key</li>
</ul>   <ul><li>keyGenerator: (row) =&gt; row.id</li>
</ul>   *
   <ul><li>// Composite key</li>
</ul>   <ul><li>keyGenerator: (row) =&gt; <code class="inline">${row.manufacturer}|${row.model}</code></li>
</ul>   */
<p>keyGenerator: (row: T) =&gt; string;</p>

<p>/**</p>
   <ul><li>Parse key back to partial row data</li>
</ul>   <ul><li>Used for URL hydration before data loads</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>// Simple ID-based parse</li>
</ul>   <ul><li>keyParser: (key) =&gt; ({ id: key })</li>
</ul>   *
   <ul><li>// Composite key parse</li>
</ul>   <ul><li>keyParser: (key) =&gt; {</li>
</ul>   <ul><li>  const [manufacturer, model] = key.split('|');</li>
</ul>   <ul><li>  return { manufacturer, model };</li>
</ul>   <ul><li>}</li>
</ul>   */
<p>keyParser: (key: string) =&gt; Partial&lt;T&gt;; }</p>

<p>/**</p>
 <ul><li>Picker selection configuration</li>
</ul> *
 <ul><li>Defines selection behavior and URL synchronization.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface PickerSelectionConfig&lt;T&gt; { /**</p>
   <ul><li>Selection mode</li>
</ul>   <ul><li>- 'single': Only one item can be selected</li>
</ul>   <ul><li>- 'multiple': Multiple items can be selected</li>
</ul>   <ul><li>@default 'multiple'</li>
</ul>   */
<p>mode: 'single' | 'multiple';</p>

<p>/**</p>
   <ul><li>URL query parameter name for storing selections</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>urlParam: 'selectedManufacturers'</li>
</ul>   <ul><li>// URL becomes: ?selectedManufacturers=Ford,Toyota,Honda</li>
</ul>   */
<p>urlParam: string;</p>

<p>/**</p>
   <ul><li>Serialize selected items to URL string</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>// Comma-separated IDs</li>
</ul>   <ul><li>serializer: (items) =&gt; items.map(i =&gt; i.id).join(',')</li>
</ul>   *
   <ul><li>// Composite keys</li>
</ul>   <ul><li>serializer: (items) =&gt; items.map(i =&gt; <code class="inline">${i.make}:${i.model}</code>).join(',')</li>
</ul>   */
<p>serializer: (items: T[]) =&gt; string;</p>

<p>/**</p>
   <ul><li>Deserialize URL string to partial item data</li>
</ul>   <ul><li>Returns partial objects that will be matched against loaded data</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>// Comma-separated IDs</li>
</ul>   <ul><li>deserializer: (url) =&gt; url.split(',').map(id =&gt; ({ id }))</li>
</ul>   *
   <ul><li>// Composite keys</li>
</ul>   <ul><li>deserializer: (url) =&gt; url.split(',').map(pair =&gt; {</li>
</ul>   <ul><li>  const [make, model] = pair.split(':');</li>
</ul>   <ul><li>  return { make, model };</li>
</ul>   <ul><li>})</li>
</ul>   */
<p>deserializer: (urlString: string) =&gt; Partial&lt;T&gt;[];</p>

<p>/**</p>
   <ul><li>Generate key from partial item (from deserializer)</li>
</ul>   <ul><li>If not provided, uses row.keyGenerator</li>
</ul>   */
<p>keyGenerator?: (item: Partial&lt;T&gt;) =&gt; string; }</p>

<p>/**</p>
 <ul><li>Picker pagination configuration</li>
</ul> */
<p>export interface PickerPaginationConfig { /**</p>
   <ul><li>Pagination mode</li>
</ul>   <ul><li>- 'server': Server-side pagination (API handles paging)</li>
</ul>   <ul><li>- 'client': Client-side pagination (load all, page locally)</li>
</ul>   <ul><li>@default 'server'</li>
</ul>   */
<p>mode: 'server' | 'client';</p>

<p>/**</p>
   <ul><li>Default page size</li>
</ul>   <ul><li>@default 20</li>
</ul>   */
<p>defaultPageSize?: number;</p>

<p>/**</p>
   <ul><li>Page size options for dropdown</li>
</ul>   <ul><li>@default [10, 20, 50, 100]</li>
</ul>   */
<p>pageSizeOptions?: number[]; }</p>

<p>/**</p>
 <ul><li>Picker caching configuration</li>
</ul> */
<p>export interface PickerCachingConfig { /**</p>
   <ul><li>Enable caching of picker data</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>enabled: boolean;</p>

<p>/**</p>
   <ul><li>Cache TTL in milliseconds</li>
</ul>   <ul><li>@default 300000 (5 minutes)</li>
</ul>   */
<p>ttl?: number; }</p>

<p>/**</p>
 <ul><li>Complete picker configuration</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface PickerConfig&lt;T&gt; { /**</p>
   <ul><li>Unique identifier for this picker</li>
</ul>   <ul><li>Used for registry lookup and state management</li>
</ul>   */
<p>id: string;</p>

<p>/**</p>
   <ul><li>Display name for picker (shown in UI headers)</li>
</ul>   */
<p>displayName: string;</p>

<p>/**</p>
   <ul><li>Column definitions</li>
</ul>   <ul><li>Reuses PrimeNGColumn from table config for consistency</li>
</ul>   */
<p>columns: PrimeNGColumn&lt;T&gt;[];</p>

<p>/**</p>
   <ul><li>API configuration</li>
</ul>   */
<p>api: PickerApiConfig&lt;T&gt;;</p>

<p>/**</p>
   <ul><li>Row key configuration</li>
</ul>   */
<p>row: PickerRowConfig&lt;T&gt;;</p>

<p>/**</p>
   <ul><li>Selection configuration</li>
</ul>   */
<p>selection: PickerSelectionConfig&lt;T&gt;;</p>

<p>/**</p>
   <ul><li>Pagination configuration</li>
</ul>   */
<p>pagination: PickerPaginationConfig;</p>

<p>/**</p>
   <ul><li>Optional caching configuration</li>
</ul>   */
<p>caching?: PickerCachingConfig;</p>

<p>/**</p>
   <ul><li>Optional description/help text</li>
</ul>   */
<p>description?: string;</p>

<p>/**</p>
   <ul><li>Show search box</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>showSearch?: boolean;</p>

<p>/**</p>
   <ul><li>Search placeholder text</li>
</ul>   <ul><li>@default 'Search...'</li>
</ul>   */
<p>searchPlaceholder?: string; }</p>

<p>/**</p>
 <ul><li>Picker selection event</li>
</ul> *
 <ul><li>Emitted when user changes selection.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface PickerSelectionEvent&lt;T&gt; { /**</p>
   <ul><li>Picker ID that emitted the event</li>
</ul>   */
<p>pickerId: string;</p>

<p>/**</p>
   <ul><li>Selected item objects</li>
</ul>   */
<p>selections: T[];</p>

<p>/**</p>
   <ul><li>Selected item keys (from keyGenerator)</li>
</ul>   */
<p>selectedKeys: string[];</p>

<p>/**</p>
   <ul><li>Serialized URL parameter value</li>
</ul>   */
<p>urlValue: string; }</p>

<p>/**</p>
 <ul><li>Picker state</li>
</ul> *
 <ul><li>Internal state tracking for picker component.</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> */
<p>export interface PickerState&lt;T&gt; { /**</p>
   <ul><li>All loaded data for current page</li>
</ul>   */
<p>data: T[];</p>

<p>/**</p>
   <ul><li>Total count (for pagination)</li>
</ul>   */
<p>totalCount: number;</p>

<p>/**</p>
   <ul><li>Selected row keys (as Set for O(1) lookup)</li>
</ul>   */
<p>selectedKeys: Set&lt;string&gt;;</p>

<p>/**</p>
   <ul><li>Selected row objects</li>
</ul>   */
<p>selectedItems: T[];</p>

<p>/**</p>
   <ul><li>Loading state</li>
</ul>   */
<p>loading: boolean;</p>

<p>/**</p>
   <ul><li>Error state</li>
</ul>   */
<p>error: Error | null;</p>

<p>/**</p>
   <ul><li>Current page (0-indexed)</li>
</ul>   */
<p>currentPage: number;</p>

<p>/**</p>
   <ul><li>Page size</li>
</ul>   */
<p>pageSize: number;</p>

<p>/**</p>
   <ul><li>Search term from search box</li>
</ul>   */
<p>searchTerm: string;</p>

<p>/**</p>
   <ul><li>Current sort field</li>
</ul>   */
<p>sortField?: string;</p>

<p>/**</p>
   <ul><li>Current sort order</li>
</ul>   */
<p>sortOrder?: 1 | -1;</p>

<p>/**</p>
   <ul><li>Pending hydration keys (from URL, before data loads)</li>
</ul>   <ul><li>These are keys that should be selected once data loads</li>
</ul>   */
<p>pendingHydration: string[];</p>

<p>/**</p>
   <ul><li>Whether data has been loaded at least once</li>
</ul>   */
<p>dataLoaded: boolean; }</p>

<p>/**</p>
 <ul><li>Create default picker state</li>
</ul> *
 <ul><li>@template T - The data model type</li>
</ul> <ul><li>@param pageSize - Initial page size</li>
</ul> <ul><li>@returns Default PickerState</li>
</ul> */
<p>export function getDefaultPickerState&lt;T&gt;(pageSize: number = 20): PickerState&lt;T&gt; { return { data: [], totalCount: 0, selectedKeys: new Set&lt;string&gt;(), selectedItems: [], loading: false, error: null, currentPage: 0, pageSize, searchTerm: '', sortField: undefined, sortOrder: undefined, pendingHydration: [], dataLoaded: false }; }</p>

<p>/**</p>
 <ul><li>Create default picker pagination config</li>
</ul> *
 <ul><li>@returns Default PickerPaginationConfig</li>
</ul> */
<p>export function getDefaultPaginationConfig(): PickerPaginationConfig { return { mode: 'server', defaultPageSize: 20, pageSizeOptions: [10, 20, 50, 100] }; }</p>

<p>/**</p>
 <ul><li>Create default picker caching config</li>
</ul> *
 <ul><li>@param enabled - Whether caching is enabled</li>
</ul> <ul><li>@returns Default PickerCachingConfig</li>
</ul> */
<p>export function getDefaultCachingConfig(enabled: boolean = false): PickerCachingConfig { return { enabled, ttl: 300000 // 5 minutes }; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 205.2: Update the Barrel Export</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code> to include the new interface:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface'; export * from './resource-management.interface'; export * from './filter-definition.interface'; export * from './table-config.interface'; export * from './picker-config.interface';</p>
</code></pre>

<hr>

<h3>Step 205.3: Understand the Picker Architecture</h3>

<p>Pickers have three key responsibilities:</p>

<table>
<p><thead><tr> <th>Responsibility</th> <th>Configuration</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><strong>Data Fetching</strong></td> <td><code class="inline">api</code></td> <td>Load data from API with pagination/search</td></p>
</tr>
<p><tr> <td><strong>Row Identity</strong></td> <td><code class="inline">row</code></td> <td>Generate/parse unique keys for each row</td></p>
</tr>
<p><tr> <td><strong>URL Sync</strong></td> <td><code class="inline">selection</code></td> <td>Serialize/deserialize selections to/from URL</td></p>
</tr>
</tbody>
</table>

<p><strong>The hydration problem:</strong></p>

<p>When a user loads a URL like <code class="inline">?manufacturers=Ford,Toyota</code>, the picker must:</p>

<ul><li>Parse the URL to get selection keys: <code class="inline">["Ford", "Toyota"]</code></li>
<p><li>Store these as <code class="inline">pendingHydration</code></li> <li>Fetch data from API</li> <li>Match loaded data against pending keys</li> <li>Move matched items to <code class="inline">selectedItems</code></li></p>
</ul>
<p>This is why <code class="inline">keyParser</code> exists — it creates partial objects that can be matched against full data objects.</p>

<hr>

<h3>Step 205.4: Example Automobile Picker Configuration</h3>

<p>Here's how an automobile picker would be configured (you'll create this in Phase 6):</p>

<pre class="code-block typescript"><code>// Preview: src/app/domain-config/automobile/configs/automobile.picker-configs.ts

<p>import { PickerConfig, getDefaultPaginationConfig } from '@app/framework/models';</p>

<p>interface ManufacturerOption { name: string; country: string; vehicleCount: number; }</p>

<p>export const MANUFACTURER_PICKER_CONFIG: PickerConfig&lt;ManufacturerOption&gt; = { id: 'manufacturer-picker', displayName: 'Select Manufacturers', columns: [ { field: 'name', header: 'Manufacturer', sortable: true }, { field: 'country', header: 'Country', sortable: true }, { field: 'vehicleCount', header: 'Vehicles', sortable: true, align: 'right' } ], api: { fetchData: (params) =&gt; { // Injected via service return null as any; }, responseTransformer: (response) =&gt; ({ results: response.data, total: response.meta.total }) }, row: { keyGenerator: (row) =&gt; row.name, keyParser: (key) =&gt; ({ name: key }) }, selection: { mode: 'multiple', urlParam: 'manufacturer', serializer: (items) =&gt; items.map(i =&gt; i.name).join(','), deserializer: (url) =&gt; url.split(',').map(name =&gt; ({ name })) }, pagination: getDefaultPaginationConfig(), showSearch: true, searchPlaceholder: 'Search manufacturers...' };</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/picker-config.interface.ts
</code></pre>

<p>Expected output shows the file exists.</p>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/picker-config.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export" src/app/framework/models/picker-config.interface.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export interface PickerApiConfig&lt;T&gt; {
<p>export interface PickerApiParams { export interface PickerApiResponse&lt;T&gt; { export interface PickerRowConfig&lt;T&gt; { export interface PickerSelectionConfig&lt;T&gt; { export interface PickerPaginationConfig { export interface PickerCachingConfig { export interface PickerConfig&lt;T&gt; { export interface PickerSelectionEvent&lt;T&gt; { export interface PickerState&lt;T&gt; { export function getDefaultPickerState&lt;T&gt;(pageSize: number = 20): PickerState&lt;T&gt; { export function getDefaultPaginationConfig(): PickerPaginationConfig { export function getDefaultCachingConfig(enabled: boolean = false): PickerCachingConfig {</p>
</code></pre>

<h3>4. Verify Barrel Export</h3>

<pre class="code-block bash"><code>$ grep "picker-config" src/app/framework/models/index.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export * from './picker-config.interface';
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Observable is not defined</code></td> <td>Missing RxJS import</td> <td>Add <code class="inline">import { Observable } from 'rxjs';</code></td></p>
</tr>
<p><tr> <td><code class="inline">PrimeNGColumn is not defined</code></td> <td>Missing import</td> <td>Add <code class="inline">import { PrimeNGColumn } from './table-config.interface';</code></td></p>
</tr>
<p><tr> <td>Selections not persisting</td> <td>Wrong <code class="inline">urlParam</code></td> <td>Verify URL parameter name matches expected</td></p>
</tr>
<p><tr> <td>Hydration not working</td> <td><code class="inline">keyParser</code> returns wrong shape</td> <td>Ensure partial object matches data structure</td></p>
</tr>
<p><tr> <td>Duplicate selections</td> <td><code class="inline">keyGenerator</code> not unique</td> <td>Use unique identifier field(s)</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Pickers extend tables with URL-synchronized selection</strong> — User selections become shareable URLs</li>
<p><li><strong>Key generation/parsing enables hydration</strong> — Convert between data objects and URL-safe strings</li> <li><strong>Serialization/deserialization are symmetric</strong> — <code class="inline">deserialize(serialize(items))</code> should match original keys</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/picker-config.interface.ts</code> exists</li>
<p><li>[ ] <code class="inline">PickerConfig&lt;T&gt;</code> interface defines complete picker configuration</li> <li>[ ] <code class="inline">PickerApiConfig&lt;T&gt;</code> defines data fetching with transformer</li> <li>[ ] <code class="inline">PickerRowConfig&lt;T&gt;</code> defines key generation and parsing</li> <li>[ ] <code class="inline">PickerSelectionConfig&lt;T&gt;</code> defines URL serialization/deserialization</li> <li>[ ] <code class="inline">PickerState&lt;T&gt;</code> includes <code class="inline">pendingHydration</code> for URL restoration</li> <li>[ ] <code class="inline">PickerSelectionEvent&lt;T&gt;</code> defines selection change events</li> <li>[ ] Utility functions for default configs are implemented</li> <li>[ ] Barrel file exports all picker configuration types</li> <li>[ ] TypeScript compilation succeeds with no errors</li> <li>[ ] All interfaces have JSDoc documentation with examples</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">206-api-response-interface.md</code> to define the standard API response interface.</p></div></div>
    <div class="chapter" id="section-206">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>206: API Response Interface</h1>
        </div>
<div class="page-content"><h1>206: API Response Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 302-api-service</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand why standardized API response formats simplify frontend development</li>
<p><li>Know how TypeScript generics create type-safe response handling</li> <li>Recognize the relationship between API responses and pagination</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">ApiResponse</code> interface that defines the standard format for paginated API responses. This interface ensures consistency between backend responses and frontend expectations, enabling type-safe data handling throughout the application.</p>

<hr>

<h2>Why</h2>

<p>APIs return data in various formats. Without a standard, every component must handle response parsing differently:</p>

<pre class="code-block typescript"><code>// Anti-pattern: Ad-hoc response handling
<p>this.http.get('/vehicles').subscribe(response =&gt; { // Is it response.data? response.results? response.items? // Is total in response.total? response.meta.total? response.pagination.count? this.vehicles = response.data; // Hope this is right... this.total = response.meta?.total ?? response.total ?? 0; // Defensive coding });</p>
</code></pre>

<p>With a standardized <code class="inline">ApiResponse</code> interface:</p>

<pre class="code-block typescript"><code>// Better: Type-safe response handling
<p>this.http.get&lt;ApiResponse&lt;Vehicle&gt;&gt;('/vehicles').subscribe(response =&gt; { this.vehicles = response.results; // TypeScript knows this exists this.total = response.total;      // TypeScript knows this exists });</p>
</code></pre>

<h3>API Contract Alignment</h3>

<p>The <code class="inline">ApiResponse</code> interface aligns with the API contract defined in document 051 (API Contract Overview). The API server returns responses in this exact format:</p>

<pre class="code-block json"><code>{
<p>"results": [...], "total": 1234, "page": 1, "size": 20, "totalPages": 62, "statistics": { ... } }</p>
</code></pre>

<p>By defining this interface, the frontend and backend agree on the response shape. TypeScript enforces this agreement at compile time.</p>

<hr>

<h2>What</h2>

<h3>Step 206.1: Create the API Response Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/api-response.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/api-response.interface.ts
<p>// VERSION 1 (Section 206) - Standardized API response format</p>

<p>/**</p>
 <ul><li>Generic API response interface for paginated endpoints</li>
</ul> *
 <ul><li>This interface defines the standard response format for all paginated</li>
</ul> <ul><li>API endpoints in the vvroom application. Both the frontend and backend</li>
</ul> <ul><li>agree on this format, enabling type-safe data handling.</li>
</ul> *
 <ul><li>@template TData - The type of data items in the results array</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>interface Vehicle {</li>
</ul> <ul><li>  vin: string;</li>
</ul> <ul><li>  manufacturer: string;</li>
</ul> <ul><li>  model: string;</li>
</ul> <ul><li>  year: number;</li>
</ul> <ul><li>}</li>
</ul> *
 <ul><li>// Typed HTTP request</li>
</ul> <ul><li>this.http.get&lt;ApiResponse&lt;Vehicle&gt;&gt;('/api/vehicles', { params })</li>
</ul> <ul><li>  .subscribe(response =&gt; {</li>
</ul> <ul><li>    console.log(response.results);     // Vehicle[]</li>
</ul> <ul><li>    console.log(response.total);       // number</li>
</ul> <ul><li>    console.log(response.page);        // number</li>
</ul> <ul><li>    console.log(response.totalPages);  // number</li>
</ul> <ul><li>  });</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface ApiResponse&lt;TData&gt; { /**</p>
   <ul><li>Array of result items for the current page</li>
</ul>   */
<p>results: TData[];</p>

<p>/**</p>
   <ul><li>Total number of items across all pages</li>
</ul>   <ul><li>Used for pagination display: "Showing 1-20 of 1,234 results"</li>
</ul>   */
<p>total: number;</p>

<p>/**</p>
   <ul><li>Current page number (1-indexed)</li>
</ul>   <ul><li>Page 1 is the first page</li>
</ul>   */
<p>page: number;</p>

<p>/**</p>
   <ul><li>Number of items per page</li>
</ul>   <ul><li>Matches the <code class="inline">size</code> query parameter</li>
</ul>   */
<p>size: number;</p>

<p>/**</p>
   <ul><li>Total number of pages</li>
</ul>   <ul><li>Computed as: Math.ceil(total / size)</li>
</ul>   */
<p>totalPages: number;</p>

<p>/**</p>
   <ul><li>Optional statistics data (domain-specific)</li>
</ul>   <ul><li>Contains aggregations, counts, and other computed data</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li>statistics: {</li>
</ul>   <ul><li>  manufacturerCounts: { Ford: 150, Toyota: 120, Honda: 89 },</li>
</ul>   <ul><li>  yearRange: { min: 1990, max: 2024 },</li>
</ul>   <ul><li>  totalVins: 1234</li>
</ul>   <ul><li>}</li>
</ul>   */
<p>statistics?: any; }</p>

<p>/**</p>
 <ul><li>Generic error response from API</li>
</ul> *
 <ul><li>Defines the standard error format returned by the API server.</li>
</ul> <ul><li>All API errors follow this structure for consistent error handling.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>json</li>
</ul> <ul><li>{</li>
</ul> <ul><li>  "success": false,</li>
</ul> <ul><li>  "error": {</li>
</ul> <ul><li>    "code": "VALIDATION_ERROR",</li>
</ul> <ul><li>    "message": "Invalid year range: min cannot exceed max",</li>
</ul> <ul><li>    "details": {</li>
</ul> <ul><li>      "field": "yearMin",</li>
</ul> <ul><li>      "value": 2025,</li>
</ul> <ul><li>      "constraint": "must be less than or equal to yearMax"</li>
</ul> <ul><li>    }</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface ApiErrorResponse { /**</p>
   <ul><li>Success flag (always false for errors)</li>
</ul>   */
<p>success: false;</p>

<p>/**</p>
   <ul><li>Error details</li>
</ul>   */
<p>error: { /**</p>
     <ul><li>Error code for programmatic handling</li>
</ul>     <ul><li>@example 'VALIDATION_ERROR', 'NOT_FOUND', 'UNAUTHORIZED'</li>
</ul>     */
<p>code: string;</p>

<p>/**</p>
     <ul><li>Human-readable error message</li>
</ul>     <ul><li>Suitable for display to users</li>
</ul>     */
<p>message: string;</p>

<p>/**</p>
     <ul><li>Optional additional error details</li>
</ul>     <ul><li>Contains field-specific validation info, etc.</li>
</ul>     */
<p>details?: Record&lt;string, any&gt;; }; }</p>

<p>/**</p>
 <ul><li>Generic success response wrapper</li>
</ul> *
 <ul><li>For non-paginated endpoints that return a single object or operation result.</li>
</ul> *
 <ul><li>@template TData - The type of the response data</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Create vehicle response</li>
</ul> <ul><li>interface CreateVehicleResult {</li>
</ul> <ul><li>  vin: string;</li>
</ul> <ul><li>  created: boolean;</li>
</ul> <ul><li>}</li>
</ul> *
 <ul><li>this.http.post&lt;ApiSuccessResponse&lt;CreateVehicleResult&gt;&gt;('/api/vehicles', vehicle)</li>
</ul> <ul><li>  .subscribe(response =&gt; {</li>
</ul> <ul><li>    if (response.success) {</li>
</ul> <ul><li>      console.log('Created:', response.data.vin);</li>
</ul> <ul><li>    }</li>
</ul> <ul><li>  });</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface ApiSuccessResponse&lt;TData&gt; { /**</p>
   <ul><li>Success flag (always true for successful responses)</li>
</ul>   */
<p>success: true;</p>

<p>/**</p>
   <ul><li>Response data</li>
</ul>   */
<p>data: TData; }</p>

<p>/**</p>
 <ul><li>Standard API response type (success or error)</li>
</ul> *
 <ul><li>Union type for endpoints that may return either success or error.</li>
</ul> <ul><li>Use type guards to narrow the type:</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>function handleResponse(response: StandardApiResponse&lt;Vehicle&gt;) {</li>
</ul> <ul><li>  if (response.success) {</li>
</ul> <ul><li>    // TypeScript knows response.data exists here</li>
</ul> <ul><li>    console.log(response.data);</li>
</ul> <ul><li>  } else {</li>
</ul> <ul><li>    // TypeScript knows response.error exists here</li>
</ul> <ul><li>    console.error(response.error.message);</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export type StandardApiResponse&lt;TData&gt; = ApiSuccessResponse&lt;TData&gt; | ApiErrorResponse;</p>

<p>/**</p>
 <ul><li>Type guard: Check if response is a success response</li>
</ul> *
 <ul><li>@param response - API response to check</li>
</ul> <ul><li>@returns True if response is a success response</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const response = await firstValueFrom(http.get&lt;StandardApiResponse&lt;Vehicle&gt;&gt;(url));</li>
</ul> <ul><li>if (isSuccessResponse(response)) {</li>
</ul> <ul><li>  console.log(response.data); // TypeScript knows data exists</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function isSuccessResponse&lt;T&gt;( response: StandardApiResponse&lt;T&gt; ): response is ApiSuccessResponse&lt;T&gt; { return response.success === true; }</p>

<p>/**</p>
 <ul><li>Type guard: Check if response is an error response</li>
</ul> *
 <ul><li>@param response - API response to check</li>
</ul> <ul><li>@returns True if response is an error response</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const response = await firstValueFrom(http.get&lt;StandardApiResponse&lt;Vehicle&gt;&gt;(url));</li>
</ul> <ul><li>if (isErrorResponse(response)) {</li>
</ul> <ul><li>  console.error(response.error.message); // TypeScript knows error exists</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function isErrorResponse&lt;T&gt;( response: StandardApiResponse&lt;T&gt; ): response is ApiErrorResponse { return response.success === false; }</p>

<p>/**</p>
 <ul><li>Empty paginated response</li>
</ul> *
 <ul><li>Utility constant for initial state or empty results.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const [response, setResponse] = useState&lt;ApiResponse&lt;Vehicle&gt;&gt;(EMPTY_API_RESPONSE);</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const EMPTY_API_RESPONSE: ApiResponse&lt;never&gt; = { results: [], total: 0, page: 1, size: 20, totalPages: 0 };</p>

<p>/**</p>
 <ul><li>Create an empty ApiResponse with specified type</li>
</ul> *
 <ul><li>@template T - The data type</li>
</ul> <ul><li>@param size - Page size (default: 20)</li>
</ul> <ul><li>@returns Empty ApiResponse</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const initialState: ApiResponse&lt;Vehicle&gt; = createEmptyResponse(25);</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function createEmptyResponse&lt;T&gt;(size: number = 20): ApiResponse&lt;T&gt; { return { results: [], total: 0, page: 1, size, totalPages: 0 }; }</p>

<p>/**</p>
 <ul><li>Calculate total pages from total and page size</li>
</ul> *
 <ul><li>@param total - Total number of items</li>
</ul> <ul><li>@param size - Page size</li>
</ul> <ul><li>@returns Total number of pages</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>calculateTotalPages(100, 20); // Returns 5</li>
</ul> <ul><li>calculateTotalPages(101, 20); // Returns 6</li>
</ul> <ul><li>calculateTotalPages(0, 20);   // Returns 0</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function calculateTotalPages(total: number, size: number): number { if (total &lt;= 0 || size &lt;= 0) { return 0; } return Math.ceil(total / size); }</p>

<p>/**</p>
 <ul><li>Check if there are more pages after the current page</li>
</ul> *
 <ul><li>@param page - Current page (1-indexed)</li>
</ul> <ul><li>@param totalPages - Total number of pages</li>
</ul> <ul><li>@returns True if there are more pages</li>
</ul> */
<p>export function hasNextPage(page: number, totalPages: number): boolean { return page &lt; totalPages; }</p>

<p>/**</p>
 <ul><li>Check if there are previous pages before the current page</li>
</ul> *
 <ul><li>@param page - Current page (1-indexed)</li>
</ul> <ul><li>@returns True if there are previous pages</li>
</ul> */
<p>export function hasPreviousPage(page: number): boolean { return page &gt; 1; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 206.2: Update the Barrel Export</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code> to include the new interface:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface'; export * from './resource-management.interface'; export * from './filter-definition.interface'; export * from './table-config.interface'; export * from './picker-config.interface'; export * from './api-response.interface';</p>
</code></pre>

<hr>

<h3>Step 206.3: Understand the Response Types</h3>

<p>The API response interfaces cover three scenarios:</p>

<table>
<p><thead><tr> <th>Interface</th> <th>Use Case</th> <th>Example</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">ApiResponse&lt;T&gt;</code></td> <td>Paginated list endpoints</td> <td><code class="inline">GET /vehicles?page=1&amp;size=20</code></td></p>
</tr>
<p><tr> <td><code class="inline">ApiSuccessResponse&lt;T&gt;</code></td> <td>Non-paginated success responses</td> <td><code class="inline">POST /vehicles</code> (create)</td></p>
</tr>
<p><tr> <td><code class="inline">ApiErrorResponse</code></td> <td>Error responses</td> <td>Any failed request</td></p>
</tr>
</tbody>
</table>

<p><strong>The discriminated union pattern:</strong></p>

<p><code class="inline">StandardApiResponse&lt;T&gt;</code> uses a discriminated union based on the <code class="inline">success</code> property:</p>

<pre class="code-block typescript"><code>// TypeScript can narrow the type based on success
<p>const response: StandardApiResponse&lt;Vehicle&gt; = await getVehicle(vin);</p>

<p>if (response.success) { // Here, TypeScript knows response is ApiSuccessResponse&lt;Vehicle&gt; console.log(response.data.manufacturer); } else { // Here, TypeScript knows response is ApiErrorResponse console.error(response.error.code); }</p>
</code></pre>

<p>This pattern eliminates runtime type errors by leveraging TypeScript's type narrowing.</p>

<hr>

<h3>Step 206.4: Example Usage in Services</h3>

<p>Here's how the API response interfaces are used (preview for Phase 3):</p>

<pre class="code-block typescript"><code>// Preview: API Service usage

<p>import { ApiResponse, isSuccessResponse } from '@app/framework/models';</p>

<p>@Injectable({ providedIn: 'root' }) export class AutomobileApiService { constructor(private http: HttpClient) {}</p>

<p>getVehicles(params: HttpParams): Observable&lt;ApiResponse&lt;Vehicle&gt;&gt; { return this.http.get&lt;ApiResponse&lt;Vehicle&gt;&gt;('/api/vehicles', { params }); }</p>

<p>// Usage in component loadVehicles(): void { this.apiService.getVehicles(params).subscribe(response =&gt; { // Full type safety - TypeScript knows the shape this.vehicles = response.results; this.total = response.total; this.currentPage = response.page; this.totalPages = response.totalPages; }); } }</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/api-response.interface.ts
</code></pre>

<p>Expected output shows the file exists.</p>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/api-response.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export" src/app/framework/models/api-response.interface.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export interface ApiResponse&lt;TData&gt; {
<p>export interface ApiErrorResponse { export interface ApiSuccessResponse&lt;TData&gt; { export type StandardApiResponse&lt;TData&gt; = ApiSuccessResponse&lt;TData&gt; | ApiErrorResponse; export function isSuccessResponse&lt;T&gt;( export function isErrorResponse&lt;T&gt;( export const EMPTY_API_RESPONSE: ApiResponse&lt;never&gt; = { export function createEmptyResponse&lt;T&gt;(size: number = 20): ApiResponse&lt;T&gt; { export function calculateTotalPages(total: number, size: number): number { export function hasNextPage(page: number, totalPages: number): boolean { export function hasPreviousPage(page: number): boolean {</p>
</code></pre>

<h3>4. Verify Barrel Export</h3>

<pre class="code-block bash"><code>$ grep "api-response" src/app/framework/models/index.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export * from './api-response.interface';
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Property 'results' does not exist</code></td> <td>Response not typed</td> <td>Add generic: <code class="inline">http.get&lt;ApiResponse&lt;T&gt;&gt;(...)</code></td></p>
</tr>
<p><tr> <td>Type guard not narrowing</td> <td>Using wrong comparison</td> <td>Use <code class="inline">response.success === true</code> (strict)</td></p>
</tr>
<p><tr> <td><code class="inline">statistics</code> showing error</td> <td>Using without check</td> <td>Add optional chaining: <code class="inline">response.statistics?.field</code></td></p>
</tr>
<p><tr> <td>Page calculation wrong</td> <td>Off-by-one error</td> <td>Remember: API pages are 1-indexed</td></p>
</tr>
<p><tr> <td>Empty response type error</td> <td>Using wrong generic</td> <td>Use <code class="inline">createEmptyResponse&lt;YourType&gt;()</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Standardized response formats simplify development</strong> — One interface, consistent handling everywhere</li>
<p><li><strong>Type guards enable safe type narrowing</strong> — <code class="inline">isSuccessResponse()</code> and <code class="inline">isErrorResponse()</code> for discriminated unions</li> <li><strong>Utility functions reduce boilerplate</strong> — <code class="inline">calculateTotalPages()</code>, <code class="inline">hasNextPage()</code>, etc.</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/api-response.interface.ts</code> exists</li>
<p><li>[ ] <code class="inline">ApiResponse&lt;TData&gt;</code> interface defines paginated response format</li> <li>[ ] <code class="inline">ApiErrorResponse</code> interface defines error response format</li> <li>[ ] <code class="inline">ApiSuccessResponse&lt;TData&gt;</code> interface defines success wrapper</li> <li>[ ] <code class="inline">StandardApiResponse&lt;TData&gt;</code> type union is defined</li> <li>[ ] Type guards <code class="inline">isSuccessResponse</code> and <code class="inline">isErrorResponse</code> are implemented</li> <li>[ ] Utility functions for pagination are implemented</li> <li>[ ] <code class="inline">EMPTY_API_RESPONSE</code> constant is defined</li> <li>[ ] Barrel file exports all API response types</li> <li>[ ] TypeScript compilation succeeds with no errors</li> <li>[ ] All interfaces have JSDoc documentation with examples</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">207-pagination-interface.md</code> to define pagination parameter interfaces.</p></div></div>
    <div class="chapter" id="section-207">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>207: Pagination Interface</h1>
        </div>
<div class="page-content"><h1>207: Pagination Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 206-api-response-interface <strong>Blocks:</strong> 302-api-service, 803-basic-results-table</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the difference between pagination parameters (request) and metadata (response)</li>
<p><li>Know how to combine pagination with sorting for API requests</li> <li>Recognize the relationship between URL state and pagination</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the pagination interfaces that define how pagination and sorting parameters are structured for API requests and responses. These interfaces complement the <code class="inline">ApiResponse</code> interface by defining the input side of paginated queries.</p>

<hr>

<h2>Why</h2>

<p>Pagination in vvroom follows the URL-First architecture. When a user navigates to:</p>

<pre class="code-block text"><code>/discover?manufacturer=Ford&amp;page=2&amp;size=50&amp;sortBy=year&amp;sortOrder=desc
</code></pre>

<p>The application must:</p>
<ul><li>Parse <code class="inline">page=2</code>, <code class="inline">size=50</code> into <code class="inline">PaginationParams</code></li>
<p><li>Parse <code class="inline">sortBy=year</code>, <code class="inline">sortOrder=desc</code> into <code class="inline">SortParams</code></li> <li>Send these to the API</li> <li>Receive <code class="inline">PaginationMetadata</code> in the response</li></p>
</ul>
<p>The interfaces in this document define these structures, ensuring consistency between URL state, API requests, and response handling.</p>

<p><strong>Request flow:</strong></p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│  URL: ?page=2&amp;size=50&amp;sortBy=year&amp;sortOrder=desc                 │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  Parse into typed objects:                                       │ │  PaginationParams { page: 2, size: 50 }                          │ │  SortParams { sortBy: 'year', sortOrder: 'desc' }                │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  API Request: GET /vehicles?page=2&amp;size=50&amp;sort=year:desc        │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  Response includes PaginationMetadata:                           │ │  { page: 2, size: 50, total: 1234, totalPages: 25, hasMore: true }│ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 207.1: Create the Pagination Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/pagination.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/pagination.interface.ts
<p>// VERSION 1 (Section 207) - Pagination and sorting interfaces</p>

<p>/**</p>
 <ul><li>Pagination Interfaces</li>
</ul> *
 <ul><li>These interfaces define pagination and sorting parameters for API requests</li>
</ul> <ul><li>and responses. They complement the ApiResponse interface by defining</li>
</ul> <ul><li>the input/output structures for paginated queries.</li>
</ul> */

<p>/**</p>
 <ul><li>Pagination parameters for API requests</li>
</ul> *
 <ul><li>Represents the pagination portion of an API request.</li>
</ul> <ul><li>These values are derived from URL query parameters.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// From URL: ?page=2&amp;size=50</li>
</ul> <ul><li>const params: PaginationParams = {</li>
</ul> <ul><li>  page: 2,</li>
</ul> <ul><li>  size: 50</li>
</ul> <ul><li>};</li>
</ul> *
 <ul><li>// Convert to HTTP params</li>
</ul> <ul><li>const httpParams = new HttpParams()</li>
</ul> <ul><li>  .set('page', params.page.toString())</li>
</ul> <ul><li>  .set('size', params.size.toString());</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface PaginationParams { /**</p>
   <ul><li>Page number (1-indexed)</li>
</ul>   <ul><li>Page 1 is the first page of results</li>
</ul>   */
<p>page: number;</p>

<p>/**</p>
   <ul><li>Number of items per page</li>
</ul>   <ul><li>Common values: 10, 20, 50, 100</li>
</ul>   */
<p>size: number; }</p>

<p>/**</p>
 <ul><li>Pagination metadata from API responses</li>
</ul> *
 <ul><li>Contains complete pagination information returned by the API.</li>
</ul> <ul><li>Use this to display pagination controls and navigation.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Display pagination info</li>
</ul> <ul><li>const metadata: PaginationMetadata = response.pagination;</li>
</ul> <ul><li>console.log(<code class="inline">Page ${metadata.page} of ${metadata.totalPages}</code>);</li>
</ul> <ul><li>console.log(<code class="inline">Showing ${metadata.size} of ${metadata.total} results</code>);</li>
</ul> *
 <ul><li>if (metadata.hasMore) {</li>
</ul> <ul><li>  showNextButton();</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface PaginationMetadata { /**</p>
   <ul><li>Current page number (1-indexed)</li>
</ul>   */
<p>page: number;</p>

<p>/**</p>
   <ul><li>Number of items per page</li>
</ul>   */
<p>size: number;</p>

<p>/**</p>
   <ul><li>Total number of items across all pages</li>
</ul>   */
<p>total: number;</p>

<p>/**</p>
   <ul><li>Total number of pages</li>
</ul>   <ul><li>Computed as: Math.ceil(total / size)</li>
</ul>   */
<p>totalPages: number;</p>

<p>/**</p>
   <ul><li>Whether there are more pages after current page</li>
</ul>   <ul><li>Equivalent to: page &lt; totalPages</li>
</ul>   */
<p>hasMore: boolean; }</p>

<p>/**</p>
 <ul><li>Sorting parameters for API requests</li>
</ul> *
 <ul><li>Represents the sorting portion of an API request.</li>
</ul> <ul><li>These values are derived from URL query parameters.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// From URL: ?sortBy=year&amp;sortOrder=desc</li>
</ul> <ul><li>const params: SortParams = {</li>
</ul> <ul><li>  sortBy: 'year',</li>
</ul> <ul><li>  sortOrder: 'desc'</li>
</ul> <ul><li>};</li>
</ul> *
 <ul><li>// Convert to HTTP params (API-specific format)</li>
</ul> <ul><li>const sortParam = <code class="inline">${params.sortBy}:${params.sortOrder}</code>;</li>
</ul> <ul><li>// Results in: sort=year:desc</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface SortParams { /**</p>
   <ul><li>Field to sort by</li>
</ul>   <ul><li>Must match a field name in the data model</li>
</ul>   */
<p>sortBy?: string;</p>

<p>/**</p>
   <ul><li>Sort direction</li>
</ul>   <ul><li>- 'asc': Ascending (A-Z, 1-9, oldest first)</li>
</ul>   <ul><li>- 'desc': Descending (Z-A, 9-1, newest first)</li>
</ul>   */
<p>sortOrder?: 'asc' | 'desc'; }</p>

<p>/**</p>
 <ul><li>Combined pagination and sort parameters</li>
</ul> *
 <ul><li>Convenience interface for endpoints that support both pagination and sorting.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Build from URL state</li>
</ul> <ul><li>const params: PaginatedSortParams = {</li>
</ul> <ul><li>  page: 1,</li>
</ul> <ul><li>  size: 20,</li>
</ul> <ul><li>  sortBy: 'manufacturer',</li>
</ul> <ul><li>  sortOrder: 'asc'</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface PaginatedSortParams extends PaginationParams, SortParams {}</p>

<p>/**</p>
 <ul><li>Default pagination parameters</li>
</ul> */
<p>export const DEFAULT_PAGINATION: PaginationParams = { page: 1, size: 20 };</p>

<p>/**</p>
 <ul><li>Default sort parameters (no sorting)</li>
</ul> */
<p>export const DEFAULT_SORT: SortParams = { sortBy: undefined, sortOrder: undefined };</p>

<p>/**</p>
 <ul><li>Common page size options</li>
</ul> */
<p>export const PAGE_SIZE_OPTIONS: number[] = [10, 20, 50, 100];</p>

<p>/**</p>
 <ul><li>Create pagination metadata from response data</li>
</ul> *
 <ul><li>Utility function to construct PaginationMetadata from API response.</li>
</ul> *
 <ul><li>@param page - Current page number</li>
</ul> <ul><li>@param size - Items per page</li>
</ul> <ul><li>@param total - Total items</li>
</ul> <ul><li>@returns Complete PaginationMetadata object</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const response = await fetchData();</li>
</ul> <ul><li>const metadata = createPaginationMetadata(</li>
</ul> <ul><li>  response.page,</li>
</ul> <ul><li>  response.size,</li>
</ul> <ul><li>  response.total</li>
</ul> <ul><li>);</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function createPaginationMetadata( page: number, size: number, total: number ): PaginationMetadata { const totalPages = size &gt; 0 ? Math.ceil(total / size) : 0; return { page, size, total, totalPages, hasMore: page &lt; totalPages }; }</p>

<p>/**</p>
 <ul><li>Parse pagination from URL query parameters</li>
</ul> *
 <ul><li>@param params - URL query parameters</li>
</ul> <ul><li>@param defaults - Default values to use if not in URL</li>
</ul> <ul><li>@returns Parsed PaginationParams</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const urlParams = new URLSearchParams(location.search);</li>
</ul> <ul><li>const pagination = parsePaginationFromUrl({</li>
</ul> <ul><li>  page: urlParams.get('page'),</li>
</ul> <ul><li>  size: urlParams.get('size')</li>
</ul> <ul><li>});</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function parsePaginationFromUrl( params: { page?: string | null; size?: string | null }, defaults: PaginationParams = DEFAULT_PAGINATION ): PaginationParams { return { page: params.page ? parseInt(params.page, 10) : defaults.page, size: params.size ? parseInt(params.size, 10) : defaults.size }; }</p>

<p>/**</p>
 <ul><li>Parse sort from URL query parameters</li>
</ul> *
 <ul><li>@param params - URL query parameters</li>
</ul> <ul><li>@returns Parsed SortParams</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const urlParams = new URLSearchParams(location.search);</li>
</ul> <ul><li>const sort = parseSortFromUrl({</li>
</ul> <ul><li>  sortBy: urlParams.get('sortBy'),</li>
</ul> <ul><li>  sortOrder: urlParams.get('sortOrder')</li>
</ul> <ul><li>});</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function parseSortFromUrl( params: { sortBy?: string | null; sortOrder?: string | null } ): SortParams { const sortOrder = params.sortOrder?.toLowerCase(); return { sortBy: params.sortBy || undefined, sortOrder: sortOrder === 'asc' || sortOrder === 'desc' ? sortOrder : undefined }; }</p>

<p>/**</p>
 <ul><li>Convert pagination params to URL query parameters</li>
</ul> *
 <ul><li>@param pagination - Pagination parameters</li>
</ul> <ul><li>@returns Object with string values for URL</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const urlParams = paginationToUrlParams({ page: 2, size: 50 });</li>
</ul> <ul><li>// { page: '2', size: '50' }</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function paginationToUrlParams( pagination: PaginationParams ): { page: string; size: string } { return { page: pagination.page.toString(), size: pagination.size.toString() }; }</p>

<p>/**</p>
 <ul><li>Convert sort params to URL query parameters</li>
</ul> *
 <ul><li>@param sort - Sort parameters</li>
</ul> <ul><li>@returns Object with string values for URL (empty object if no sort)</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const urlParams = sortToUrlParams({ sortBy: 'year', sortOrder: 'desc' });</li>
</ul> <ul><li>// { sortBy: 'year', sortOrder: 'desc' }</li>
</ul> *
 <ul><li>const noSort = sortToUrlParams({});</li>
</ul> <ul><li>// {}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function sortToUrlParams( sort: SortParams ): { sortBy?: string; sortOrder?: string } { const result: { sortBy?: string; sortOrder?: string } = {};</p>

<p>if (sort.sortBy) { result.sortBy = sort.sortBy; }</p>

<p>if (sort.sortOrder) { result.sortOrder = sort.sortOrder; }</p>

<p>return result; }</p>

<p>/**</p>
 <ul><li>Calculate the range of items shown on current page</li>
</ul> *
 <ul><li>@param page - Current page (1-indexed)</li>
</ul> <ul><li>@param size - Items per page</li>
</ul> <ul><li>@param total - Total items</li>
</ul> <ul><li>@returns Object with start and end indices (1-indexed, inclusive)</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const range = getPageRange(2, 20, 45);</li>
</ul> <ul><li>// { start: 21, end: 40 }</li>
</ul> *
 <ul><li>const lastPage = getPageRange(3, 20, 45);</li>
</ul> <ul><li>// { start: 41, end: 45 }</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function getPageRange( page: number, size: number, total: number ): { start: number; end: number } { if (total === 0) { return { start: 0, end: 0 }; }</p>

<p>const start = (page - 1) * size + 1; const end = Math.min(page * size, total);</p>

<p>return { start, end }; }</p>

<p>/**</p>
 <ul><li>Format pagination for display</li>
</ul> *
 <ul><li>@param page - Current page</li>
</ul> <ul><li>@param size - Items per page</li>
</ul> <ul><li>@param total - Total items</li>
</ul> <ul><li>@returns Formatted string like "Showing 21-40 of 1,234 results"</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const display = formatPaginationDisplay(2, 20, 1234);</li>
</ul> <ul><li>// "Showing 21-40 of 1,234 results"</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function formatPaginationDisplay( page: number, size: number, total: number ): string { if (total === 0) { return 'No results'; }</p>

<p>const { start, end } = getPageRange(page, size, total); const formattedTotal = total.toLocaleString();</p>

<p>return <code class="inline">Showing ${start}-${end} of ${formattedTotal} results</code>; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 207.2: Update the Barrel Export</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code> to include the new interface:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface'; export * from './resource-management.interface'; export * from './filter-definition.interface'; export * from './table-config.interface'; export * from './picker-config.interface'; export * from './api-response.interface'; export * from './pagination.interface';</p>
</code></pre>

<hr>

<h3>Step 207.3: Understand the Pagination Flow</h3>

<p>The pagination interfaces connect URL state to API requests:</p>

<table>
<p><thead><tr> <th>Layer</th> <th>Interface</th> <th>Example</th></p>
</tr></thead>
<p><tbody> <tr> <td><strong>URL</strong></td> <td>String params</td> <td><code class="inline">?page=2&amp;size=50&amp;sortBy=year</code></td></p>
</tr>
<p><tr> <td><strong>Parse</strong></td> <td><code class="inline">PaginationParams</code>, <code class="inline">SortParams</code></td> <td><code class="inline">{ page: 2, size: 50 }</code>, <code class="inline">{ sortBy: 'year' }</code></td></p>
</tr>
<p><tr> <td><strong>API Request</strong></td> <td>Combined params</td> <td><code class="inline">GET /vehicles?page=2&amp;size=50&amp;sort=year</code></td></p>
</tr>
<p><tr> <td><strong>API Response</strong></td> <td><code class="inline">PaginationMetadata</code> in <code class="inline">ApiResponse</code></td> <td><code class="inline">{ page: 2, size: 50, total: 1234, ... }</code></td></p>
</tr>
</tbody>
</table>

<p>The utility functions handle conversions between these layers.</p>

<hr>

<h3>Step 207.4: Example Usage</h3>

<p>Here's how pagination interfaces are used throughout the application:</p>

<pre class="code-block typescript"><code>// In a component
<p>import { PaginationParams, SortParams, parsePaginationFromUrl, parseSortFromUrl, formatPaginationDisplay } from '@app/framework/models';</p>

<p>@Component({...}) export class DiscoverComponent implements OnInit { pagination: PaginationMetadata;</p>

<p>constructor(private route: ActivatedRoute) {}</p>

<p>ngOnInit(): void { this.route.queryParams.subscribe(params =&gt; { // Parse pagination from URL const pagination = parsePaginationFromUrl({ page: params['page'], size: params['size'] });</p>

<p>// Parse sort from URL const sort = parseSortFromUrl({ sortBy: params['sortBy'], sortOrder: params['sortOrder'] });</p>

<p>// Fetch data with these params this.loadData(pagination, sort); }); }</p>

<p>get paginationDisplay(): string { return formatPaginationDisplay( this.pagination.page, this.pagination.size, this.pagination.total ); } }</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/pagination.interface.ts
</code></pre>

<p>Expected output shows the file exists.</p>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/pagination.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export" src/app/framework/models/pagination.interface.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export interface PaginationParams {
<p>export interface PaginationMetadata { export interface SortParams { export interface PaginatedSortParams extends PaginationParams, SortParams {} export const DEFAULT_PAGINATION: PaginationParams = { export const DEFAULT_SORT: SortParams = { export const PAGE_SIZE_OPTIONS: number[] = [10, 20, 50, 100]; export function createPaginationMetadata( export function parsePaginationFromUrl( export function parseSortFromUrl( export function paginationToUrlParams( export function sortToUrlParams( export function getPageRange( export function formatPaginationDisplay(</p>
</code></pre>

<h3>4. Verify Barrel Export</h3>

<pre class="code-block bash"><code>$ grep "pagination" src/app/framework/models/index.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export * from './pagination.interface';
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Page showing 0 results</td> <td>Page is 0-indexed in code but 1-indexed in API</td> <td>Use 1-indexed pages consistently</td></p>
</tr>
<p><tr> <td>Sort not applied</td> <td><code class="inline">sortBy</code> is undefined</td> <td>Check URL param parsing</td></p>
</tr>
<p><tr> <td>Pagination display wrong</td> <td>Off-by-one in range calculation</td> <td>Use <code class="inline">getPageRange</code> helper</td></p>
</tr>
<p><tr> <td><code class="inline">hasMore</code> always false</td> <td>Total not set correctly</td> <td>Verify API returns total count</td></p>
</tr>
<p><tr> <td>NaN in pagination</td> <td>String not parsed</td> <td>Use <code class="inline">parseInt()</code> with radix 10</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Separate input params from output metadata</strong> — <code class="inline">PaginationParams</code> for requests, <code class="inline">PaginationMetadata</code> for responses</li>
<p><li><strong>Utility functions handle URL &lt;-&gt; object conversion</strong> — Consistent parsing and formatting</li> <li><strong>1-indexed pages match user expectations</strong> — Page 1 is the first page, not page 0</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/pagination.interface.ts</code> exists</li>
<p><li>[ ] <code class="inline">PaginationParams</code> interface defines page and size</li> <li>[ ] <code class="inline">PaginationMetadata</code> interface includes hasMore boolean</li> <li>[ ] <code class="inline">SortParams</code> interface defines sortBy and sortOrder</li> <li>[ ] <code class="inline">PaginatedSortParams</code> combines both interfaces</li> <li>[ ] Default constants <code class="inline">DEFAULT_PAGINATION</code>, <code class="inline">DEFAULT_SORT</code> are defined</li> <li>[ ] <code class="inline">PAGE_SIZE_OPTIONS</code> constant provides common page sizes</li> <li>[ ] Parsing functions handle null/undefined gracefully</li> <li>[ ] <code class="inline">formatPaginationDisplay</code> produces user-friendly output</li> <li>[ ] Barrel file exports all pagination types</li> <li>[ ] TypeScript compilation succeeds with no errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">208-popout-interface.md</code> to define the pop-out window communication interfaces.</p></div></div>
    <div class="chapter" id="section-208">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>208: Popout Interface</h1>
        </div>
<div class="page-content"><h1>208: Popout Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 307-popout-context-service, 308-popout-manager-service, 904-popout-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how pop-out windows communicate with the parent application</li>
<p><li>Know how to use the BroadcastChannel API for cross-window messaging</li> <li>Recognize the challenges of maintaining state synchronization across windows</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the popout interfaces that define how pop-out windows communicate with the parent application. These interfaces establish the message protocol, window configuration, and context tracking needed for the pop-out feature.</p>

<hr>

<h2>Why</h2>

<p>The vvroom application supports "pop-out" functionality: users can detach panels (charts, pickers, filters) into separate browser windows. This is powerful for multi-monitor setups where users might want a chart on one screen while filtering on another.</p>

<p><strong>The challenge:</strong> How do separate browser windows share state?</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│  Parent Window (Main Application)                                │ │  - Controls URL state                                            │ │  - Manages filter selections                                     │ │  - Coordinates all pop-outs                                      │ └─────────────────────────────────────────────────────────────────┘ │                           │                           │ │ BroadcastChannel          │                           │ ▼                           ▼                           ▼ ┌───────────────────┐    ┌───────────────────┐    ┌───────────────────┐ │   Pop-out: Chart  │    │  Pop-out: Picker  │    │ Pop-out: Filters  │ │   (Separate Tab)  │    │  (Separate Tab)   │    │  (Separate Tab)   │ └───────────────────┘    └───────────────────┘    └───────────────────┘</p>
</code></pre>

<p><strong>Solution:</strong> The <a href="https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel">BroadcastChannel API</a> allows communication between browser contexts (tabs, windows, iframes) on the same origin.</p>

<p>The popout interfaces define:</p>
<ul><li><strong>Message types</strong> — What kinds of messages can be sent</li>
<p><li><strong>Message payloads</strong> — What data each message contains</li> <li><strong>Window configuration</strong> — Size, position, features</li> <li><strong>Context tracking</strong> — Is this window a pop-out? Which panel?</li></ul></p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 208.1: Create the Popout Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/popout.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/popout.interface.ts
<p>// VERSION 1 (Section 208) - Pop-out window communication interfaces</p>

<p>/**</p>
 <ul><li>Popout Interfaces</li>
</ul> *
 <ul><li>Defines the communication protocol between the parent application</li>
</ul> <ul><li>and pop-out windows. Uses BroadcastChannel API for cross-window messaging.</li>
</ul> */

<p>/**</p>
 <ul><li>Pop-out message structure</li>
</ul> *
 <ul><li>All messages between parent and pop-out windows follow this format.</li>
</ul> *
 <ul><li>@template T - The payload type for this message</li>
</ul> */
<p>export interface PopOutMessage&lt;T = any&gt; { /**</p>
   <ul><li>Message type identifier</li>
</ul>   */
<p>type: PopOutMessageType;</p>

<p>/**</p>
   <ul><li>Message payload (type depends on message type)</li>
</ul>   */
<p>payload?: T;</p>

<p>/**</p>
   <ul><li>Timestamp when message was created</li>
</ul>   <ul><li>Used for debugging and ordering</li>
</ul>   */
<p>timestamp?: number; }</p>

<p>/**</p>
 <ul><li>Pop-out message types</li>
</ul> *
 <ul><li>Enumeration of all possible message types in the pop-out protocol.</li>
</ul> */
<p>export enum PopOutMessageType { /**</p>
   <ul><li>State update from parent to pop-out</li>
</ul>   <ul><li>Sent when URL/filter state changes</li>
</ul>   */
<p>STATE_UPDATE = 'STATE_UPDATE',</p>

<p>/**</p>
   <ul><li>Request to close a pop-out window</li>
</ul>   <ul><li>Sent from parent when pop-out should be closed</li>
</ul>   */
<p>CLOSE_POPOUT = 'CLOSE_POPOUT',</p>

<p>/**</p>
   <ul><li>Pop-out panel is ready to receive messages</li>
</ul>   <ul><li>Sent from pop-out after initialization</li>
</ul>   */
<p>PANEL_READY = 'PANEL_READY',</p>

<p>/**</p>
   <ul><li>Picker selection changed in pop-out</li>
</ul>   <ul><li>Sent from pop-out picker to update parent URL</li>
</ul>   */
<p>PICKER_SELECTION_CHANGE = 'PICKER_SELECTION_CHANGE',</p>

<p>/**</p>
   <ul><li>Filter added in pop-out</li>
</ul>   <ul><li>Sent from pop-out filter panel to update parent URL</li>
</ul>   */
<p>FILTER_ADD = 'FILTER_ADD',</p>

<p>/**</p>
   <ul><li>Filter removed in pop-out</li>
</ul>   <ul><li>Sent from pop-out filter panel to update parent URL</li>
</ul>   */
<p>FILTER_REMOVE = 'FILTER_REMOVE',</p>

<p>/**</p>
   <ul><li>Highlight removed in pop-out</li>
</ul>   <em> Sent from pop-out to remove h_</em> parameter
<p>*/ HIGHLIGHT_REMOVE = 'HIGHLIGHT_REMOVE',</p>

<p>/**</p>
   <ul><li>Clear all highlights</li>
</ul>   <em> Sent from pop-out to remove all h_</em> parameters
<p>*/ CLEAR_HIGHLIGHTS = 'CLEAR_HIGHLIGHTS',</p>

<p>/**</p>
   <ul><li>Clear all filters</li>
</ul>   <ul><li>Sent from pop-out to reset all filters</li>
</ul>   */
<p>CLEAR_ALL_FILTERS = 'CLEAR_ALL_FILTERS',</p>

<p>/**</p>
   <ul><li>URL parameters changed in parent</li>
</ul>   <ul><li>Sent to pop-outs when URL updates</li>
</ul>   */
<p>URL_PARAMS_CHANGED = 'URL_PARAMS_CHANGED',</p>

<p>/**</p>
   <ul><li>Request URL parameter sync</li>
</ul>   <ul><li>Pop-out requests current URL state from parent</li>
</ul>   */
<p>URL_PARAMS_SYNC = 'URL_PARAMS_SYNC',</p>

<p>/**</p>
   <ul><li>Chart element clicked in pop-out</li>
</ul>   <ul><li>Sent to parent to apply filter from chart click</li>
</ul>   */
<p>CHART_CLICK = 'CHART_CLICK' }</p>

<p>/**</p>
 <ul><li>Payload for picker selection change messages</li>
</ul> */
<p>export interface PickerSelectionPayload { /**</p>
   <ul><li>Picker configuration ID</li>
</ul>   */
<p>configId: string;</p>

<p>/**</p>
   <ul><li>URL parameter name for this picker's selections</li>
</ul>   */
<p>urlParam: string;</p>

<p>/**</p>
   <ul><li>Serialized selection value for URL</li>
</ul>   */
<p>urlValue: string; }</p>

<p>/**</p>
 <ul><li>Reference to an open pop-out window</li>
</ul> *
 <ul><li>Used by PopOutManagerService to track and manage pop-out windows.</li>
</ul> */
<p>export interface PopOutWindowRef { /**</p>
   <ul><li>Reference to the Window object</li>
</ul>   */
<p>window: Window;</p>

<p>/**</p>
   <ul><li>BroadcastChannel for communication</li>
</ul>   */
<p>channel: BroadcastChannel;</p>

<p>/**</p>
   <ul><li>Interval ID for checking if window is still open</li>
</ul>   */
<p>checkInterval: number;</p>

<p>/**</p>
   <ul><li>Panel ID within the grid</li>
</ul>   */
<p>panelId: string;</p>

<p>/**</p>
   <ul><li>Panel type (e.g., 'chart', 'picker', 'filter')</li>
</ul>   */
<p>panelType: string; }</p>

<p>/**</p>
 <ul><li>Window features for pop-out creation</li>
</ul> *
 <ul><li>Configures the appearance and behavior of pop-out windows.</li>
</ul> */
<p>export interface PopOutWindowFeatures { /**</p>
   <ul><li>Window width in pixels</li>
</ul>   <ul><li>@default 1200</li>
</ul>   */
<p>width?: number;</p>

<p>/**</p>
   <ul><li>Window height in pixels</li>
</ul>   <ul><li>@default 800</li>
</ul>   */
<p>height?: number;</p>

<p>/**</p>
   <ul><li>Left position in pixels</li>
</ul>   <ul><li>@default 100</li>
</ul>   */
<p>left?: number;</p>

<p>/**</p>
   <ul><li>Top position in pixels</li>
</ul>   <ul><li>@default 100</li>
</ul>   */
<p>top?: number;</p>

<p>/**</p>
   <ul><li>Show menu bar</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>menubar?: boolean;</p>

<p>/**</p>
   <ul><li>Show toolbar</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>toolbar?: boolean;</p>

<p>/**</p>
   <ul><li>Show location/address bar</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>location?: boolean;</p>

<p>/**</p>
   <ul><li>Show status bar</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>status?: boolean;</p>

<p>/**</p>
   <ul><li>Allow window resizing</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>resizable?: boolean;</p>

<p>/**</p>
   <ul><li>Show scrollbars when needed</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>scrollbars?: boolean; }</p>

<p>/**</p>
 <ul><li>Route parameters for pop-out URLs</li>
</ul> *
 <ul><li>Pop-out windows use a special route format:</li>
</ul> <ul><li>/popout/:gridId/:panelId/:type</li>
</ul> */
<p>export interface PopOutRouteParams { /**</p>
   <ul><li>Grid container ID (e.g., 'automobile-discover')</li>
</ul>   */
<p>gridId: string;</p>

<p>/**</p>
   <ul><li>Panel ID within the grid (e.g., 'chart-year')</li>
</ul>   */
<p>panelId: string;</p>

<p>/**</p>
   <ul><li>Panel type (e.g., 'chart', 'picker', 'table')</li>
</ul>   */
<p>type: string; }</p>

<p>/**</p>
 <ul><li>Pop-out context information</li>
</ul> *
 <ul><li>Provides context about whether the current window is a pop-out</li>
</ul> <ul><li>and what panel it represents.</li>
</ul> */
<p>export interface PopOutContext { /**</p>
   <ul><li>Whether this window is a pop-out (vs main application)</li>
</ul>   */
<p>isPopOut: boolean;</p>

<p>/**</p>
   <ul><li>Panel ID if this is a pop-out</li>
</ul>   */
<p>panelId?: string;</p>

<p>/**</p>
   <ul><li>Grid ID if this is a pop-out</li>
</ul>   */
<p>gridId?: string;</p>

<p>/**</p>
   <ul><li>Panel type if this is a pop-out</li>
</ul>   */
<p>panelType?: string; }</p>

<p>/**</p>
 <ul><li>Build window features string for window.open()</li>
</ul> *
 <ul><li>Converts PopOutWindowFeatures to the comma-separated string</li>
</ul> <ul><li>required by window.open().</li>
</ul> *
 <ul><li>@param features - Window feature configuration</li>
</ul> <ul><li>@returns Feature string for window.open()</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const features = buildWindowFeatures({ width: 800, height: 600 });</li>
</ul> <ul><li>// "width=800,height=600,left=100,top=100,menubar=no,..."</li>
</ul> *
 <ul><li>window.open('/popout/grid/panel/chart', 'popout-panel', features);</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function buildWindowFeatures(features: PopOutWindowFeatures): string { const { width = 1200, height = 800, left = 100, top = 100, menubar = false, toolbar = false, location = false, status = false, resizable = true, scrollbars = true } = features;</p>

<p>const boolToYesNo = (val: boolean) =&gt; (val ? 'yes' : 'no');</p>

<p>return [ <code class="inline">width=${width}</code>, <code class="inline">height=${height}</code>, <code class="inline">left=${left}</code>, <code class="inline">top=${top}</code>, <code class="inline">menubar=${boolToYesNo(menubar)}</code>, <code class="inline">toolbar=${boolToYesNo(toolbar)}</code>, <code class="inline">location=${boolToYesNo(location)}</code>, <code class="inline">status=${boolToYesNo(status)}</code>, <code class="inline">resizable=${boolToYesNo(resizable)}</code>, <code class="inline">scrollbars=${boolToYesNo(scrollbars)}</code> ].join(','); }</p>

<p>/**</p>
 <ul><li>Parse pop-out route to extract context</li>
</ul> *
 <ul><li>Parses a pop-out URL path to extract grid ID, panel ID, and type.</li>
</ul> *
 <ul><li>@param url - URL path to parse</li>
</ul> <ul><li>@returns PopOutContext if URL matches pop-out pattern, null otherwise</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const context = parsePopOutRoute('/popout/automobile-discover/chart-year/chart');</li>
</ul> <ul><li>// {</li>
</ul> <ul><li>//   isPopOut: true,</li>
</ul> <ul><li>//   gridId: 'automobile-discover',</li>
</ul> <ul><li>//   panelId: 'chart-year',</li>
</ul> <ul><li>//   panelType: 'chart'</li>
</ul> <ul><li>// }</li>
</ul> *
 <ul><li>const notPopout = parsePopOutRoute('/discover');</li>
</ul> <ul><li>// null</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function parsePopOutRoute(url: string): PopOutContext | null { // Match /popout/:gridId/:panelId/:type const match = url.match(/^\/popout\/([^/]+)\/([^/]+)\/([^/?]+)/);</p>

<p>if (!match) { return null; }</p>

<p>return { isPopOut: true, gridId: match[1], panelId: match[2], panelType: match[3] }; }</p>

<p>/**</p>
 <ul><li>Build pop-out URL from route parameters</li>
</ul> *
 <ul><li>@param params - Route parameters</li>
</ul> <ul><li>@param queryString - Optional query string to append</li>
</ul> <ul><li>@returns Pop-out URL path</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const url = buildPopOutUrl({</li>
</ul> <ul><li>  gridId: 'automobile-discover',</li>
</ul> <ul><li>  panelId: 'chart-year',</li>
</ul> <ul><li>  type: 'chart'</li>
</ul> <ul><li>}, '?manufacturer=Ford');</li>
</ul> <ul><li>// '/popout/automobile-discover/chart-year/chart?manufacturer=Ford'</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function buildPopOutUrl( params: PopOutRouteParams, queryString: string = '' ): string { return <code class="inline">/popout/${params.gridId}/${params.panelId}/${params.type}${queryString}</code>; }</p>

<p>/**</p>
 <ul><li>Create a pop-out message with timestamp</li>
</ul> *
 <ul><li>@param type - Message type</li>
</ul> <ul><li>@param payload - Message payload</li>
</ul> <ul><li>@returns Complete PopOutMessage</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const message = createPopOutMessage(</li>
</ul> <ul><li>  PopOutMessageType.STATE_UPDATE,</li>
</ul> <ul><li>  { filters: currentFilters }</li>
</ul> <ul><li>);</li>
</ul> <ul><li>channel.postMessage(message);</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function createPopOutMessage&lt;T&gt;( type: PopOutMessageType, payload?: T ): PopOutMessage&lt;T&gt; { return { type, payload, timestamp: Date.now() }; }</p>

<p>/**</p>
 <ul><li>Default window features for charts</li>
</ul> */
<p>export const CHART_POPOUT_FEATURES: PopOutWindowFeatures = { width: 900, height: 600, resizable: true, scrollbars: false };</p>

<p>/**</p>
 <ul><li>Default window features for pickers</li>
</ul> */
<p>export const PICKER_POPOUT_FEATURES: PopOutWindowFeatures = { width: 800, height: 700, resizable: true, scrollbars: true };</p>

<p>/**</p>
 <ul><li>Default window features for filter panels</li>
</ul> */
<p>export const FILTER_POPOUT_FEATURES: PopOutWindowFeatures = { width: 500, height: 600, resizable: true, scrollbars: true };</p>

<p>/**</p>
 <ul><li>BroadcastChannel name prefix</li>
</ul> <ul><li>Each pop-out gets a unique channel: <code class="inline">${CHANNEL_PREFIX}-${panelId}</code></li>
</ul> */
<p>export const POPOUT_CHANNEL_PREFIX = 'vvroom-popout';</p>

<p>/**</p>
 <ul><li>Create BroadcastChannel name for a panel</li>
</ul> *
 <ul><li>@param panelId - Panel identifier</li>
</ul> <ul><li>@returns Channel name</li>
</ul> */
<p>export function getPopOutChannelName(panelId: string): string { return <code class="inline">${POPOUT_CHANNEL_PREFIX}-${panelId}</code>; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 208.2: Update the Barrel Export</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code> to include the new interface:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface'; export * from './resource-management.interface'; export * from './filter-definition.interface'; export * from './table-config.interface'; export * from './picker-config.interface'; export * from './api-response.interface'; export * from './pagination.interface'; export * from './popout.interface';</p>
</code></pre>

<hr>

<h3>Step 208.3: Understand the Pop-out Architecture</h3>

<p>Pop-out communication follows a parent-child pattern:</p>

<p><strong>Parent Window Responsibilities:</strong></p>
<ul><li>Owns the URL state (single source of truth)</li>
<p><li>Opens pop-out windows with specific routes</li> <li>Sends STATE_UPDATE when URL changes</li> <li>Receives messages from pop-outs (filter changes, etc.)</li> <li>Updates URL based on pop-out messages</li></p>
</ul>
<p><strong>Pop-out Window Responsibilities:</strong></p>
<ul><li>Renders a single panel (chart, picker, etc.)</li>
<p><li>Listens for STATE_UPDATE from parent</li> <li>Sends user actions to parent (clicks, selections)</li> <li>Closes cleanly when parent closes or navigates away</li></p>
</ul>
<p><strong>Message Flow Example:</strong></p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│  User clicks "Pop Out Chart"                                     │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  Parent: window.open('/popout/grid/chart/chart', features)       │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  Pop-out: Initializes, sends PANEL_READY                         │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  Parent: Receives PANEL_READY, sends STATE_UPDATE with filters   │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │  Pop-out: Receives STATE_UPDATE, renders chart with data         │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/popout.interface.ts
</code></pre>

<p>Expected output shows the file exists.</p>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/popout.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export" src/app/framework/models/popout.interface.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export interface PopOutMessage&lt;T = any&gt; {
<p>export enum PopOutMessageType { export interface PickerSelectionPayload { export interface PopOutWindowRef { export interface PopOutWindowFeatures { export interface PopOutRouteParams { export interface PopOutContext { export function buildWindowFeatures(features: PopOutWindowFeatures): string { export function parsePopOutRoute(url: string): PopOutContext | null { export function buildPopOutUrl( export function createPopOutMessage&lt;T&gt;( export const CHART_POPOUT_FEATURES: PopOutWindowFeatures = { export const PICKER_POPOUT_FEATURES: PopOutWindowFeatures = { export const FILTER_POPOUT_FEATURES: PopOutWindowFeatures = { export const POPOUT_CHANNEL_PREFIX = 'vvroom-popout'; export function getPopOutChannelName(panelId: string): string {</p>
</code></pre>

<h3>4. Verify Barrel Export</h3>

<pre class="code-block bash"><code>$ grep "popout" src/app/framework/models/index.ts
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>export * from './popout.interface';
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>BroadcastChannel not defined</td> <td>Older browser</td> <td>Check browser compatibility or use polyfill</td></p>
</tr>
<p><tr> <td>Pop-out shows blank</td> <td>Route not configured</td> <td>Add pop-out routes to app.routes.ts</td></p>
</tr>
<p><tr> <td>Messages not received</td> <td>Wrong channel name</td> <td>Verify both windows use same channel name</td></p>
</tr>
<p><tr> <td>Pop-out loses state on refresh</td> <td>URL not preserved</td> <td>Include query params in pop-out URL</td></p>
</tr>
<p><tr> <td>Window features ignored</td> <td>Browser restrictions</td> <td>Some browsers limit window.open() features</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>BroadcastChannel enables cross-window communication</strong> — Same-origin windows can send messages</li>
<p><li><strong>The parent owns URL state</strong> — Pop-outs request changes, parent applies them</li> <li><strong>Message types create a protocol</strong> — Typed messages ensure consistent communication</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/popout.interface.ts</code> exists</li>
<p><li>[ ] <code class="inline">PopOutMessage&lt;T&gt;</code> interface defines message structure</li> <li>[ ] <code class="inline">PopOutMessageType</code> enum lists all message types</li> <li>[ ] <code class="inline">PopOutWindowRef</code> interface tracks open windows</li> <li>[ ] <code class="inline">PopOutWindowFeatures</code> interface configures window appearance</li> <li>[ ] <code class="inline">PopOutContext</code> interface identifies pop-out windows</li> <li>[ ] <code class="inline">buildWindowFeatures</code> function generates feature string</li> <li>[ ] <code class="inline">parsePopOutRoute</code> function extracts context from URL</li> <li>[ ] Default feature constants for charts, pickers, filters exist</li> <li>[ ] Barrel file exports all popout types</li> <li>[ ] TypeScript compilation succeeds with no errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">209-error-notification-interface.md</code> to define the error notification interfaces.</p></div></div>
    <div class="chapter" id="section-209">
        <div class="chapter-header">
            <div class="chapter-category">Interfaces</div>
            <h1>209: Error Notification Interface</h1>
        </div>
<div class="page-content"><h1>209: Error Notification Interface</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 312-error-notification-service, 313-http-error-interceptor</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how centralized error handling simplifies application-wide error management</li>
<p><li>Know how to categorize errors by source and severity for appropriate user feedback</li> <li>Recognize the relationship between HTTP interceptors and error notification services</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the error notification interfaces that define how errors are categorized, formatted, and displayed to users. These interfaces establish a consistent error handling pattern using PrimeNG Toast for user-friendly error messages.</p>

<hr>

<h2>Why</h2>

<p>Errors happen. APIs fail, networks drop, validation rules are violated. How you handle these errors determines user experience:</p>

<p><strong>Poor error handling:</strong></p>
<pre class="code-block text"><code>Error: [object Object]
</code></pre>

<p><strong>Good error handling:</strong></p>
<pre class="code-block text"><code>Connection Error
<p>Unable to reach the server. Please check your network connection. [Retry] [Dismiss]</p>
</code></pre>

<p>The error notification interfaces define:</p>
<ul><li><strong>Error categories</strong> — Network, validation, authorization, server, client</li>
<p><li><strong>Severity levels</strong> — Maps to PrimeNG Toast colors (success, info, warn, error)</li> <li><strong>Notification structure</strong> — Summary, detail, timestamp, original error</li> <li><strong>Display options</strong> — Auto-hide duration, closable, sticky</li></p>
</ul>
<p><strong>Centralized error handling benefits:</strong></p>

<table>
<p><thead><tr> <th>Without Centralization</th> <th>With Centralization</th></p>
</tr></thead>
<p><tbody> <tr> <td>Error handling in every component</td> <td>Single error service</td></p>
</tr>
<p><tr> <td>Inconsistent error messages</td> <td>Consistent formatting</td></p>
</tr>
<p><tr> <td>Easy to miss errors</td> <td>All errors captured</td></p>
</tr>
<p><tr> <td>No logging</td> <td>Centralized logging</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>What</h2>

<h3>Step 209.1: Create the Error Notification Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/error-notification.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/error-notification.interface.ts
<p>// VERSION 1 (Section 209) - Error notification interfaces</p>

<p>/**</p>
 <ul><li>Error Notification Interfaces</li>
</ul> *
 <ul><li>Provides comprehensive error categorization and notification configuration</li>
</ul> <ul><li>for user-facing error messages using PrimeNG Toast.</li>
</ul> */

<p>/**</p>
 <ul><li>Error category enumeration</li>
</ul> *
 <ul><li>Categorizes errors by their source and nature for appropriate handling</li>
</ul> <ul><li>and user messaging.</li>
</ul> */
<p>export enum ErrorCategory { /**</p>
   <ul><li>Network-related errors (connection issues, timeouts, etc.)</li>
</ul>   <ul><li>HTTP status 0 or network failures</li>
</ul>   */
<p>NETWORK = 'NETWORK',</p>

<p>/**</p>
   <ul><li>Validation errors (invalid input, business rule violations)</li>
</ul>   <ul><li>HTTP status 400, 422</li>
</ul>   */
<p>VALIDATION = 'VALIDATION',</p>

<p>/**</p>
   <ul><li>Authorization/authentication errors</li>
</ul>   <ul><li>HTTP status 401 (unauthorized), 403 (forbidden)</li>
</ul>   */
<p>AUTHORIZATION = 'AUTHORIZATION',</p>

<p>/**</p>
   <ul><li>Server-side errors</li>
</ul>   <ul><li>HTTP status 5xx</li>
</ul>   */
<p>SERVER = 'SERVER',</p>

<p>/**</p>
   <ul><li>Client-side errors (JavaScript errors, component errors)</li>
</ul>   <ul><li>Runtime errors in the application</li>
</ul>   */
<p>CLIENT = 'CLIENT',</p>

<p>/**</p>
   <ul><li>Application-level errors (business logic, state errors)</li>
</ul>   <ul><li>Custom application errors</li>
</ul>   */
<p>APPLICATION = 'APPLICATION',</p>

<p>/**</p>
   <ul><li>Unknown or uncategorized errors</li>
</ul>   <ul><li>Fallback for unrecognized error types</li>
</ul>   */
<p>UNKNOWN = 'UNKNOWN' }</p>

<p>/**</p>
 <ul><li>Error severity levels</li>
</ul> *
 <ul><li>Maps to PrimeNG Toast severity levels for visual feedback.</li>
</ul> <ul><li>- 'success': Green (not typically used for errors)</li>
</ul> <ul><li>- 'info': Blue (informational messages)</li>
</ul> <ul><li>- 'warn': Yellow/Orange (warnings, validation errors)</li>
</ul> <ul><li>- 'error': Red (critical errors)</li>
</ul> */
<p>export type ErrorSeverity = 'success' | 'info' | 'warn' | 'error';</p>

<p>/**</p>
 <ul><li>Error notification data structure</li>
</ul> *
 <ul><li>Contains all information needed to display an error to the user.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const notification: ErrorNotification = {</li>
</ul> <ul><li>  category: ErrorCategory.NETWORK,</li>
</ul> <ul><li>  severity: 'error',</li>
</ul> <ul><li>  summary: 'Connection Error',</li>
</ul> <ul><li>  detail: 'Unable to reach the server. Please check your network connection.',</li>
</ul> <ul><li>  timestamp: new Date().toISOString(),</li>
</ul> <ul><li>  status: 0</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface ErrorNotification { /**</p>
   <ul><li>Error category for categorization and routing</li>
</ul>   */
<p>category: ErrorCategory;</p>

<p>/**</p>
   <ul><li>Display severity (maps to PrimeNG Toast severity)</li>
</ul>   */
<p>severity: ErrorSeverity;</p>

<p>/**</p>
   <ul><li>Brief error summary (shown as toast title)</li>
</ul>   <ul><li>Should be short and actionable</li>
</ul>   */
<p>summary: string;</p>

<p>/**</p>
   <ul><li>Detailed error message (shown as toast body)</li>
</ul>   <ul><li>Provides more context about the error</li>
</ul>   */
<p>detail: string;</p>

<p>/**</p>
   <ul><li>Optional error code for debugging</li>
</ul>   <ul><li>From API or generated locally</li>
</ul>   */
<p>code?: string;</p>

<p>/**</p>
   <ul><li>Timestamp of when error occurred</li>
</ul>   <ul><li>ISO 8601 format</li>
</ul>   */
<p>timestamp?: string;</p>

<p>/**</p>
   <ul><li>URL where error occurred (for HTTP errors)</li>
</ul>   */
<p>url?: string;</p>

<p>/**</p>
   <ul><li>HTTP status code (for network errors)</li>
</ul>   */
<p>status?: number;</p>

<p>/**</p>
   <ul><li>Original error object (for logging/debugging)</li>
</ul>   <ul><li>Not displayed to user, but useful for console/reporting</li>
</ul>   */
<p>originalError?: any; }</p>

<p>/**</p>
 <ul><li>Error display options</li>
</ul> *
 <ul><li>Configuration for how errors should be displayed to users.</li>
</ul> <ul><li>Passed to PrimeNG Toast component.</li>
</ul> */
<p>export interface ErrorDisplayOptions { /**</p>
   <ul><li>Auto-hide duration in milliseconds</li>
</ul>   <ul><li>Set to 0 or null to prevent auto-hide</li>
</ul>   <ul><li>@default 5000 (5 seconds)</li>
</ul>   */
<p>life?: number;</p>

<p>/**</p>
   <ul><li>Whether to show close button</li>
</ul>   <ul><li>@default true</li>
</ul>   */
<p>closable?: boolean;</p>

<p>/**</p>
   <ul><li>Whether to show in sticky mode (no auto-hide)</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>sticky?: boolean;</p>

<p>/**</p>
   <ul><li>Custom CSS class for the toast</li>
</ul>   */
<p>styleClass?: string;</p>

<p>/**</p>
   <ul><li>Toast position key (used with multiple toast containers)</li>
</ul>   <ul><li>@default 'app-toast'</li>
</ul>   */
<p>key?: string; }</p>

<p>/**</p>
 <ul><li>Default error display options</li>
</ul> */
<p>export const DEFAULT_ERROR_DISPLAY_OPTIONS: ErrorDisplayOptions = { life: 5000, closable: true, sticky: false, key: 'app-toast' };</p>

<p>/**</p>
 <ul><li>Error severity mapping configuration</li>
</ul> *
 <ul><li>Maps error categories to default severity levels.</li>
</ul> <ul><li>- NETWORK, SERVER, CLIENT, APPLICATION, UNKNOWN → 'error' (red)</li>
</ul> <ul><li>- VALIDATION, AUTHORIZATION → 'warn' (yellow)</li>
</ul> */
<p>export const ERROR_CATEGORY_SEVERITY_MAP: Record&lt;ErrorCategory, ErrorSeverity&gt; = { [ErrorCategory.NETWORK]: 'error', [ErrorCategory.VALIDATION]: 'warn', [ErrorCategory.AUTHORIZATION]: 'warn', [ErrorCategory.SERVER]: 'error', [ErrorCategory.CLIENT]: 'error', [ErrorCategory.APPLICATION]: 'error', [ErrorCategory.UNKNOWN]: 'error' };</p>

<p>/**</p>
 <ul><li>Determine error category from HTTP status code</li>
</ul> *
 <ul><li>@param status - HTTP status code</li>
</ul> <ul><li>@returns Appropriate error category</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>getErrorCategoryFromStatus(401); // ErrorCategory.AUTHORIZATION</li>
</ul> <ul><li>getErrorCategoryFromStatus(500); // ErrorCategory.SERVER</li>
</ul> <ul><li>getErrorCategoryFromStatus(0);   // ErrorCategory.NETWORK</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function getErrorCategoryFromStatus(status: number): ErrorCategory { // Status 0 typically means network failure if (status === 0) { return ErrorCategory.NETWORK; }</p>

<p>// Authentication/authorization errors if (status === 401 || status === 403) { return ErrorCategory.AUTHORIZATION; }</p>

<p>// Validation errors if (status === 400 || status === 422) { return ErrorCategory.VALIDATION; }</p>

<p>// Server errors if (status &gt;= 500 &amp;&amp; status &lt; 600) { return ErrorCategory.SERVER; }</p>

<p>// Other client errors if (status &gt;= 400 &amp;&amp; status &lt; 500) { return ErrorCategory.CLIENT; }</p>

<p>return ErrorCategory.UNKNOWN; }</p>

<p>/**</p>
 <ul><li>Determine error category from error code string</li>
</ul> *
 <ul><li>@param code - Error code string</li>
</ul> <ul><li>@returns Appropriate error category</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>getErrorCategoryFromCode('NETWORK_TIMEOUT');    // ErrorCategory.NETWORK</li>
</ul> <ul><li>getErrorCategoryFromCode('VALIDATION_FAILED'); // ErrorCategory.VALIDATION</li>
</ul> <ul><li>getErrorCategoryFromCode('UNAUTHORIZED');      // ErrorCategory.AUTHORIZATION</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function getErrorCategoryFromCode(code: string): ErrorCategory { const upperCode = code.toUpperCase();</p>

<p>if (upperCode.includes('NETWORK') || upperCode.includes('TIMEOUT')) { return ErrorCategory.NETWORK; }</p>

<p>if (upperCode.includes('VALIDATION') || upperCode.includes('INVALID')) { return ErrorCategory.VALIDATION; }</p>

<p>if ( upperCode.includes('UNAUTHORIZED') || upperCode.includes('FORBIDDEN') || upperCode.includes('AUTH') ) { return ErrorCategory.AUTHORIZATION; }</p>

<p>if (upperCode.includes('SERVER') || upperCode.includes('INTERNAL')) { return ErrorCategory.SERVER; }</p>

<p>if (upperCode.includes('CLIENT')) { return ErrorCategory.CLIENT; }</p>

<p>return ErrorCategory.UNKNOWN; }</p>

<p>/**</p>
 <ul><li>Get user-friendly summary for error category</li>
</ul> *
 <ul><li>@param category - Error category</li>
</ul> <ul><li>@returns Summary text suitable for toast title</li>
</ul> */
<p>export function getSummaryForCategory(category: ErrorCategory): string { switch (category) { case ErrorCategory.NETWORK: return 'Connection Error'; case ErrorCategory.VALIDATION: return 'Validation Error'; case ErrorCategory.AUTHORIZATION: return 'Access Denied'; case ErrorCategory.SERVER: return 'Server Error'; case ErrorCategory.CLIENT: return 'Application Error'; case ErrorCategory.APPLICATION: return 'Operation Failed'; case ErrorCategory.UNKNOWN: default: return 'Error'; } }</p>

<p>/**</p>
 <ul><li>Create error notification from HTTP error</li>
</ul> *
 <ul><li>Converts an HTTP error response to an ErrorNotification.</li>
</ul> <ul><li>Typically called from HTTP error interceptor.</li>
</ul> *
 <ul><li>@param error - HTTP error object (from HttpErrorResponse or interceptor)</li>
</ul> <ul><li>@returns ErrorNotification object ready for display</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In HTTP interceptor</li>
</ul> <ul><li>catchError((error: HttpErrorResponse) =&gt; {</li>
</ul> <ul><li>  const notification = createErrorNotificationFromHttpError({</li>
</ul> <ul><li>    status: error.status,</li>
</ul> <ul><li>    message: error.message,</li>
</ul> <ul><li>    url: error.url,</li>
</ul> <ul><li>    code: error.error?.code</li>
</ul> <ul><li>  });</li>
</ul> <ul><li>  this.errorService.show(notification);</li>
</ul> <ul><li>  return throwError(() =&gt; error);</li>
</ul> <ul><li>})</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function createErrorNotificationFromHttpError(error: { status?: number; message?: string; url?: string; code?: string; timestamp?: string; }): ErrorNotification { const status = error.status || 0; const code = error.code || 'UNKNOWN_ERROR'; const category = getErrorCategoryFromStatus(status); const severity = ERROR_CATEGORY_SEVERITY_MAP[category];</p>

<p>return { category, severity, summary: getSummaryForCategory(category), detail: error.message || 'An unexpected error occurred', code, timestamp: error.timestamp || new Date().toISOString(), url: error.url, status, originalError: error }; }</p>

<p>/**</p>
 <ul><li>Create error notification from generic Error</li>
</ul> *
 <ul><li>Converts a JavaScript Error to an ErrorNotification.</li>
</ul> <ul><li>Typically called from global error handler.</li>
</ul> *
 <ul><li>@param error - JavaScript Error object</li>
</ul> <ul><li>@returns ErrorNotification object ready for display</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In global error handler</li>
</ul> <ul><li>handleError(error: Error): void {</li>
</ul> <ul><li>  const notification = createErrorNotificationFromError(error);</li>
</ul> <ul><li>  this.errorService.show(notification);</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function createErrorNotificationFromError(error: Error): ErrorNotification { const code = (error as any).code; const category = code ? getErrorCategoryFromCode(code) : ErrorCategory.CLIENT; const severity = ERROR_CATEGORY_SEVERITY_MAP[category];</p>

<p>return { category, severity, summary: getSummaryForCategory(category), detail: error.message || 'An unexpected error occurred', code, timestamp: new Date().toISOString(), originalError: error }; }</p>

<p>/**</p>
 <ul><li>Create a custom error notification</li>
</ul> *
 <ul><li>For application-specific errors that don't come from HTTP or JavaScript errors.</li>
</ul> *
 <ul><li>@param summary - Brief error summary</li>
</ul> <ul><li>@param detail - Detailed error message</li>
</ul> <ul><li>@param category - Error category (default: APPLICATION)</li>
</ul> <ul><li>@returns ErrorNotification object</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Business logic error</li>
</ul> <ul><li>if (cart.items.length === 0) {</li>
</ul> <ul><li>  const notification = createCustomErrorNotification(</li>
</ul> <ul><li>    'Empty Cart',</li>
</ul> <ul><li>    'Please add items to your cart before checkout.',</li>
</ul> <ul><li>    ErrorCategory.APPLICATION</li>
</ul> <ul><li>  );</li>
</ul> <ul><li>  this.errorService.show(notification);</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function createCustomErrorNotification( summary: string, detail: string, category: ErrorCategory = ErrorCategory.APPLICATION ): ErrorNotification { const severity = ERROR_CATEGORY_SEVERITY_MAP[category];</p>

<p>return { category, severity, summary, detail, timestamp: new Date().toISOString() }; }</p>

<p>/**</p>
 <ul><li>Default display options by error category</li>
</ul> *
 <ul><li>Some error types should be more prominent than others.</li>
</ul> <ul><li>- Authorization errors are sticky (user must acknowledge)</li>
</ul> <ul><li>- Validation errors auto-hide quickly</li>
</ul> */
<p>export const CATEGORY_DISPLAY_OPTIONS: Record&lt;ErrorCategory, Partial&lt;ErrorDisplayOptions&gt;&gt; = { [ErrorCategory.NETWORK]: { life: 8000 }, [ErrorCategory.VALIDATION]: { life: 4000 }, [ErrorCategory.AUTHORIZATION]: { sticky: true, closable: true }, [ErrorCategory.SERVER]: { life: 6000 }, [ErrorCategory.CLIENT]: { life: 5000 }, [ErrorCategory.APPLICATION]: { life: 5000 }, [ErrorCategory.UNKNOWN]: { life: 5000 } };</p>

<p>/**</p>
 <ul><li>Merge display options with category defaults</li>
</ul> *
 <ul><li>@param category - Error category</li>
</ul> <ul><li>@param options - Custom display options</li>
</ul> <ul><li>@returns Merged display options</li>
</ul> */
<p>export function mergeDisplayOptions( category: ErrorCategory, options?: Partial&lt;ErrorDisplayOptions&gt; ): ErrorDisplayOptions { return { ...DEFAULT_ERROR_DISPLAY_OPTIONS, ...CATEGORY_DISPLAY_OPTIONS[category], ...options }; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 209.2: Update the Barrel Export</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code> to include the new interface:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts

<p>// This barrel file exports all framework model interfaces. // Import from '@app/framework/models' instead of individual files.</p>

<p>export * from './domain-config.interface'; export * from './resource-management.interface'; export * from './filter-definition.interface'; export * from './table-config.interface'; export * from './picker-config.interface'; export * from './api-response.interface'; export * from './pagination.interface'; export * from './popout.interface'; export * from './error-notification.interface';</p>
</code></pre>

<hr>

<h3>Step 209.3: Understand the Error Handling Flow</h3>

<p>Error handling in vvroom follows this pattern:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│                     Error Occurs                                 │ │  (HTTP Error, Runtime Error, Business Error)                     │ └─────────────────────────────────────────────────────────────────┘ │                    │                    │ ▼                    ▼                    ▼ ┌───────────────┐    ┌───────────────┐    ┌───────────────┐ │ HTTP Error    │    │ Runtime Error │    │ Business      │ │ Interceptor   │    │ Handler       │    │ Logic         │ └───────────────┘    └───────────────┘    └───────────────┘ │                    │                    │ │                    │                    │ └────────────────────┴────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │                  createErrorNotification*()                      │ │         Convert to ErrorNotification structure                   │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │                  ErrorNotificationService                        │ │         Display via PrimeNG Toast, log to console               │ └─────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────┐ │                       PrimeNG Toast                              │ │  ┌─────────────────────────────────────────────────────────┐    │ │  │  Connection Error                               [×]      │    │ │  │  Unable to reach the server.                            │    │ │  └─────────────────────────────────────────────────────────┘    │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 209.4: Phase 2 Complete</h3>

<p>Congratulations! You have completed Phase 2: Framework Models.</p>

<p><strong>What you built:</strong></p>

<table>
<p><thead><tr> <th>Document</th> <th>Interface</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td>201</td> <td><code class="inline">DomainConfig&lt;T&gt;</code></td> <td>Central configuration for domains</td></p>
</tr>
<p><tr> <td>202</td> <td><code class="inline">IApiAdapter&lt;T&gt;</code>, <code class="inline">IFilterUrlMapper&lt;T&gt;</code></td> <td>URL-First adapters</td></p>
</tr>
<p><tr> <td>203</td> <td><code class="inline">FilterDefinition&lt;T&gt;</code></td> <td>Query Control filters</td></p>
</tr>
<p><tr> <td>204</td> <td><code class="inline">TableConfig&lt;T&gt;</code>, <code class="inline">PrimeNGColumn&lt;T&gt;</code></td> <td>Data table configuration</td></p>
</tr>
<p><tr> <td>205</td> <td><code class="inline">PickerConfig&lt;T&gt;</code></td> <td>Selection picker configuration</td></p>
</tr>
<p><tr> <td>206</td> <td><code class="inline">ApiResponse&lt;T&gt;</code></td> <td>Standard API response format</td></p>
</tr>
<p><tr> <td>207</td> <td><code class="inline">PaginationParams</code>, <code class="inline">SortParams</code></td> <td>Pagination utilities</td></p>
</tr>
<p><tr> <td>208</td> <td><code class="inline">PopOutMessage</code>, <code class="inline">PopOutContext</code></td> <td>Pop-out communication</td></p>
</tr>
<p><tr> <td>209</td> <td><code class="inline">ErrorNotification</code>, <code class="inline">ErrorCategory</code></td> <td>Error handling</td></p>
</tr>
</tbody>
</table>

<p><strong>Phase 2 Aha Moment achieved:</strong> "TypeScript interfaces are executable documentation."</p>

<p>These interfaces don't execute at runtime — they have zero impact on bundle size. But they provide:</p>
<ul><li><strong>Compile-time safety</strong> — TypeScript catches configuration errors</li>
<p><li><strong>IDE support</strong> — Autocomplete and inline documentation</li> <li><strong>Living documentation</strong> — The interface IS the specification</li></p>
</ul>
<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/error-notification.interface.ts
</code></pre>

<p>Expected output shows the file exists.</p>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/models/error-notification.interface.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify All Model Files Exist</h3>

<pre class="code-block bash"><code>$ ls -1 src/app/framework/models/
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>api-response.interface.ts
<p>domain-config.interface.ts error-notification.interface.ts filter-definition.interface.ts index.ts pagination.interface.ts picker-config.interface.ts popout.interface.ts resource-management.interface.ts table-config.interface.ts</p>
</code></pre>

<h3>4. Verify Barrel Exports All Interfaces</h3>

<pre class="code-block bash"><code>$ grep "export" src/app/framework/models/index.ts
</code></pre>

<p>Expected: All 9 interface files are exported.</p></div><div class="page-content"><h3>5. Phase 2 Checkpoint</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors. All interfaces compile.</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">ErrorCategory is not defined</code></td> <td>Missing import</td> <td>Import from the interface file</td></p>
</tr>
<p><tr> <td>Toast not appearing</td> <td>MessageService not provided</td> <td>Add to providers in AppModule</td></p>
</tr>
<p><tr> <td>Severity color wrong</td> <td>Wrong severity string</td> <td>Use: 'success', 'info', 'warn', 'error'</td></p>
</tr>
<p><tr> <td>Timestamp format wrong</td> <td>Not ISO 8601</td> <td>Use <code class="inline">new Date().toISOString()</code></td></p>
</tr>
<p><tr> <td>originalError circular reference</td> <td>Logging issue</td> <td>JSON.stringify with replacer</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Centralized error handling provides consistency</strong> — One place to format and display all errors</li>
<p><li><strong>Error categories enable smart handling</strong> — Different categories get different treatment</li> <li><strong>Factory functions simplify error creation</strong> — <code class="inline">createErrorNotificationFromHttpError()</code>, etc.</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/error-notification.interface.ts</code> exists</li>
<p><li>[ ] <code class="inline">ErrorCategory</code> enum defines all error categories</li> <li>[ ] <code class="inline">ErrorSeverity</code> type matches PrimeNG Toast severities</li> <li>[ ] <code class="inline">ErrorNotification</code> interface captures all error information</li> <li>[ ] <code class="inline">ErrorDisplayOptions</code> interface configures toast behavior</li> <li>[ ] <code class="inline">getErrorCategoryFromStatus</code> correctly categorizes HTTP errors</li> <li>[ ] <code class="inline">getErrorCategoryFromCode</code> correctly categorizes error codes</li> <li>[ ] Factory functions create notifications from different error sources</li> <li>[ ] <code class="inline">CATEGORY_DISPLAY_OPTIONS</code> provides sensible defaults per category</li> <li>[ ] Barrel file exports all error notification types</li> <li>[ ] TypeScript compilation succeeds with no errors</li></p>
</ul>
<hr>

<h2>Phase 2 Checkpoint</h2>

<p>Before proceeding to Phase 3 (Framework Services), verify:</p>

<ul><li>[ ] All 9 interface files exist in <code class="inline">src/app/framework/models/</code></li>
<p><li>[ ] Barrel file (<code class="inline">index.ts</code>) exports all interfaces</li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li> <li>[ ] Each interface has JSDoc documentation</li> <li>[ ] No runtime code exists yet — these are all types</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">250-rxjs-patterns-primer.md</code> (Interlude B) to learn the RxJS patterns needed for Phase 3 services.</p></div></div>
    <div class="chapter" id="section-250">
        <div class="chapter-header">
            <div class="chapter-category">Primers</div>
            <h1>250: RxJS Patterns Primer</h1>
        </div>
<div class="page-content"><h1>250: RxJS Patterns Primer</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 209-error-notification-interface <strong>Blocks:</strong> 301-url-state-service</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand why Observables are well-suited for modeling state that changes over time</li>
<p><li>Know how to use the key RxJS operators used in vvroom: <code class="inline">switchMap</code>, <code class="inline">combineLatest</code>, <code class="inline">distinctUntilChanged</code>, <code class="inline">shareReplay</code></li> <li>Be able to apply proper cleanup patterns to prevent memory leaks</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build practical RxJS knowledge before tackling the framework services in Phase 3. This is a teaching interlude focused on the specific RxJS patterns used in vvroom — it's practical, not comprehensive.</p>

<hr>

<h2>Why This Interlude Exists</h2>

<p>Phase 3 introduces services like <code class="inline">UrlStateService</code> and <code class="inline">ResourceManagementService</code> that use RxJS extensively:</p>

<pre class="code-block typescript"><code>// From UrlStateService (Section 301)
<p>this.filters$ = this.route.queryParams.pipe( map(params =&gt; this.urlMapper.fromUrlParams(params)), distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)), shareReplay(1) );</p>

<p>// From ResourceManagementService (Section 306) this.results$ = this.filters$.pipe( switchMap(filters =&gt; this.apiAdapter.fetchData(filters)), map(response =&gt; response.results), shareReplay(1) );</p>
</code></pre>

<p>If you've never used RxJS, this code is confusing. What does <code class="inline">switchMap</code> do? Why <code class="inline">shareReplay(1)</code>? This primer answers those questions with practical examples.</p>

<hr>

<h2>What Are Observables?</h2>

<h3>The Problem: Modeling Change Over Time</h3>

<p>Traditional variables represent a value at a single point in time:</p>

<pre class="code-block typescript"><code>let count = 0;
<p>count = 1; count = 2; // Each assignment replaces the previous value</p>
</code></pre>

<p>But in UI applications, we often need to react to changes:</p>
<ul><li>When the URL changes, update the display</li>
<p><li>When a filter changes, fetch new data</li> <li>When data arrives, update the table</li></p>
</ul>
<p>Observables model <strong>sequences of values over time</strong>:</p>

<pre class="code-block typescript"><code>// Observable of values: 0, then 1, then 2, over time
<p>const count$ = interval(1000); // Emits 0, 1, 2, ... every second</p>

<p>count$.subscribe(value =&gt; { console.log(value); // Logs each value as it arrives });</p>
</code></pre>

<p>The <code class="inline">$</code> suffix is a naming convention indicating "this is an Observable."</p></div><div class="page-content"><h3>Observables vs Promises</h3>

<table>
<p><thead><tr> <th>Promises</th> <th>Observables</th></p>
</tr></thead>
<p><tbody> <tr> <td>Single value</td> <td>Multiple values over time</td></p>
</tr>
<p><tr> <td>Eager (starts immediately)</td> <td>Lazy (starts on subscribe)</td></p>
</tr>
<p><tr> <td>Not cancellable</td> <td>Cancellable (unsubscribe)</td></p>
</tr>
<p><tr> <td>No operators</td> <td>Rich operator library</td></p>
</tr>
</tbody>
</table>

<p>Promises are great for one-time async operations. Observables are better for ongoing data streams like user input, WebSocket messages, or state changes.</p>

<hr>

<h2>The Four Essential Operators</h2>

<p>Vvroom uses many RxJS operators, but four are critical to understand:</p>

<h3>1. <code class="inline">switchMap</code> — Cancel and Switch</h3>

<p><strong>Problem:</strong> When the URL changes rapidly (user clicking filters quickly), you don't want to process all intermediate requests — just the latest one.</p>

<pre class="code-block typescript"><code>import { switchMap } from 'rxjs/operators';

<p>// Without switchMap: every filter change triggers a request // Results may arrive out of order, showing stale data</p>

<p>// With switchMap: previous request is cancelled when a new one starts this.results$ = this.filters$.pipe( switchMap(filters =&gt; this.apiAdapter.fetchData(filters)) );</p>
</code></pre>

<p><strong>How it works:</strong></p>

<pre class="code-block text"><code>filters$:    --A------B--C--------&gt;
<p>\      \  \ fetchData(A):    ---X   |  |      (cancelled) fetchData(B):          -X  |      (cancelled) fetchData(C):              ----Y--&gt; results$:    ----------------Y---&gt;</p>

<p>Only the result of the last request (C → Y) is emitted.</p>
</code></pre>

<p><strong>When to use:</strong> API calls triggered by user input where only the latest matters.</p>

<h3>2. <code class="inline">combineLatest</code> — Combine Multiple Streams</h3>

<p><strong>Problem:</strong> You need to react when <em>any</em> of several values change, and you need all current values together.</p>

<pre class="code-block typescript"><code>import { combineLatest } from 'rxjs';

<p>// Combine filters and highlights into a single stream const combined$ = combineLatest([ this.filters$, this.highlights$ ]);</p>

<p>combined$.subscribe(([filters, highlights]) =&gt; { // Called whenever either filters OR highlights change // Always has the latest value of both this.fetchData(filters, highlights); });</p>
</code></pre>

<p><strong>How it works:</strong></p>

<pre class="code-block text"><code>filters$:      --A----B----------&gt;
<p>highlights$:   ----1----2--------&gt; combined$:     ----[A,1][B,1][B,2]&gt;</p>

<p>Emits when either changes, always with latest values.</p>
</code></pre>

<p><strong>Important:</strong> <code class="inline">combineLatest</code> doesn't emit until <em>all</em> source Observables have emitted at least once. If one never emits, combined never emits.</p>

<p><strong>When to use:</strong> Combining multiple independent state sources.</p></div><div class="page-content"><h3>3. <code class="inline">distinctUntilChanged</code> — Skip Duplicates</h3>

<p><strong>Problem:</strong> The URL might "change" to the same value (user clicks same link twice). You don't want to re-fetch identical data.</p>

<pre class="code-block typescript"><code>import { distinctUntilChanged } from 'rxjs/operators';

<p>this.filters$ = this.route.queryParams.pipe( map(params =&gt; this.urlMapper.fromUrlParams(params)), distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)) );</p>
</code></pre>

<p><strong>How it works:</strong></p>

<pre class="code-block text"><code>input:    --A--A--B--B--A--&gt;
<p>output:   --A-----B-----A--&gt;</p>

<p>Consecutive duplicates are skipped.</p>
</code></pre>

<p><strong>The comparator function:</strong> For objects, you need a custom comparator because <code class="inline">{a:1} !== {a:1}</code> (different object references). The example uses <code class="inline">JSON.stringify</code> for deep comparison. For large objects, consider a more efficient comparison.</p>

<p><strong>When to use:</strong> Preventing unnecessary work when values haven't actually changed.</p>

<h3>4. <code class="inline">shareReplay(1)</code> — Share and Cache</h3>

<p><strong>Problem:</strong> Multiple components subscribe to <code class="inline">filters$</code>. Without sharing, each subscription triggers a new execution of the Observable chain.</p>

<pre class="code-block typescript"><code>import { shareReplay } from 'rxjs/operators';

<p>// Without shareReplay: each subscriber gets a separate stream // URL parsing happens multiple times</p>

<p>// With shareReplay(1): all subscribers share one stream this.filters$ = this.route.queryParams.pipe( map(params =&gt; this.urlMapper.fromUrlParams(params)), distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)), shareReplay(1)  // Share with all subscribers, replay last value );</p>
</code></pre>

<p><strong>How it works:</strong></p>

<pre class="code-block text"><code>Without shareReplay:
<p>Subscriber A: queryParams → map → distinctUntilChanged Subscriber B: queryParams → map → distinctUntilChanged  (separate execution)</p>

<p>With shareReplay(1): Subscriber A ─┐ ├─ queryParams → map → distinctUntilChanged (shared) Subscriber B ─┘</p>
</code></pre>

<p><strong>The <code class="inline">1</code> parameter:</strong> Replay the last 1 value to new subscribers. This means late subscribers immediately get the current value without waiting for the next emission.</p>

<p><strong>When to use:</strong> Any Observable that multiple components will subscribe to.</p></div><div class="page-content"><hr>

<h2>Combining Operators: A Real Example</h2>

<p>Here's how these operators work together in <code class="inline">ResourceManagementService</code>:</p>

<pre class="code-block typescript"><code>// Setup: combine filters and highlights
<p>private readonly combined$ = combineLatest([ this.filters$, this.highlights$ ]).pipe( // Skip if neither actually changed distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b) ) );</p>

<p>// Fetch data when combined state changes this.results$ = this.combined$.pipe( // Cancel previous request, start new one switchMap(([filters, highlights]) =&gt; this.apiAdapter.fetchData(filters, highlights) ), // Extract just the results map(response =&gt; response.results), // Share with all subscribers, cache last value shareReplay(1) );</p>
</code></pre>

<p><strong>The flow:</strong></p>

<ul><li><code class="inline">combineLatest</code> — Whenever filters OR highlights change, emit both</li>
<p><li><code class="inline">distinctUntilChanged</code> — Skip if the combined value is the same</li> <li><code class="inline">switchMap</code> — Cancel any in-flight request, start a new one</li> <li><code class="inline">map</code> — Extract the results from the response</li> <li><code class="inline">shareReplay(1)</code> — Share with all components, cache the latest</li></p>
</ul>
<hr>

<h2>Error Handling</h2>

<p>Observables have built-in error handling with <code class="inline">catchError</code>:</p>

<pre class="code-block typescript"><code>import { catchError, of } from 'rxjs';

<p>this.results$ = this.filters$.pipe( switchMap(filters =&gt; this.apiAdapter.fetchData(filters).pipe( catchError(error =&gt; { // Log the error console.error('API Error:', error);</p>

<p>// Notify the user this.errorService.notify(error);</p>

<p>// Return empty results (don't break the stream) return of({ results: [], total: 0 }); }) )), map(response =&gt; response.results), shareReplay(1) );</p>
</code></pre>

<p><strong>Important:</strong> <code class="inline">catchError</code> must return an Observable. Use <code class="inline">of()</code> to create an Observable from a static value.</p>

<p><strong>Where to put catchError:</strong> Inside the <code class="inline">switchMap</code> callback, not after it. This way, errors in one request don't kill the entire stream — future filter changes will still trigger new requests.</p>

<hr>

<h2>Cleanup Patterns</h2>

<p>Observables can cause memory leaks if not properly cleaned up. Every <code class="inline">subscribe()</code> must eventually <code class="inline">unsubscribe()</code>.</p></div><div class="page-content"><h3>Pattern 1: Store and Unsubscribe</h3>

<pre class="code-block typescript"><code>import { Subscription } from 'rxjs';

<p>@Component({ /<em> ... </em>/ }) export class MyComponent implements OnDestroy { private subscription: Subscription;</p>

<p>ngOnInit() { this.subscription = this.filters$.subscribe(filters =&gt; { // Handle filters }); }</p>

<p>ngOnDestroy() { this.subscription.unsubscribe(); } }</p>
</code></pre>

<h3>Pattern 2: Use <code class="inline">takeUntil</code> (Preferred)</h3>

<pre class="code-block typescript"><code>import { Subject } from 'rxjs';
<p>import { takeUntil } from 'rxjs/operators';</p>

<p>@Component({ /<em> ... </em>/ }) export class MyComponent implements OnDestroy { private destroy$ = new Subject&lt;void&gt;();</p>

<p>ngOnInit() { this.filters$.pipe( takeUntil(this.destroy$) ).subscribe(filters =&gt; { // Handle filters });</p>

<p>// Multiple subscriptions can share the same destroy$ this.results$.pipe( takeUntil(this.destroy$) ).subscribe(results =&gt; { // Handle results }); }</p>

<p>ngOnDestroy() { this.destroy$.next(); this.destroy$.complete(); } }</p>
</code></pre>

<h3>Pattern 3: Use the Async Pipe (Best)</h3>

<p>The async pipe in templates automatically subscribes and unsubscribes:</p>

<pre class="code-block typescript"><code>@Component({
<p>template: <code class="inline"> &lt;div *ngIf="filters$ | async as filters"&gt; Current manufacturer: {{ filters.manufacturer }} &lt;/div&gt;</p>
  </code>
<p>}) export class MyComponent { filters$ = this.urlStateService.filters$; }</p>
</code></pre>

<p><strong>Why this is best:</strong></p>
<ul><li>No manual subscription management</li>
<p><li>No memory leak risk</li> <li>Angular handles everything</li></p>
</ul>
<p>Use the async pipe whenever possible. Fall back to <code class="inline">takeUntil</code> when you need the value in component code.</p>

<hr>

<h2>The Aha Moment</h2>

<p><strong>Observables model change over time. That's why they fit state management.</strong></p>

<p>In vvroom's URL-First architecture:</p>
<ul><li>The URL is state</li>
<p><li>The URL changes over time (user navigates, clicks filters)</li> <li>Components need to react to those changes</li></p>
</ul>
<p>Observables are the perfect fit:</p>

<pre class="code-block typescript"><code>// URL changes over time
<p>this.route.queryParams  // Observable&lt;Params&gt;</p>

<p>// Filters derived from URL, changing over time this.filters$  // Observable&lt;TFilters&gt;</p>

<p>// Results derived from filters, changing over time this.results$  // Observable&lt;TData[]&gt;</p>

<p>// Components react to changes this.results$.subscribe(results =&gt; this.updateTable(results));</p>
</code></pre>

<p>The entire data flow is modeled as Observables:</p>

<pre class="code-block text"><code>URL → queryParams → filters → API request → results → display
<p>(Observable)  (Observable)            (Observable)</p>
</code></pre>

<p>When the URL changes, the entire chain reacts automatically. You don't manually trigger updates — you describe how data flows, and RxJS handles the rest.</p></div><div class="page-content"><hr>

<h2>Quick Reference</h2>

<table>
<p><thead><tr> <th>Operator</th> <th>Purpose</th> <th>Use When</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">switchMap</code></td> <td>Cancel previous, use latest</td> <td>API calls from user input</td></p>
</tr>
<p><tr> <td><code class="inline">combineLatest</code></td> <td>Combine multiple streams</td> <td>Need all current values together</td></p>
</tr>
<p><tr> <td><code class="inline">distinctUntilChanged</code></td> <td>Skip duplicates</td> <td>Preventing unnecessary work</td></p>
</tr>
<p><tr> <td><code class="inline">shareReplay(1)</code></td> <td>Share and cache</td> <td>Multiple subscribers</td></p>
</tr>
<p><tr> <td><code class="inline">catchError</code></td> <td>Handle errors</td> <td>API calls that might fail</td></p>
</tr>
<p><tr> <td><code class="inline">takeUntil</code></td> <td>Auto-unsubscribe</td> <td>Component cleanup</td></p>
</tr>
<p><tr> <td><code class="inline">map</code></td> <td>Transform values</td> <td>Converting response formats</td></p>
</tr>
<p><tr> <td><code class="inline">filter</code></td> <td>Skip values</td> <td>Conditional processing</td></p>
</tr>
<p><tr> <td><code class="inline">tap</code></td> <td>Side effects</td> <td>Logging, debugging</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Practice Exercises</h2>

<p>Try these in your editor or the TypeScript Playground.</p>

<h3>Exercise 1: Basic Observable</h3>

<p>What does this log?</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { map } from 'rxjs/operators';</p>

<p>of(1, 2, 3).pipe( map(x =&gt; x * 2) ).subscribe(console.log);</p>
</code></pre>

<p>&lt;details&gt; &lt;summary&gt;Answer&lt;/summary&gt;</p>

<pre class="code-block text"><code>2
<p>4 6</p>
</code></pre>

<p><code class="inline">of(1, 2, 3)</code> emits three values. <code class="inline">map(x =&gt; x * 2)</code> doubles each. &lt;/details&gt;</p>

<h3>Exercise 2: switchMap</h3>

<p>If <code class="inline">fetchData(id)</code> returns a Promise, what's the output?</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { switchMap, delay } from 'rxjs/operators';</p>

<p>of('A', 'B', 'C').pipe( switchMap(id =&gt; of(<code class="inline">Result: ${id}</code>).pipe(delay(100))) ).subscribe(console.log);</p>
</code></pre>

<p>&lt;details&gt; &lt;summary&gt;Answer&lt;/summary&gt;</p>

<pre class="code-block text"><code>Result: C
</code></pre>

<p>Only the last value (<code class="inline">C</code>) produces output because <code class="inline">switchMap</code> cancels previous inner Observables when a new value arrives. &lt;/details&gt;</p>

<h3>Exercise 3: combineLatest</h3>

<p>When does this emit?</p>

<pre class="code-block typescript"><code>import { combineLatest, Subject } from 'rxjs';

<p>const a$ = new Subject&lt;string&gt;(); const b$ = new Subject&lt;number&gt;();</p>

<p>combineLatest([a$, b$]).subscribe(console.log);</p>

<p>a$.next('X'); b$.next(1); a$.next('Y');</p>
</code></pre>

<p>&lt;details&gt; &lt;summary&gt;Answer&lt;/summary&gt;</p>

<pre class="code-block text"><code>['X', 1]
<p>['Y', 1]</p>
</code></pre>

<p>Nothing emits after <code class="inline">a$.next('X')</code> because <code class="inline">b$</code> hasn't emitted yet. After <code class="inline">b$.next(1)</code>, both have values, so it emits <code class="inline">['X', 1]</code>. After <code class="inline">a$.next('Y')</code>, it emits <code class="inline">['Y', 1]</code> (latest values). &lt;/details&gt;</p></div><div class="page-content"><hr>

<h2>Common Mistakes</h2>

<h3>Mistake 1: Forgetting to Unsubscribe</h3>

<pre class="code-block typescript"><code>// Wrong: memory leak
<p>ngOnInit() { this.filters$.subscribe(filters =&gt; { /<em> ... </em>/ }); }</p>

<p>// Right: cleanup on destroy ngOnDestroy() { this.subscription.unsubscribe(); }</p>
</code></pre>

<h3>Mistake 2: Nested Subscribes</h3>

<pre class="code-block typescript"><code>// Wrong: callback hell, hard to manage
<p>this.filters$.subscribe(filters =&gt; { this.apiAdapter.fetchData(filters).subscribe(response =&gt; { this.results = response.results; }); });</p>

<p>// Right: use operators to flatten this.results$ = this.filters$.pipe( switchMap(filters =&gt; this.apiAdapter.fetchData(filters)), map(response =&gt; response.results) );</p>
</code></pre>

<h3>Mistake 3: Missing shareReplay</h3>

<pre class="code-block typescript"><code>// Wrong: each subscriber triggers separate API calls
<p>this.results$ = this.filters$.pipe( switchMap(filters =&gt; this.apiAdapter.fetchData(filters)) );</p>

<p>// Right: share the result this.results$ = this.filters$.pipe( switchMap(filters =&gt; this.apiAdapter.fetchData(filters)), shareReplay(1) );</p>
</code></pre>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Observables model change over time</strong> — Perfect for UI state that updates</li>
<p><li><strong><code class="inline">switchMap</code> cancels previous operations</strong> — Use for API calls from user input</li> <li><strong><code class="inline">shareReplay(1)</code> prevents duplicate work</strong> — Always use when multiple components subscribe</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<p>This is a teaching section with no code changes. Criteria are conceptual:</p>

<ul><li>[ ] You can explain why Observables fit state management</li>
<p><li>[ ] You know when to use <code class="inline">switchMap</code> vs other flattening operators</li> <li>[ ] You understand what <code class="inline">shareReplay(1)</code> does and why it matters</li> <li>[ ] You can implement proper cleanup with <code class="inline">takeUntil</code> or async pipe</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">301-url-state-service.md</code> to create the first framework service using the RxJS patterns you just learned.</p></div></div>
    <div class="chapter" id="section-301">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>301: URL State Service</h1>
        </div>
<div class="page-content"><h1>301: URL State Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 201-209 (Framework Models), 250-rxjs-patterns-primer <strong>Blocks:</strong> 303-request-coordinator, 306-resource-management-service</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand why the URL is the single source of truth for application state</li>
<p><li>Know how to read and write URL query parameters in Angular</li> <li>Recognize the role of BehaviorSubject in providing synchronous access to asynchronous state</li> <li>Be able to implement bidirectional synchronization between application state and the URL</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">UrlStateService</code> that provides bidirectional synchronization between application state and URL query parameters. This service is the foundation of the URL-First State Management architecture.</p>

<hr>

<h2>Why</h2>

<p>Every web application manages state. The question is: <em>where does that state live?</em></p>

<p>Traditional approaches store state in:</p>
<ul><li>Component properties (lost on navigation)</li>
<p><li>Services (lost on page refresh)</li> <li>LocalStorage (requires manual sync)</li></p>
</ul>
<p><strong>The URL-First approach stores state in the URL itself.</strong> This provides several benefits:</p>

<table>
<p><thead><tr> <th>Feature</th> <th>URL-First</th> <th>Traditional State</th></p>
</tr></thead>
<p><tbody> <tr> <td>Shareable</td> <td>Copy URL to share exact application state</td> <td>Users see different views</td></p>
</tr>
<p><tr> <td>Bookmarkable</td> <td>Browser bookmarks preserve state</td> <td>Bookmarks lose context</td></p>
</tr>
<p><tr> <td>Deep-linkable</td> <td>External links open specific views</td> <td>Links open default views</td></p>
</tr>
<p><tr> <td>Back/Forward</td> <td>Browser history "just works"</td> <td>Requires manual history management</td></p>
</tr>
<p><tr> <td>Refresh-safe</td> <td>State survives page refresh</td> <td>State is lost</td></p>
</tr>
<p><tr> <td>Debuggable</td> <td>State visible in browser URL bar</td> <td>State hidden in memory</td></p>
</tr>
</tbody>
</table>

<h3>The Aha Moment</h3>

<p><strong>The URL is the single source of truth. Components react to URL changes, they don't control them.</strong></p>

<p>When a user clicks a filter, the component doesn't update its own state. Instead, it updates the URL. The URL change triggers an observable emission, which the component subscribes to. The component always <em>reads</em> state from the URL.</p>

<p>This creates a unidirectional data flow:</p>

<pre class="code-block text"><code>User Action → URL Update → Observable Emission → Component Update → UI Render
</code></pre></div><div class="page-content"><h3>Angular Router Integration</h3>

<p>The Angular Router provides <code class="inline">ActivatedRoute.queryParams</code> for reading query parameters. However, there's a subtlety: <code class="inline">ActivatedRoute</code> is scoped to the route hierarchy. A root-level service doesn't receive query param updates from child routes.</p>

<p><code class="inline">UrlStateService</code> solves this by:</p>
<ul><li>Using <code class="inline">Router.events</code> to watch all navigation events globally</li>
<p><li>Parsing query parameters from the router's URL directly</li> <li>Emitting changes through a <code class="inline">BehaviorSubject</code> that any component can subscribe to</li></p>
</ul>
<h3>RxJS Patterns Used</h3>

<p>This service uses patterns from Interlude B (Section 250):</p>

<table>
<p><thead><tr> <th>Pattern</th> <th>Usage</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">BehaviorSubject</code></td> <td>Holds current URL params with synchronous access via <code class="inline">.value</code></td></p>
</tr>
<p><tr> <td><code class="inline">filter()</code></td> <td>Only process <code class="inline">NavigationEnd</code> events</td></p>
</tr>
<p><tr> <td><code class="inline">map()</code></td> <td>Transform navigation events to query param objects</td></p>
</tr>
<p><tr> <td><code class="inline">distinctUntilChanged()</code></td> <td>Prevent duplicate emissions for identical params</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>What</h2>

<h3>Step 301.1: Create the Services Directory Index</h3>

<p>Before creating individual service files, create a barrel export file that will aggregate all service exports.</p>

<p>Create the file <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 1 (Section 301) - Barrel file for framework services</p>

<p>// This barrel file exports all framework services. // Import from '@app/framework/services' instead of individual files.</p>

<p>export * from './url-state.service';</p>
</code></pre>

<p>Delete the <code class="inline">.gitkeep</code> file since the directory now has real content:</p>

<pre class="code-block bash"><code>$ rm src/app/framework/services/.gitkeep
</code></pre>

<hr>

<h3>Step 301.2: Create the URL State Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/url-state.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/url-state.service.ts
<p>// VERSION 1 (Section 301) - URL-First state management foundation</p>

<p>import { Injectable, NgZone } from '@angular/core'; import { Router, ActivatedRoute, Params, NavigationEnd } from '@angular/router'; import { Observable, BehaviorSubject } from 'rxjs'; import { map, distinctUntilChanged, filter } from 'rxjs/operators';</p>

<p>/**</p>
 <ul><li>Domain-agnostic URL state management service</li>
</ul> *
 <ul><li>Provides bidirectional synchronization between application state and URL query parameters.</li>
</ul> <ul><li>The URL serves as the single source of truth for application state.</li>
</ul> *
 <ul><li><strong>Key Design Decisions:</strong></li>
</ul> *
 <ul><li>1. Uses Router.events instead of ActivatedRoute.queryParams because this is a</li>
</ul> <ul><li>   root-level singleton service. ActivatedRoute at root level doesn't receive</li>
</ul> <ul><li>   query param updates from child routes (like /discover).</li>
</ul> *
 <ul><li>2. Uses Router.url and parseUrl() instead of ActivatedRoute.snapshot.queryParams</li>
</ul> <ul><li>   for the same reason — to capture the full URL including child route params.</li>
</ul> *
 <ul><li>3. Uses BehaviorSubject to provide:</li>
</ul> <ul><li>   - Synchronous access to current params via getParams()</li>
</ul> <ul><li>   - Observable stream for reactive updates via watchParams()</li>
</ul> <ul><li>   - Immediate value emission to new subscribers</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In a component</li>
</ul> <ul><li>constructor(private urlState: UrlStateService) {</li>
</ul> <ul><li>  // Watch for changes reactively</li>
</ul> <ul><li>  this.urlState.watchParams&lt;MyFilters&gt;().subscribe(filters =&gt; {</li>
</ul> <ul><li>    console.log('Filters changed:', filters);</li>
</ul> <ul><li>  });</li>
</ul> *
 <ul><li>  // Get current value synchronously</li>
</ul> <ul><li>  const current = this.urlState.getParams&lt;MyFilters&gt;();</li>
</ul> *
 <ul><li>  // Update URL (triggers navigation)</li>
</ul> <ul><li>  this.urlState.setParams({ page: 2, search: 'ford' });</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class UrlStateService { /**</p>
   <ul><li>BehaviorSubject holding current URL query parameters</li>
</ul>   *
   <ul><li>BehaviorSubject is used instead of Subject because:</li>
</ul>   <ul><li>1. It holds the current value, enabling synchronous getParams()</li>
</ul>   <ul><li>2. New subscribers immediately receive the current value</li>
</ul>   <ul><li>3. It requires an initial value (empty object)</li>
</ul>   */
<p>private paramsSubject = new BehaviorSubject&lt;Params&gt;({});</p>

<p>/**</p>
   <ul><li>Public observable stream of URL query parameters</li>
</ul>   *
   <ul><li>Components subscribe to this to react to URL changes.</li>
</ul>   */
<p>public params$: Observable&lt;Params&gt; = this.paramsSubject.asObservable();</p>

<p>/**</p>
   <ul><li>Constructor - sets up URL synchronization</li>
</ul>   *
   <ul><li>@param router - Angular Router for navigation and URL parsing</li>
</ul>   <ul><li>@param route - ActivatedRoute for relative navigation</li>
</ul>   <ul><li>@param ngZone - NgZone for ensuring change detection runs</li>
</ul>   */
<p>constructor( private router: Router, private route: ActivatedRoute, private ngZone: NgZone ) { // Initialize from current URL on service creation this.initializeFromRoute();</p>

<p>// Watch for all future URL changes this.watchRouteChanges(); }</p>

<p>/**</p>
   <ul><li>Get current URL query parameters as a typed object</li>
</ul>   *
   <ul><li>Provides synchronous access to the current URL state.</li>
</ul>   <ul><li>Use this when you need the current value without subscribing.</li>
</ul>   *
   <ul><li>@template TParams - The shape of the parameters object</li>
</ul>   <ul><li>@returns Current query parameters cast to TParams</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>interface MyFilters {</li>
</ul>   <ul><li>  search: string;</li>
</ul>   <ul><li>  page: number;</li>
</ul>   <ul><li>}</li>
</ul>   *
   <ul><li>const filters = urlState.getParams&lt;MyFilters&gt;();</li>
</ul>   <ul><li>console.log(filters.search); // Type-safe access</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>getParams&lt;TParams = Params&gt;(): TParams { return this.paramsSubject.value as TParams; }</p>

<p>/**</p>
   <ul><li>Update URL query parameters</li>
</ul>   *
   <ul><li>Performs a shallow merge with existing parameters and navigates to the new URL.</li>
</ul>   <ul><li>Use null or undefined to remove a parameter.</li>
</ul>   *
   <ul><li>@template TParams - The shape of the parameters object</li>
</ul>   <ul><li>@param params - Partial parameters to update</li>
</ul>   <ul><li>@param replaceUrl - If true, replaces current history entry instead of pushing</li>
</ul>   <ul><li>@returns Promise that resolves when navigation completes</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// Update specific params</li>
</ul>   <ul><li>await urlState.setParams({ page: 2, search: 'test' });</li>
</ul>   *
   <ul><li>// Remove a param by setting to null</li>
</ul>   <ul><li>await urlState.setParams({ search: null });</li>
</ul>   *
   <ul><li>// Replace history entry (no new back button entry)</li>
</ul>   <ul><li>await urlState.setParams({ page: 1 }, true);</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>async setParams&lt;TParams = Params&gt;( params: Partial&lt;TParams&gt;, replaceUrl = false ): Promise&lt;boolean&gt; { const currentParams = this.paramsSubject.value; const mergedParams = { ...currentParams };</p>

<p>// Merge new params, removing null/undefined values Object.keys(params).forEach(key =&gt; { const value = (params as any)[key]; if (value === null || value === undefined) { delete mergedParams[key]; } else { mergedParams[key] = value; } });</p>

<p>return await this.router.navigate([], { relativeTo: this.route, queryParams: mergedParams, replaceUrl, queryParamsHandling: '' // Use exact params, don't preserve }); }</p>

<p>/**</p>
   <ul><li>Watch URL query parameters as an observable stream</li>
</ul>   *
   <ul><li>Returns an observable that emits whenever URL query parameters change.</li>
</ul>   <ul><li>Uses distinctUntilChanged to prevent duplicate emissions.</li>
</ul>   *
   <ul><li>@template TParams - The shape of the parameters object</li>
</ul>   <ul><li>@returns Observable of query parameters</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>urlState.watchParams&lt;MyFilters&gt;().subscribe(filters =&gt; {</li>
</ul>   <ul><li>  console.log('URL changed:', filters);</li>
</ul>   <ul><li>  this.loadData(filters);</li>
</ul>   <ul><li>});</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>watchParams&lt;TParams = Params&gt;(): Observable&lt;TParams&gt; { return this.params$.pipe( map(params =&gt; params as TParams), distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)) ); }</p>

<p>/**</p>
   <ul><li>Clear all URL query parameters</li>
</ul>   *
   <ul><li>Navigates to the current path with empty query string.</li>
</ul>   *
   <ul><li>@param replaceUrl - If true, replaces current history entry</li>
</ul>   <ul><li>@returns Promise that resolves when navigation completes</li>
</ul>   */
<p>async clearParams(replaceUrl = false): Promise&lt;boolean&gt; { return this.router.navigate([], { relativeTo: this.route, queryParams: {}, replaceUrl }); }</p>

<p>/**</p>
   <ul><li>Get a specific query parameter value</li>
</ul>   *
   <ul><li>@param key - Parameter key</li>
</ul>   <ul><li>@returns Parameter value or null if not found</li>
</ul>   */
<p>getParam(key: string): any { return this.paramsSubject.value[key] || null; }</p>

<p>/**</p>
   <ul><li>Set a specific query parameter</li>
</ul>   *
   <ul><li>Convenience method for updating a single parameter.</li>
</ul>   *
   <ul><li>@param key - Parameter key</li>
</ul>   <ul><li>@param value - Parameter value (null to remove)</li>
</ul>   <ul><li>@param replaceUrl - If true, replaces current history entry</li>
</ul>   <ul><li>@returns Promise that resolves when navigation completes</li>
</ul>   */
<p>async setParam( key: string, value: any, replaceUrl = false ): Promise&lt;boolean&gt; { return this.setParams({ [key]: value } as any, replaceUrl); }</p>

<p>/**</p>
   <ul><li>Check if a specific parameter exists in the URL</li>
</ul>   *
   <ul><li>@param key - Parameter key</li>
</ul>   <ul><li>@returns True if parameter exists</li>
</ul>   */
<p>hasParam(key: string): boolean { return key in this.paramsSubject.value; }</p>

<p>/**</p>
   <ul><li>Watch a specific parameter for changes</li>
</ul>   *
   <ul><li>@param key - Parameter key to watch</li>
</ul>   <ul><li>@returns Observable of parameter value</li>
</ul>   */
<p>watchParam(key: string): Observable&lt;any&gt; { return this.params$.pipe( map(params =&gt; params[key] || null), distinctUntilChanged() ); }</p>

<p>/**</p>
   <ul><li>Serialize parameters to URL query string</li>
</ul>   *
   <ul><li>Utility method for converting params object to query string format.</li>
</ul>   *
   <ul><li>@param params - Parameters object</li>
</ul>   <ul><li>@returns Query string (without leading '?')</li>
</ul>   */
<p>serializeParams(params: Params): string { const queryParams = new URLSearchParams();</p>

<p>Object.keys(params).forEach(key =&gt; { const value = params[key];</p>

<p>// Skip null/undefined if (value === null || value === undefined) { return; }</p>

<p>// Handle arrays (comma-separated) if (Array.isArray(value)) { queryParams.set(key, value.join(',')); return; }</p>

<p>// Convert to string queryParams.set(key, String(value)); });</p>

<p>return queryParams.toString(); }</p>

<p>/**</p>
   <ul><li>Deserialize URL query string to parameters object</li>
</ul>   *
   <ul><li>Utility method for parsing query string to params object.</li>
</ul>   <ul><li>Automatically converts numeric and boolean strings.</li>
</ul>   *
   <ul><li>@param queryString - Query string (with or without leading '?')</li>
</ul>   <ul><li>@returns Parameters object</li>
</ul>   */
<p>deserializeParams(queryString: string): Params { const params: Params = {}; const urlParams = new URLSearchParams( queryString.startsWith('?') ? queryString.slice(1) : queryString );</p>

<p>urlParams.forEach((value, key) =&gt; { // Try to parse as number if (!isNaN(Number(value)) &amp;&amp; value !== '') { params[key] = Number(value); return; }</p>

<p>// Try to parse as boolean if (value === 'true' || value === 'false') { params[key] = value === 'true'; return; }</p>

<p>// Check for comma-separated values (arrays) if (value.includes(',')) { params[key] = value.split(','); return; }</p>

<p>// Keep as string params[key] = value; });</p>

<p>return params; }</p>

<p>/**</p>
   <ul><li>Initialize from current route</li>
</ul>   *
   <ul><li>Called once in constructor to set initial state from URL.</li>
</ul>   *
   <ul><li>IMPORTANT: Uses router.url instead of route.snapshot because UrlStateService</li>
</ul>   <ul><li>is a root singleton. Root-level ActivatedRoute.snapshot may not have query</li>
</ul>   <ul><li>params from child routes (like /discover). router.url contains the full URL.</li>
</ul>   */
<p>private initializeFromRoute(): void { const params = this.extractQueryParams(); this.ngZone.run(() =&gt; { this.paramsSubject.next(params); }); }</p>

<p>/**</p>
   <ul><li>Watch for route changes and update internal state</li>
</ul>   *
   <ul><li>Sets up subscription to Router.events for ongoing synchronization.</li>
</ul>   *
   <ul><li>IMPORTANT: Uses Router.events instead of ActivatedRoute.queryParams because</li>
</ul>   <ul><li>UrlStateService is a root singleton. Root-level ActivatedRoute doesn't receive</li>
</ul>   <ul><li>query param updates from child routes (like /discover). Router.events is global</li>
</ul>   <ul><li>and captures all navigation events including query parameter changes.</li>
</ul>   */
<p>private watchRouteChanges(): void { this.router.events .pipe( // Only process NavigationEnd events (route change complete) filter((event): event is NavigationEnd =&gt; event instanceof NavigationEnd), // Extract query params from the new URL map(() =&gt; this.extractQueryParams()), // Only emit if params actually changed distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)) ) .subscribe(params =&gt; { // Use NgZone.run to ensure change detection runs this.ngZone.run(() =&gt; { this.paramsSubject.next(params); }); }); }</p>

<p>/**</p>
   <ul><li>Extract query parameters from current router state</li>
</ul>   *
   <ul><li>Uses router.parseUrl() to reliably extract query params</li>
</ul>   <ul><li>regardless of the route hierarchy.</li>
</ul>   */
<p>private extractQueryParams(): Params { const urlTree = this.router.parseUrl(this.router.url); return urlTree.queryParams; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 301.3: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code> to ensure the export is correct:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 1 (Section 301) - Barrel file for framework services</p>

<p>export * from './url-state.service';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>total 12
<p>drwxr-xr-x 2 user user 4096 Feb  9 12:00 . drwxr-xr-x 5 user user 4096 Feb  9 12:00 .. -rw-r--r-- 1 user user  123 Feb  9 12:00 index.ts -rw-r--r-- 1 user user 8456 Feb  9 12:00 url-state.service.ts</p>
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/services/url-state.service.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Verify Service Injectability</h3>

<p>Add a temporary test to <code class="inline">src/app/app.component.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/app.component.ts
<p>// TEMPORARY TEST - Remove after verification</p>

<p>import { Component, OnInit } from '@angular/core'; import { UrlStateService } from './framework/services';</p>

<p>@Component({ selector: 'app-root', templateUrl: './app.component.html', styleUrls: ['./app.component.scss'] }) export class AppComponent implements OnInit { title = 'vvroom';</p>

<p>constructor(private urlState: UrlStateService) {}</p>

<p>ngOnInit(): void { // Log URL changes to console this.urlState.watchParams().subscribe(params =&gt; { console.log('[UrlStateService] URL params:', params); }); } }</p>
</code></pre>

<h3>4. Run the Application</h3>

<pre class="code-block bash"><code>$ ng serve
</code></pre>

<p>Open browser to <code class="inline">http://localhost:4200</code> and:</p>

<ul><li>Open browser DevTools (F12) and go to Console tab</li>
<p><li>Navigate to <code class="inline">http://localhost:4200?search=ford&amp;page=1</code></li> <li>You should see in console: <code class="inline">[UrlStateService] URL params: {search: 'ford', page: '1'}</code></li> <li>Modify the URL manually to <code class="inline">http://localhost:4200?search=toyota&amp;page=2</code></li> <li>Console should show the new params</li></p>
</ul>
<h3>5. Verify Browser History</h3>

<ul><li>Navigate through several URL param changes</li>
<p><li>Click browser Back button</li> <li>Console should show params reverting to previous values</li> <li>This confirms URL-First state management is working</li></p>
</ul>
<p><strong>After verification, remove the temporary test code from AppComponent.</strong></p></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module '@angular/router'</code></td> <td>RouterModule not imported</td> <td>Ensure RouterModule is in app.module.ts imports</td></p>
</tr>
<p><tr> <td>Console shows empty object <code class="inline">{}</code></td> <td>Route not configured</td> <td>Ensure routes exist in app-routing.module.ts</td></p>
</tr>
<p><tr> <td>Params not updating on child route navigation</td> <td>Wrong ActivatedRoute</td> <td>Using Router.events (as implemented) solves this</td></p>
</tr>
<p><tr> <td>Change detection not running</td> <td>Missing NgZone</td> <td>Ensure ngZone.run() wraps paramsSubject.next()</td></p>
</tr>
<p><tr> <td>Duplicate console logs</td> <td>Multiple emissions</td> <td>distinctUntilChanged() should prevent this</td></p>
</tr>
<p><tr> <td>URL not updating on setParams()</td> <td>Navigation blocked</td> <td>Check for route guards or canDeactivate</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>The URL is the single source of truth</strong> — Components read state from the URL, they don't maintain their own copy</li>
<p><li><strong>BehaviorSubject enables both sync and async access</strong> — <code class="inline">.value</code> for sync, <code class="inline">.asObservable()</code> for reactive streams</li> <li><strong>Root services need special URL handling</strong> — Use <code class="inline">Router.events</code> and <code class="inline">router.parseUrl()</code> instead of <code class="inline">ActivatedRoute.queryParams</code></li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/url-state.service.ts</code> exists with complete implementation</li>
<p><li>[ ] <code class="inline">src/app/framework/services/index.ts</code> exports the service</li> <li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code> for singleton behavior</li> <li>[ ] <code class="inline">getParams&lt;T&gt;()</code> returns typed URL parameters synchronously</li> <li>[ ] <code class="inline">setParams&lt;T&gt;()</code> updates URL and triggers navigation</li> <li>[ ] <code class="inline">watchParams&lt;T&gt;()</code> returns observable stream of URL changes</li> <li>[ ] <code class="inline">distinctUntilChanged()</code> prevents duplicate emissions</li> <li>[ ] Service handles child route query params correctly via Router.events</li> <li>[ ] NgZone.run() ensures Angular change detection runs</li> <li>[ ] TypeScript compilation succeeds with no errors</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">302-api-service.md</code> to create the service for making HTTP requests to the API.</p></div></div>
    <div class="chapter" id="section-302">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>302: API Service</h1>
        </div>
<div class="page-content"><h1>302: API Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 206-api-response-interface <strong>Blocks:</strong> 303-request-coordinator, 310-filter-options-service, 502-api-adapter</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the role of a thin HTTP wrapper service in Angular applications</li>
<p><li>Know how to serialize query parameters for HTTP requests</li> <li>Recognize when to handle errors at the service level vs. propagate them</li> <li>Be able to implement a domain-agnostic API service</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">ApiService</code> that provides a type-safe, domain-agnostic wrapper around Angular's <code class="inline">HttpClient</code>. This service handles common patterns like query parameter serialization, error transformation, and response typing.</p>

<hr>

<h2>Why</h2>

<p>Every Angular application needs to make HTTP requests. The question is: <em>how do we structure these requests?</em></p>

<p><strong>Option 1: Direct HttpClient Usage</strong></p>

<pre class="code-block typescript"><code>// In component
<p>this.http.get&lt;Vehicle[]&gt;('/api/vehicles', { params: new HttpParams() .set('page', '1') .set('size', '20') .set('manufacturer', 'Ford,Toyota') }).subscribe(data =&gt; { // handle response });</p>
</code></pre>

<p>This works, but has problems:</p>
<ul><li>Verbose param building repeated everywhere</li>
<p><li>Error handling duplicated in each call</li> <li>No consistent typing strategy</li> <li>Hard to add cross-cutting concerns (logging, auth)</li></p>
</ul>
<p><strong>Option 2: Domain-Specific Services</strong></p>

<pre class="code-block typescript"><code>// In VehicleService
<p>getVehicles(filters: VehicleFilters): Observable&lt;Vehicle[]&gt; { return this.http.get&lt;Vehicle[]&gt;('/api/vehicles', { params: this.buildParams(filters) }); }</p>
</code></pre>

<p>Better, but now every domain needs its own service with repeated boilerplate.</p>

<p><strong>Option 3: Thin HTTP Wrapper (Our Approach)</strong></p>

<pre class="code-block typescript"><code>// ApiService provides thin wrapper
<p>this.api.get&lt;Vehicle&gt;('/api/vehicles', { params: filters })</p>

<p>// Domain adapter uses it this.api.get&lt;Vehicle&gt;(this.baseUrl + '/vehicles', { params: filters })</p>
</code></pre>

<p><code class="inline">ApiService</code> handles:</p>
<ul><li>Query parameter serialization (including arrays)</li>
<p><li>Error transformation to consistent format</li> <li>Response typing</li></p>
</ul>
<p>Domain adapters (created in Phase 5) use <code class="inline">ApiService</code> for domain-specific logic.</p></div><div class="page-content"><h3>Why Not More Abstraction?</h3>

<p>You might wonder: <em>Why not build a full data layer with repositories, unit of work, etc.?</em></p>

<p>The answer is <strong>YAGNI (You Aren't Gonna Need It)</strong>. The vvroom application:</p>
<ul><li>Reads data from a REST API</li>
<p><li>Displays it in tables and charts</li> <li>Filters via URL parameters</li></p>
</ul>
<p>A thin HTTP wrapper is all we need. Adding more abstraction would increase complexity without benefit.</p>

<h3>Error Handling Strategy</h3>

<p><code class="inline">ApiService</code> catches errors and transforms them into consistent Error objects. It does NOT:</p>
<ul><li>Show UI notifications (that's the component's job)</li>
<p><li>Retry failed requests (that's <code class="inline">RequestCoordinator</code>'s job)</li> <li>Log to external services (that's the error handler's job)</li></p>
</ul>
<p>Each layer has its responsibility.</p>

<hr>

<h2>What</h2>

<h3>Step 302.1: Create the API Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/api.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/api.service.ts
<p>// VERSION 1 (Section 302) - Domain-agnostic HTTP wrapper</p>

<p>import { Injectable } from '@angular/core'; import { HttpClient, HttpParams, HttpErrorResponse } from '@angular/common/http'; import { Observable, throwError } from 'rxjs'; import { catchError, map } from 'rxjs/operators'; import { ApiResponse, StandardApiResponse } from '../models/api-response.interface';</p>

<p>/**</p>
 <ul><li>Options for API requests</li>
</ul> *
 <ul><li>Provides a simplified interface for common HTTP options.</li>
</ul> */
<p>export interface ApiRequestOptions { /**</p>
   <ul><li>Query parameters to append to the URL</li>
</ul>   <ul><li>Arrays are serialized as comma-separated values</li>
</ul>   */
<p>params?: Record&lt;string, any&gt;;</p>

<p>/**</p>
   <ul><li>HTTP headers to include in the request</li>
</ul>   */
<p>headers?: Record&lt;string, string&gt;;</p>

<p>/**</p>
   <ul><li>Whether to include credentials (cookies) in the request</li>
</ul>   */
<p>withCredentials?: boolean;</p>

<p>/**</p>
   <ul><li>Response type (default: 'json')</li>
</ul>   */
<p>responseType?: 'json' | 'text' | 'blob' | 'arraybuffer'; }</p>

<p>/**</p>
 <ul><li>Domain-agnostic API service for making HTTP requests</li>
</ul> *
 <ul><li>This service provides a thin, type-safe wrapper around Angular's HttpClient.</li>
</ul> <ul><li>It handles common patterns like query parameter serialization and error handling.</li>
</ul> *
 <ul><li><strong>Design Philosophy:</strong></li>
</ul> *
 <ul><li>1. <strong>Thin wrapper</strong> - Doesn't add unnecessary abstraction over HttpClient</li>
</ul> <ul><li>2. <strong>Type-safe</strong> - Generic methods return typed observables</li>
</ul> <ul><li>3. <strong>Domain-agnostic</strong> - No domain-specific logic here</li>
</ul> <ul><li>4. <strong>Error transformation</strong> - Converts HTTP errors to consistent Error objects</li>
</ul> *
 <ul><li>Domain-specific logic (like URL construction, response transformation) belongs</li>
</ul> <ul><li>in domain adapters (created in Phase 5), not here.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// GET request with pagination</li>
</ul> <ul><li>this.api.get&lt;VehicleResult&gt;('/api/vehicles', {</li>
</ul> <ul><li>  params: { page: 1, size: 20, manufacturer: ['Ford', 'Toyota'] }</li>
</ul> <ul><li>}).subscribe(response =&gt; {</li>
</ul> <ul><li>  console.log(response.results);</li>
</ul> <ul><li>});</li>
</ul> *
 <ul><li>// POST request</li>
</ul> <ul><li>this.api.post&lt;VehicleResult&gt;('/api/vehicles', {</li>
</ul> <ul><li>  manufacturer: 'Ford',</li>
</ul> <ul><li>  model: 'F-150'</li>
</ul> <ul><li>}).subscribe(vehicle =&gt; {</li>
</ul> <ul><li>  console.log('Created:', vehicle);</li>
</ul> <ul><li>});</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class ApiService { /**</p>
   <ul><li>Constructor - injects HttpClient</li>
</ul>   *
   <ul><li>Using <code class="inline">readonly</code> to ensure the dependency isn't reassigned.</li>
</ul>   */
<p>constructor(private readonly http: HttpClient) {}</p>

<p>/**</p>
   <ul><li>Execute a GET request</li>
</ul>   *
   <ul><li>Returns the standard paginated API response format.</li>
</ul>   *
   <ul><li>@template TData - The type of items in the response</li>
</ul>   <ul><li>@param endpoint - API endpoint (absolute or relative URL)</li>
</ul>   <ul><li>@param options - Request options (params, headers, etc.)</li>
</ul>   <ul><li>@returns Observable of paginated response</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>this.api.get&lt;VehicleResult&gt;('/api/vehicles', {</li>
</ul>   <ul><li>  params: { page: 1, manufacturer: 'Ford' }</li>
</ul>   <ul><li>}).subscribe(response =&gt; {</li>
</ul>   <ul><li>  console.log(<code class="inline">Found ${response.total} vehicles</code>);</li>
</ul>   <ul><li>  console.log('Results:', response.results);</li>
</ul>   <ul><li>});</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>get&lt;TData&gt;( endpoint: string, options?: ApiRequestOptions ): Observable&lt;ApiResponse&lt;TData&gt;&gt; { const httpParams = this.buildHttpParams(options?.params);</p>

<p>return this.http .get&lt;ApiResponse&lt;TData&gt;&gt;(endpoint, { params: httpParams, headers: options?.headers, withCredentials: options?.withCredentials }) .pipe(catchError(this.handleError)); }</p>

<p>/**</p>
   <ul><li>Execute a POST request</li>
</ul>   *
   <ul><li>@template TData - The type of response data</li>
</ul>   <ul><li>@param endpoint - API endpoint (absolute or relative URL)</li>
</ul>   <ul><li>@param body - Request body</li>
</ul>   <ul><li>@param options - Request options (params, headers, etc.)</li>
</ul>   <ul><li>@returns Observable of response data</li>
</ul>   */
<p>post&lt;TData&gt;( endpoint: string, body: any, options?: ApiRequestOptions ): Observable&lt;TData&gt; { const httpParams = this.buildHttpParams(options?.params);</p>

<p>return this.http .post&lt;TData&gt;(endpoint, body, { params: httpParams, headers: options?.headers, withCredentials: options?.withCredentials }) .pipe(catchError(this.handleError)); }</p>

<p>/**</p>
   <ul><li>Execute a PUT request</li>
</ul>   *
   <ul><li>@template TData - The type of response data</li>
</ul>   <ul><li>@param endpoint - API endpoint (absolute or relative URL)</li>
</ul>   <ul><li>@param body - Request body</li>
</ul>   <ul><li>@param options - Request options (params, headers, etc.)</li>
</ul>   <ul><li>@returns Observable of response data</li>
</ul>   */
<p>put&lt;TData&gt;( endpoint: string, body: any, options?: ApiRequestOptions ): Observable&lt;TData&gt; { const httpParams = this.buildHttpParams(options?.params);</p>

<p>return this.http .put&lt;TData&gt;(endpoint, body, { params: httpParams, headers: options?.headers, withCredentials: options?.withCredentials }) .pipe(catchError(this.handleError)); }</p>

<p>/**</p>
   <ul><li>Execute a PATCH request</li>
</ul>   *
   <ul><li>@template TData - The type of response data</li>
</ul>   <ul><li>@param endpoint - API endpoint (absolute or relative URL)</li>
</ul>   <ul><li>@param body - Request body</li>
</ul>   <ul><li>@param options - Request options (params, headers, etc.)</li>
</ul>   <ul><li>@returns Observable of response data</li>
</ul>   */
<p>patch&lt;TData&gt;( endpoint: string, body: any, options?: ApiRequestOptions ): Observable&lt;TData&gt; { const httpParams = this.buildHttpParams(options?.params);</p>

<p>return this.http .patch&lt;TData&gt;(endpoint, body, { params: httpParams, headers: options?.headers, withCredentials: options?.withCredentials }) .pipe(catchError(this.handleError)); }</p>

<p>/**</p>
   <ul><li>Execute a DELETE request</li>
</ul>   *
   <ul><li>@template TData - The type of response data</li>
</ul>   <ul><li>@param endpoint - API endpoint (absolute or relative URL)</li>
</ul>   <ul><li>@param options - Request options (params, headers, etc.)</li>
</ul>   <ul><li>@returns Observable of response data</li>
</ul>   */
<p>delete&lt;TData&gt;( endpoint: string, options?: ApiRequestOptions ): Observable&lt;TData&gt; { const httpParams = this.buildHttpParams(options?.params);</p>

<p>return this.http .delete&lt;TData&gt;(endpoint, { params: httpParams, headers: options?.headers, withCredentials: options?.withCredentials }) .pipe(catchError(this.handleError)); }</p>

<p>/**</p>
   <ul><li>Execute a GET request that returns a standard success/error response</li>
</ul>   *
   <ul><li>Some APIs wrap responses in a success/error envelope:</li>
</ul>   <ul><li></code></pre>json</li>
</ul>   <ul><li>{ "success": true, "data": { ... } }</li>
</ul>   <ul><li>{ "success": false, "error": { "message": "..." } }</li>
</ul>   <em> <pre class="code-block text"><code>   </em>
   <ul><li>This method unwraps successful responses and throws on error.</li>
</ul>   *
   <ul><li>@template TData - The type of data in the response</li>
</ul>   <ul><li>@param endpoint - API endpoint (absolute or relative URL)</li>
</ul>   <ul><li>@param options - Request options (params, headers, etc.)</li>
</ul>   <ul><li>@returns Observable of response data (unwrapped from success envelope)</li>
</ul>   */
<p>getStandard&lt;TData&gt;( endpoint: string, options?: ApiRequestOptions ): Observable&lt;TData&gt; { const httpParams = this.buildHttpParams(options?.params);</p>

<p>return this.http .get&lt;StandardApiResponse&lt;TData&gt;&gt;(endpoint, { params: httpParams, headers: options?.headers, withCredentials: options?.withCredentials }) .pipe( map(response =&gt; { if (response.success) { return response.data; } else { throw new Error(response.error.message); } }), catchError(this.handleError) ); }</p>

<p>/**</p>
   <ul><li>Build HttpParams from a plain object</li>
</ul>   *
   <ul><li>Handles:</li>
</ul>   <ul><li>- Null/undefined value filtering (skipped)</li>
</ul>   <ul><li>- Array serialization (comma-separated)</li>
</ul>   <ul><li>- Boolean/number to string conversion</li>
</ul>   *
   <ul><li>@param params - Plain object of query parameters</li>
</ul>   <ul><li>@returns HttpParams instance</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// Input</li>
</ul>   <ul><li>{ page: 1, manufacturer: ['Ford', 'Toyota'], active: true, empty: null }</li>
</ul>   *
   <ul><li>// Output HttpParams</li>
</ul>   <ul><li>page=1&amp;manufacturer=Ford,Toyota&amp;active=true</li>
</ul>   <ul><li>// Note: 'empty' is skipped because it's null</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>private buildHttpParams(params?: Record&lt;string, any&gt;): HttpParams { let httpParams = new HttpParams();</p>

<p>if (!params) { return httpParams; }</p>

<p>Object.keys(params).forEach(key =&gt; { const value = params[key];</p>

<p>// Skip null/undefined values if (value === null || value === undefined) { return; }</p>

<p>// Handle arrays (comma-separated) if (Array.isArray(value)) { httpParams = httpParams.set(key, value.join(',')); return; }</p>

<p>// Convert to string httpParams = httpParams.set(key, String(value)); });</p>

<p>return httpParams; }</p>

<p>/**</p>
   <ul><li>Handle HTTP errors</li>
</ul>   *
   <ul><li>Transforms HttpErrorResponse into a consistent Error format.</li>
</ul>   <ul><li>Logs the error for debugging, then re-throws for upstream handling.</li>
</ul>   *
   <ul><li>@param error - HTTP error response</li>
</ul>   <ul><li>@returns Observable that throws a formatted error</li>
</ul>   */
<p>private handleError(error: HttpErrorResponse): Observable&lt;never&gt; { let errorMessage = 'An unknown error occurred';</p>

<p>if (error.error instanceof ErrorEvent) { // Client-side or network error errorMessage = <code class="inline">Network error: ${error.error.message}</code>; } else { // Backend error if (error.error?.error?.message) { // Structured error response: { error: { message: "..." } } errorMessage = error.error.error.message; } else if (error.error?.message) { // Simple error response: { message: "..." } errorMessage = error.error.message; } else if (error.message) { // HttpErrorResponse message errorMessage = error.message; } else { // Fallback to status errorMessage = <code class="inline">Server error: ${error.status} ${error.statusText}</code>; } }</p>

<p>console.error('API Error:', errorMessage, error);</p>

<p>return throwError(() =&gt; new Error(errorMessage)); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 302.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code> to export the new service:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 2 (Section 302) - Added ApiService</p>

<p>export * from './url-state.service'; export * from './api.service';</p>
</code></pre>

<hr>

<h3>Step 302.3: Ensure HttpClientModule is Imported</h3>

<p>The <code class="inline">ApiService</code> depends on <code class="inline">HttpClient</code>, which requires <code class="inline">HttpClientModule</code> to be imported in the app module.</p>

<p>Verify <code class="inline">src/app/app.module.ts</code> includes:</p>

<pre class="code-block typescript"><code>// src/app/app.module.ts
<p>// Ensure HttpClientModule is imported</p>

<p>import { NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { HttpClientModule } from '@angular/common/http';  // &lt;-- Required</p>

<p>import { AppRoutingModule } from './app-routing.module'; import { AppComponent } from './app.component';</p>

<p>@NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, AppRoutingModule, HttpClientModule  // &lt;-- Must be here ], providers: [], bootstrap: [AppComponent] }) export class AppModule { }</p>
</code></pre>

<p>If <code class="inline">HttpClientModule</code> is missing, add it as shown.</p>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/
</code></pre>

<p>Expected output includes:</p>

<pre class="code-block text"><code>-rw-r--r-- 1 user user 7234 Feb  9 12:00 api.service.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/framework/services/api.service.ts</p>
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>4. Verify in Browser (Optional)</h3>

<p>If you have a working API endpoint, you can test:</p>

<pre class="code-block typescript"><code>// Temporary test in any component
<p>constructor(private api: ApiService) { this.api.get&lt;any&gt;('http://generic-prime.minilab/api/specs/v1/automobiles', { params: { page: 1, size: 5 } }).subscribe({ next: response =&gt; console.log('API Response:', response), error: err =&gt; console.error('API Error:', err) }); }</p>
</code></pre></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">NullInjectorError: No provider for HttpClient</code></td> <td>HttpClientModule not imported</td> <td>Add HttpClientModule to app.module.ts imports</td></p>
</tr>
<p><tr> <td><code class="inline">Cannot find module '../models/api-response.interface'</code></td> <td>Interface file missing</td> <td>Create it in Section 206 first</td></p>
</tr>
<p><tr> <td>CORS errors in browser</td> <td>API doesn't allow cross-origin</td> <td>Configure API server or use proxy</td></p>
</tr>
<p><tr> <td><code class="inline">Type 'Observable&lt;Object&gt;' is not assignable to...</code></td> <td>Generic type mismatch</td> <td>Ensure response type matches expected type</td></p>
</tr>
<p><tr> <td>Arrays serialized as <code class="inline">[object Object]</code></td> <td>Nested objects in params</td> <td>Flatten objects before passing to params</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Thin wrappers reduce boilerplate</strong> — ApiService handles serialization and errors so each call site doesn't have to</li>
<p><li><strong>Arrays serialize as comma-separated values</strong> — This matches common REST API conventions</li> <li><strong>Error handling transforms, doesn't swallow</strong> — Errors are logged and re-thrown for upstream handling</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/api.service.ts</code> exists with complete implementation</li>
<p><li>[ ] Barrel file exports the service</li> <li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li>[ ] <code class="inline">get&lt;T&gt;()</code> method returns typed Observable</li> <li>[ ] <code class="inline">post&lt;T&gt;()</code>, <code class="inline">put&lt;T&gt;()</code>, <code class="inline">patch&lt;T&gt;()</code>, <code class="inline">delete&lt;T&gt;()</code> methods implemented</li> <li>[ ] <code class="inline">getStandard&lt;T&gt;()</code> unwraps success/error envelope responses</li> <li>[ ] <code class="inline">buildHttpParams()</code> correctly serializes arrays as comma-separated</li> <li>[ ] <code class="inline">handleError()</code> transforms errors consistently</li> <li>[ ] HttpClientModule is imported in app.module.ts</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">303-request-coordinator.md</code> to create the service that coordinates API requests with caching and deduplication.</p></div></div>
    <div class="chapter" id="section-303">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>303: Request Coordinator</h1>
        </div>
<div class="page-content"><h1>303: Request Coordinator Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 302-api-service <strong>Blocks:</strong> 306-resource-management-service</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the three-layer request processing model (cache, dedup, HTTP)</li>
<p><li>Know how to implement TTL-based response caching</li> <li>Recognize the in-flight deduplication pattern for preventing duplicate requests</li> <li>Be able to implement exponential backoff retry logic</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">RequestCoordinatorService</code> that provides intelligent request coordination with three processing layers: response caching, in-flight deduplication, and HTTP execution with retry.</p>

<hr>

<h2>Why</h2>

<p>When users interact with the vvroom application, they generate many API requests:</p>
<ul><li>Changing filters → new data fetch</li>
<p><li>Navigating between pages → data fetch</li> <li>Browser back/forward → URL change → data fetch</li> <li>Pop-out windows → parallel data fetch</li></p>
</ul>
<p>Without coordination, these requests can:</p>
<ul><li><strong>Overwhelm the API</strong> — Same request sent multiple times</li>
<p><li><strong>Waste bandwidth</strong> — Re-fetching data that hasn't changed</li> <li><strong>Create race conditions</strong> — Responses arriving out of order</li> <li><strong>Fail silently</strong> — Transient network errors losing data</li></p>
</ul>
<p><code class="inline">RequestCoordinatorService</code> solves these problems with a three-layer approach:</p>

<h3>Layer 1: Response Cache (TTL-Based)</h3>

<pre class="code-block text"><code>Request comes in → Check cache → If fresh, return cached → Skip HTTP
</code></pre>

<ul><li>Stores successful responses with timestamp</li>
<p><li>Returns cached response if within TTL</li> <li>Reduces API load for repeated queries</li></p>
</ul>
<h3>Layer 2: In-Flight Deduplication</h3>

<pre class="code-block text"><code>Request comes in → Check if same request in progress → If yes, share observable → One HTTP call serves many subscribers
</code></pre>

<ul><li>Tracks ongoing requests by key</li>
<p><li>Multiple calls to same endpoint share one observable</li> <li>Prevents duplicate concurrent requests</li></p>
</ul>
<h3>Layer 3: HTTP Request with Retry</h3>

<pre class="code-block text"><code>Execute HTTP → On failure, wait → Retry with exponential backoff → After N failures, give up
</code></pre>

<ul><li>Executes the actual HTTP request</li>
<p><li>Retries transient failures with exponential backoff</li> <li>Gives up after configurable number of attempts</li></ul></p></div><div class="page-content"><h3>Visual Flow</h3>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────────────────┐
<p>│                          Request Comes In                                    │ └─────────────────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────────────────┐ │ Layer 1: Response Cache                                                      │ │ ┌─────────────────────────────────────────────────────────────────────────┐ │ │ │  Is there a cached response for this key that hasn't expired?           │ │ │ │  YES → Return cached response immediately (no HTTP)                     │ │ │ │  NO  → Proceed to Layer 2                                               │ │ │ └─────────────────────────────────────────────────────────────────────────┘ │ └─────────────────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────────────────┐ │ Layer 2: In-Flight Deduplication                                             │ │ ┌─────────────────────────────────────────────────────────────────────────┐ │ │ │  Is there already a request in progress for this key?                   │ │ │ │  YES → Return the existing observable (share it)                        │ │ │ │  NO  → Proceed to Layer 3                                               │ │ │ └─────────────────────────────────────────────────────────────────────────┘ │ └─────────────────────────────────────────────────────────────────────────────┘ │ ▼ ┌─────────────────────────────────────────────────────────────────────────────┐ │ Layer 3: HTTP Request with Retry                                             │ │ ┌─────────────────────────────────────────────────────────────────────────┐ │ │ │  Execute HTTP request                                                    │ │ │ │  On success → Cache response → Return data                              │ │ │ │  On failure → Retry with exponential backoff                            │ │ │ │  After N failures → Propagate error                                     │ │ │ └─────────────────────────────────────────────────────────────────────────┘ │ └─────────────────────────────────────────────────────────────────────────────┘</p>
</code></pre></div><div class="page-content"><h3>RxJS Patterns Used</h3>

<table>
<p><thead><tr> <th>Pattern</th> <th>Usage</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">BehaviorSubject</code></td> <td>Tracks loading states per request key</td></p>
</tr>
<p><tr> <td><code class="inline">shareReplay(1)</code></td> <td>Shares observable among multiple subscribers</td></p>
</tr>
<p><tr> <td><code class="inline">retry()</code></td> <td>Retries failed requests with custom delay</td></p>
</tr>
<p><tr> <td><code class="inline">timer()</code></td> <td>Creates delay between retries</td></p>
</tr>
<p><tr> <td><code class="inline">finalize()</code></td> <td>Cleanup when observable completes or errors</td></p>
</tr>
<p><tr> <td><code class="inline">tap()</code></td> <td>Side effect to cache successful responses</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>What</h2>

<h3>Step 303.1: Create the Request Coordinator Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/request-coordinator.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/request-coordinator.service.ts
<p>// VERSION 1 (Section 303) - Three-layer request coordination</p>

<p>import { Injectable } from '@angular/core'; import { Observable, BehaviorSubject, timer } from 'rxjs'; import { tap, finalize, shareReplay, retry, map, distinctUntilChanged } from 'rxjs/operators';</p>

<p>/**</p>
 <ul><li>Configuration options for request coordination</li>
</ul> */
<p>export interface RequestConfig { /**</p>
   <ul><li>Cache time-to-live in milliseconds</li>
</ul>   <ul><li>Responses older than this are considered stale and refetched</li>
</ul>   <ul><li>@default 30000 (30 seconds)</li>
</ul>   */
<p>cacheTTL?: number;</p>

<p>/**</p>
   <ul><li>Number of retry attempts on failure</li>
</ul>   <ul><li>Set to 0 to disable retries</li>
</ul>   <ul><li>@default 3</li>
</ul>   */
<p>retryAttempts?: number;</p>

<p>/**</p>
   <ul><li>Initial retry delay in milliseconds</li>
</ul>   <em> Subsequent retries use exponential backoff (delay </em> 2^attempt)
   <ul><li>@default 1000 (1 second)</li>
</ul>   */
<p>retryDelay?: number;</p>

<p>/**</p>
   <ul><li>Force bypass cache and execute fresh request</li>
</ul>   <ul><li>Use for "refresh" functionality</li>
</ul>   <ul><li>@default false</li>
</ul>   */
<p>skipCache?: boolean; }</p>

<p>/**</p>
 <ul><li>Cache entry structure</li>
</ul> */
<p>interface CacheEntry&lt;T&gt; { /<em>* Cached response data </em>/ data: T; /<em>* Timestamp when cached (ms since epoch) </em>/ timestamp: number; /<em>* Time-to-live in milliseconds </em>/ ttl: number; }</p>

<p>/**</p>
 <ul><li>Domain-agnostic request coordination service</li>
</ul> *
 <ul><li>Provides three-layer request processing:</li>
</ul> <ul><li>1. <strong>Response Cache</strong> (TTL-based) - Return cached response if fresh</li>
</ul> <ul><li>2. <strong>In-Flight Deduplication</strong> - Share ongoing requests</li>
</ul> <ul><li>3. <strong>HTTP Request with Retry</strong> - Execute with exponential backoff</li>
</ul> *
 <ul><li><strong>Why This Matters:</strong></li>
</ul> *
 <ul><li>Without coordination:</li>
</ul> <ul><li>- User changes filter → 5 requests fire → 5 responses arrive → UI flickers</li>
</ul> <ul><li>- User hits back button → request for data we just had → wasted bandwidth</li>
</ul> <ul><li>- Network blip → request fails → data lost</li>
</ul> *
 <ul><li>With coordination:</li>
</ul> <ul><li>- User changes filter → 1 request fires → 1 response → smooth UI</li>
</ul> <ul><li>- User hits back → cache hit → instant data → no network call</li>
</ul> <ul><li>- Network blip → retry → data recovered</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Basic usage</li>
</ul> <ul><li>this.coordinator.execute(</li>
</ul> <ul><li>  'vehicles-page-1',</li>
</ul> <ul><li>  () =&gt; this.api.get&lt;Vehicle[]&gt;('/vehicles?page=1')</li>
</ul> <ul><li>).subscribe(vehicles =&gt; {</li>
</ul> <ul><li>  console.log('Vehicles:', vehicles);</li>
</ul> <ul><li>});</li>
</ul> *
 <ul><li>// With custom configuration</li>
</ul> <ul><li>this.coordinator.execute(</li>
</ul> <ul><li>  'stats-latest',</li>
</ul> <ul><li>  () =&gt; this.api.get&lt;Stats&gt;('/stats'),</li>
</ul> <ul><li>  { cacheTTL: 60000, retryAttempts: 5 }</li>
</ul> <ul><li>).subscribe(stats =&gt; {</li>
</ul> <ul><li>  console.log('Statistics:', stats);</li>
</ul> <ul><li>});</li>
</ul> *
 <ul><li>// Force fresh fetch (skip cache)</li>
</ul> <ul><li>this.coordinator.execute(</li>
</ul> <ul><li>  'vehicles-page-1',</li>
</ul> <ul><li>  () =&gt; this.api.get&lt;Vehicle[]&gt;('/vehicles?page=1'),</li>
</ul> <ul><li>  { skipCache: true }</li>
</ul> <ul><li>).subscribe();</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class RequestCoordinatorService { /**</p>
   <ul><li>Response cache storage</li>
</ul>   *
   <ul><li>Maps request keys to CacheEntry objects containing:</li>
</ul>   <ul><li>- Cached data</li>
</ul>   <ul><li>- Timestamp when cached</li>
</ul>   <ul><li>- TTL for this entry</li>
</ul>   */
<p>private cache = new Map&lt;string, CacheEntry&lt;any&gt;&gt;();</p>

<p>/**</p>
   <ul><li>In-flight requests storage</li>
</ul>   *
   <ul><li>Maps request keys to Observable instances of ongoing HTTP requests.</li>
</ul>   <ul><li>If a second request comes in with the same key while the first is</li>
</ul>   <ul><li>still in progress, we return the same observable (deduplication).</li>
</ul>   */
<p>private inFlightRequests = new Map&lt;string, Observable&lt;any&gt;&gt;();</p>

<p>/**</p>
   <ul><li>Loading state per request key</li>
</ul>   *
   <ul><li>Tracks which requests are currently loading.</li>
</ul>   <ul><li>Components can subscribe to know when specific data is loading.</li>
</ul>   */
<p>private loadingStateSubject = new BehaviorSubject&lt;Map&lt;string, boolean&gt;&gt;( new Map() );</p>

<p>/**</p>
   <ul><li>Observable of loading states</li>
</ul>   *
   <ul><li>Emits Map of request keys to loading booleans.</li>
</ul>   <ul><li>Use getLoadingState$() or getGlobalLoading$() for filtered access.</li>
</ul>   */
<p>public loadingState$ = this.loadingStateSubject.asObservable();</p>

<p>/**</p>
   <ul><li>Execute HTTP request with caching, deduplication, and retry</li>
</ul>   *
   <ul><li>The three-layer processing:</li>
</ul>   <ul><li>1. Check cache (return immediately if fresh)</li>
</ul>   <ul><li>2. Check in-flight (share if same request in progress)</li>
</ul>   <ul><li>3. Execute HTTP with retry and caching</li>
</ul>   *
   <ul><li>@template T - Response type</li>
</ul>   <ul><li>@param requestKey - Unique identifier for this request</li>
</ul>   <ul><li>@param requestFn - Function that returns Observable (lazy execution)</li>
</ul>   <ul><li>@param config - Optional request configuration</li>
</ul>   <ul><li>@returns Observable of response data (shared, cached, deduplicated)</li>
</ul>   */
<p>execute&lt;T&gt;( requestKey: string, requestFn: () =&gt; Observable&lt;T&gt;, config?: RequestConfig ): Observable&lt;T&gt; { const effectiveConfig = this.getEffectiveConfig(config);</p>

<p>// Layer 1: Check response cache (unless skipCache) if (!effectiveConfig.skipCache) { const cachedResponse = this.getCachedResponse&lt;T&gt;(requestKey); if (cachedResponse !== null) { // Return cached data wrapped in observable return new Observable(observer =&gt; { observer.next(cachedResponse); observer.complete(); }); } }</p>

<p>// Layer 2: Check in-flight requests (deduplication) if (this.inFlightRequests.has(requestKey)) { // Return existing observable (same request in progress) return this.inFlightRequests.get(requestKey)!; }</p>

<p>// Layer 3: Execute HTTP request with retry this.setLoadingState(requestKey, true);</p>

<p>const request$ = requestFn().pipe( // Retry with exponential backoff retry({ count: effectiveConfig.retryAttempts!, delay: (error, retryCount) =&gt; { const delay = effectiveConfig.retryDelay! * Math.pow(2, retryCount - 1); console.log( <code class="inline">[RequestCoordinator] Retry ${retryCount} for ${requestKey} in ${delay}ms</code> ); return timer(delay); } }), // Cache successful response tap(data =&gt; { if (!effectiveConfig.skipCache) { this.setCachedResponse( requestKey, data, effectiveConfig.cacheTTL! ); } }), // Cleanup on complete/error finalize(() =&gt; { this.inFlightRequests.delete(requestKey); this.setLoadingState(requestKey, false); }), // Share with multiple subscribers (deduplication) shareReplay(1) );</p>

<p>// Store in-flight request for deduplication this.inFlightRequests.set(requestKey, request$);</p>

<p>return request$; }</p>

<p>/**</p>
   <ul><li>Get loading state for specific request</li>
</ul>   *
   <ul><li>@param requestKey - Request identifier</li>
</ul>   <ul><li>@returns Observable of loading state for this request</li>
</ul>   */
<p>getLoadingState$(requestKey: string): Observable&lt;boolean&gt; { return this.loadingState$.pipe( map(stateMap =&gt; stateMap.get(requestKey) || false), distinctUntilChanged() ); }</p>

<p>/**</p>
   <ul><li>Get global loading state (true if any request is loading)</li>
</ul>   *
   <ul><li>@returns Observable of global loading state</li>
</ul>   */
<p>getGlobalLoading$(): Observable&lt;boolean&gt; { return this.loadingState$.pipe( map(stateMap =&gt; Array.from(stateMap.values()).some(loading =&gt; loading)), distinctUntilChanged() ); }</p>

<p>/**</p>
   <ul><li>Clear all cached responses or specific request cache</li>
</ul>   *
   <ul><li>@param requestKey - Optional specific request key to clear</li>
</ul>   */
<p>clearCache(requestKey?: string): void { if (requestKey) { this.cache.delete(requestKey); } else { this.cache.clear(); } }</p>

<p>/**</p>
   <ul><li>Invalidate specific cached response</li>
</ul>   *
   <ul><li>Alias for clearCache(requestKey) for semantic clarity.</li>
</ul>   *
   <ul><li>@param requestKey - Request identifier</li>
</ul>   */
<p>invalidateCache(requestKey: string): void { this.cache.delete(requestKey); }</p>

<p>/**</p>
   <ul><li>Invalidate all cached responses matching pattern</li>
</ul>   *
   <ul><li>Useful for invalidating related caches (e.g., all vehicle pages).</li>
</ul>   *
   <ul><li>@param pattern - String pattern to match (simple substring match)</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// Invalidate all vehicle-related caches</li>
</ul>   <ul><li>coordinator.invalidateCachePattern('vehicles');</li>
</ul>   <ul><li>// Clears: 'vehicles-page-1', 'vehicles-page-2', 'vehicles-stats'</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>invalidateCachePattern(pattern: string): void { const keysToDelete: string[] = [];</p>

<p>this.cache.forEach((_, key) =&gt; { if (key.includes(pattern)) { keysToDelete.push(key); } });</p>

<p>keysToDelete.forEach(key =&gt; this.cache.delete(key)); }</p>

<p>/**</p>
   <ul><li>Get current cache size</li>
</ul>   *
   <ul><li>@returns Number of cached entries</li>
</ul>   */
<p>getCacheSize(): number { return this.cache.size; }</p>

<p>/**</p>
   <ul><li>Get number of in-flight requests</li>
</ul>   *
   <ul><li>@returns Number of ongoing requests</li>
</ul>   */
<p>getInFlightCount(): number { return this.inFlightRequests.size; }</p>

<p>/**</p>
   <ul><li>Get cached response if exists and not expired</li>
</ul>   *
   <ul><li>@returns Cached data or null if not found/expired</li>
</ul>   */
<p>private getCachedResponse&lt;T&gt;(key: string): T | null { const entry = this.cache.get(key); if (!entry) { return null; }</p>

<p>// Check if expired const age = Date.now() - entry.timestamp; if (age &gt; entry.ttl) { // Expired - remove and return null this.cache.delete(key); return null; }</p>

<p>return entry.data; }</p>

<p>/**</p>
   <ul><li>Store response in cache</li>
</ul>   */
<p>private setCachedResponse&lt;T&gt;(key: string, data: T, ttl: number): void { this.cache.set(key, { data, timestamp: Date.now(), ttl }); }</p>

<p>/**</p>
   <ul><li>Update loading state for request</li>
</ul>   */
<p>private setLoadingState(requestKey: string, loading: boolean): void { const currentStates = new Map(this.loadingStateSubject.value);</p>

<p>if (loading) { currentStates.set(requestKey, true); } else { currentStates.delete(requestKey); }</p>

<p>this.loadingStateSubject.next(currentStates); }</p>

<p>/**</p>
   <ul><li>Get effective configuration with defaults</li>
</ul>   */
<p>private getEffectiveConfig(config?: RequestConfig): Required&lt;RequestConfig&gt; { return { cacheTTL: config?.cacheTTL ?? 30000, retryAttempts: config?.retryAttempts ?? 3, retryDelay: config?.retryDelay ?? 1000, skipCache: config?.skipCache ?? false }; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 303.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 3 (Section 303) - Added RequestCoordinatorService</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/request-coordinator.service.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/request-coordinator.service.ts
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>4. Verify Deduplication (Optional)</h3>

<p>Add temporary test code:</p>

<pre class="code-block typescript"><code>// In any component
<p>constructor( private api: ApiService, private coordinator: RequestCoordinatorService ) { // Fire same request 5 times simultaneously for (let i = 0; i &lt; 5; i++) { this.coordinator.execute( 'test-dedup', () =&gt; this.api.get&lt;any&gt;('http://generic-prime.minilab/api/specs/v1/automobiles') ).subscribe(response =&gt; { console.log(<code class="inline">Request ${i} received:</code>, response); }); } }</p>
</code></pre>

<p>In browser DevTools Network tab, you should see only <strong>1</strong> HTTP request, but 5 console logs.</p>

<h3>5. Verify Caching (Optional)</h3>

<pre class="code-block typescript"><code>// First request
<p>this.coordinator.execute('test-cache', () =&gt; this.api.get&lt;any&gt;(url)) .subscribe(() =&gt; console.log('First request complete'));</p>

<p>// Second request after 1 second (should be cached) setTimeout(() =&gt; { this.coordinator.execute('test-cache', () =&gt; this.api.get&lt;any&gt;(url)) .subscribe(() =&gt; console.log('Second request complete (from cache)')); }, 1000);</p>

<p>// Third request after 35 seconds (cache expired, new request) setTimeout(() =&gt; { this.coordinator.execute('test-cache', () =&gt; this.api.get&lt;any&gt;(url)) .subscribe(() =&gt; console.log('Third request complete (fresh)')); }, 35000);</p>
</code></pre>

<p>Network tab should show 2 requests total (first and third).</p></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Multiple HTTP requests despite deduplication</td> <td>Different request keys</td> <td>Ensure same key for same request</td></p>
</tr>
<p><tr> <td>Cache never expires</td> <td>TTL too high</td> <td>Reduce cacheTTL value</td></p>
</tr>
<p><tr> <td>Cache always misses</td> <td>TTL too low</td> <td>Increase cacheTTL value</td></p>
</tr>
<p><tr> <td>Retries not working</td> <td>retryAttempts set to 0</td> <td>Use default or positive number</td></p>
</tr>
<p><tr> <td>Loading state stuck on true</td> <td>Request never completes</td> <td>Check for hung HTTP requests</td></p>
</tr>
<p><tr> <td><code class="inline">shareReplay</code> memory leak</td> <td>Observable never completes</td> <td>finalize() handles cleanup</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Three-layer processing prevents redundant requests</strong> — Cache → Dedup → HTTP</li>
<p><li><strong><code class="inline">shareReplay(1)</code> enables deduplication</strong> — Multiple subscribers share one HTTP call</li> <li><strong>Exponential backoff handles transient failures</strong> — Each retry waits longer than the last</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/request-coordinator.service.ts</code> exists</li>
<p><li>[ ] Barrel file exports the service</li> <li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li>[ ] <code class="inline">execute()</code> implements three-layer processing</li> <li>[ ] Response cache stores with TTL and expires correctly</li> <li>[ ] In-flight deduplication shares observable for duplicate requests</li> <li>[ ] Retry logic uses exponential backoff</li> <li>[ ] <code class="inline">getLoadingState$()</code> returns per-request loading observable</li> <li>[ ] <code class="inline">getGlobalLoading$()</code> returns any-loading observable</li> <li>[ ] Cache invalidation methods work correctly</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">304-domain-config-registry.md</code> to create the service that manages domain configurations.</p></div></div>
    <div class="chapter" id="section-304">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>304: Domain Config Registry</h1>
        </div>
<div class="page-content"><h1>304: Domain Config Registry</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 305-domain-config-validator, 306-resource-management-service, 310-filter-options-service, 311-picker-config-registry</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the Registry pattern and when to use it</li>
<p><li>Know how to use Angular InjectionTokens for flexible configuration</li> <li>Recognize how runtime registration enables multi-domain applications</li> <li>Be able to implement a type-safe configuration registry</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">DomainConfigRegistry</code> service that provides centralized management of domain configurations. This registry allows domains to be registered, retrieved, and switched at runtime.</p>

<hr>

<h2>Why</h2>

<p>The vvroom application is designed to be domain-agnostic. The framework doesn't know about automobiles — it knows about <code class="inline">DomainConfig</code>. This raises a question: <em>how does the framework access domain-specific configuration?</em></p>

<h3>Option 1: Import Directly</h3>

<pre class="code-block typescript"><code>// In a component
<p>import { AUTOMOBILE_DOMAIN_CONFIG } from './domain-config/automobile';</p>

<p>@Component({...}) export class DiscoverComponent { config = AUTOMOBILE_DOMAIN_CONFIG; }</p>
</code></pre>

<p>This works, but:</p>
<ul><li>Hard-codes the domain in the component</li>
<p><li>Can't switch domains at runtime</li> <li>Can't add new domains without modifying framework code</li></p>
</ul>
<h3>Option 2: Injection Token</h3>

<pre class="code-block typescript"><code>// In a module
<p>providers: [ { provide: DOMAIN_CONFIG, useValue: AUTOMOBILE_DOMAIN_CONFIG } ]</p>

<p>// In a component constructor(@Inject(DOMAIN_CONFIG) private config: DomainConfig&lt;...&gt;) {}</p>
</code></pre>

<p>Better, but:</p>
<ul><li>Only one domain at a time</li>
<p><li>No runtime switching</li> <li>No validation</li></p>
</ul>
<h3>Option 3: Registry Pattern (Our Approach)</h3>

<pre class="code-block typescript"><code>// At app startup
<p>registry.register(AUTOMOBILE_DOMAIN_CONFIG); registry.register(REAL_ESTATE_DOMAIN_CONFIG);</p>

<p>// In a component const config = registry.getActive();</p>

<p>// Switch domain registry.setActive('real-estate');</p>
</code></pre>

<p>The registry:</p>
<ul><li>Stores multiple domain configurations</li>
<p><li>Provides runtime switching</li> <li>Validates configurations on registration</li> <li>Offers type-safe retrieval</li></ul></p></div><div class="page-content"><h3>Why Both Token AND Registry?</h3>

<p>We use BOTH:</p>
<ul><li><strong><code class="inline">DOMAIN_CONFIG</code> token</strong> — For component injection (simpler DI)</li>
<p><li><strong><code class="inline">DomainConfigRegistry</code></strong> — For runtime management</li></p>
</ul>
<p>The token is <em>populated from</em> the registry. Components inject <code class="inline">DOMAIN_CONFIG</code>, and the module provider gets it from the registry.</p>

<pre class="code-block typescript"><code>providers: [
<p>{ provide: DOMAIN_CONFIG, useFactory: (registry: DomainConfigRegistry) =&gt; registry.getActive(), deps: [DomainConfigRegistry] } ]</p>
</code></pre>

<hr>

<h2>What</h2>

<h3>Step 304.1: Create the Domain Config Registry Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/domain-config-registry.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/domain-config-registry.service.ts
<p>// VERSION 1 (Section 304) - Domain configuration registry</p>

<p>import { Injectable, InjectionToken, Injector, Provider } from '@angular/core'; import { DomainConfig } from '../models/domain-config.interface'; import { DomainConfigValidator } from './domain-config-validator.service';</p>

<p>/**</p>
 <ul><li>Injection token for domain configuration</li>
</ul> *
 <ul><li>Used to provide domain-specific configuration to components.</li>
</ul> <ul><li>The value is typically retrieved from DomainConfigRegistry.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In domain module providers</li>
</ul> <ul><li>providers: [</li>
</ul> <ul><li>  {</li>
</ul> <ul><li>    provide: DOMAIN_CONFIG,</li>
</ul> <ul><li>    useFactory: (registry: DomainConfigRegistry) =&gt; registry.getActive(),</li>
</ul> <ul><li>    deps: [DomainConfigRegistry]</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>]</li>
</ul> *
 <ul><li>// In component</li>
</ul> <ul><li>constructor(</li>
</ul> <ul><li>  @Inject(DOMAIN_CONFIG) private domainConfig: DomainConfig&lt;any, any, any&gt;</li>
</ul> <ul><li>) {}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const DOMAIN_CONFIG = new InjectionToken&lt;DomainConfig&lt;any, any, any&gt;&gt;( 'Domain Configuration' );</p>

<p>/**</p>
 <ul><li>Domain configuration registry service</li>
</ul> *
 <ul><li>Centralized registry for managing multiple domain configurations.</li>
</ul> <ul><li>Supports registering, retrieving, and switching between domains.</li>
</ul> *
 <ul><li><strong>Why a Registry?</strong></li>
</ul> *
 <ul><li>1. <strong>Multi-domain support</strong> — Register multiple domains, switch at runtime</li>
</ul> <ul><li>2. <strong>Validation</strong> — Catch configuration errors early</li>
</ul> <ul><li>3. <strong>Type safety</strong> — Generic methods preserve type information</li>
</ul> <ul><li>4. <strong>Centralized access</strong> — Single point for all domain config access</li>
</ul> *
 <ul><li><strong>Typical Usage Flow:</strong></li>
</ul> *
 <ul><li>1. App initializes → Register domain configs</li>
</ul> <ul><li>2. User navigates → Framework gets active config</li>
</ul> <ul><li>3. User switches domain → Registry changes active</li>
</ul> <ul><li>4. Framework components → Inject DOMAIN_CONFIG token</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Register domains at app initialization</li>
</ul> <ul><li>registry.register(AUTOMOBILE_DOMAIN_CONFIG);</li>
</ul> <ul><li>registry.register(REAL_ESTATE_DOMAIN_CONFIG);</li>
</ul> *
 <ul><li>// Get active domain config</li>
</ul> <ul><li>const config = registry.getActive();</li>
</ul> *
 <ul><li>// Switch active domain</li>
</ul> <ul><li>registry.setActive('real-estate');</li>
</ul> *
 <ul><li>// List all registered domains</li>
</ul> <ul><li>const domains = registry.getAllDomainNames(); // ['automobile', 'real-estate']</li>
</ul> *
 <ul><li>// Get specific domain by name</li>
</ul> <ul><li>const autoConfig = registry.get&lt;AutoFilters, AutoData&gt;('automobile');</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class DomainConfigRegistry { /**</p>
   <ul><li>Storage for registered domain configurations</li>
</ul>   *
   <ul><li>Maps domain name (e.g., 'automobile') to DomainConfig instance.</li>
</ul>   */
<p>private configs = new Map&lt;string, DomainConfig&lt;any, any, any&gt;&gt;();</p>

<p>/**</p>
   <ul><li>Currently active domain name</li>
</ul>   *
   <ul><li>Set to first registered domain by default.</li>
</ul>   <ul><li>Can be changed via setActive().</li>
</ul>   */
<p>private activeDomainName?: string;</p>

<p>/**</p>
   <ul><li>Constructor - injects validator</li>
</ul>   *
   <ul><li>@param validator - Service for validating domain configurations</li>
</ul>   */
<p>constructor(private validator: DomainConfigValidator) {}</p>

<p>/**</p>
   <ul><li>Register a domain configuration</li>
</ul>   *
   <ul><li>Validates the configuration (unless disabled) and adds it to the registry.</li>
</ul>   <ul><li>First registered domain becomes the active domain.</li>
</ul>   *
   <ul><li>@template TFilters - Filter model type</li>
</ul>   <ul><li>@template TData - Data model type</li>
</ul>   <ul><li>@template TStatistics - Statistics model type</li>
</ul>   <ul><li>@param config - Domain configuration to register</li>
</ul>   <ul><li>@param validate - Whether to validate configuration (default: true)</li>
</ul>   <ul><li>@throws Error if configuration is invalid (when validate=true)</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// Register with validation</li>
</ul>   <ul><li>registry.register(AUTOMOBILE_DOMAIN_CONFIG);</li>
</ul>   *
   <ul><li>// Register without validation (e.g., in tests)</li>
</ul>   <ul><li>registry.register(TEST_CONFIG, false);</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>register&lt;TFilters, TData, TStatistics&gt;( config: DomainConfig&lt;TFilters, TData, TStatistics&gt;, validate: boolean = true ): void { // Validate if requested if (validate) { const sanitizedConfig = this.validator.validateAndSanitize(config); config = sanitizedConfig as DomainConfig&lt;TFilters, TData, TStatistics&gt;; }</p>

<p>// Check for duplicate (warn but allow overwrite) if (this.configs.has(config.domainName)) { console.warn( <code class="inline">Domain '${config.domainName}' already registered. Overwriting.</code> ); }</p>

<p>// Register the config this.configs.set(config.domainName, config);</p>

<p>// Set as active if first domain if (!this.activeDomainName) { this.activeDomainName = config.domainName; }</p>

<p>console.log(<code class="inline">Domain '${config.domainName}' registered successfully</code>); }</p>

<p>/**</p>
   <ul><li>Register multiple domain configurations</li>
</ul>   *
   <ul><li>Convenience method for registering several domains at once.</li>
</ul>   *
   <ul><li>@param configs - Array of domain configurations</li>
</ul>   <ul><li>@param validate - Whether to validate configurations (default: true)</li>
</ul>   */
<p>registerMultiple( configs: DomainConfig&lt;any, any, any&gt;[], validate: boolean = true ): void { configs.forEach((config) =&gt; this.register(config, validate)); }</p>

<p>/**</p>
   <ul><li>Get domain configuration by name</li>
</ul>   *
   <ul><li>@template TFilters - Filter model type</li>
</ul>   <ul><li>@template TData - Data model type</li>
</ul>   <ul><li>@template TStatistics - Statistics model type</li>
</ul>   <ul><li>@param domainName - Domain name to retrieve</li>
</ul>   <ul><li>@returns Domain configuration</li>
</ul>   <ul><li>@throws Error if domain not found</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>const config = registry.get&lt;AutoFilters, VehicleResult&gt;('automobile');</li>
</ul>   <ul><li>// config is typed as DomainConfig&lt;AutoFilters, VehicleResult, any&gt;</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>get&lt;TFilters, TData, TStatistics&gt;( domainName: string ): DomainConfig&lt;TFilters, TData, TStatistics&gt; { const config = this.configs.get(domainName);</p>

<p>if (!config) { const available = this.getAllDomainNames().join(', '); throw new Error( <code class="inline">Domain '${domainName}' not found. Available domains: ${available}</code> ); }</p>

<p>return config as DomainConfig&lt;TFilters, TData, TStatistics&gt;; }</p>

<p>/**</p>
   <ul><li>Get active domain configuration</li>
</ul>   *
   <ul><li>Returns the currently active domain's configuration.</li>
</ul>   *
   <ul><li>@template TFilters - Filter model type</li>
</ul>   <ul><li>@template TData - Data model type</li>
</ul>   <ul><li>@template TStatistics - Statistics model type</li>
</ul>   <ul><li>@returns Active domain configuration</li>
</ul>   <ul><li>@throws Error if no domain is active</li>
</ul>   */
<p>getActive&lt;TFilters, TData, TStatistics&gt;(): DomainConfig&lt; TFilters, TData, TStatistics &gt; { if (!this.activeDomainName) { throw new Error('No active domain. Register a domain first.'); }</p>

<p>return this.get&lt;TFilters, TData, TStatistics&gt;(this.activeDomainName); }</p>

<p>/**</p>
   <ul><li>Set active domain</li>
</ul>   *
   <ul><li>Changes which domain is returned by getActive().</li>
</ul>   *
   <ul><li>@param domainName - Domain name to activate</li>
</ul>   <ul><li>@throws Error if domain not found</li>
</ul>   */
<p>setActive(domainName: string): void { if (!this.configs.has(domainName)) { const available = this.getAllDomainNames().join(', '); throw new Error( <code class="inline">Cannot activate domain '${domainName}'. Available domains: ${available}</code> ); }</p>

<p>this.activeDomainName = domainName; console.log(<code class="inline">Active domain set to '${domainName}'</code>); }</p>

<p>/**</p>
   <ul><li>Get active domain name</li>
</ul>   *
   <ul><li>@returns Active domain name or undefined if none</li>
</ul>   */
<p>getActiveDomainName(): string | undefined { return this.activeDomainName; }</p>

<p>/**</p>
   <ul><li>Check if domain is registered</li>
</ul>   *
   <ul><li>@param domainName - Domain name to check</li>
</ul>   <ul><li>@returns True if domain is registered</li>
</ul>   */
<p>has(domainName: string): boolean { return this.configs.has(domainName); }</p>

<p>/**</p>
   <ul><li>Get all registered domain names</li>
</ul>   *
   <ul><li>@returns Array of domain names</li>
</ul>   */
<p>getAllDomainNames(): string[] { return Array.from(this.configs.keys()); }</p>

<p>/**</p>
   <ul><li>Get all registered domain configurations</li>
</ul>   *
   <ul><li>@returns Array of domain configurations</li>
</ul>   */
<p>getAll(): DomainConfig&lt;any, any, any&gt;[] { return Array.from(this.configs.values()); }</p>

<p>/**</p>
   <ul><li>Unregister a domain</li>
</ul>   *
   <ul><li>Removes domain from registry. If it was active, activates the next available.</li>
</ul>   *
   <ul><li>@param domainName - Domain name to unregister</li>
</ul>   <ul><li>@returns True if domain was unregistered, false if not found</li>
</ul>   */
<p>unregister(domainName: string): boolean { const result = this.configs.delete(domainName);</p>

<p>// Handle active domain removal if (this.activeDomainName === domainName) { this.activeDomainName = undefined;</p>

<p>// Set first remaining domain as active const remaining = this.getAllDomainNames(); if (remaining.length &gt; 0) { this.setActive(remaining[0]); } }</p>

<p>if (result) { console.log(<code class="inline">Domain '${domainName}' unregistered</code>); }</p>

<p>return result; }</p>

<p>/**</p>
   <ul><li>Clear all registered domains</li>
</ul>   */
<p>clear(): void { this.configs.clear(); this.activeDomainName = undefined; console.log('All domains cleared'); }</p>

<p>/**</p>
   <ul><li>Get count of registered domains</li>
</ul>   *
   <ul><li>@returns Number of registered domains</li>
</ul>   */
<p>getCount(): number { return this.configs.size; }</p>

<p>/**</p>
   <ul><li>Validate a domain configuration without registering</li>
</ul>   *
   <ul><li>Useful for pre-validation before registration.</li>
</ul>   *
   <ul><li>@template TFilters - Filter model type</li>
</ul>   <ul><li>@template TData - Data model type</li>
</ul>   <ul><li>@template TStatistics - Statistics model type</li>
</ul>   <ul><li>@param config - Domain configuration to validate</li>
</ul>   <ul><li>@returns Validation result</li>
</ul>   */
<p>validate&lt;TFilters, TData, TStatistics&gt;( config: DomainConfig&lt;TFilters, TData, TStatistics&gt; ) { return this.validator.validate(config); }</p>

<p>/**</p>
   <ul><li>Get human-readable validation summary for a domain</li>
</ul>   *
   <ul><li>@param domainName - Domain name</li>
</ul>   <ul><li>@returns Validation summary string</li>
</ul>   */
<p>getValidationSummary(domainName: string): string { const config = this.get(domainName); const result = this.validator.validate(config); return this.validator.getValidationSummary(result); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 304.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 4 (Section 304) - Added DomainConfigRegistry</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service';</p>
</code></pre>

<hr>

<h3>Step 304.3: Understand the Dependency</h3>

<p>Note that <code class="inline">DomainConfigRegistry</code> depends on <code class="inline">DomainConfigValidator</code> (Section 305). The registry won't compile until the validator exists.</p>

<p>This creates a circular documentation dependency:</p>
<ul><li>Registry (304) uses Validator (305)</li>
<p><li>We document Registry first to show the pattern</li></p>
</ul>
<p>In practice, you'll create both files, then build.</p>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/domain-config-registry.service.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<p>After creating Section 305 (Validator), run:</p>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/domain-config-registry.service.ts
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Build the Application</h3>

<p>After Section 305:</p>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>4. Verify Registration (Optional)</h3>

<p>Add temporary test code:</p>

<pre class="code-block typescript"><code>// In app.component.ts ngOnInit
<p>import { DomainConfigRegistry } from './framework/services';</p>

<p>constructor(private registry: DomainConfigRegistry) {}</p>

<p>ngOnInit(): void { // Mock config for testing (real config comes in Phase 6) const mockConfig = { domainName: 'test-automobile', domainLabel: 'Test Automobiles', apiBaseUrl: 'http://example.com/api', filterModel: class {}, dataModel: class {}, apiAdapter: { fetchData: () =&gt; {} }, urlMapper: { toUrlParams: () =&gt; ({}), fromUrlParams: () =&gt; ({}) }, cacheKeyBuilder: { buildKey: () =&gt; '' }, tableConfig: { tableId: 'test', dataKey: 'id', columns: [{ field: 'id' }] }, pickers: [], filters: [], queryControlFilters: [], charts: [], features: { highlights: true, popOuts: true, rowExpansion: true } };</p>

<p>this.registry.register(mockConfig as any, false); // Skip validation for test console.log('Registered domains:', this.registry.getAllDomainNames()); console.log('Active domain:', this.registry.getActiveDomainName()); }</p>
</code></pre>

<p>Console should show:</p>
<pre class="code-block text"><code>Domain 'test-automobile' registered successfully
<p>Registered domains: ['test-automobile'] Active domain: test-automobile</p>
</code></pre></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module './domain-config-validator.service'</code></td> <td>Validator not created yet</td> <td>Complete Section 305 first</td></p>
</tr>
<p><tr> <td><code class="inline">No active domain</code> error</td> <td>No domains registered</td> <td>Register at least one domain</td></p>
</tr>
<p><tr> <td><code class="inline">Domain 'X' not found</code></td> <td>Domain not registered</td> <td>Check spelling, ensure registration happened</td></p>
</tr>
<p><tr> <td>Validation errors on register</td> <td>Config missing required fields</td> <td>Check DomainConfig interface requirements</td></p>
</tr>
<p><tr> <td>Console warnings about overwriting</td> <td>Same domain registered twice</td> <td>Remove duplicate registration</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Registry pattern enables runtime flexibility</strong> — Register, retrieve, switch domains dynamically</li>
<p><li><strong>Injection tokens simplify component DI</strong> — Components inject DOMAIN_CONFIG, not the registry</li> <li><strong>Validation catches errors early</strong> — Invalid configs fail at registration, not at runtime</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/domain-config-registry.service.ts</code> exists</li>
<p><li>[ ] Barrel file exports the service and DOMAIN_CONFIG token</li> <li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li>[ ] <code class="inline">register()</code> validates and stores configurations</li> <li>[ ] <code class="inline">get()</code> retrieves configurations by name</li> <li>[ ] <code class="inline">getActive()</code> returns the active domain configuration</li> <li>[ ] <code class="inline">setActive()</code> changes the active domain</li> <li>[ ] First registered domain becomes active automatically</li> <li>[ ] <code class="inline">getAllDomainNames()</code> lists all registered domains</li> <li>[ ] <code class="inline">unregister()</code> removes domains and handles active domain gracefully</li> <li>[ ] DOMAIN_CONFIG InjectionToken is exported</li> <li>[ ] TypeScript compilation succeeds (after Section 305)</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">305-domain-config-validator.md</code> to create the validation service that the registry depends on.</p></div></div>
    <div class="chapter" id="section-305">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>305: Domain Config Validator</h1>
        </div>
<div class="page-content"><h1>305: Domain Config Validator</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 201-domain-config-interface, 304-domain-config-registry <strong>Blocks:</strong> 306-resource-management-service</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand runtime validation patterns in TypeScript</li>
<p><li>Know how to create comprehensive validation with error categorization</li> <li>Recognize the value of catching configuration errors early</li> <li>Be able to implement a reusable validation service</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">DomainConfigValidator</code> service that validates domain configurations at runtime, ensuring all required fields are present and correctly typed before the framework attempts to use them.</p>

<hr>

<h2>Why</h2>

<p>TypeScript provides compile-time type checking, but it can't catch everything:</p>

<h3>What TypeScript Catches</h3>

<pre class="code-block typescript"><code>const config: DomainConfig&lt;F, D, S&gt; = {
<p>domainName: 123, // Error: Type 'number' is not assignable to type 'string' // Missing required properties - TypeScript error };</p>
</code></pre>

<h3>What TypeScript Misses</h3>

<pre class="code-block typescript"><code>const config: DomainConfig&lt;any, any, any&gt; = {
<p>domainName: '',        // Empty string - valid type, invalid value apiBaseUrl: 'not-url', // Not a valid URL - valid type, invalid value tableConfig: { tableId: 'test', columns: []          // Empty array - valid type, likely an error } };</p>
</code></pre>

<p>TypeScript checks types. It doesn't check:</p>
<ul><li>Empty strings vs meaningful strings</li>
<p><li>Valid URLs vs arbitrary strings</li> <li>Empty arrays vs populated arrays</li> <li>Interface compliance (does <code class="inline">apiAdapter</code> have <code class="inline">fetchData</code>?)</li></p>
</ul>
<h3>Why Not Just Trust TypeScript?</h3>

<p>In a perfect world, every <code class="inline">DomainConfig</code> would be created with correct types and values. In practice:</p>

<ul><li><strong>Dynamic data</strong> — Configs may come from JSON files or APIs</li>
<p><li><strong>User error</strong> — Developers make mistakes</li> <li><strong>Refactoring</strong> — Interface changes can break existing configs</li> <li><strong>Third-party configs</strong> — Can't trust external data</li></p>
</ul>
<p>Runtime validation catches these issues <strong>at registration time</strong>, with clear error messages, instead of cryptic failures deep in framework code.</p></div><div class="page-content"><h3>Validation vs. Sanitization</h3>

<p>The validator does two things:</p>

<ul><li><strong>Validate</strong> — Check for errors, return result object</li>
<p><li><strong>Validate and Sanitize</strong> — Check for errors, apply defaults, return clean config</li></p>
</ul>
<pre class="code-block typescript"><code>// Validation only
<p>const result = validator.validate(config); if (!result.valid) { console.error(result.errors); }</p>

<p>// Validation with sanitization (applies defaults) const cleanConfig = validator.validateAndSanitize(config); // Throws if invalid, returns sanitized config if valid</p>
</code></pre>

<hr>

<h2>What</h2>

<h3>Step 305.1: Create the Domain Config Validator Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/domain-config-validator.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/domain-config-validator.service.ts
<p>// VERSION 1 (Section 305) - Runtime configuration validation</p>

<p>import { Injectable } from '@angular/core'; import { DomainConfig, ConfigValidationError, ConfigValidationResult, ConfigErrorType, mergeDomainFeatures } from '../models/domain-config.interface';</p>

<p>/**</p>
 <ul><li>Domain configuration validator service</li>
</ul> *
 <ul><li>Validates domain configurations at runtime to ensure they meet all</li>
</ul> <ul><li>requirements before being used by the framework. Catches errors that</li>
</ul> <ul><li>TypeScript's compile-time checks miss.</li>
</ul> *
 <ul><li><strong>Why Runtime Validation?</strong></li>
</ul> *
 <ul><li>TypeScript checks types but not values:</li>
</ul> <ul><li>- Empty strings pass type check but aren't valid domain names</li>
</ul> <ul><li>- Invalid URLs pass type check but won't work for API calls</li>
</ul> <ul><li>- Missing interface methods pass type check with 'any' types</li>
</ul> *
 <ul><li><strong>Error Categories:</strong></li>
</ul> *
 <ul><li>| Category | Description |</li>
</ul> <ul><li>|----------|-------------|</li>
</ul> <ul><li>| MISSING_REQUIRED | Required field is null/undefined |</li>
</ul> <ul><li>| INVALID_TYPE | Field has wrong type |</li>
</ul> <ul><li>| INVALID_VALUE | Field has valid type but invalid value |</li>
</ul> <ul><li>| EMPTY_ARRAY | Required array is empty |</li>
</ul> <ul><li>| DUPLICATE_ID | Duplicate ID in array (pickers, filters, charts) |</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const validator = inject(DomainConfigValidator);</li>
</ul> *
 <ul><li>// Validate without modifying</li>
</ul> <ul><li>const result = validator.validate(config);</li>
</ul> <ul><li>if (!result.valid) {</li>
</ul> <ul><li>  console.error('Errors:', result.errors);</li>
</ul> <ul><li>}</li>
</ul> *
 <ul><li>// Validate and apply defaults</li>
</ul> <ul><li>try {</li>
</ul> <ul><li>  const cleanConfig = validator.validateAndSanitize(config);</li>
</ul> <ul><li>} catch (error) {</li>
</ul> <ul><li>  console.error('Invalid config:', error.message);</li>
</ul> <ul><li>}</li>
</ul> *
 <ul><li>// Get human-readable summary</li>
</ul> <ul><li>console.log(validator.getValidationSummary(result));</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class DomainConfigValidator { /**</p>
   <ul><li>Validate domain configuration</li>
</ul>   *
   <ul><li>Performs comprehensive validation and returns result object.</li>
</ul>   <ul><li>Does not modify the configuration.</li>
</ul>   *
   <ul><li>@template TFilters - Filter model type</li>
</ul>   <ul><li>@template TData - Data model type</li>
</ul>   <ul><li>@template TStatistics - Statistics model type</li>
</ul>   <ul><li>@param config - Domain configuration to validate</li>
</ul>   <ul><li>@returns Validation result with errors and warnings</li>
</ul>   */
<p>validate&lt;TFilters, TData, TStatistics&gt;( config: DomainConfig&lt;TFilters, TData, TStatistics&gt; ): ConfigValidationResult { const errors: ConfigValidationError[] = []; const warnings: ConfigValidationError[] = [];</p>

<p>// Validate required string fields this.validateRequiredString(config, 'domainName', errors); this.validateRequiredString(config, 'domainLabel', errors); this.validateRequiredString(config, 'apiBaseUrl', errors);</p>

<p>// Validate domain name format (lowercase, alphanumeric with hyphens) this.validateDomainNameFormat(config.domainName, errors);</p>

<p>// Validate API base URL format this.validateApiBaseUrl(config.apiBaseUrl, errors);</p>

<p>// Validate type models this.validateRequiredField(config, 'filterModel', errors); this.validateRequiredField(config, 'dataModel', errors);</p>

<p>// Validate adapters exist this.validateRequiredField(config, 'apiAdapter', errors); this.validateRequiredField(config, 'urlMapper', errors); this.validateRequiredField(config, 'cacheKeyBuilder', errors);</p>

<p>// Validate adapter interfaces (have required methods) this.validateApiAdapter(config.apiAdapter, errors); this.validateUrlMapper(config.urlMapper, errors); this.validateCacheKeyBuilder(config.cacheKeyBuilder, errors);</p>

<p>// Validate table configuration this.validateRequiredField(config, 'tableConfig', errors); this.validateTableConfig(config.tableConfig, errors);</p>

<p>// Validate arrays (may be empty, but should be arrays) this.validateArray(config, 'pickers', errors, warnings); this.validateArray(config, 'filters', errors, warnings); this.validateArray(config, 'charts', errors, warnings);</p>

<p>// Validate array contents for duplicates if (config.pickers &amp;&amp; config.pickers.length &gt; 0) { this.validatePickers(config.pickers, errors); }</p>

<p>if (config.filters &amp;&amp; config.filters.length &gt; 0) { this.validateFilters(config.filters, errors); }</p>

<p>if (config.charts &amp;&amp; config.charts.length &gt; 0) { this.validateCharts(config.charts, errors); }</p>

<p>// Validate features this.validateRequiredField(config, 'features', errors); this.validateFeatures(config.features, errors);</p>

<p>return { valid: errors.length === 0, errors, warnings }; }</p>

<p>/**</p>
   <ul><li>Validate and sanitize domain configuration</li>
</ul>   *
   <ul><li>Validates configuration and applies defaults for optional fields.</li>
</ul>   <ul><li>Throws if validation fails.</li>
</ul>   *
   <ul><li>@template TFilters - Filter model type</li>
</ul>   <ul><li>@template TData - Data model type</li>
</ul>   <ul><li>@template TStatistics - Statistics model type</li>
</ul>   <ul><li>@param config - Domain configuration to validate</li>
</ul>   <ul><li>@returns Sanitized configuration with defaults applied</li>
</ul>   <ul><li>@throws Error if configuration is invalid</li>
</ul>   */
<p>validateAndSanitize&lt;TFilters, TData, TStatistics&gt;( config: DomainConfig&lt;TFilters, TData, TStatistics&gt; ): DomainConfig&lt;TFilters, TData, TStatistics&gt; { const result = this.validate(config);</p>

<p>if (!result.valid) { const errorMessages = result.errors .map((e) =&gt; <code class="inline">${e.field}: ${e.message}</code>) .join('\n'); throw new Error( <code class="inline">Domain configuration validation failed:\n${errorMessages}</code> ); }</p>

<p>// Apply defaults for optional fields return { ...config, features: mergeDomainFeatures(config.features), pickers: config.pickers || [], filters: config.filters || [], charts: config.charts || [] }; }</p>

<p>/**</p>
   <ul><li>Get human-readable validation summary</li>
</ul>   *
   <ul><li>Formats validation result into readable multi-line string.</li>
</ul>   *
   <ul><li>@param result - Validation result from validate()</li>
</ul>   <ul><li>@returns Formatted summary string</li>
</ul>   */
<p>getValidationSummary(result: ConfigValidationResult): string { if (result.valid) { return 'Configuration is valid'; }</p>

<p>const lines: string[] = ['Configuration validation failed:'];</p>

<p>if (result.errors.length &gt; 0) { lines.push(<code class="inline">\nErrors (${result.errors.length}):</code>); result.errors.forEach((error, index) =&gt; { lines.push( <code class="inline">  ${index + 1}. [${error.type}] ${error.field}: ${error.message}</code> ); }); }</p>

<p>if (result.warnings &amp;&amp; result.warnings.length &gt; 0) { lines.push(<code class="inline">\nWarnings (${result.warnings.length}):</code>); result.warnings.forEach((warning, index) =&gt; { lines.push( <code class="inline">  ${index + 1}. [${warning.type}] ${warning.field}: ${warning.message}</code> ); }); }</p>

<p>return lines.join('\n'); }</p>

<p>// ============================================================================ // Private Validation Methods // ============================================================================</p>

<p>/**</p>
   <ul><li>Validate required string field (non-empty)</li>
</ul>   */
<p>private validateRequiredString( config: any, field: string, errors: ConfigValidationError[] ): void { if (!config[field]) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field, message: <code class="inline">Required field '${field}' is missing</code>, expected: 'string' }); } else if (typeof config[field] !== 'string') { errors.push({ type: ConfigErrorType.INVALID_TYPE, field, message: <code class="inline">Field '${field}' must be a string</code>, expected: 'string', actual: typeof config[field] }); } else if (config[field].trim().length === 0) { errors.push({ type: ConfigErrorType.INVALID_VALUE, field, message: <code class="inline">Field '${field}' cannot be empty</code>, expected: 'non-empty string', actual: config[field] }); } }</p>

<p>/**</p>
   <ul><li>Validate required field exists</li>
</ul>   */
<p>private validateRequiredField( config: any, field: string, errors: ConfigValidationError[] ): void { if (!config[field]) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field, message: <code class="inline">Required field '${field}' is missing</code> }); } }</p>

<p>/**</p>
   <ul><li>Validate domain name format</li>
</ul>   */
<p>private validateDomainNameFormat( domainName: string, errors: ConfigValidationError[] ): void { if (!domainName) return;</p>

<p>// Domain name: lowercase, starts with letter, alphanumeric with hyphens const validPattern = /^[a-z][a-z0-9-]*$/; if (!validPattern.test(domainName)) { errors.push({ type: ConfigErrorType.INVALID_VALUE, field: 'domainName', message: 'Domain name must be lowercase, start with a letter, and contain only letters, numbers, and hyphens', expected: 'lowercase alphanumeric with hyphens (e.g., "automobile")', actual: domainName }); } }</p>

<p>/**</p>
   <ul><li>Validate API base URL format</li>
</ul>   */
<p>private validateApiBaseUrl( apiBaseUrl: string, errors: ConfigValidationError[] ): void { if (!apiBaseUrl) return;</p>

<p>try { new URL(apiBaseUrl); } catch (e) { errors.push({ type: ConfigErrorType.INVALID_VALUE, field: 'apiBaseUrl', message: 'API base URL is not a valid URL', expected: 'valid URL (e.g., "http://api.example.com")', actual: apiBaseUrl }); } }</p>

<p>/**</p>
   <ul><li>Validate API adapter has required methods</li>
</ul>   */
<p>private validateApiAdapter( adapter: any, errors: ConfigValidationError[] ): void { if (!adapter) return;</p>

<p>if (typeof adapter.fetchData !== 'function') { errors.push({ type: ConfigErrorType.INVALID_TYPE, field: 'apiAdapter.fetchData', message: 'API adapter must implement fetchData method', expected: 'function' }); } }</p>

<p>/**</p>
   <ul><li>Validate URL mapper has required methods</li>
</ul>   */
<p>private validateUrlMapper( mapper: any, errors: ConfigValidationError[] ): void { if (!mapper) return;</p>

<p>if (typeof mapper.toUrlParams !== 'function') { errors.push({ type: ConfigErrorType.INVALID_TYPE, field: 'urlMapper.toUrlParams', message: 'URL mapper must implement toUrlParams method', expected: 'function' }); }</p>

<p>if (typeof mapper.fromUrlParams !== 'function') { errors.push({ type: ConfigErrorType.INVALID_TYPE, field: 'urlMapper.fromUrlParams', message: 'URL mapper must implement fromUrlParams method', expected: 'function' }); } }</p>

<p>/**</p>
   <ul><li>Validate cache key builder has required methods</li>
</ul>   */
<p>private validateCacheKeyBuilder( builder: any, errors: ConfigValidationError[] ): void { if (!builder) return;</p>

<p>if (typeof builder.buildKey !== 'function') { errors.push({ type: ConfigErrorType.INVALID_TYPE, field: 'cacheKeyBuilder.buildKey', message: 'Cache key builder must implement buildKey method', expected: 'function' }); } }</p>

<p>/**</p>
   <ul><li>Validate table configuration</li>
</ul>   */
<p>private validateTableConfig( tableConfig: any, errors: ConfigValidationError[] ): void { if (!tableConfig) return;</p>

<p>if (!tableConfig.tableId) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field: 'tableConfig.tableId', message: 'Table config must have tableId' }); }</p>

<p>if (!tableConfig.dataKey) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field: 'tableConfig.dataKey', message: 'Table config must have dataKey' }); }</p>

<p>if (!tableConfig.columns || !Array.isArray(tableConfig.columns)) { errors.push({ type: ConfigErrorType.INVALID_TYPE, field: 'tableConfig.columns', message: 'Table config must have columns array', expected: 'array' }); } else if (tableConfig.columns.length === 0) { errors.push({ type: ConfigErrorType.EMPTY_ARRAY, field: 'tableConfig.columns', message: 'Table config must have at least one column' }); } }</p>

<p>/**</p>
   <ul><li>Validate array field</li>
</ul>   */
<p>private validateArray( config: any, field: string, errors: ConfigValidationError[], warnings: ConfigValidationError[] ): void { if (config[field] === undefined || config[field] === null) { // Missing array is a warning (will be defaulted to []) warnings.push({ type: ConfigErrorType.MISSING_REQUIRED, field, message: <code class="inline">Field '${field}' is missing, will default to empty array</code>, expected: 'array' }); } else if (!Array.isArray(config[field])) { // Wrong type is an error errors.push({ type: ConfigErrorType.INVALID_TYPE, field, message: <code class="inline">Field '${field}' must be an array</code>, expected: 'array', actual: typeof config[field] }); } }</p>

<p>/**</p>
   <ul><li>Validate pickers array (check for duplicate IDs)</li>
</ul>   */
<p>private validatePickers( pickers: any[], errors: ConfigValidationError[] ): void { const ids = new Set&lt;string&gt;();</p>

<p>pickers.forEach((picker, index) =&gt; { if (!picker.id) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field: <code class="inline">pickers[${index}].id</code>, message: <code class="inline">Picker at index ${index} must have id</code> }); } else { if (ids.has(picker.id)) { errors.push({ type: ConfigErrorType.DUPLICATE_ID, field: <code class="inline">pickers[${index}].id</code>, message: <code class="inline">Duplicate picker id: ${picker.id}</code>, actual: picker.id }); } ids.add(picker.id); } }); }</p>

<p>/**</p>
   <ul><li>Validate filters array (check for duplicate IDs and required fields)</li>
</ul>   */
<p>private validateFilters( filters: any[], errors: ConfigValidationError[] ): void { const ids = new Set&lt;string&gt;();</p>

<p>filters.forEach((filter, index) =&gt; { if (!filter.id) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field: <code class="inline">filters[${index}].id</code>, message: <code class="inline">Filter at index ${index} must have id</code> }); } else { if (ids.has(filter.id)) { errors.push({ type: ConfigErrorType.DUPLICATE_ID, field: <code class="inline">filters[${index}].id</code>, message: <code class="inline">Duplicate filter id: ${filter.id}</code>, actual: filter.id }); } ids.add(filter.id); }</p>

<p>if (!filter.type) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field: <code class="inline">filters[${index}].type</code>, message: <code class="inline">Filter at index ${index} must have type</code> }); } }); }</p>

<p>/**</p>
   <ul><li>Validate charts array (check for duplicate IDs and required fields)</li>
</ul>   */
<p>private validateCharts( charts: any[], errors: ConfigValidationError[] ): void { const ids = new Set&lt;string&gt;();</p>

<p>charts.forEach((chart, index) =&gt; { if (!chart.id) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field: <code class="inline">charts[${index}].id</code>, message: <code class="inline">Chart at index ${index} must have id</code> }); } else { if (ids.has(chart.id)) { errors.push({ type: ConfigErrorType.DUPLICATE_ID, field: <code class="inline">charts[${index}].id</code>, message: <code class="inline">Duplicate chart id: ${chart.id}</code>, actual: chart.id }); } ids.add(chart.id); }</p>

<p>if (!chart.type) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field: <code class="inline">charts[${index}].type</code>, message: <code class="inline">Chart at index ${index} must have type</code> }); }</p>

<p>if (!chart.dataSourceId) { errors.push({ type: ConfigErrorType.MISSING_REQUIRED, field: <code class="inline">charts[${index}].dataSourceId</code>, message: <code class="inline">Chart at index ${index} must have dataSourceId</code> }); } }); }</p>

<p>/**</p>
   <ul><li>Validate features object</li>
</ul>   */
<p>private validateFeatures( features: any, errors: ConfigValidationError[] ): void { if (!features) return;</p>

<p>const requiredFeatures = ['highlights', 'popOuts', 'rowExpansion'];</p>

<p>requiredFeatures.forEach((feature) =&gt; { if (typeof features[feature] !== 'boolean') { errors.push({ type: ConfigErrorType.INVALID_TYPE, field: <code class="inline">features.${feature}</code>, message: <code class="inline">Feature '${feature}' must be a boolean</code>, expected: 'boolean', actual: typeof features[feature] }); } }); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 305.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 5 (Section 305) - Added DomainConfigValidator</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/domain-config-validator.service.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/domain-config-validator.service.ts
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>4. Verify Validation (Optional)</h3>

<p>Add temporary test code:</p>

<pre class="code-block typescript"><code>// In any component
<p>constructor(private validator: DomainConfigValidator) { // Test invalid config const badConfig = { domainName: '', // Empty - invalid domainLabel: 'Test', apiBaseUrl: 'not-a-url', // Invalid URL filterModel: null, // Missing dataModel: class {}, apiAdapter: {}, // Missing fetchData urlMapper: { toUrlParams: () =&gt; ({}) }, // Missing fromUrlParams cacheKeyBuilder: { buildKey: () =&gt; '' }, tableConfig: { tableId: 'test', dataKey: 'id', columns: [] }, // Empty columns features: { highlights: 'yes' } // Wrong type } as any;</p>

<p>const result = this.validator.validate(badConfig); console.log('Valid:', result.valid); console.log('Summary:\n', this.validator.getValidationSummary(result)); }</p>
</code></pre>

<p>Console should show multiple validation errors.</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module '../models/domain-config.interface'</code></td> <td>Interface file missing</td> <td>Complete Section 201 first</td></p>
</tr>
<p><tr> <td><code class="inline">ConfigErrorType is not defined</code></td> <td>Enum not exported from interface</td> <td>Check domain-config.interface.ts exports</td></p>
</tr>
<p><tr> <td>No errors shown for bad config</td> <td>Validation too lenient</td> <td>Check validateRequiredField is called</td></p>
</tr>
<p><tr> <td>validateAndSanitize doesn't throw</td> <td>result.valid is true</td> <td>Check all validation rules are running</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Runtime validation catches what TypeScript misses</strong> — Type checks pass for empty strings and invalid URLs</li>
<p><li><strong>Categorized errors enable targeted fixes</strong> — MISSING_REQUIRED vs INVALID_VALUE vs DUPLICATE_ID</li> <li><strong>Validation summary provides actionable feedback</strong> — Human-readable error messages with field paths</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/domain-config-validator.service.ts</code> exists</li>
<p><li>[ ] Barrel file exports the service</li> <li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li>[ ] <code class="inline">validate()</code> returns ConfigValidationResult</li> <li>[ ] <code class="inline">validateAndSanitize()</code> throws on invalid, returns clean config on valid</li> <li>[ ] <code class="inline">getValidationSummary()</code> returns human-readable string</li> <li>[ ] Validates required string fields (non-empty)</li> <li>[ ] Validates domain name format (lowercase, alphanumeric)</li> <li>[ ] Validates API base URL is valid URL</li> <li>[ ] Validates adapter interfaces have required methods</li> <li>[ ] Validates table config has columns</li> <li>[ ] Validates arrays for duplicate IDs</li> <li>[ ] Validates features are booleans</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">306-resource-management-service.md</code> to create the core state orchestration service.</p></div></div>
    <div class="chapter" id="section-306">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>306: Resource Management Service</h1>
        </div>
<div class="page-content"><h1>306: Resource Management Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 301-url-state-service, 302-api-service, 303-request-coordinator, 304-domain-config-registry, 305-domain-config-validator <strong>Blocks:</strong> Phase 3B (307-311), Phase 8 (Framework Components), Phase 9 (Feature Components)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the role of a state orchestrator in URL-First architecture</li>
<p><li>Know how BehaviorSubject enables reactive state management</li> <li>Recognize the pattern of converting URL changes to data fetches</li> <li>Be able to implement a generic, domain-agnostic resource management service</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">ResourceManagementService</code> that orchestrates application state with the URL as the single source of truth. This service coordinates filter changes, API calls, state updates, and cross-window synchronization.</p>

<hr>

<h2>Why</h2>

<p>We've built the foundation:</p>
<ul><li><strong>UrlStateService</strong> — Reads/writes URL parameters</li>
<p><li><strong>ApiService</strong> — Makes HTTP requests</li> <li><strong>RequestCoordinator</strong> — Caches, deduplicates, retries</li> <li><strong>DomainConfigRegistry</strong> — Provides domain configuration</li></p>
</ul>
<p>Now we need a service that ties them together. When a user changes a filter:</p>

<pre class="code-block text"><code>User clicks filter → URL updates → Data fetches → UI updates
</code></pre>

<p><code class="inline">ResourceManagementService</code> is the orchestrator that makes this flow work.</p>

<h3>The State Flow</h3>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────────────────┐
<p>│                              URL (Source of Truth)                           │ │                           ?manufacturer=Ford&amp;page=1                          │ └─────────────────────────────────────────────────────────────────────────────┘ │ ▼ watchParams() ┌─────────────────────────────────────────────────────────────────────────────┐ │                         ResourceManagementService                            │ │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐    │ │  │   filters$   │  │   results$   │  │   loading$   │  │    error$    │    │ │  │ {mfr: Ford}  │  │ [...data]    │  │    false     │  │    null      │    │ │  └──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘    │ └─────────────────────────────────────────────────────────────────────────────┘ │ ▼ subscribe() ┌─────────────────────────────────────────────────────────────────────────────┐ │                              UI Components                                   │ │               Render tables, charts, loading indicators                      │ └─────────────────────────────────────────────────────────────────────────────┘</p>
</code></pre></div><div class="page-content"><h3>Why Not Put This in Components?</h3>

<p>You might ask: <em>Why not just subscribe to URL changes in each component?</em></p>

<pre class="code-block typescript"><code>// Bad: Every component manages its own state
<p>@Component({...}) export class DiscoverComponent { filters$ = this.urlState.watchParams().pipe( map(params =&gt; this.mapper.fromUrlParams(params)) );</p>

<p>results$ = this.filters$.pipe( switchMap(filters =&gt; this.api.get('/vehicles', { params: filters })) ); }</p>
</code></pre>

<p>Problems:</p>
<ul><li><strong>Duplication</strong> — Every component repeats the same logic</li>
<p><li><strong>No state sharing</strong> — Pop-outs can't share state with main window</li> <li><strong>No caching</strong> — Every component fetches independently</li> <li><strong>Complex cleanup</strong> — Each component manages subscriptions</li></p>
</ul>
<p><code class="inline">ResourceManagementService</code> centralizes this:</p>
<ul><li><strong>One place</strong> for URL → filters → API → state logic</li>
<p><li><strong>State sharing</strong> via <code class="inline">syncStateFromExternal()</code></li> <li><strong>Automatic caching</strong> via RequestCoordinator</li> <li><strong>Proper cleanup</strong> via <code class="inline">ngOnDestroy()</code></li></p>
</ul>
<h3>Pop-Out Awareness</h3>

<p>When the service runs in a pop-out window, it behaves differently:</p>

<ul><li><strong>Main window</strong>: Watches URL, fetches data, updates state</li>
<p><li><strong>Pop-out window</strong>: Does NOT fetch (receives state from main window)</li></p>
</ul>
<p>This prevents duplicate API calls and ensures consistency.</p>

<h3>Component-Level Injection</h3>

<p>Unlike singleton services, <code class="inline">ResourceManagementService</code> is <strong>not</strong> <code class="inline">providedIn: 'root'</code>. Each component that needs resource management provides its own instance:</p>

<pre class="code-block typescript"><code>@Component({
<p>providers: [ResourceManagementService] }) export class DiscoverComponent { constructor(private resources: ResourceManagementService&lt;F, D, S&gt;) {} }</p>
</code></pre>

<p>This enables different components to manage different resources independently.</p>

<hr>

<h2>What</h2>

<h3>Step 306.1: Create the Popout Token (Placeholder)</h3>

<p>Before creating <code class="inline">ResourceManagementService</code>, we need the <code class="inline">IS_POPOUT_TOKEN</code>. This will be fully implemented in Section 315, but we need a placeholder now.</p>

<p>Create <code class="inline">src/app/framework/tokens/popout.token.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/tokens/popout.token.ts
<p>// VERSION 1 (Section 306) - Placeholder, fully implemented in Section 315</p>

<p>import { InjectionToken } from '@angular/core';</p>

<p>/**</p>
 <ul><li>Injection token to indicate if component is in a pop-out window</li>
</ul> *
 <ul><li>When true, ResourceManagementService disables auto-fetching</li>
</ul> <ul><li>and waits for state to be synced from the main window.</li>
</ul> */
<p>export const IS_POPOUT_TOKEN = new InjectionToken&lt;boolean&gt;('IS_POPOUT_TOKEN');</p>
</code></pre>

<p>Create the tokens barrel file <code class="inline">src/app/framework/tokens/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/tokens/index.ts
<p>// VERSION 1 (Section 306)</p>

<p>export * from './popout.token';</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 306.2: Create Placeholder for PopOutContextService</h3>

<p>We also need <code class="inline">PopOutContextService</code>. Create a placeholder:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/popout-context.service.ts
<p>// VERSION 1 (Section 306) - Placeholder, fully implemented in Section 307</p>

<p>import { Injectable } from '@angular/core';</p>

<p>/**</p>
 <ul><li>Pop-out context service (placeholder)</li>
</ul> *
 <ul><li>Determines if the current window is a pop-out.</li>
</ul> <ul><li>Full implementation in Section 307.</li>
</ul> */
<p>@Injectable({ providedIn: 'root' }) export class PopOutContextService { /**</p>
   <ul><li>Check if current window is a pop-out</li>
</ul>   *
   <ul><li>@returns True if in pop-out window</li>
</ul>   */
<p>isInPopOut(): boolean { // Placeholder implementation // Real implementation in Section 307 checks window.opener return false; } }</p>
</code></pre>

<hr>

<h3>Step 306.3: Create the Resource Management Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/resource-management.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/resource-management.service.ts
<p>// VERSION 1 (Section 306) - Core state orchestrator</p>

<p>import { Inject, Injectable, NgZone, OnDestroy, Optional } from '@angular/core'; import { BehaviorSubject, Observable, of, Subject } from 'rxjs'; import { catchError, distinctUntilChanged, finalize, map, takeUntil } from 'rxjs/operators'; import { DomainConfig } from '../models/domain-config.interface'; import { ResourceManagementConfig, ResourceState } from '../models/resource-management.interface'; import { DOMAIN_CONFIG } from './domain-config-registry.service'; import { PopOutContextService } from './popout-context.service'; import { UrlStateService } from './url-state.service'; import { IS_POPOUT_TOKEN } from '../tokens/popout.token';</p>

<p>/**</p>
 <ul><li>Deep equality check for filter objects</li>
</ul> *
 <ul><li>Replaces JSON.stringify comparison with proper structural equality.</li>
</ul> <ul><li>Handles nested objects and arrays correctly.</li>
</ul> */
<p>function deepEqual(a: unknown, b: unknown): boolean { if (a === b) return true; if (a == null || b == null) return a === b; if (typeof a !== typeof b) return false; if (typeof a !== 'object') return a === b;</p>

<p>const aObj = a as Record&lt;string, unknown&gt;; const bObj = b as Record&lt;string, unknown&gt;; const aKeys = Object.keys(aObj); const bKeys = Object.keys(bObj);</p>

<p>if (aKeys.length !== bKeys.length) return false;</p>

<p>return aKeys.every(key =&gt; deepEqual(aObj[key], bObj[key])); }</p>

<p>/**</p>
 <ul><li>Generic resource management service - Core state orchestrator</li>
</ul> *
 <ul><li><strong>Purpose:</strong> Manages application state with URL as single source of truth.</li>
</ul> <ul><li>Coordinates filter changes, API calls, state updates, and cross-window sync.</li>
</ul> *
 <ul><li><strong>Architecture:</strong> URL → Filters → API → Data → Components</li>
</ul> *
 <ul><li><strong>Key Features:</strong></li>
</ul> *
 <ul><li>1. <strong>URL-first design</strong> — URL parameters are the single source of truth</li>
</ul> <ul><li>2. <strong>BehaviorSubject state</strong> — Current values with Observable streams</li>
</ul> <ul><li>3. <strong>Domain-agnostic</strong> — Works with any domain via DOMAIN_CONFIG injection</li>
</ul> <ul><li>4. <strong>Component-level injection</strong> — New instance per component (not singleton)</li>
</ul> <ul><li>5. <strong>Pop-out aware</strong> — Disables API calls in pop-out windows</li>
</ul> *
 <ul><li><strong>Usage Pattern:</strong></li>
</ul> *
 <ul><li></code></pre>typescript</li>
</ul> <ul><li>@Component({</li>
</ul> <ul><li>  providers: [ResourceManagementService] // New instance for this component</li>
</ul> <ul><li>})</li>
</ul> <ul><li>export class DiscoverComponent {</li>
</ul> <ul><li>  filters$ = this.resources.filters$;</li>
</ul> <ul><li>  results$ = this.resources.results$;</li>
</ul> <ul><li>  loading$ = this.resources.loading$;</li>
</ul> *
 <ul><li>  constructor(</li>
</ul> <ul><li>    private resources: ResourceManagementService&lt;AutoFilters, VehicleResult&gt;</li>
</ul> <ul><li>  ) {}</li>
</ul> *
 <ul><li>  onFilterChange(filters: Partial&lt;AutoFilters&gt;): void {</li>
</ul> <ul><li>    this.resources.updateFilters(filters);</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>
 <ul><li>@template TFilters - Domain-specific filter model type</li>
</ul> <ul><li>@template TData - Domain-specific data model type</li>
</ul> <ul><li>@template TStatistics - Domain-specific statistics model type</li>
</ul> */
<p>@Injectable() // NOT providedIn: 'root' — component-level injection export class ResourceManagementService&lt;TFilters, TData, TStatistics = any&gt; implements OnDestroy {</p>

<p>// ============================================================================ // Internal State // ============================================================================</p>

<p>/<em>* Subject for cleanup on destroy </em>/ private readonly destroy$ = new Subject&lt;void&gt;();</p>

<p>/<em>* Configuration derived from DOMAIN_CONFIG </em>/ private readonly config: ResourceManagementConfig&lt;TFilters, TData, TStatistics&gt;;</p>

<p>// ============================================================================ // BehaviorSubject-Based State // ============================================================================</p>

<p>/<em>* Main state holder — all state in one object </em>/ private readonly stateSubject: BehaviorSubject&lt;ResourceState&lt;TFilters, TData, TStatistics&gt;&gt;;</p>

<p>// ============================================================================ // Observable Streams (Public API) // ============================================================================</p>

<p>/<em>* Full state observable </em>/ public readonly state$: Observable&lt;ResourceState&lt;TFilters, TData, TStatistics&gt;&gt;;</p>

<p>/<em>* Current filters (from URL) </em>/ public readonly filters$: Observable&lt;TFilters&gt;;</p>

<p>/<em>* Current results (from API) </em>/ public readonly results$: Observable&lt;TData[]&gt;;</p>

<p>/<em>* Total result count (for pagination) </em>/ public readonly totalResults$: Observable&lt;number&gt;;</p>

<p>/<em>* Loading state </em>/ public readonly loading$: Observable&lt;boolean&gt;;</p>

<p>/<em>* Current error (null if none) </em>/ public readonly error$: Observable&lt;Error | null&gt;;</p>

<p>/<em>* Statistics data (optional, depends on API) </em>/ public readonly statistics$: Observable&lt;TStatistics | undefined&gt;;</p>

<p>/<em>* Highlight filters (for chart segmentation) </em>/ public readonly highlights$: Observable&lt;any&gt;;</p>

<p>// ============================================================================ // Constructor // ============================================================================</p>

<p>/**</p>
   <ul><li>Constructor — wires up state management</li>
</ul>   *
   <ul><li>@param urlState - Service for URL state management</li>
</ul>   <ul><li>@param domainConfig - Domain configuration (injected via DOMAIN_CONFIG)</li>
</ul>   <ul><li>@param popOutContext - Service to check if in pop-out window</li>
</ul>   <ul><li>@param ngZone - Angular zone for change detection</li>
</ul>   <ul><li>@param isPopOutToken - Optional token indicating pop-out mode</li>
</ul>   */
<p>constructor( private readonly urlState: UrlStateService, @Inject(DOMAIN_CONFIG) private readonly domainConfig: DomainConfig&lt;TFilters, TData, TStatistics&gt;, private readonly popOutContext: PopOutContextService, private readonly ngZone: NgZone, @Optional() @Inject(IS_POPOUT_TOKEN) private readonly isPopOutToken: boolean ) { // Determine if in pop-out (token takes precedence) const isPopOut = this.isPopOutToken ?? false;</p>

<p>// Build configuration from domain config this.config = { filterMapper: this.domainConfig.urlMapper, apiAdapter: this.domainConfig.apiAdapter, cacheKeyBuilder: this.domainConfig.cacheKeyBuilder, defaultFilters: (this.domainConfig.defaultFilters || {}) as TFilters, supportsHighlights: this.domainConfig.features?.highlights ?? false, highlightPrefix: 'h_', // Disable auto-fetch in pop-out windows autoFetch: isPopOut ? false : !this.popOutContext.isInPopOut() };</p>

<p>// Initialize state with defaults this.stateSubject = new BehaviorSubject&lt;ResourceState&lt;TFilters, TData, TStatistics&gt;&gt;({ filters: this.config.defaultFilters, results: [], totalResults: 0, loading: false, error: null, statistics: undefined });</p>

<p>// Create derived observables from state this.state$ = this.stateSubject.asObservable();</p>

<p>this.filters$ = this.state$.pipe( map(s =&gt; s.filters), distinctUntilChanged((a, b) =&gt; deepEqual(a, b)) );</p>

<p>this.results$ = this.state$.pipe( map(s =&gt; s.results), distinctUntilChanged() );</p>

<p>this.totalResults$ = this.state$.pipe( map(s =&gt; s.totalResults), distinctUntilChanged() );</p>

<p>this.loading$ = this.state$.pipe( map(s =&gt; s.loading), distinctUntilChanged() );</p>

<p>this.error$ = this.state$.pipe( map(s =&gt; s.error), distinctUntilChanged() );</p>

<p>this.statistics$ = this.state$.pipe( map(s =&gt; s.statistics), distinctUntilChanged() );</p>

<p>this.highlights$ = this.state$.pipe( map(s =&gt; s.highlights ?? {}), distinctUntilChanged((a, b) =&gt; deepEqual(a, b)) );</p>

<p>// Initialize from current URL this.initializeFromUrl();</p>

<p>// Watch for URL changes this.watchUrlChanges(); }</p>

<p>// ============================================================================ // Public API — State Mutation // ============================================================================</p>

<p>/**</p>
   <ul><li>Update filters (triggers URL update → data fetch)</li>
</ul>   *
   <ul><li>Merges partial filters with current filters, updates URL.</li>
</ul>   <ul><li>URL change triggers automatic data fetch (in main window).</li>
</ul>   *
   <ul><li>@param partial - Partial filter object to merge</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// Update manufacturer filter</li>
</ul>   <ul><li>this.resources.updateFilters({ manufacturer: 'Ford' });</li>
</ul>   *
   <ul><li>// Update multiple filters</li>
</ul>   <ul><li>this.resources.updateFilters({ manufacturer: 'Ford', page: 1 });</li>
</ul>   *
   <ul><li>// Clear a filter by setting to null/undefined</li>
</ul>   <ul><li>this.resources.updateFilters({ manufacturer: null });</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>updateFilters(partial: Partial&lt;TFilters&gt;): void { const currentFilters = this.stateSubject.value.filters; const merged = { ...currentFilters, ...partial };</p>

<p>// Clean up empty values const newFilters: Record&lt;string, any&gt; = {}; for (const key of Object.keys(merged)) { const value = (merged as Record&lt;string, any&gt;)[key]; if (value !== undefined &amp;&amp; value !== null &amp;&amp; value !== '') { newFilters[key] = value; } }</p>

<p>// Convert to URL parameters const newUrlParams = this.config.filterMapper.toUrlParams(newFilters as TFilters);</p>

<p>// Get current URL params to identify removals const currentUrlParams = this.config.filterMapper.toUrlParams(currentFilters);</p>

<p>// Build final params with null for removed params const finalParams: Record&lt;string, any&gt; = { ...newUrlParams }; for (const key of Object.keys(currentUrlParams)) { if (!(key in newUrlParams)) { finalParams[key] = null; // Mark for removal } }</p>

<p>// Update URL (triggers watchUrlChanges → fetchData) this.urlState.setParams(finalParams); }</p>

<p>/**</p>
   <ul><li>Clear all filters (reset to defaults)</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// Reset to initial state</li>
</ul>   <ul><li>this.resources.clearFilters();</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>clearFilters(): void { const currentFilters = this.stateSubject.value.filters; const currentUrlParams = this.config.filterMapper.toUrlParams(currentFilters); const defaultUrlParams = this.config.filterMapper.toUrlParams(this.config.defaultFilters);</p>

<p>// Build params with null for all current params const finalParams: Record&lt;string, any&gt; = { ...defaultUrlParams }; for (const key of Object.keys(currentUrlParams)) { if (!(key in defaultUrlParams)) { finalParams[key] = null; } }</p>

<p>this.urlState.setParams(finalParams, true); // Replace URL }</p>

<p>/**</p>
   <ul><li>Refresh data with current filters</li>
</ul>   *
   <ul><li>Forces a new API call with current filter state.</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// Force refresh after external data change</li>
</ul>   <ul><li>this.resources.refresh();</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>refresh(): void { this.fetchData(this.stateSubject.value.filters); }</p>

<p>// ============================================================================ // Public API — State Access // ============================================================================</p>

<p>/**</p>
   <ul><li>Get current state snapshot (synchronous)</li>
</ul>   *
   <ul><li>@returns Current resource state</li>
</ul>   */
<p>getCurrentState(): ResourceState&lt;TFilters, TData, TStatistics&gt; { return this.stateSubject.value; }</p>

<p>/**</p>
   <ul><li>Get current filters snapshot (synchronous)</li>
</ul>   *
   <ul><li>@returns Current filters</li>
</ul>   */
<p>getCurrentFilters(): TFilters { return this.stateSubject.value.filters; }</p>

<p>// ============================================================================ // Public API — Cross-Window Sync // ============================================================================</p>

<p>/**</p>
   <ul><li>Sync state from external source</li>
</ul>   *
   <ul><li>Used by pop-out windows to receive state from main window.</li>
</ul>   <ul><li>Bypasses URL → fetch flow and directly updates state.</li>
</ul>   *
   <ul><li>@param externalState - State to sync from main window</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// In pop-out window, receiving message from main window</li>
</ul>   <ul><li>window.addEventListener('message', (event) =&gt; {</li>
</ul>   <ul><li>  if (event.data.type === 'STATE_SYNC') {</li>
</ul>   <ul><li>    this.resources.syncStateFromExternal(event.data.state);</li>
</ul>   <ul><li>  }</li>
</ul>   <ul><li>});</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>public syncStateFromExternal( externalState: ResourceState&lt;TFilters, TData, TStatistics&gt; ): void { this.ngZone.run(() =&gt; { this.stateSubject.next(externalState); }); }</p>

<p>// ============================================================================ // Private Methods — Initialization // ============================================================================</p>

<p>/**</p>
   <ul><li>Initialize filters from current URL</li>
</ul>   */
<p>private initializeFromUrl(): void { const urlParams = this.urlState.getParams(); const filters = this.config.filterMapper.fromUrlParams(urlParams); const highlights = this.extractHighlights(urlParams);</p>

<p>this.updateState({ filters, highlights }); }</p>

<p>/**</p>
   <ul><li>Watch for URL changes and update state</li>
</ul>   */
<p>private watchUrlChanges(): void { this.urlState .watchParams() .pipe(takeUntil(this.destroy$)) .subscribe(urlParams =&gt; { const filters = this.config.filterMapper.fromUrlParams(urlParams); const highlights = this.extractHighlights(urlParams); this.updateState({ filters, highlights });</p>

<p>// Only fetch in main window (not in pop-out) if (this.config.autoFetch) { this.fetchData(filters); } }); }</p>

<p>// ============================================================================ // Private Methods — Data Fetching // ============================================================================</p>

<p>/**</p>
   <ul><li>Fetch data from API</li>
</ul>   */
<p>private fetchData(filters: TFilters): void { this.updateState({ loading: true, error: null });</p>

<p>const highlights = this.stateSubject.value.highlights;</p>

<p>this.config.apiAdapter .fetchData(filters, highlights) .pipe( takeUntil(this.destroy$), catchError(error =&gt; { console.error('[ResourceManagementService] Fetch error:', error); this.updateState({ loading: false, error: error instanceof Error ? error : new Error(String(error)), results: [], totalResults: 0 }); return of(null); }), finalize(() =&gt; { // Ensure loading is false even if observable completes without value if (this.stateSubject.value.loading) { this.updateState({ loading: false }); } }) ) .subscribe(response =&gt; { if (response) { this.updateState({ results: response.results, totalResults: response.total, statistics: response.statistics, loading: false, error: null }); } }); }</p>

<p>// ============================================================================ // Private Methods — Highlights // ============================================================================</p>

<p>/**</p>
   <ul><li>Extract highlight filters from URL parameters</li>
</ul>   */
<p>private extractHighlights(urlParams: Record&lt;string, any&gt;): any { // Prefer domain-specific mapper strategy if (this.config.filterMapper.extractHighlights) { return this.config.filterMapper.extractHighlights(urlParams); }</p>

<p>// Fallback: prefix-based extraction if (!this.config.supportsHighlights) { return {}; }</p>

<p>const prefix = this.config.highlightPrefix || 'h_'; const highlights: Record&lt;string, any&gt; = {};</p>

<p>Object.keys(urlParams).forEach(key =&gt; { if (key.startsWith(prefix)) { const highlightKey = key.substring(prefix.length); let value = urlParams[key];</p>

<p>// Convert pipe-separated to comma-separated if (typeof value === 'string' &amp;&amp; value.includes('|')) { value = value.replace(/\|/g, ','); }</p>

<p>highlights[highlightKey] = value; } });</p>

<p>return highlights; }</p>

<p>// ============================================================================ // Private Methods — State Management // ============================================================================</p>

<p>/**</p>
   <ul><li>Update state immutably</li>
</ul>   */
<p>private updateState(partial: Partial&lt;ResourceState&lt;TFilters, TData, TStatistics&gt;&gt;): void { this.stateSubject.next({ ...this.stateSubject.value, ...partial }); }</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>/**</p>
   <ul><li>Clean up subscriptions (public alias)</li>
</ul>   */
<p>destroy(): void { this.ngOnDestroy(); }</p>

<p>/**</p>
   <ul><li>Clean up subscriptions on component destroy</li>
</ul>   */
<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 306.4: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 6 (Section 306) - Added ResourceManagementService, PopOutContextService</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service'; export * from './popout-context.service'; export * from './resource-management.service';</p>
</code></pre>

<hr>

<h2>Phase 3A Milestone: Demo Component</h2>

<p>After completing Section 306, create a temporary demo component that displays URL state changes.</p>

<p>Create <code class="inline">src/app/features/demo/url-state-demo.component.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/demo/url-state-demo.component.ts
<p>// TEMPORARY - Remove after verification</p>

<p>import { Component, OnInit, OnDestroy } from '@angular/core'; import { Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators'; import { UrlStateService } from '../../framework/services';</p>

<p>@Component({ selector: 'app-url-state-demo', template: <code class="inline"> &lt;div style="padding: 20px; font-family: monospace;"&gt; &lt;h2&gt;URL State Demo&lt;/h2&gt;</p>

<p>&lt;div style="margin: 20px 0;"&gt; &lt;h3&gt;Current URL Params:&lt;/h3&gt; &lt;pre&gt;{{ currentParams | json }}&lt;/pre&gt; &lt;/div&gt;</p>

<p>&lt;div style="margin: 20px 0;"&gt; &lt;h3&gt;Test Controls:&lt;/h3&gt; &lt;button (click)="setManufacturer('Ford')"&gt;Set manufacturer=Ford&lt;/button&gt; &lt;button (click)="setManufacturer('Toyota')"&gt;Set manufacturer=Toyota&lt;/button&gt; &lt;button (click)="setPage(1)"&gt;Set page=1&lt;/button&gt; &lt;button (click)="setPage(2)"&gt;Set page=2&lt;/button&gt; &lt;button (click)="clearAll()"&gt;Clear All&lt;/button&gt; &lt;/div&gt;</p>

<p>&lt;div style="margin: 20px 0;"&gt; &lt;h3&gt;Log:&lt;/h3&gt; &lt;div *ngFor="let log of logs" style="font-size: 12px;"&gt;{{ log }}&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</p>
  </code>
<p>}) export class UrlStateDemoComponent implements OnInit, OnDestroy { currentParams: any = {}; logs: string[] = []; private destroy$ = new Subject&lt;void&gt;();</p>

<p>constructor(private urlState: UrlStateService) {}</p>

<p>ngOnInit(): void { this.urlState.watchParams() .pipe(takeUntil(this.destroy$)) .subscribe(params =&gt; { this.currentParams = params; this.logs.unshift(<code class="inline">${new Date().toISOString()}: ${JSON.stringify(params)}</code>); if (this.logs.length &gt; 10) this.logs.pop(); }); }</p>

<p>setManufacturer(value: string): void { this.urlState.setParam('manufacturer', value); }</p>

<p>setPage(value: number): void { this.urlState.setParam('page', value); }</p>

<p>clearAll(): void { this.urlState.clearParams(); }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); } }</p>
</code></pre>

<p>Add route for demo (temporary):</p>

<pre class="code-block typescript"><code>// In app-routing.module.ts
<p>{ path: 'demo', component: UrlStateDemoComponent }</p>
</code></pre>

<p>Navigate to <code class="inline">/demo</code> and test the URL-First pattern in action.</p></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check Files Exist</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/resource-management.service.ts
<p>$ ls -la src/app/framework/services/popout-context.service.ts $ ls -la src/app/framework/tokens/popout.token.ts</p>
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/resource-management.service.ts
</code></pre>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>4. Run Demo Component</h3>

<pre class="code-block bash"><code>$ ng serve
</code></pre>

<p>Navigate to <code class="inline">http://localhost:4200/demo</code> and:</p>

<ul><li>Click "Set manufacturer=Ford"</li>
<p><li>Observe URL changes to <code class="inline">?manufacturer=Ford</code></li> <li>Observe Current URL Params updates</li> <li>Use browser back button</li> <li>Observe params revert</li></p>
</ul>
<p><strong>This is the Phase 3A Aha Moment in action:</strong></p>

<p>"The URL is the single source of truth. Components react to URL changes, they don't control them."</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module '../tokens/popout.token'</code></td> <td>Token file not created</td> <td>Create the token file in Step 306.1</td></p>
</tr>
<p><tr> <td><code class="inline">No provider for DOMAIN_CONFIG</code></td> <td>Missing provider</td> <td>Add provider in component or module</td></p>
</tr>
<p><tr> <td>State not updating</td> <td>Missing subscription</td> <td>Ensure component subscribes to observables</td></p>
</tr>
<p><tr> <td>Infinite loop on filter change</td> <td>Filter update triggers URL, URL triggers fetch</td> <td>Check distinctUntilChanged is working</td></p>
</tr>
<p><tr> <td>Pop-out doesn't receive state</td> <td>syncStateFromExternal not called</td> <td>Implement message passing (Phase 3B)</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>URL is the single source of truth</strong> — updateFilters() modifies URL, not internal state</li>
<p><li><strong>State flows one direction</strong> — URL → filters → API → results → components</li> <li><strong>Component-level injection enables isolation</strong> — Each component gets its own instance</li> <li><strong>Pop-out awareness prevents duplicate fetches</strong> — Main window fetches, pop-outs sync</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/resource-management.service.ts</code> exists</li>
<p><li>[ ] <code class="inline">src/app/framework/services/popout-context.service.ts</code> exists (placeholder)</li> <li>[ ] <code class="inline">src/app/framework/tokens/popout.token.ts</code> exists</li> <li>[ ] Service is <code class="inline">@Injectable()</code> (not providedIn: 'root')</li> <li>[ ] Observable streams: filters$, results$, loading$, error$, statistics$</li> <li>[ ] <code class="inline">updateFilters()</code> updates URL, not internal state directly</li> <li>[ ] <code class="inline">clearFilters()</code> resets to default filters</li> <li>[ ] <code class="inline">refresh()</code> forces new data fetch</li> <li>[ ] <code class="inline">syncStateFromExternal()</code> enables pop-out state sync</li> <li>[ ] autoFetch disabled in pop-out windows</li> <li>[ ] Proper cleanup via ngOnDestroy()</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] Demo component works as described</li></ul></p></div><div class="page-content"><hr>

<h2>Phase 3A Complete</h2>

<p>Congratulations! You have completed Phase 3A: Core Services.</p>

<p><strong>What you built:</strong></p>
<ul><li>UrlStateService — URL as source of truth</li>
<p><li>ApiService — Thin HTTP wrapper</li> <li>RequestCoordinatorService — Cache, dedup, retry</li> <li>DomainConfigRegistry — Multi-domain support</li> <li>DomainConfigValidator — Runtime validation</li> <li>ResourceManagementService — State orchestration</li></p>
</ul>
<p><strong>The Aha Moment:</strong> "The URL is the single source of truth. Components react to URL changes, they don't control them."</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">307-popout-context-service.md</code> to begin Phase 3B: Popout &amp; Specialized Services.</p></div></div>
    <div class="chapter" id="section-307">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>307: Popout Context Service</h1>
        </div>
<div class="page-content"><h1>307: Popout Context Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 208-popout-interface, 306-resource-management-service <strong>Blocks:</strong> 308-popout-manager-service</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the BroadcastChannel API for cross-window communication</li>
<p><li>Know how to determine if code is running in a pop-out window</li> <li>Recognize the messaging patterns for parent-child window coordination</li> <li>Be able to implement bidirectional communication between windows</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">PopOutContextService</code> that determines whether the current window is a pop-out and provides messaging infrastructure for communication between the main window and pop-out windows.</p>

<hr>

<h2>Why</h2>

<p>Pop-out windows are a core feature of vvroom. Users can detach panels (statistics, charts) into separate browser windows for multi-monitor workflows. This creates a challenge: <em>how do these windows communicate?</em></p>

<h3>The Pop-Out Challenge</h3>

<p>When you call <code class="inline">window.open()</code>, the new window is essentially a separate instance:</p>
<ul><li>Different JavaScript context</li>
<p><li>Different Angular application instance</li> <li>No shared services or state</li></p>
</ul>
<p>We need a way for:</p>
<ul><li><strong>Main window</strong> → Detect when pop-out is ready</li>
<p><li><strong>Main window</strong> → Send state updates to pop-out</li> <li><strong>Pop-out</strong> → Receive state updates</li> <li><strong>Pop-out</strong> → Notify main window it's closing</li></p>
</ul>
<h3>Communication Options</h3>

<table>
<p><thead><tr> <th>Option</th> <th>Pros</th> <th>Cons</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">window.opener</code></td> <td>Direct reference</td> <td>Security restrictions, fragile</td></p>
</tr>
<p><tr> <td><code class="inline">postMessage()</code></td> <td>Standard API</td> <td>Requires origin checks, complex</td></p>
</tr>
<p><tr> <td><code class="inline">BroadcastChannel</code></td> <td>Simple, bidirectional</td> <td>Browser support (good since 2017)</td></p>
</tr>
<p><tr> <td><code class="inline">SharedWorker</code></td> <td>Powerful</td> <td>Complex setup</td></p>
</tr>
</tbody>
</table>

<p>We use <strong>BroadcastChannel</strong> because:</p>
<ul><li>Simple API: <code class="inline">channel.postMessage()</code> and <code class="inline">channel.onmessage</code></li>
<p><li>Works across same-origin windows</li> <li>No need to track window references</li> <li>Automatic cleanup when windows close</li></p>
</ul>
<h3>The Context Service Pattern</h3>

<p><code class="inline">PopOutContextService</code> serves two roles:</p>

<ul><li><strong>In pop-out window</strong>: Determines "I am a pop-out" and sets up messaging</li>
<p><li><strong>In main window</strong>: Initializes as parent for pop-out management</li></p>
</ul>
<pre class="code-block typescript"><code>// Pop-out window
<p>if (contextService.isInPopOut()) { contextService.initializeAsPopOut('statistics-panel'); }</p>

<p>// Main window contextService.initializeAsParent();</p>
</code></pre></div><div class="page-content"><h3>Route-Based Detection</h3>

<p>Pop-outs are identified by their URL pattern:</p>

<pre class="code-block text"><code>/popout/:gridId/:panelId/:panelType
</code></pre>

<p>Example: <code class="inline">/popout/main-grid/statistics-1/statistics-panel-2</code></p>

<p>The service parses this URL to extract:</p>
<ul><li><code class="inline">isPopOut</code>: true (URL starts with <code class="inline">/popout</code>)</li>
<p><li><code class="inline">gridId</code>: "main-grid"</li> <li><code class="inline">panelId</code>: "statistics-1"</li> <li><code class="inline">panelType</code>: "statistics-panel-2"</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 307.1: Replace the Placeholder Service</h3>

<p>Replace the placeholder created in Section 306 with the full implementation.</p>

<p>Update <code class="inline">src/app/framework/services/popout-context.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/popout-context.service.ts
<p>// VERSION 2 (Section 307) - Full implementation with BroadcastChannel</p>

<p>import { Injectable, OnDestroy, NgZone } from '@angular/core'; import { Router } from '@angular/router'; import { Observable, ReplaySubject } from 'rxjs'; import { PopOutMessage, PopOutMessageType, PopOutContext, parsePopOutRoute } from '../models/popout.interface';</p>

<p>/**</p>
 <ul><li>Pop-out context service</li>
</ul> *
 <ul><li>Determines whether the current window is a pop-out and provides</li>
</ul> <ul><li>messaging infrastructure for parent-child window communication.</li>
</ul> *
 <ul><li><strong>Two Modes:</strong></li>
</ul> *
 <ul><li>1. <strong>Pop-out mode</strong> — Running in a pop-out window</li>
</ul> <ul><li>   - <code class="inline">isInPopOut()</code> returns true</li>
</ul> <ul><li>   - Sets up BroadcastChannel to receive state from main window</li>
</ul> <ul><li>   - Sends PANEL_READY message when initialized</li>
</ul> *
 <ul><li>2. <strong>Parent mode</strong> — Running in main window</li>
</ul> <ul><li>   - <code class="inline">isInPopOut()</code> returns false</li>
</ul> <ul><li>   - Manages channels for each pop-out panel</li>
</ul> <ul><li>   - Broadcasts state updates to all pop-outs</li>
</ul> *
 <ul><li><strong>BroadcastChannel Pattern:</strong></li>
</ul> *
 <ul><li>Each panel gets its own channel named <code class="inline">panel-{panelId}</code>.</li>
</ul> <ul><li>This allows targeted messaging to specific panels.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In pop-out window component</li>
</ul> <ul><li>if (this.context.isInPopOut()) {</li>
</ul> <ul><li>  const ctx = this.context.getContext();</li>
</ul> <ul><li>  this.context.initializeAsPopOut(ctx.panelId);</li>
</ul> *
 <ul><li>  this.context.getMessages$().subscribe(message =&gt; {</li>
</ul> <ul><li>    if (message.type === PopOutMessageType.STATE_UPDATE) {</li>
</ul> <ul><li>      this.handleStateUpdate(message.payload);</li>
</ul> <ul><li>    }</li>
</ul> <ul><li>  });</li>
</ul> <ul><li>}</li>
</ul> *
 <ul><li>// In main window</li>
</ul> <ul><li>this.context.initializeAsParent();</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class PopOutContextService implements OnDestroy { /**</p>
   <ul><li>BroadcastChannel for this window</li>
</ul>   *
   <ul><li>In pop-out: channel for receiving messages from main window</li>
</ul>   <ul><li>In parent: may be null (uses per-panel channels via PopOutManager)</li>
</ul>   */
<p>private channel: BroadcastChannel | null = null;</p>

<p>/**</p>
   <ul><li>ReplaySubject for incoming messages</li>
</ul>   *
   <ul><li>ReplaySubject with buffer of 10 ensures late subscribers</li>
</ul>   <ul><li>can receive recent messages they might have missed.</li>
</ul>   */
<p>private messagesSubject = new ReplaySubject&lt;PopOutMessage&gt;(10);</p>

<p>/**</p>
   <ul><li>Parsed context from URL</li>
</ul>   *
   <ul><li>Contains isPopOut, gridId, panelId, panelType</li>
</ul>   */
<p>private context: PopOutContext | null = null;</p>

<p>/**</p>
   <ul><li>Initialization flag to prevent double-init</li>
</ul>   */
<p>private initialized = false;</p>

<p>/**</p>
   <ul><li>Constructor - parses URL to determine context</li>
</ul>   *
   <ul><li>@param router - Angular Router for URL access</li>
</ul>   <ul><li>@param ngZone - NgZone for ensuring change detection</li>
</ul>   */
<p>constructor( private router: Router, private ngZone: NgZone ) { // Parse context from current URL this.context = parsePopOutRoute(this.router.url); }</p>

<p>/**</p>
   <ul><li>Check if current window is a pop-out</li>
</ul>   *
   <ul><li>Determined by URL pattern: /popout/:gridId/:panelId/:panelType</li>
</ul>   *
   <ul><li>@returns True if in pop-out window</li>
</ul>   */
<p>isInPopOut(): boolean { // Re-parse if context not set (defensive) if (!this.context) { this.context = parsePopOutRoute(this.router.url); } return this.context?.isPopOut || false; }</p>

<p>/**</p>
   <ul><li>Get parsed pop-out context</li>
</ul>   *
   <ul><li>@returns Context object with gridId, panelId, panelType, or null</li>
</ul>   */
<p>getContext(): PopOutContext | null { if (!this.context) { this.context = parsePopOutRoute(this.router.url); } return this.context; }</p>

<p>/**</p>
   <ul><li>Initialize as pop-out window</li>
</ul>   *
   <ul><li>Sets up BroadcastChannel for receiving messages from main window.</li>
</ul>   <ul><li>Sends PANEL_READY message to notify main window.</li>
</ul>   *
   <ul><li>@param panelId - Panel identifier for channel naming</li>
</ul>   */
<p>initializeAsPopOut(panelId: string): void { if (this.initialized) { return; }</p>

<p>this.initialized = true; this.setupChannel(panelId);</p>

<p>// Notify main window that pop-out is ready this.sendMessage({ type: PopOutMessageType.PANEL_READY, timestamp: Date.now() }); }</p>

<p>/**</p>
   <ul><li>Initialize as parent window</li>
</ul>   *
   <ul><li>Called by main window to set initialized flag.</li>
</ul>   <ul><li>Actual channel management is handled by PopOutManagerService.</li>
</ul>   */
<p>initializeAsParent(): void { if (this.initialized) { return; }</p>

<p>this.initialized = true; // Parent doesn't set up a channel here - PopOutManager handles per-panel channels }</p>

<p>/**</p>
   <ul><li>Set up BroadcastChannel for this panel</li>
</ul>   *
   <ul><li>@param panelId - Panel identifier for channel naming</li>
</ul>   */
<p>private setupChannel(panelId: string): void { const channelName = <code class="inline">panel-${panelId}</code>;</p>

<p>// Close existing channel if any if (this.channel) { this.channel.close(); }</p>

<p>// Create new channel this.channel = new BroadcastChannel(channelName);</p>

<p>// Handle incoming messages this.channel.onmessage = (event: MessageEvent) =&gt; { const message = event.data as PopOutMessage; // Use NgZone to ensure Angular change detection runs this.ngZone.run(() =&gt; { this.messagesSubject.next(message); }); };</p>

<p>// Handle message errors (rare, but log them) this.channel.onmessageerror = () =&gt; { console.warn('[PopOutContextService] Message deserialization error'); }; }</p>

<p>/**</p>
   <ul><li>Send message to channel</li>
</ul>   *
   <ul><li>Used by pop-out to send messages to main window.</li>
</ul>   *
   <ul><li>@template T - Payload type</li>
</ul>   <ul><li>@param message - Message to send</li>
</ul>   */
<p>sendMessage&lt;T = any&gt;(message: PopOutMessage&lt;T&gt;): void { if (!this.channel) { console.warn('[PopOutContextService] No channel available for sending'); return; }</p>

<p>// Add timestamp if not present if (!message.timestamp) { message.timestamp = Date.now(); }</p>

<p>try { this.channel.postMessage(message); } catch (error) { console.error('[PopOutContextService] Failed to send message:', error); } }</p>

<p>/**</p>
   <ul><li>Get observable of incoming messages</li>
</ul>   *
   <ul><li>@returns Observable of PopOutMessage</li>
</ul>   */
<p>getMessages$(): Observable&lt;PopOutMessage&gt; { return this.messagesSubject.asObservable(); }</p>

<p>/**</p>
   <ul><li>Create a BroadcastChannel for a specific panel</li>
</ul>   *
   <ul><li>Used by PopOutManagerService to create channels for pop-out windows.</li>
</ul>   *
   <ul><li>@param panelId - Panel identifier</li>
</ul>   <ul><li>@returns New BroadcastChannel instance</li>
</ul>   */
<p>createChannelForPanel(panelId: string): BroadcastChannel { const channelName = <code class="inline">panel-${panelId}</code>; return new BroadcastChannel(channelName); }</p>

<p>/**</p>
   <ul><li>Close the channel</li>
</ul>   *
   <ul><li>Call when pop-out is closing or service is destroyed.</li>
</ul>   */
<p>close(): void { if (this.channel) { this.channel.close(); this.channel = null; }</p>

<p>this.initialized = false; }</p>

<p>/**</p>
   <ul><li>Cleanup on service destroy</li>
</ul>   */
<p>ngOnDestroy(): void { this.close(); this.messagesSubject.complete(); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 307.2: Verify Popout Interface Exists</h3>

<p>Ensure <code class="inline">src/app/framework/models/popout.interface.ts</code> exists (from Section 208).</p>

<p>If the interface doesn't include <code class="inline">parsePopOutRoute</code>, add it:</p>

<pre class="code-block typescript"><code>// Add to src/app/framework/models/popout.interface.ts
<p>// VERSION 2 (Section 307) - Added parsePopOutRoute function</p>

<p>/**</p>
 <ul><li>Parse pop-out route to extract context</li>
</ul> *
 <ul><li>@param url - Current router URL</li>
</ul> <ul><li>@returns PopOutContext with parsed values, or default context if not pop-out</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>parsePopOutRoute('/popout/main-grid/stats-1/statistics-panel-2')</li>
</ul> <ul><li>// Returns: { isPopOut: true, gridId: 'main-grid', panelId: 'stats-1', panelType: 'statistics-panel-2' }</li>
</ul> *
 <ul><li>parsePopOutRoute('/discover')</li>
</ul> <ul><li>// Returns: { isPopOut: false, gridId: '', panelId: '', panelType: '' }</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function parsePopOutRoute(url: string): PopOutContext { // Pattern: /popout/:gridId/:panelId/:panelType const match = url.match(/^\/popout\/([^\/]+)\/([^\/]+)\/([^\/\?]+)/);</p>

<p>if (match) { return { isPopOut: true, gridId: match[1], panelId: match[2], panelType: match[3] }; }</p>

<p>return { isPopOut: false, gridId: '', panelId: '', panelType: '' }; }</p>
</code></pre>

<hr>

<h3>Step 307.3: Update the Barrel File</h3>

<p>The barrel file should already export this service from Section 306. Verify:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>export * from './popout-context.service';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Updated</h3>

<pre class="code-block bash"><code>$ wc -l src/app/framework/services/popout-context.service.ts
</code></pre>

<p>Should show ~200+ lines (not the short placeholder).</p>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/popout-context.service.ts
</code></pre>

<p>Expected: No output (no compilation errors).</p>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>4. Verify Context Detection (Optional)</h3>

<p>Add temporary test code:</p>

<pre class="code-block typescript"><code>// In app.component.ts
<p>import { PopOutContextService } from './framework/services';</p>

<p>constructor(private popOutContext: PopOutContextService) { console.log('Is pop-out?', this.popOutContext.isInPopOut()); console.log('Context:', this.popOutContext.getContext()); }</p>
</code></pre>

<p>Navigate to <code class="inline">/</code> — Should log <code class="inline">Is pop-out? false</code> Navigate to <code class="inline">/popout/grid1/panel1/stats</code> — Should log <code class="inline">Is pop-out? true</code></p></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module '../models/popout.interface'</code></td> <td>Interface file missing</td> <td>Complete Section 208 first</td></p>
</tr>
<p><tr> <td><code class="inline">parsePopOutRoute is not a function</code></td> <td>Function not exported</td> <td>Add to popout.interface.ts and export</td></p>
</tr>
<p><tr> <td>isInPopOut always false</td> <td>URL doesn't match pattern</td> <td>Check URL pattern is <code class="inline">/popout/...</code></td></p>
</tr>
<p><tr> <td>Messages not received</td> <td>Channel name mismatch</td> <td>Verify both sides use <code class="inline">panel-{panelId}</code></td></p>
</tr>
<p><tr> <td>Change detection not running</td> <td>Missing NgZone.run()</td> <td>Wrap message handling in ngZone.run()</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>BroadcastChannel enables simple cross-window messaging</strong> — No window references needed</li>
<p><li><strong>URL pattern determines pop-out status</strong> — Route-based detection is reliable</li> <li><strong>ReplaySubject with buffer catches late subscribers</strong> — Messages aren't lost</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/popout-context.service.ts</code> fully implemented</li>
<p><li>[ ] <code class="inline">isInPopOut()</code> correctly detects pop-out windows by URL pattern</li> <li>[ ] <code class="inline">getContext()</code> returns parsed gridId, panelId, panelType</li> <li>[ ] <code class="inline">initializeAsPopOut()</code> sets up BroadcastChannel</li> <li>[ ] <code class="inline">initializeAsParent()</code> sets initialized flag</li> <li>[ ] <code class="inline">sendMessage()</code> sends via BroadcastChannel</li> <li>[ ] <code class="inline">getMessages$()</code> returns observable of incoming messages</li> <li>[ ] <code class="inline">createChannelForPanel()</code> creates channels for parent use</li> <li>[ ] <code class="inline">parsePopOutRoute()</code> function added to popout.interface.ts</li> <li>[ ] NgZone.run() wraps message handling</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">308-popout-manager-service.md</code> to create the service that manages pop-out windows from the main window.</p></div></div>
    <div class="chapter" id="section-308">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>308: Popout Manager Service</h1>
        </div>
<div class="page-content"><h1>308: Popout Manager Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 307-popout-context-service, 208-popout-interface <strong>Blocks:</strong> Phase 9 (Feature Components)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the window.open() API and its configuration options</li>
<p><li>Know how to track pop-out window lifecycle (open, close)</li> <li>Recognize the state broadcast pattern for multi-window synchronization</li> <li>Be able to implement a comprehensive pop-out window manager</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">PopOutManagerService</code> that opens, tracks, and communicates with pop-out windows from the main window. This service is the counterpart to <code class="inline">PopOutContextService</code> — one manages from the main window, the other runs inside pop-outs.</p>

<hr>

<h2>Why</h2>

<p><code class="inline">PopOutContextService</code> handles the pop-out side. Now we need the parent side:</p>

<table>
<p><thead><tr> <th>Service</th> <th>Runs In</th> <th>Responsibility</th></p>
</tr></thead>
<p><tbody> <tr> <td>PopOutContextService</td> <td>Pop-out window</td> <td>Receive state, send events</td></p>
</tr>
<p><tr> <td>PopOutManagerService</td> <td>Main window</td> <td>Open pop-outs, broadcast state, track lifecycle</td></p>
</tr>
</tbody>
</table>

<h3>The Manager's Responsibilities</h3>

<ul><li><strong>Open pop-out windows</strong> — Call <code class="inline">window.open()</code> with correct URL and features</li>
<p><li><strong>Track open pop-outs</strong> — Know which panels are currently popped out</li> <li><strong>Broadcast state</strong> — Send state updates to all pop-out windows</li> <li><strong>Handle closing</strong> — Detect when pop-outs close and clean up</li> <li><strong>Prevent duplicates</strong> — Don't open same panel twice</li></p>
</ul>
<h3>Why Component-Level Injection?</h3>

<p>Unlike <code class="inline">PopOutContextService</code> (singleton), <code class="inline">PopOutManagerService</code> is component-level:</p>

<pre class="code-block typescript"><code>@Component({
<p>providers: [PopOutManagerService] }) export class DiscoverComponent { ... }</p>
</code></pre>

<p>Reasons:</p>
<ul><li>Manager is tied to a specific grid/layout</li>
<p><li>Different pages might have different pop-out needs</li> <li>Cleanup is easier when tied to component lifecycle</li></p>
</ul>
<h3>The State Broadcast Pattern</h3>

<p>When filters change in the main window:</p>

<pre class="code-block text"><code>Main Window                          Pop-out Window
<p>│                                     │ ├── Filters change                    │ │                                     │ ├── ResourceManagementService         │ │   updates state$                    │ │                                     │ ├── Component subscribes to state$    │ │                                     │ ├── Component calls                   │ │   popOutManager.broadcastState()    │ │          │                          │ │          └──── BroadcastChannel ───►│ │                                     │ │                                     ├── PopOutContextService │                                     │   receives message │                                     │ │                                     ├── ResourceManagementService │                                     │   .syncStateFromExternal() │                                     │ │                                     └── UI updates</p>
</code></pre>

<p>Pop-outs never make API calls. They receive state from the main window.</p></div><div class="page-content"><h3>Window Lifecycle Detection</h3>

<p>JavaScript can't directly listen for window close events on child windows. We use polling:</p>

<pre class="code-block typescript"><code>const checkInterval = setInterval(() =&gt; {
<p>if (popoutWindow.closed) { clearInterval(checkInterval); this.handlePopOutClosed(panelId); } }, 500);</p>
</code></pre>

<hr>

<h2>What</h2>

<h3>Step 308.1: Create the Popout Manager Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/popout-manager.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/popout-manager.service.ts
<p>// VERSION 1 (Section 308) - Pop-out window manager</p>

<p>import { Injectable, NgZone, OnDestroy } from '@angular/core'; import { Subject } from 'rxjs'; import { buildWindowFeatures, PopOutMessage, PopOutMessageType, PopOutWindowFeatures, PopOutWindowRef } from '../models/popout.interface'; import { PopOutContextService } from './popout-context.service';</p>

<p>/**</p>
 <ul><li>Pop-out manager service</li>
</ul> *
 <ul><li>Manages pop-out windows from the main window. Opens windows,</li>
</ul> <ul><li>broadcasts state, and tracks lifecycle.</li>
</ul> *
 <ul><li><strong>Important:</strong> This is a component-level service, not a singleton.</li>
</ul> <ul><li>Each component that needs pop-out management provides its own instance.</li>
</ul> *
 <ul><li><strong>Lifecycle:</strong></li>
</ul> *
 <ul><li>1. Component creates → Manager injected</li>
</ul> <ul><li>2. Component calls initialize() with grid ID</li>
</ul> <ul><li>3. User clicks pop-out button → openPopOut() called</li>
</ul> <ul><li>4. Filter changes → broadcastState() called</li>
</ul> <ul><li>5. Pop-out closes → Manager detects and cleans up</li>
</ul> <ul><li>6. Component destroys → All pop-outs closed</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>@Component({</li>
</ul> <ul><li>  providers: [PopOutManagerService]</li>
</ul> <ul><li>})</li>
</ul> <ul><li>export class DiscoverComponent implements OnInit, OnDestroy {</li>
</ul> <ul><li>  constructor(</li>
</ul> <ul><li>    private popOutManager: PopOutManagerService,</li>
</ul> <ul><li>    private resources: ResourceManagementService</li>
</ul> <ul><li>  ) {}</li>
</ul> *
 <ul><li>  ngOnInit(): void {</li>
</ul> <ul><li>    this.popOutManager.initialize('discover-grid');</li>
</ul> *
 <ul><li>    // Broadcast state to pop-outs when it changes</li>
</ul> <ul><li>    this.resources.state$.subscribe(state =&gt; {</li>
</ul> <ul><li>      this.popOutManager.broadcastState(state);</li>
</ul> <ul><li>    });</li>
</ul> *
 <ul><li>    // Handle pop-out closure</li>
</ul> <ul><li>    this.popOutManager.closed$.subscribe(panelId =&gt; {</li>
</ul> <ul><li>      console.log(<code class="inline">Pop-out ${panelId} closed</code>);</li>
</ul> <ul><li>    });</li>
</ul> <ul><li>  }</li>
</ul> *
 <ul><li>  onPopOutClick(panelId: string, panelType: string): void {</li>
</ul> <ul><li>    this.popOutManager.openPopOut(panelId, panelType);</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable() // Component-level, not providedIn: 'root' export class PopOutManagerService implements OnDestroy { /**</p>
   <ul><li>Grid ID for URL construction</li>
</ul>   */
<p>private gridId = '';</p>

<p>/**</p>
   <ul><li>Set of currently popped-out panel IDs</li>
</ul>   */
<p>private poppedOutPanels = new Set&lt;string&gt;();</p>

<p>/**</p>
   <ul><li>Map of panel ID to window reference/channel</li>
</ul>   */
<p>private popoutWindows = new Map&lt;string, PopOutWindowRef&gt;();</p>

<p>/**</p>
   <ul><li>Subject for messages from pop-outs</li>
</ul>   */
<p>private messagesSubject = new Subject&lt;{ panelId: string; message: PopOutMessage }&gt;();</p>

<p>/**</p>
   <ul><li>Subject for pop-out close events</li>
</ul>   */
<p>private closedSubject = new Subject&lt;string&gt;();</p>

<p>/**</p>
   <ul><li>Subject for blocked pop-up events (browser blocked window.open)</li>
</ul>   */
<p>private blockedSubject = new Subject&lt;string&gt;();</p>

<p>/**</p>
   <ul><li>Handler for beforeunload to close all pop-outs</li>
</ul>   */
<p>private beforeUnloadHandler = () =&gt; this.closeAllPopOuts();</p>

<p>/**</p>
   <ul><li>Initialization flag</li>
</ul>   */
<p>private initialized = false;</p>

<p>// Public observables readonly messages$ = this.messagesSubject.asObservable(); readonly closed$ = this.closedSubject.asObservable(); readonly blocked$ = this.blockedSubject.asObservable();</p>

<p>/**</p>
   <ul><li>Constructor</li>
</ul>   *
   <ul><li>@param popOutContext - Context service for channel creation</li>
</ul>   <ul><li>@param ngZone - NgZone for change detection</li>
</ul>   */
<p>constructor( private popOutContext: PopOutContextService, private ngZone: NgZone ) {}</p>

<p>/**</p>
   <ul><li>Initialize the manager</li>
</ul>   *
   <ul><li>Must be called before any pop-out operations.</li>
</ul>   *
   <ul><li>@param gridId - Grid identifier for URL construction</li>
</ul>   */
<p>initialize(gridId: string): void { if (this.initialized) { return; }</p>

<p>this.gridId = gridId; this.initialized = true;</p>

<p>// Initialize context as parent this.popOutContext.initializeAsParent();</p>

<p>// Close all pop-outs when main window closes window.addEventListener('beforeunload', this.beforeUnloadHandler);</p>

<p>// Subscribe to messages from pop-outs this.popOutContext.getMessages$().subscribe(message =&gt; { this.messagesSubject.next({ panelId: '', message }); }); }</p>

<p>/**</p>
   <ul><li>Check if a panel is currently popped out</li>
</ul>   *
   <ul><li>@param panelId - Panel identifier</li>
</ul>   <ul><li>@returns True if panel is popped out</li>
</ul>   */
<p>isPoppedOut(panelId: string): boolean { return this.poppedOutPanels.has(panelId); }</p>

<p>/**</p>
   <ul><li>Get all currently popped-out panel IDs</li>
</ul>   *
   <ul><li>@returns Array of panel IDs</li>
</ul>   */
<p>getPoppedOutPanels(): string[] { return Array.from(this.poppedOutPanels); }</p>

<p>/**</p>
   <ul><li>Open a panel in a pop-out window</li>
</ul>   *
   <ul><li>@param panelId - Panel identifier</li>
</ul>   <ul><li>@param panelType - Panel type (e.g., 'statistics-panel-2')</li>
</ul>   <ul><li>@param features - Optional window features</li>
</ul>   <ul><li>@returns True if opened successfully, false if blocked or already open</li>
</ul>   */
<p>openPopOut( panelId: string, panelType: string, features?: Partial&lt;PopOutWindowFeatures&gt; ): boolean { // Don't open if already popped out if (this.poppedOutPanels.has(panelId)) { console.log(<code class="inline">[PopOutManager] Panel ${panelId} already popped out</code>); return false; }</p>

<p>// Construct URL: /popout/:gridId/:panelId/:panelType const url = <code class="inline">/popout/${this.gridId}/${panelId}/${panelType}</code>;</p>

<p>// Build window features string const windowFeatures = buildWindowFeatures({ width: 1200, height: 800, left: 100, top: 100, resizable: true, scrollbars: true, ...features });</p>

<p>// Open the window const popoutWindow = window.open(url, <code class="inline">panel-${panelId}</code>, windowFeatures);</p>

<p>// Handle blocked popup if (!popoutWindow) { console.warn(<code class="inline">[PopOutManager] Pop-up blocked for panel ${panelId}</code>); this.blockedSubject.next(panelId); return false; }</p>

<p>// Track the pop-out this.poppedOutPanels.add(panelId);</p>

<p>// Create channel for this panel const channel = this.popOutContext.createChannelForPanel(panelId);</p>

<p>// Listen for messages from this panel channel.onmessage = event =&gt; { this.ngZone.run(() =&gt; { this.messagesSubject.next({ panelId, message: event.data }); }); };</p>

<p>// Poll to detect when window closes const checkInterval = window.setInterval(() =&gt; { if (popoutWindow.closed) { this.ngZone.run(() =&gt; { this.handlePopOutClosed(panelId, channel, checkInterval); }); } }, 500);</p>

<p>// Store reference this.popoutWindows.set(panelId, { window: popoutWindow, channel, checkInterval, panelId, panelType });</p>

<p>console.log(<code class="inline">[PopOutManager] Opened pop-out for panel ${panelId}</code>); return true; }</p>

<p>/**</p>
   <ul><li>Broadcast state to all pop-out windows</li>
</ul>   *
   <ul><li>Call this whenever state changes in the main window.</li>
</ul>   *
   <ul><li>@param state - Application state from ResourceManagementService</li>
</ul>   <ul><li>@param filterOptionsCache - Optional cached filter options</li>
</ul>   */
<p>broadcastState(state: any, filterOptionsCache?: any): void { if (this.popoutWindows.size === 0) { return; // No pop-outs to broadcast to }</p>

<p>const message: PopOutMessage = { type: PopOutMessageType.STATE_UPDATE, payload: { state, filterOptionsCache: filterOptionsCache || null }, timestamp: Date.now() };</p>

<p>// Send to all pop-out channels this.popoutWindows.forEach(({ channel }) =&gt; { try { channel.postMessage(message); } catch { // Silently ignore posting errors (channel may be closed) } }); }</p>

<p>/**</p>
   <ul><li>Close a specific pop-out window</li>
</ul>   *
   <ul><li>@param panelId - Panel identifier</li>
</ul>   */
<p>closePopOut(panelId: string): void { const ref = this.popoutWindows.get(panelId); if (ref) { // Send close message ref.channel.postMessage({ type: PopOutMessageType.CLOSE_POPOUT, timestamp: Date.now() }); } }</p>

<p>/**</p>
   <ul><li>Close all pop-out windows</li>
</ul>   *
   <ul><li>Called when main window is closing.</li>
</ul>   */
<p>closeAllPopOuts(): void { this.popoutWindows.forEach(({ channel }) =&gt; { channel.postMessage({ type: PopOutMessageType.CLOSE_POPOUT, timestamp: Date.now() }); }); }</p>

<p>/**</p>
   <ul><li>Handle pop-out window closed</li>
</ul>   *
   <ul><li>@param panelId - Panel that closed</li>
</ul>   <ul><li>@param channel - BroadcastChannel to close</li>
</ul>   <ul><li>@param checkInterval - Interval to clear</li>
</ul>   */
<p>private handlePopOutClosed( panelId: string, channel: BroadcastChannel, checkInterval: number ): void { // Clear polling interval clearInterval(checkInterval);</p>

<p>// Close channel channel.close();</p>

<p>// Remove from tracking this.popoutWindows.delete(panelId); this.poppedOutPanels.delete(panelId);</p>

<p>// Emit closed event this.closedSubject.next(panelId);</p>

<p>console.log(<code class="inline">[PopOutManager] Pop-out ${panelId} closed</code>); }</p>

<p>/**</p>
   <ul><li>Cleanup on service destroy</li>
</ul>   */
<p>ngOnDestroy(): void { // Remove beforeunload listener window.removeEventListener('beforeunload', this.beforeUnloadHandler);</p>

<p>// Close all pop-outs and cleanup this.popoutWindows.forEach(({ window: win, channel, checkInterval }) =&gt; { clearInterval(checkInterval); channel.close(); if (win &amp;&amp; !win.closed) { win.close(); } });</p>

<p>// Complete subjects this.messagesSubject.complete(); this.closedSubject.complete(); this.blockedSubject.complete(); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 308.2: Update Popout Interface</h3>

<p>Ensure <code class="inline">src/app/framework/models/popout.interface.ts</code> includes necessary types:</p>

<pre class="code-block typescript"><code>// Add to src/app/framework/models/popout.interface.ts if not present
<p>// VERSION 2 (Section 308) - Added window reference types</p>

<p>/**</p>
 <ul><li>Pop-out window features configuration</li>
</ul> */
<p>export interface PopOutWindowFeatures { width: number; height: number; left: number; top: number; resizable: boolean; scrollbars: boolean; menubar?: boolean; toolbar?: boolean; location?: boolean; status?: boolean; }</p>

<p>/**</p>
 <ul><li>Reference to an open pop-out window</li>
</ul> */
<p>export interface PopOutWindowRef { /<em>* Window object </em>/ window: Window; /<em>* BroadcastChannel for communication </em>/ channel: BroadcastChannel; /<em>* Interval ID for close detection </em>/ checkInterval: number; /<em>* Panel identifier </em>/ panelId: string; /<em>* Panel type </em>/ panelType: string; }</p>

<p>/**</p>
 <ul><li>Build window.open() features string from options</li>
</ul> *
 <ul><li>@param features - Window features configuration</li>
</ul> <ul><li>@returns Features string for window.open()</li>
</ul> */
<p>export function buildWindowFeatures(features: PopOutWindowFeatures): string { const parts: string[] = [ <code class="inline">width=${features.width}</code>, <code class="inline">height=${features.height}</code>, <code class="inline">left=${features.left}</code>, <code class="inline">top=${features.top}</code>, <code class="inline">resizable=${features.resizable ? 'yes' : 'no'}</code>, <code class="inline">scrollbars=${features.scrollbars ? 'yes' : 'no'}</code> ];</p>

<p>if (features.menubar !== undefined) { parts.push(<code class="inline">menubar=${features.menubar ? 'yes' : 'no'}</code>); } if (features.toolbar !== undefined) { parts.push(<code class="inline">toolbar=${features.toolbar ? 'yes' : 'no'}</code>); } if (features.location !== undefined) { parts.push(<code class="inline">location=${features.location ? 'yes' : 'no'}</code>); } if (features.status !== undefined) { parts.push(<code class="inline">status=${features.status ? 'yes' : 'no'}</code>); }</p>

<p>return parts.join(','); }</p>
</code></pre>

<hr>

<h3>Step 308.3: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 7 (Section 308) - Added PopOutManagerService</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service'; export * from './popout-context.service'; export * from './popout-manager.service'; export * from './resource-management.service';</p>
</code></pre></div><div class="page-content"><hr>

<h2>Phase 3B Milestone: Pop-Out Demo</h2>

<p>After completing Section 308, demonstrate pop-out communication:</p>

<ul><li>Add temporary route for pop-out testing</li>
<p><li>Create a simple pop-out component</li> <li>Verify communication works</li></p>
</ul>
<pre class="code-block typescript"><code>// Temporary demo component in main window
<p>@Component({ selector: 'app-popout-demo', template: <code class="inline"> &lt;h2&gt;Pop-Out Demo&lt;/h2&gt; &lt;button (click)="openPopOut()"&gt;Open Pop-Out&lt;/button&gt; &lt;p&gt;Popped out: {{ isPoppedOut }}&lt;/p&gt; &lt;div *ngFor="let log of logs"&gt;{{ log }}&lt;/div&gt;</p>
  </code>,
<p>providers: [PopOutManagerService] }) export class PopOutDemoComponent implements OnInit { isPoppedOut = false; logs: string[] = [];</p>

<p>constructor(private popOutManager: PopOutManagerService) {}</p>

<p>ngOnInit(): void { this.popOutManager.initialize('demo-grid');</p>

<p>this.popOutManager.closed$.subscribe(panelId =&gt; { this.logs.push(<code class="inline">Panel ${panelId} closed</code>); this.isPoppedOut = false; }); }</p>

<p>openPopOut(): void { this.isPoppedOut = this.popOutManager.openPopOut('demo-panel', 'demo'); if (this.isPoppedOut) { this.logs.push('Pop-out opened'); } } }</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/popout-manager.service.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/popout-manager.service.ts
</code></pre>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Pop-up blocked</td> <td>Browser blocking window.open()</td> <td>User must allow pop-ups for site</td></p>
</tr>
<p><tr> <td><code class="inline">blocked$</code> emits</td> <td>window.open() returned null</td> <td>Check browser pop-up settings</td></p>
</tr>
<p><tr> <td>Messages not received</td> <td>Channel name mismatch</td> <td>Verify <code class="inline">panel-{panelId}</code> format</td></p>
</tr>
<p><tr> <td>Pop-out not detected as closed</td> <td>Polling interval issue</td> <td>Check checkInterval is set</td></p>
</tr>
<p><tr> <td>State not updating in pop-out</td> <td>broadcastState not called</td> <td>Subscribe to state$ and broadcast</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Pop-outs are core functionality</strong> — Users need multi-monitor workflows</li>
<p><li><strong>BroadcastChannel simplifies messaging</strong> — No window reference management</li> <li><strong>Polling detects window close</strong> — No direct event available</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/popout-manager.service.ts</code> exists</li>
<p><li>[ ] Service is component-level <code class="inline">@Injectable()</code> (not singleton)</li> <li>[ ] <code class="inline">initialize()</code> sets up grid ID and event listeners</li> <li>[ ] <code class="inline">openPopOut()</code> opens window with correct URL pattern</li> <li>[ ] <code class="inline">isPoppedOut()</code> tracks open panels</li> <li>[ ] <code class="inline">broadcastState()</code> sends state to all pop-outs</li> <li>[ ] <code class="inline">closePopOut()</code> and <code class="inline">closeAllPopOuts()</code> work</li> <li>[ ] Pop-out close detection via polling works</li> <li>[ ] <code class="inline">closed$</code> emits when pop-outs close</li> <li>[ ] <code class="inline">blocked$</code> emits when pop-ups are blocked</li> <li>[ ] beforeunload handler closes all pop-outs</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>The Aha Moment</h2>

<p><strong>Pop-out windows share state with the parent through a coordination service.</strong></p>

<p>The main window fetches data. Pop-outs receive state through BroadcastChannel. This ensures:</p>
<ul><li>No duplicate API calls</li>
<p><li>Consistent state across windows</li> <li>Clean separation of concerns</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">309-user-preferences-service.md</code> to create the service for persisting user preferences.</p></div></div>
    <div class="chapter" id="section-309">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>309: User Preferences Service</h1>
        </div>
<div class="page-content"><h1>309: User Preferences Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> None (standalone) <strong>Blocks:</strong> Phase 8 (Framework Components - for panel ordering)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand localStorage patterns for persistent state</li>
<p><li>Know how to handle storage failures gracefully</li> <li>Recognize domain-aware key namespacing patterns</li> <li>Be able to implement a preferences service with reactive state</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">UserPreferencesService</code> that persists user preferences (panel order, collapsed state) using localStorage with domain-aware namespacing and graceful degradation.</p>

<hr>

<h2>Why</h2>

<p>Users customize their experience:</p>
<ul><li>Drag panels to reorder them</li>
<p><li>Collapse panels they don't use often</li> <li>Their preferences should persist across sessions</li></p>
</ul>
<h3>Storage Options</h3>

<table>
<p><thead><tr> <th>Option</th> <th>Persistence</th> <th>Sharing</th> <th>Complexity</th></p>
</tr></thead>
<p><tbody> <tr> <td>Component state</td> <td>None</td> <td>None</td> <td>Low</td></p>
</tr>
<p><tr> <td>Service state</td> <td>Session only</td> <td>Same tab</td> <td>Low</td></p>
</tr>
<p><tr> <td>localStorage</td> <td>Permanent</td> <td>Same origin</td> <td>Medium</td></p>
</tr>
<p><tr> <td>Backend API</td> <td>Permanent</td> <td>All devices</td> <td>High</td></p>
</tr>
</tbody>
</table>

<p>We use <strong>localStorage</strong> because:</p>
<ul><li>Works offline</li>
<p><li>No backend required</li> <li>Suitable for UI preferences</li> <li>Falls back gracefully in private browsing</li></p>
</ul>
<h3>Domain-Aware Namespacing</h3>

<p>Vvroom supports multiple domains (automobile, agriculture, etc.). Each domain may have different panels and preferences. Keys are namespaced:</p>

<pre class="code-block text"><code>prefs:automobile:panelOrder → ['stats-1', 'chart-1', 'query-control']
<p>prefs:automobile:collapsedPanels → ['chart-1'] prefs:agriculture:panelOrder → ['crop-stats', 'yield-chart']</p>
</code></pre>

<h3>Graceful Degradation</h3>

<p>localStorage can fail:</p>
<ul><li>Private browsing mode</li>
<p><li>Storage quota exceeded</li> <li>SecurityError in iframes</li></p>
</ul>
<p>The service:</p>
<ul><li>Checks storage availability on init</li>
<p><li>Uses in-memory fallback if unavailable</li> <li>Logs warnings in dev mode</li> <li>Never crashes the app</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 309.1: Create the User Preferences Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/user-preferences.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/user-preferences.service.ts
<p>// VERSION 1 (Section 309) - User preferences with localStorage</p>

<p>import { Injectable, isDevMode } from '@angular/core'; import { BehaviorSubject, Observable } from 'rxjs';</p>

<p>/**</p>
 <ul><li>User preferences service</li>
</ul> *
 <ul><li>Persists user preferences using localStorage with domain-aware namespacing.</li>
</ul> <ul><li>Handles storage failures gracefully with in-memory fallback.</li>
</ul> *
 <ul><li><strong>Features:</strong></li>
</ul> *
 <ul><li>1. <strong>Domain namespacing</strong> — Each domain has its own preferences</li>
</ul> <ul><li>2. <strong>Reactive state</strong> — BehaviorSubjects for real-time updates</li>
</ul> <ul><li>3. <strong>Graceful degradation</strong> — Works even if localStorage unavailable</li>
</ul> <ul><li>4. <strong>Panel merge logic</strong> — New panels inserted at correct positions</li>
</ul> *
 <ul><li><strong>Storage Keys:</strong></li>
</ul> *
 <ul><li></code></pre></li>
</ul> <ul><li>prefs:{domain}:panelOrder → ['panel-1', 'panel-2', ...]</li>
</ul> <ul><li>prefs:{domain}:collapsedPanels → ['panel-1']</li>
</ul> <em> <pre class="code-block text"><code> </em>
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In component</li>
</ul> <ul><li>constructor(private prefs: UserPreferencesService) {</li>
</ul> <ul><li>  // Subscribe to panel order changes</li>
</ul> <ul><li>  this.prefs.getPanelOrder().subscribe(order =&gt; {</li>
</ul> <ul><li>    this.panelOrder = order;</li>
</ul> <ul><li>  });</li>
</ul> *
 <ul><li>  // Save new order after drag-drop</li>
</ul> <ul><li>  this.prefs.savePanelOrder(['panel-2', 'panel-1', 'panel-3']);</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class UserPreferencesService { /**</p>
   <ul><li>Default panel order when no preferences saved</li>
</ul>   */
<p>private readonly DEFAULT_PANEL_ORDER = [ 'query-control', 'statistics-panel-2', 'results-table' ];</p>

<p>/**</p>
   <ul><li>Default collapsed panels (none)</li>
</ul>   */
<p>private readonly DEFAULT_COLLAPSED_PANELS: string[] = [];</p>

<p>/**</p>
   <ul><li>Current domain extracted from URL</li>
</ul>   */
<p>private currentDomain = this.extractCurrentDomain();</p>

<p>/**</p>
   <ul><li>BehaviorSubject for panel order</li>
</ul>   */
<p>private panelOrderSubject = new BehaviorSubject&lt;string[]&gt;( this.loadPanelOrder() );</p>

<p>/**</p>
   <ul><li>BehaviorSubject for collapsed panels</li>
</ul>   */
<p>private collapsedPanelsSubject = new BehaviorSubject&lt;string[]&gt;( this.loadCollapsedPanels() );</p>

<p>/**</p>
   <ul><li>Storage availability flag</li>
</ul>   */
<p>private storageAvailable = this.checkStorageAvailable();</p>

<p>/**</p>
   <ul><li>Get panel order as observable</li>
</ul>   *
   <ul><li>Emits current order immediately, then on every change.</li>
</ul>   *
   <ul><li>@returns Observable of panel order array</li>
</ul>   */
<p>getPanelOrder(): Observable&lt;string[]&gt; { return this.panelOrderSubject.asObservable(); }</p>

<p>/**</p>
   <ul><li>Get collapsed panels as observable</li>
</ul>   *
   <ul><li>@returns Observable of collapsed panel IDs</li>
</ul>   */
<p>getCollapsedPanels(): Observable&lt;string[]&gt; { return this.collapsedPanelsSubject.asObservable(); }</p>

<p>/**</p>
   <ul><li>Get current panel order synchronously</li>
</ul>   *
   <ul><li>@returns Current panel order array</li>
</ul>   */
<p>getCurrentPanelOrder(): string[] { return this.panelOrderSubject.value; }</p>

<p>/**</p>
   <ul><li>Get current collapsed panels synchronously</li>
</ul>   *
   <ul><li>@returns Current collapsed panel IDs</li>
</ul>   */
<p>getCurrentCollapsedPanels(): string[] { return this.collapsedPanelsSubject.value; }</p>

<p>/**</p>
   <ul><li>Save panel order</li>
</ul>   *
   <ul><li>Updates BehaviorSubject and persists to localStorage.</li>
</ul>   *
   <ul><li>@param order - New panel order array</li>
</ul>   */
<p>savePanelOrder(order: string[]): void { this.panelOrderSubject.next(order); this.saveToStorage('panelOrder', order); }</p>

<p>/**</p>
   <ul><li>Save collapsed panels</li>
</ul>   *
   <ul><li>@param panels - Array of collapsed panel IDs</li>
</ul>   */
<p>saveCollapsedPanels(panels: string[]): void { this.collapsedPanelsSubject.next(panels); this.saveToStorage('collapsedPanels', panels); }</p>

<p>/**</p>
   <ul><li>Toggle panel collapsed state</li>
</ul>   *
   <ul><li>@param panelId - Panel to toggle</li>
</ul>   <ul><li>@returns New collapsed state</li>
</ul>   */
<p>togglePanelCollapsed(panelId: string): boolean { const current = this.collapsedPanelsSubject.value; let newCollapsed: string[]; let isCollapsed: boolean;</p>

<p>if (current.includes(panelId)) { newCollapsed = current.filter(id =&gt; id !== panelId); isCollapsed = false; } else { newCollapsed = [...current, panelId]; isCollapsed = true; }</p>

<p>this.saveCollapsedPanels(newCollapsed); return isCollapsed; }</p>

<p>/**</p>
   <ul><li>Check if panel is collapsed</li>
</ul>   *
   <ul><li>@param panelId - Panel to check</li>
</ul>   <ul><li>@returns True if collapsed</li>
</ul>   */
<p>isPanelCollapsed(panelId: string): boolean { return this.collapsedPanelsSubject.value.includes(panelId); }</p>

<p>/**</p>
   <ul><li>Reset preferences for current domain</li>
</ul>   *
   <ul><li>@param domain - Optional domain (defaults to current)</li>
</ul>   */
<p>reset(domain?: string): void { const targetDomain = domain || this.currentDomain;</p>

<p>if (this.storageAvailable) { try { localStorage.removeItem(this.getKey('panelOrder', targetDomain)); localStorage.removeItem(this.getKey('collapsedPanels', targetDomain)); } catch (e) { // Ignore errors on reset } }</p>

<p>this.panelOrderSubject.next(this.DEFAULT_PANEL_ORDER); this.collapsedPanelsSubject.next(this.DEFAULT_COLLAPSED_PANELS); }</p>

<p>/**</p>
   <ul><li>Switch to a different domain</li>
</ul>   *
   <ul><li>Loads preferences for the new domain.</li>
</ul>   *
   <ul><li>@param domain - Domain to switch to</li>
</ul>   */
<p>switchDomain(domain: string): void { this.currentDomain = domain; this.panelOrderSubject.next(this.loadPanelOrder()); this.collapsedPanelsSubject.next(this.loadCollapsedPanels()); }</p>

<p>/**</p>
   <ul><li>Get current domain</li>
</ul>   *
   <ul><li>@returns Current domain name</li>
</ul>   */
<p>getCurrentDomain(): string { return this.currentDomain; }</p>

<p>// ============================================================================ // Private Methods // ============================================================================</p>

<p>/**</p>
   <ul><li>Load panel order from localStorage</li>
</ul>   */
<p>private loadPanelOrder(): string[] { if (!this.storageAvailable) { return this.DEFAULT_PANEL_ORDER; }</p>

<p>try { const key = this.getKey('panelOrder'); const stored = localStorage.getItem(key);</p>

<p>if (stored) { const parsed = JSON.parse(stored); if (Array.isArray(parsed)) { // Merge with defaults to include new panels return this.mergePanelOrder(parsed, this.DEFAULT_PANEL_ORDER); } } } catch (e) { this.logError('loadPanelOrder', e); }</p>

<p>return this.DEFAULT_PANEL_ORDER; }</p>

<p>/**</p>
   <ul><li>Load collapsed panels from localStorage</li>
</ul>   */
<p>private loadCollapsedPanels(): string[] { if (!this.storageAvailable) { return this.DEFAULT_COLLAPSED_PANELS; }</p>

<p>try { const key = this.getKey('collapsedPanels'); const stored = localStorage.getItem(key);</p>

<p>if (stored) { const parsed = JSON.parse(stored); if (Array.isArray(parsed)) { return parsed; } } } catch (e) { this.logError('loadCollapsedPanels', e); }</p>

<p>return this.DEFAULT_COLLAPSED_PANELS; }</p>

<p>/**</p>
   <ul><li>Merge stored order with defaults</li>
</ul>   *
   <ul><li>- Removes panels no longer in defaults</li>
</ul>   <ul><li>- Inserts new panels at their default relative position</li>
</ul>   *
   <ul><li>@param stored - User's stored order</li>
</ul>   <ul><li>@param defaults - Default order (source of truth for valid panels)</li>
</ul>   <ul><li>@returns Merged order</li>
</ul>   */
<p>private mergePanelOrder(stored: string[], defaults: string[]): string[] { const defaultsSet = new Set(defaults);</p>

<p>// Filter out panels that no longer exist const result = stored.filter(id =&gt; defaultsSet.has(id)); const resultSet = new Set(result);</p>

<p>// Insert new panels at their relative position for (let i = 0; i &lt; defaults.length; i++) { const panelId = defaults[i]; if (!resultSet.has(panelId)) { // Find insertion point based on previous panel in defaults let insertIndex = result.length;</p>

<p>for (let j = i - 1; j &gt;= 0; j--) { const prevPanel = defaults[j]; const prevIndex = result.indexOf(prevPanel); if (prevIndex !== -1) { insertIndex = prevIndex + 1; break; } }</p>

<p>result.splice(insertIndex, 0, panelId); resultSet.add(panelId); } }</p>

<p>return result; }</p>

<p>/**</p>
   <ul><li>Save to localStorage</li>
</ul>   */
<p>private saveToStorage(preference: string, value: any): void { if (!this.storageAvailable) { return; }</p>

<p>try { const key = this.getKey(preference); localStorage.setItem(key, JSON.stringify(value)); } catch (e) { this.handleStorageError(e); } }</p>

<p>/**</p>
   <ul><li>Get storage key with domain prefix</li>
</ul>   */
<p>private getKey(preference: string, domain?: string): string { const targetDomain = domain || this.currentDomain; return <code class="inline">prefs:${targetDomain}:${preference}</code>; }</p>

<p>/**</p>
   <ul><li>Check if localStorage is available</li>
</ul>   */
<p>private checkStorageAvailable(): boolean { try { const test = '__localStorage_test__'; localStorage.setItem(test, 'test'); localStorage.removeItem(test); return true; } catch (e) { return false; } }</p>

<p>/**</p>
   <ul><li>Handle storage errors</li>
</ul>   */
<p>private handleStorageError(error: any): void { this.storageAvailable = false; this.logError('storage', error); }</p>

<p>/**</p>
   <ul><li>Log error in dev mode only</li>
</ul>   */
<p>private logError(context: string, error: any): void { if (isDevMode()) { console.debug(<code class="inline">[UserPreferencesService] ${context} error:</code>, error); } }</p>

<p>/**</p>
   <ul><li>Extract current domain from URL</li>
</ul>   */
<p>private extractCurrentDomain(): string { const path = window.location.pathname; const match = path.match(/^\/([a-z-]+)/);</p>

<p>if (match &amp;&amp; match[1] &amp;&amp; match[1] !== 'popout') { return match[1]; }</p>

<p>return 'automobile'; // Default domain } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 309.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 8 (Section 309) - Added UserPreferencesService</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service'; export * from './popout-context.service'; export * from './popout-manager.service'; export * from './user-preferences.service'; export * from './resource-management.service';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/user-preferences.service.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/user-preferences.service.ts
</code></pre>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<h3>4. Verify Storage (Optional)</h3>

<pre class="code-block typescript"><code>// In any component
<p>constructor(private prefs: UserPreferencesService) { // Save order this.prefs.savePanelOrder(['panel-b', 'panel-a', 'panel-c']);</p>

<p>// Check localStorage in DevTools // Key: prefs:automobile:panelOrder // Value: ["panel-b","panel-a","panel-c"]</p>

<p>// Subscribe to changes this.prefs.getPanelOrder().subscribe(order =&gt; { console.log('Current order:', order); }); }</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Preferences not persisting</td> <td>localStorage unavailable</td> <td>Check private browsing mode</td></p>
</tr>
<p><tr> <td>Wrong domain detected</td> <td>URL pattern mismatch</td> <td>Check extractCurrentDomain() logic</td></p>
</tr>
<p><tr> <td>New panels missing</td> <td>Not in DEFAULT_PANEL_ORDER</td> <td>Update defaults when adding panels</td></p>
</tr>
<p><tr> <td>Quota exceeded</td> <td>Too much data</td> <td>Clear old preferences or reduce data</td></p>
</tr>
<p><tr> <td>JSON parse error</td> <td>Corrupted data</td> <td>Service handles with try/catch</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Graceful degradation is essential</strong> — App works even if storage fails</li>
<p><li><strong>Domain namespacing enables multi-domain support</strong> — Preferences don't conflict</li> <li><strong>Panel merge logic handles updates</strong> — New panels appear at correct positions</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/user-preferences.service.ts</code> exists</li>
<p><li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li>[ ] <code class="inline">getPanelOrder()</code> returns observable</li> <li>[ ] <code class="inline">getCollapsedPanels()</code> returns observable</li> <li>[ ] <code class="inline">savePanelOrder()</code> persists to localStorage</li> <li>[ ] <code class="inline">saveCollapsedPanels()</code> persists to localStorage</li> <li>[ ] <code class="inline">togglePanelCollapsed()</code> toggles and saves</li> <li>[ ] <code class="inline">reset()</code> clears preferences</li> <li>[ ] <code class="inline">switchDomain()</code> loads different domain's preferences</li> <li>[ ] Domain-aware key namespacing works</li> <li>[ ] Graceful degradation when localStorage unavailable</li> <li>[ ] Panel merge logic handles new/removed panels</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">310-filter-options-service.md</code> to create the service for caching filter dropdown options.</p></div></div>
    <div class="chapter" id="section-310">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>310: Filter Options Service</h1>
        </div>
<div class="page-content"><h1>310: Filter Options Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 302-api-service, 304-domain-config-registry <strong>Blocks:</strong> Phase 8 (Framework Components - for filter dropdowns)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand why filter options caching matters for pop-outs</li>
<p><li>Know how to implement a cache-first data loading pattern</li> <li>Recognize the transformer pattern for API response adaptation</li> <li>Be able to implement a service that supports cross-window option sharing</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">FilterOptionsService</code> that caches filter dropdown options and supports cross-window sharing for pop-out windows.</p>

<hr>

<h2>Why</h2>

<p>Filter dropdowns (manufacturer, body class, year) need options from the API. Without caching:</p>

<ul><li><strong>Duplicate requests</strong> — Each dropdown fetches options independently</li>
<p><li><strong>Pop-out overhead</strong> — Pop-out windows make their own API calls</li> <li><strong>Slow UX</strong> — Users wait for options to load</li></p>
</ul>
<h3>The Pop-Out Challenge</h3>

<p>Pop-out windows should NOT make API calls. They receive state from the main window. But what about filter options?</p>

<pre class="code-block text"><code>Main Window                     Pop-out Window
<p>│                                │ ├── Load manufacturer options    │ │   (API call)                   │ │                                │ ├── Load body class options      │ │   (API call)                   │ │                                │ ├── Open pop-out                 │ │   │                            │ │   └── Broadcast state ────────►│ │       (includes filter cache)  │ │                                │ │                                ├── FilterOptionsService │                                │   syncFromExternal() │                                │ │                                └── Options available │                                    (no API calls!)</p>
</code></pre>

<h3>Cache Structure</h3>

<pre class="code-block typescript"><code>{
<p>'http://api/manufacturers': { field: 'manufacturer', endpoint: 'http://api/manufacturers', options: [{ value: 'Ford', label: 'Ford' }, ...], rawResponse: { data: [...] }, cachedAt: 1707500000000 }, 'http://api/body-classes': { field: 'bodyClass', endpoint: 'http://api/body-classes', options: [{ value: 'Sedan', label: 'Sedan' }, ...], rawResponse: { data: [...] }, cachedAt: 1707500001000 } }</p>
</code></pre></div><div class="page-content"><h3>Transformer Pattern</h3>

<p>Different APIs return options in different formats. The service accepts a transformer function:</p>

<pre class="code-block typescript"><code>// API returns: { data: [{ id: 1, name: 'Ford' }, ...] }
<p>// We need: [{ value: 1, label: 'Ford' }, ...]</p>

<p>filterOptions.getOptions( 'http://api/manufacturers', 'manufacturer', (response) =&gt; response.data.map(item =&gt; ({ value: item.id, label: item.name })) );</p>
</code></pre>

<hr>

<h2>What</h2>

<h3>Step 310.1: Create the Filter Options Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/filter-options.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/filter-options.service.ts
<p>// VERSION 1 (Section 310) - Filter options caching</p>

<p>import { Injectable } from '@angular/core'; import { BehaviorSubject, Observable, of } from 'rxjs'; import { tap, catchError, map } from 'rxjs/operators'; import { ApiService } from './api.service';</p>

<p>/**</p>
 <ul><li>Filter option for dropdowns</li>
</ul> */
<p>export interface FilterOption { /<em>* Option value (sent to API) </em>/ value: any; /<em>* Display label </em>/ label: string; /<em>* Optional icon </em>/ icon?: string; /<em>* Disabled state </em>/ disabled?: boolean; }</p>

<p>/**</p>
 <ul><li>Cached options for a single filter</li>
</ul> */
<p>export interface CachedFilterOptions { /<em>* Filter field identifier </em>/ field: string; /<em>* API endpoint used </em>/ endpoint: string; /<em>* Transformed options </em>/ options: FilterOption[]; /<em>* Raw API response (for custom transformers) </em>/ rawResponse?: any; /<em>* Cache timestamp </em>/ cachedAt: number; }</p>

<p>/**</p>
 <ul><li>Complete filter options cache</li>
</ul> */
<p>export interface FilterOptionsCache { [endpoint: string]: CachedFilterOptions; }</p>

<p>/**</p>
 <ul><li>Filter options service</li>
</ul> *
 <ul><li>Caches filter dropdown options and supports cross-window sharing.</li>
</ul> *
 <ul><li><strong>Key Features:</strong></li>
</ul> *
 <ul><li>1. <strong>Cache-first loading</strong> — Returns cached options if available</li>
</ul> <ul><li>2. <strong>Transformer support</strong> — Adapts API responses to FilterOption[]</li>
</ul> <ul><li>3. <strong>Pop-out support</strong> — syncFromExternal() receives cache from main window</li>
</ul> <ul><li>4. <strong>Reactive cache</strong> — Observable of cache changes</li>
</ul> *
 <ul><li><strong>Usage Pattern:</strong></li>
</ul> *
 <ul><li>1. Main window loads options (API call + cache)</li>
</ul> <ul><li>2. Main window broadcasts state (includes filterOptionsCache)</li>
</ul> <ul><li>3. Pop-out receives state</li>
</ul> <ul><li>4. Pop-out calls syncFromExternal(cache)</li>
</ul> <ul><li>5. Pop-out has options without API calls</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Load with transformer</li>
</ul> <ul><li>this.filterOptions.getOptions(</li>
</ul> <ul><li>  'http://api/manufacturers',</li>
</ul> <ul><li>  'manufacturer',</li>
</ul> <ul><li>  response =&gt; response.data.map(m =&gt; ({ value: m.id, label: m.name }))</li>
</ul> <ul><li>).subscribe(options =&gt; {</li>
</ul> <ul><li>  this.manufacturerOptions = options;</li>
</ul> <ul><li>});</li>
</ul> *
 <ul><li>// In pop-out, sync from main window</li>
</ul> <ul><li>this.filterOptions.syncFromExternal(message.payload.filterOptionsCache);</li>
</ul> *
 <ul><li>// Check if cached</li>
</ul> <ul><li>if (this.filterOptions.isCached('http://api/manufacturers')) {</li>
</ul> <ul><li>  // Use cached value</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class FilterOptionsService { /**</p>
   <ul><li>Cache storage</li>
</ul>   */
<p>private cache: FilterOptionsCache = {};</p>

<p>/**</p>
   <ul><li>Observable of cache state</li>
</ul>   */
<p>private cache$ = new BehaviorSubject&lt;FilterOptionsCache&gt;({});</p>

<p>/**</p>
   <ul><li>Constructor</li>
</ul>   *
   <ul><li>@param apiService - API service for fetching options</li>
</ul>   */
<p>constructor(private apiService: ApiService) {}</p>

<p>/**</p>
   <ul><li>Get current cache for state broadcast</li>
</ul>   *
   <ul><li>@returns Copy of current cache</li>
</ul>   */
<p>getCache(): FilterOptionsCache { return { ...this.cache }; }</p>

<p>/**</p>
   <ul><li>Get observable of cache changes</li>
</ul>   *
   <ul><li>@returns Observable of cache state</li>
</ul>   */
<p>getCache$(): Observable&lt;FilterOptionsCache&gt; { return this.cache$.asObservable(); }</p>

<p>/**</p>
   <ul><li>Get options (from cache or API)</li>
</ul>   *
   <ul><li>@param endpoint - API endpoint URL</li>
</ul>   <ul><li>@param field - Filter field identifier</li>
</ul>   <ul><li>@param transformer - Optional function to transform API response</li>
</ul>   <ul><li>@returns Observable of filter options</li>
</ul>   */
<p>getOptions( endpoint: string, field: string, transformer?: (response: any) =&gt; FilterOption[] ): Observable&lt;FilterOption[]&gt; { // Check cache first const cached = this.cache[endpoint]; if (cached) { // If transformer provided and we have raw response, re-transform if (transformer &amp;&amp; cached.rawResponse) { return of(transformer(cached.rawResponse)); } return of(cached.options); }</p>

<p>// Fetch from API return this.apiService.get(endpoint).pipe( tap(response =&gt; { const options = transformer ? transformer(response) : []; this.cache[endpoint] = { field, endpoint, options, rawResponse: response, cachedAt: Date.now() }; this.cache$.next({ ...this.cache }); }), map(response =&gt; transformer ? transformer(response) : []), catchError(error =&gt; { console.error(<code class="inline">[FilterOptionsService] Failed to load from ${endpoint}:</code>, error); throw error; }) ); }</p>

<p>/**</p>
   <ul><li>Get raw API response from cache</li>
</ul>   *
   <ul><li>Used for filters that need the full response (e.g., range filters).</li>
</ul>   *
   <ul><li>@param endpoint - API endpoint URL</li>
</ul>   <ul><li>@returns Cached raw response or null</li>
</ul>   */
<p>getRawResponse(endpoint: string): any | null { return this.cache[endpoint]?.rawResponse ?? null; }</p>

<p>/**</p>
   <ul><li>Get raw response asynchronously (from cache or API)</li>
</ul>   *
   <ul><li>@param endpoint - API endpoint URL</li>
</ul>   <ul><li>@param field - Filter field identifier</li>
</ul>   <ul><li>@returns Observable of raw API response</li>
</ul>   */
<p>getRawResponseAsync(endpoint: string, field: string): Observable&lt;any&gt; { // Check cache first const cached = this.cache[endpoint]; if (cached?.rawResponse) { return of(cached.rawResponse); }</p>

<p>// Fetch from API return this.apiService.get(endpoint).pipe( tap(response =&gt; { this.cache[endpoint] = { field, endpoint, options: [], rawResponse: response, cachedAt: Date.now() }; this.cache$.next({ ...this.cache }); }), catchError(error =&gt; { console.error(<code class="inline">[FilterOptionsService] Failed to load from ${endpoint}:</code>, error); throw error; }) ); }</p>

<p>/**</p>
   <ul><li>Sync cache from external source</li>
</ul>   *
   <ul><li>Used by pop-out windows to receive cache from main window.</li>
</ul>   *
   <ul><li>@param externalCache - Cache from main window</li>
</ul>   */
<p>syncFromExternal(externalCache: FilterOptionsCache): void { if (!externalCache) { return; }</p>

<p>// Merge external cache into local cache this.cache = { ...this.cache, ...externalCache }; this.cache$.next({ ...this.cache }); }</p>

<p>/**</p>
   <ul><li>Check if options are cached</li>
</ul>   *
   <ul><li>@param endpoint - API endpoint URL</li>
</ul>   <ul><li>@returns True if cached</li>
</ul>   */
<p>isCached(endpoint: string): boolean { return !!this.cache[endpoint]; }</p>

<p>/**</p>
   <ul><li>Get cached options synchronously</li>
</ul>   *
   <ul><li>@param endpoint - API endpoint URL</li>
</ul>   <ul><li>@returns Cached options or null</li>
</ul>   */
<p>getCachedOptions(endpoint: string): FilterOption[] | null { return this.cache[endpoint]?.options ?? null; }</p>

<p>/**</p>
   <ul><li>Invalidate specific cache entry</li>
</ul>   *
   <ul><li>@param endpoint - API endpoint URL</li>
</ul>   */
<p>invalidate(endpoint: string): void { delete this.cache[endpoint]; this.cache$.next({ ...this.cache }); }</p>

<p>/**</p>
   <ul><li>Clear entire cache</li>
</ul>   */
<p>clearCache(): void { this.cache = {}; this.cache$.next({}); }</p>

<p>/**</p>
   <ul><li>Preload options for multiple endpoints</li>
</ul>   *
   <ul><li>Useful for initializing filters on page load.</li>
</ul>   *
   <ul><li>@param endpoints - Array of { endpoint, field, transformer }</li>
</ul>   <ul><li>@returns Observable that completes when all loaded</li>
</ul>   */
<p>preload( endpoints: Array&lt;{ endpoint: string; field: string; transformer?: (response: any) =&gt; FilterOption[]; }&gt; ): Observable&lt;void&gt; { const requests = endpoints.map(({ endpoint, field, transformer }) =&gt; this.getOptions(endpoint, field, transformer) );</p>

<p>return new Observable(observer =&gt; { let completed = 0; const total = requests.length;</p>

<p>if (total === 0) { observer.next(); observer.complete(); return; }</p>

<p>requests.forEach(request =&gt; { request.subscribe({ next: () =&gt; { completed++; if (completed === total) { observer.next(); observer.complete(); } }, error: err =&gt; { completed++; console.warn('[FilterOptionsService] Preload error:', err); if (completed === total) { observer.next(); observer.complete(); } } }); }); }); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 310.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 9 (Section 310) - Added FilterOptionsService</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service'; export * from './popout-context.service'; export * from './popout-manager.service'; export * from './user-preferences.service'; export * from './filter-options.service'; export * from './resource-management.service';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/filter-options.service.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/filter-options.service.ts
</code></pre>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<h3>4. Verify Caching (Optional)</h3>

<pre class="code-block typescript"><code>// In any component
<p>constructor(private filterOptions: FilterOptionsService) { // First call - API request this.filterOptions.getOptions( 'http://example.com/api/options', 'testField', (res: any) =&gt; res.data.map((d: any) =&gt; ({ value: d.id, label: d.name })) ).subscribe(options =&gt; { console.log('First call:', options); });</p>

<p>// Second call (1s later) - from cache setTimeout(() =&gt; { this.filterOptions.getOptions( 'http://example.com/api/options', 'testField' ).subscribe(options =&gt; { console.log('Second call (cached):', options); }); }, 1000); }</p>
</code></pre>

<p>Network tab should show only 1 request.</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Options not cached</td> <td>Different endpoint URLs</td> <td>Ensure exact same URL string</td></p>
</tr>
<p><tr> <td>Transformer not applied</td> <td>Raw response missing</td> <td>Check API returns data</td></p>
</tr>
<p><tr> <td>Pop-out missing options</td> <td>syncFromExternal not called</td> <td>Call after receiving state</td></p>
</tr>
<p><tr> <td>Cache stale</td> <td>No invalidation</td> <td>Call invalidate() when needed</td></p>
</tr>
<p><tr> <td>Type errors</td> <td>Transformer return type</td> <td>Ensure returns FilterOption[]</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Cache-first prevents duplicate requests</strong> — Options loaded once, reused everywhere</li>
<p><li><strong>Transformers adapt API responses</strong> — Decouple option format from API format</li> <li><strong>External sync enables pop-outs</strong> — No API calls in pop-out windows</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/filter-options.service.ts</code> exists</li>
<p><li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li>[ ] <code class="inline">getOptions()</code> returns from cache or fetches from API</li> <li>[ ] <code class="inline">getCache()</code> returns current cache for broadcasting</li> <li>[ ] <code class="inline">syncFromExternal()</code> merges external cache</li> <li>[ ] <code class="inline">isCached()</code> checks cache presence</li> <li>[ ] <code class="inline">getRawResponse()</code> and <code class="inline">getRawResponseAsync()</code> work</li> <li>[ ] <code class="inline">preload()</code> loads multiple endpoints</li> <li>[ ] <code class="inline">invalidate()</code> and <code class="inline">clearCache()</code> work</li> <li>[ ] Transformer pattern correctly adapts responses</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">311-picker-config-registry.md</code> to create the service for managing picker configurations.</p></div></div>
    <div class="chapter" id="section-311">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>311: Picker Config Registry</h1>
        </div>
<div class="page-content"><h1>311: Picker Config Registry</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 205-picker-config-interface, 304-domain-config-registry <strong>Blocks:</strong> Phase 8 (Framework Components - for picker dialogs)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the Registry pattern for UI configurations</li>
<p><li>Know how to decouple picker configuration from picker components</li> <li>Recognize the benefits of ID-based configuration lookup</li> <li>Be able to implement a type-safe configuration registry</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">PickerConfigRegistry</code> that provides centralized management of picker configurations. Pickers are dialogs that let users select items (vehicles, manufacturers, models) from searchable tables.</p>

<hr>

<h2>Why</h2>

<p>Vvroom has multiple picker dialogs:</p>
<ul><li><strong>Vehicle Picker</strong> — Select vehicles to compare</li>
<p><li><strong>Manufacturer/Model Picker</strong> — Filter by manufacturer and model</li> <li><strong>VIN Picker</strong> — Find vehicles by VIN</li></p>
</ul>
<p>Each picker needs configuration:</p>
<ul><li>Which columns to display</li>
<p><li>How to fetch data</li> <li>Selection behavior (single vs multi-select)</li></p>
</ul>
<h3>The Configuration Challenge</h3>

<p>Where should picker configuration live?</p>

<p><strong>Option 1: In the picker component</strong></p>
<pre class="code-block typescript"><code>@Component({...})
<p>export class VehiclePickerComponent { columns = [ { field: 'manufacturer', header: 'Manufacturer' }, { field: 'model', header: 'Model' }, // ... ]; }</p>
</code></pre>

<p>Problem: Every picker duplicates configuration logic.</p>

<p><strong>Option 2: In the domain config</strong></p>
<pre class="code-block typescript"><code>const AUTOMOBILE_CONFIG = {
<p>pickers: [VEHICLE_PICKER_CONFIG, MODEL_PICKER_CONFIG] };</p>
</code></pre>

<p>Problem: Components need to search arrays to find their config.</p>

<p><strong>Option 3: In a registry (our approach)</strong></p>
<pre class="code-block typescript"><code>// At initialization
<p>registry.register(VEHICLE_PICKER_CONFIG);</p>

<p>// In component const config = registry.get('vehicle-picker');</p>
</code></pre>

<p>Benefits:</p>
<ul><li><strong>O(1) lookup</strong> by ID</li>
<p><li><strong>Type-safe</strong> retrieval with generics</li> <li><strong>Decoupled</strong> from component hierarchy</li> <li><strong>Centralized</strong> validation and management</li></p>
</ul>
<h3>Usage Pattern</h3>

<pre class="code-block typescript"><code>// Domain config module registers pickers
<p>@NgModule({...}) export class AutomobileDomainModule { constructor(private registry: PickerConfigRegistry) { registry.registerMultiple([ VEHICLE_PICKER_CONFIG, MANUFACTURER_MODEL_PICKER_CONFIG ]); } }</p>

<p>// Component looks up config by ID @Component({...}) export class VehicleSelectionComponent { pickerConfig = this.registry.get&lt;VehicleResult&gt;('vehicle-picker'); }</p>

<p>// Or use ID in template &lt;app-base-picker [configId]="'vehicle-picker'"&gt;&lt;/app-base-picker&gt;</p>
</code></pre></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 311.1: Create the Picker Config Registry Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/picker-config-registry.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/picker-config-registry.service.ts
<p>// VERSION 1 (Section 311) - Picker configuration registry</p>

<p>import { Injectable } from '@angular/core'; import { PickerConfig } from '../models/picker-config.interface';</p>

<p>/**</p>
 <ul><li>Picker configuration registry service</li>
</ul> *
 <ul><li>Centralized registry for managing picker configurations.</li>
</ul> <ul><li>Allows registration and retrieval of picker configs by ID.</li>
</ul> *
 <ul><li><strong>Why a Registry?</strong></li>
</ul> *
 <ul><li>1. <strong>O(1) lookup</strong> — Get config by ID without searching arrays</li>
</ul> <ul><li>2. <strong>Type safety</strong> — Generic retrieval preserves types</li>
</ul> <ul><li>3. <strong>Centralized</strong> — Single source of truth for picker configs</li>
</ul> <ul><li>4. <strong>Decoupled</strong> — Components don't need to know about domain config</li>
</ul> *
 <ul><li><strong>Typical Flow:</strong></li>
</ul> *
 <ul><li>1. Domain module registers picker configs at init</li>
</ul> <ul><li>2. Components/templates reference pickers by ID</li>
</ul> <ul><li>3. BasePicker component looks up config from registry</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Registration (in domain module)</li>
</ul> <ul><li>constructor(private registry: PickerConfigRegistry) {</li>
</ul> <ul><li>  registry.registerMultiple(AUTOMOBILE_PICKER_CONFIGS);</li>
</ul> <ul><li>}</li>
</ul> *
 <ul><li>// Lookup (in component)</li>
</ul> <ul><li>const config = registry.get&lt;VehicleResult&gt;('vehicle-picker');</li>
</ul> *
 <ul><li>// Template usage</li>
</ul> <ul><li>&lt;app-base-picker [configId]="'vehicle-picker'"&gt;&lt;/app-base-picker&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class PickerConfigRegistry { /**</p>
   <ul><li>Storage for registered picker configurations</li>
</ul>   */
<p>private configs = new Map&lt;string, PickerConfig&lt;any&gt;&gt;();</p>

<p>/**</p>
   <ul><li>Register a picker configuration</li>
</ul>   *
   <ul><li>@template T - The data model type</li>
</ul>   <ul><li>@param config - Picker configuration to register</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>const vehicleConfig: PickerConfig&lt;VehicleResult&gt; = {</li>
</ul>   <ul><li>  id: 'vehicle-picker',</li>
</ul>   <ul><li>  displayName: 'Vehicle Selection',</li>
</ul>   <ul><li>  columns: [...],</li>
</ul>   <ul><li>  // ...</li>
</ul>   <ul><li>};</li>
</ul>   *
   <ul><li>registry.register(vehicleConfig);</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>register&lt;T&gt;(config: PickerConfig&lt;T&gt;): void { if (this.configs.has(config.id)) { console.warn( <code class="inline">[PickerConfigRegistry] Picker '${config.id}' already registered. Overwriting.</code> ); }</p>

<p>this.configs.set(config.id, config); }</p>

<p>/**</p>
   <ul><li>Register multiple picker configurations</li>
</ul>   *
   <ul><li>@param configs - Array of picker configurations</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>registry.registerMultiple([</li>
</ul>   <ul><li>  VEHICLE_PICKER_CONFIG,</li>
</ul>   <ul><li>  MANUFACTURER_MODEL_PICKER_CONFIG,</li>
</ul>   <ul><li>  VIN_PICKER_CONFIG</li>
</ul>   <ul><li>]);</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>registerMultiple(configs: PickerConfig&lt;any&gt;[]): void { configs.forEach(config =&gt; this.register(config)); }</p>

<p>/**</p>
   <ul><li>Get picker configuration by ID</li>
</ul>   *
   <ul><li>@template T - The data model type</li>
</ul>   <ul><li>@param id - Picker configuration ID</li>
</ul>   <ul><li>@returns Picker configuration</li>
</ul>   <ul><li>@throws Error if picker ID not found</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>const config = registry.get&lt;VehicleResult&gt;('vehicle-picker');</li>
</ul>   <ul><li>// config is typed as PickerConfig&lt;VehicleResult&gt;</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>get&lt;T&gt;(id: string): PickerConfig&lt;T&gt; { const config = this.configs.get(id);</p>

<p>if (!config) { const available = this.getAllIds().join(', ') || '(none)'; throw new Error( <code class="inline">[PickerConfigRegistry] Picker '${id}' not found. Available: ${available}</code> ); }</p>

<p>return config as PickerConfig&lt;T&gt;; }</p>

<p>/**</p>
   <ul><li>Get picker configuration by ID (returns null if not found)</li>
</ul>   *
   <ul><li>@template T - The data model type</li>
</ul>   <ul><li>@param id - Picker configuration ID</li>
</ul>   <ul><li>@returns Picker configuration or null</li>
</ul>   */
<p>tryGet&lt;T&gt;(id: string): PickerConfig&lt;T&gt; | null { return (this.configs.get(id) as PickerConfig&lt;T&gt;) ?? null; }</p>

<p>/**</p>
   <ul><li>Check if picker configuration exists</li>
</ul>   *
   <ul><li>@param id - Picker configuration ID</li>
</ul>   <ul><li>@returns True if picker exists</li>
</ul>   */
<p>has(id: string): boolean { return this.configs.has(id); }</p>

<p>/**</p>
   <ul><li>Get all registered picker IDs</li>
</ul>   *
   <ul><li>@returns Array of picker IDs</li>
</ul>   */
<p>getAllIds(): string[] { return Array.from(this.configs.keys()); }</p>

<p>/**</p>
   <ul><li>Get all registered picker configurations</li>
</ul>   *
   <ul><li>@returns Array of all picker configurations</li>
</ul>   */
<p>getAll(): PickerConfig&lt;any&gt;[] { return Array.from(this.configs.values()); }</p>

<p>/**</p>
   <ul><li>Unregister a picker configuration</li>
</ul>   *
   <ul><li>@param id - Picker configuration ID</li>
</ul>   <ul><li>@returns True if removed, false if not found</li>
</ul>   */
<p>unregister(id: string): boolean { return this.configs.delete(id); }</p>

<p>/**</p>
   <ul><li>Clear all registered picker configurations</li>
</ul>   */
<p>clear(): void { this.configs.clear(); }</p>

<p>/**</p>
   <ul><li>Get count of registered pickers</li>
</ul>   *
   <ul><li>@returns Number of registered pickers</li>
</ul>   */
<p>getCount(): number { return this.configs.size; }</p>

<p>/**</p>
   <ul><li>Get pickers by category (if categories are defined)</li>
</ul>   *
   <ul><li>@param category - Category to filter by</li>
</ul>   <ul><li>@returns Array of picker configurations in that category</li>
</ul>   */
<p>getByCategory(category: string): PickerConfig&lt;any&gt;[] { return this.getAll().filter(config =&gt; config.category === category); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 311.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 10 (Section 311) - Added PickerConfigRegistry</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service'; export * from './popout-context.service'; export * from './popout-manager.service'; export * from './user-preferences.service'; export * from './filter-options.service'; export * from './picker-config-registry.service'; export * from './resource-management.service';</p>
</code></pre>

<hr>

<h3>Step 311.3: Ensure PickerConfig Interface Exists</h3>

<p>Verify <code class="inline">src/app/framework/models/picker-config.interface.ts</code> includes the <code class="inline">category</code> property:</p>

<pre class="code-block typescript"><code>// Add to PickerConfig interface if not present
<p>export interface PickerConfig&lt;T&gt; { /<em>* Unique picker identifier </em>/ id: string;</p>

<p>/<em>* Display name for the picker dialog </em>/ displayName: string;</p>

<p>/<em>* Columns to display in picker table </em>/ columns: ColumnConfig[];</p>

<p>/<em>* Optional category for grouping </em>/ category?: string;</p>

<p>// ... other properties from Section 205 }</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/picker-config-registry.service.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/picker-config-registry.service.ts
</code></pre>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<h3>4. Verify Registration (Optional)</h3>

<pre class="code-block typescript"><code>// In any component
<p>constructor(private pickerRegistry: PickerConfigRegistry) { // Register test config this.pickerRegistry.register({ id: 'test-picker', displayName: 'Test Picker', columns: [{ field: 'name', header: 'Name' }] } as any);</p>

<p>console.log('Registered pickers:', this.pickerRegistry.getAllIds()); console.log('Test picker:', this.pickerRegistry.get('test-picker')); }</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Picker 'X' not found</code></td> <td>Not registered</td> <td>Register before component init</td></p>
</tr>
<p><tr> <td>Registration order issues</td> <td>Component loads before module</td> <td>Use APP_INITIALIZER</td></p>
</tr>
<p><tr> <td>Type errors on get&lt;T&gt;()</td> <td>Wrong type parameter</td> <td>Check data model matches config</td></p>
</tr>
<p><tr> <td>Config overwritten warning</td> <td>Same ID registered twice</td> <td>Use unique IDs</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>O(1) lookup beats array search</strong> — Registry is faster than filtering arrays</li>
<p><li><strong>ID-based access decouples components</strong> — Components don't know about domain config structure</li> <li><strong>Type-safe retrieval preserves generics</strong> — get&lt;VehicleResult&gt;() returns typed config</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/picker-config-registry.service.ts</code> exists</li>
<p><li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li>[ ] <code class="inline">register()</code> stores config by ID</li> <li>[ ] <code class="inline">registerMultiple()</code> registers array of configs</li> <li>[ ] <code class="inline">get&lt;T&gt;()</code> returns typed config, throws if not found</li> <li>[ ] <code class="inline">tryGet&lt;T&gt;()</code> returns null instead of throwing</li> <li>[ ] <code class="inline">has()</code> checks if picker exists</li> <li>[ ] <code class="inline">getAllIds()</code> returns all registered IDs</li> <li>[ ] <code class="inline">getAll()</code> returns all configs</li> <li>[ ] <code class="inline">unregister()</code> removes config</li> <li>[ ] <code class="inline">clear()</code> removes all configs</li> <li>[ ] <code class="inline">getByCategory()</code> filters by category</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Phase 3B Complete</h2>

<p>Congratulations! You have completed Phase 3B: Popout &amp; Specialized Services.</p>

<p><strong>What you built:</strong></p>
<ul><li>PopOutContextService — Pop-out window detection and messaging</li>
<p><li>PopOutManagerService — Pop-out window management from main window</li> <li>UserPreferencesService — localStorage-based preferences</li> <li>FilterOptionsService — Filter dropdown caching</li> <li>PickerConfigRegistry — Picker configuration lookup</li></p>
</ul>
<p><strong>The Aha Moment:</strong> "Pop-out windows share state with the parent through a coordination service."</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">312-error-notification-service.md</code> to begin Phase 3C: Error Handling.</p></div></div>
    <div class="chapter" id="section-312">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>312: Error Notification Service</h1>
        </div>
<div class="page-content"><h1>312: Error Notification Service</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 201-209 (Framework Models) <strong>Blocks:</strong> 313-http-error-interceptor, 314-global-error-handler</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the need for centralized error notification</li>
<p><li>Know how to deduplicate error messages to prevent notification spam</li> <li>Recognize the role of error categorization in user-facing messaging</li> <li>Be able to implement toast notifications using PrimeNG MessageService</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">ErrorNotificationService</code> that provides centralized error notification using PrimeNG Toast. This service handles error deduplication, categorization, and consistent display for all user-facing error messages.</p>

<hr>

<h2>Why</h2>

<p>Applications generate errors from multiple sources:</p>
<ul><li>HTTP requests failing</li>
<p><li>Validation errors from form inputs</li> <li>Component lifecycle errors</li> <li>Unhandled promise rejections</li></p>
</ul>
<p>Without centralized error handling, each component handles errors differently. Users see inconsistent messages, and developers repeat the same error-handling logic.</p>

<h3>The Problem: Notification Spam</h3>

<p>When errors occur, they often repeat rapidly:</p>
<ul><li>Network failures cause multiple retries</li>
<p><li>Polling requests all fail simultaneously</li> <li>Component re-renders trigger the same error</li></p>
</ul>
<p>Showing every error individually creates <strong>notification spam</strong> that overwhelms users.</p>

<h3>The Solution: Deduplication</h3>

<p>The ErrorNotificationService maintains a short-term memory of recent errors. If the same error (same category + summary + detail) occurs within a deduplication window (3 seconds), subsequent errors are suppressed.</p>

<pre class="code-block typescript"><code>// First error: Shows toast
<p>showError('Connection Error', 'Unable to reach server');</p>

<p>// Same error within 3 seconds: Suppressed showError('Connection Error', 'Unable to reach server'); // No toast</p>

<p>// After 3 seconds: Shows toast again showError('Connection Error', 'Unable to reach server'); // Toast shown</p>
</code></pre>

<h3>Error Categories</h3>

<p>Errors are categorized by source and type:</p>

<table>
<p><thead><tr> <th>Category</th> <th>Description</th> <th>Default Severity</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">NETWORK</code></td> <td>Connection issues, timeouts</td> <td>error</td></p>
</tr>
<p><tr> <td><code class="inline">VALIDATION</code></td> <td>Invalid input, business rules</td> <td>warn</td></p>
</tr>
<p><tr> <td><code class="inline">AUTHORIZATION</code></td> <td>401/403 errors</td> <td>warn</td></p>
</tr>
<p><tr> <td><code class="inline">SERVER</code></td> <td>5xx status codes</td> <td>error</td></p>
</tr>
<p><tr> <td><code class="inline">CLIENT</code></td> <td>JavaScript errors</td> <td>error</td></p>
</tr>
<p><tr> <td><code class="inline">APPLICATION</code></td> <td>Business logic errors</td> <td>error</td></p>
</tr>
<p><tr> <td><code class="inline">UNKNOWN</code></td> <td>Uncategorized</td> <td>error</td></p>
</tr>
</tbody>
</table>

<p>Categories drive two behaviors:</p>
<ul><li><strong>Visual severity</strong> — Maps to PrimeNG toast colors (error=red, warn=yellow)</li>
<p><li><strong>User-friendly summaries</strong> — "Connection Error" instead of "NETWORK"</li></ul></p></div><div class="page-content"><h3>PrimeNG Toast Integration</h3>

<p>PrimeNG's <code class="inline">MessageService</code> provides toast notifications. The ErrorNotificationService wraps it to add:</p>
<ul><li>Error categorization</li>
<p><li>Deduplication</li> <li>Consistent formatting</li> <li>Debug logging</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 312.1: Create the Error Notification Interface</h3>

<p>Create the file <code class="inline">src/app/framework/models/error-notification.interface.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/models/error-notification.interface.ts
<p>// VERSION 1 (Section 312) - Error notification types</p>

<p>/**</p>
 <ul><li>Error category enumeration</li>
</ul> *
 <ul><li>Categorizes errors by their source and nature for appropriate handling</li>
</ul> <ul><li>and user messaging.</li>
</ul> */
<p>export enum ErrorCategory { /**</p>
   <ul><li>Network-related errors (connection issues, timeouts, etc.)</li>
</ul>   */
<p>NETWORK = 'NETWORK',</p>

<p>/**</p>
   <ul><li>Validation errors (invalid input, business rule violations)</li>
</ul>   */
<p>VALIDATION = 'VALIDATION',</p>

<p>/**</p>
   <ul><li>Authorization/authentication errors (401, 403)</li>
</ul>   */
<p>AUTHORIZATION = 'AUTHORIZATION',</p>

<p>/**</p>
   <ul><li>Server-side errors (5xx status codes)</li>
</ul>   */
<p>SERVER = 'SERVER',</p>

<p>/**</p>
   <ul><li>Client-side errors (JavaScript errors, component errors)</li>
</ul>   */
<p>CLIENT = 'CLIENT',</p>

<p>/**</p>
   <ul><li>Application-level errors (business logic, state errors)</li>
</ul>   */
<p>APPLICATION = 'APPLICATION',</p>

<p>/**</p>
   <ul><li>Unknown or uncategorized errors</li>
</ul>   */
<p>UNKNOWN = 'UNKNOWN' }</p>

<p>/**</p>
 <ul><li>Error severity levels</li>
</ul> *
 <ul><li>Maps to PrimeNG Toast severity levels for visual feedback</li>
</ul> */
<p>export type ErrorSeverity = 'success' | 'info' | 'warn' | 'error';</p>

<p>/**</p>
 <ul><li>Error notification data structure</li>
</ul> *
 <ul><li>Contains all information needed to display an error to the user</li>
</ul> */
<p>export interface ErrorNotification { /**</p>
   <ul><li>Error category for categorization and routing</li>
</ul>   */
<p>category: ErrorCategory;</p>

<p>/**</p>
   <ul><li>Display severity (maps to PrimeNG Toast severity)</li>
</ul>   */
<p>severity: ErrorSeverity;</p>

<p>/**</p>
   <ul><li>Brief error summary (shown as toast title)</li>
</ul>   */
<p>summary: string;</p>

<p>/**</p>
   <ul><li>Detailed error message (shown as toast body)</li>
</ul>   */
<p>detail: string;</p>

<p>/**</p>
   <ul><li>Optional error code for debugging</li>
</ul>   */
<p>code?: string;</p>

<p>/**</p>
   <ul><li>Optional timestamp of when error occurred</li>
</ul>   */
<p>timestamp?: string;</p>

<p>/**</p>
   <ul><li>Optional URL where error occurred</li>
</ul>   */
<p>url?: string;</p>

<p>/**</p>
   <ul><li>Optional HTTP status code (for network errors)</li>
</ul>   */
<p>status?: number;</p>

<p>/**</p>
   <ul><li>Original error object (for logging/debugging)</li>
</ul>   */
<p>originalError?: any; }</p>

<p>/**</p>
 <ul><li>Error display options</li>
</ul> *
 <ul><li>Configuration for how errors should be displayed to users</li>
</ul> */
<p>export interface ErrorDisplayOptions { /**</p>
   <ul><li>Auto-hide duration in milliseconds</li>
</ul>   <ul><li>Set to 0 or null to prevent auto-hide</li>
</ul>   <ul><li>Default: 5000 (5 seconds)</li>
</ul>   */
<p>life?: number;</p>

<p>/**</p>
   <ul><li>Whether to show close button</li>
</ul>   <ul><li>Default: true</li>
</ul>   */
<p>closable?: boolean;</p>

<p>/**</p>
   <ul><li>Whether to show in sticky mode (no auto-hide)</li>
</ul>   <ul><li>Default: false</li>
</ul>   */
<p>sticky?: boolean;</p>

<p>/**</p>
   <ul><li>Custom CSS class for the toast</li>
</ul>   */
<p>styleClass?: string;</p>

<p>/**</p>
   <ul><li>Toast position key</li>
</ul>   <ul><li>Default: 'app-toast'</li>
</ul>   */
<p>key?: string; }</p>

<p>/**</p>
 <ul><li>Default error display options</li>
</ul> */
<p>export const DEFAULT_ERROR_DISPLAY_OPTIONS: ErrorDisplayOptions = { life: 5000, closable: true, sticky: false, key: 'app-toast' };</p>

<p>/**</p>
 <ul><li>Error severity mapping configuration</li>
</ul> *
 <ul><li>Maps error categories to default severity levels</li>
</ul> */
<p>export const ERROR_CATEGORY_SEVERITY_MAP: Record&lt;ErrorCategory, ErrorSeverity&gt; = { [ErrorCategory.NETWORK]: 'error', [ErrorCategory.VALIDATION]: 'warn', [ErrorCategory.AUTHORIZATION]: 'warn', [ErrorCategory.SERVER]: 'error', [ErrorCategory.CLIENT]: 'error', [ErrorCategory.APPLICATION]: 'error', [ErrorCategory.UNKNOWN]: 'error' };</p>

<p>/**</p>
 <ul><li>HTTP status code to error category mapping</li>
</ul> *
 <ul><li>@param status - HTTP status code</li>
</ul> <ul><li>@returns Appropriate error category</li>
</ul> */
<p>export function getErrorCategoryFromStatus(status: number): ErrorCategory { if (status === 0) { return ErrorCategory.NETWORK; }</p>

<p>if (status === 401 || status === 403) { return ErrorCategory.AUTHORIZATION; }</p>

<p>if (status === 400 || status === 422) { return ErrorCategory.VALIDATION; }</p>

<p>if (status &gt;= 500 &amp;&amp; status &lt; 600) { return ErrorCategory.SERVER; }</p>

<p>if (status &gt;= 400 &amp;&amp; status &lt; 500) { return ErrorCategory.CLIENT; }</p>

<p>return ErrorCategory.UNKNOWN; }</p>

<p>/**</p>
 <ul><li>Error code to error category mapping</li>
</ul> *
 <ul><li>@param code - Error code string</li>
</ul> <ul><li>@returns Appropriate error category</li>
</ul> */
<p>export function getErrorCategoryFromCode(code: string): ErrorCategory { const upperCode = code.toUpperCase();</p>

<p>if (upperCode.includes('NETWORK') || upperCode.includes('TIMEOUT')) { return ErrorCategory.NETWORK; }</p>

<p>if (upperCode.includes('VALIDATION') || upperCode.includes('INVALID')) { return ErrorCategory.VALIDATION; }</p>

<p>if ( upperCode.includes('UNAUTHORIZED') || upperCode.includes('FORBIDDEN') || upperCode.includes('AUTH') ) { return ErrorCategory.AUTHORIZATION; }</p>

<p>if (upperCode.includes('SERVER') || upperCode.includes('INTERNAL')) { return ErrorCategory.SERVER; }</p>

<p>if (upperCode.includes('CLIENT')) { return ErrorCategory.CLIENT; }</p>

<p>return ErrorCategory.UNKNOWN; }</p>

<p>/**</p>
 <ul><li>Get user-friendly summary for error category</li>
</ul> *
 <ul><li>@param category - Error category</li>
</ul> <ul><li>@returns Summary text</li>
</ul> */
<p>export function getSummaryForCategory(category: ErrorCategory): string { switch (category) { case ErrorCategory.NETWORK: return 'Connection Error'; case ErrorCategory.VALIDATION: return 'Validation Error'; case ErrorCategory.AUTHORIZATION: return 'Access Denied'; case ErrorCategory.SERVER: return 'Server Error'; case ErrorCategory.CLIENT: return 'Application Error'; case ErrorCategory.APPLICATION: return 'Operation Failed'; case ErrorCategory.UNKNOWN: default: return 'Error'; } }</p>

<p>/**</p>
 <ul><li>Create error notification from HTTP error</li>
</ul> *
 <ul><li>@param error - HTTP error object (from interceptor)</li>
</ul> <ul><li>@returns ErrorNotification object</li>
</ul> */
<p>export function createErrorNotificationFromHttpError(error: any): ErrorNotification { const status = error.status || 0; const code = error.code || 'UNKNOWN_ERROR'; const category = getErrorCategoryFromStatus(status); const severity = ERROR_CATEGORY_SEVERITY_MAP[category];</p>

<p>return { category, severity, summary: getSummaryForCategory(category), detail: error.message || 'An unexpected error occurred', code, timestamp: error.timestamp, url: error.url, status, originalError: error }; }</p>

<p>/**</p>
 <ul><li>Create error notification from generic error</li>
</ul> *
 <ul><li>@param error - Generic error object</li>
</ul> <ul><li>@returns ErrorNotification object</li>
</ul> */
<p>export function createErrorNotificationFromError(error: Error): ErrorNotification { const code = (error as any).code; const category = code ? getErrorCategoryFromCode(code) : ErrorCategory.CLIENT; const severity = ERROR_CATEGORY_SEVERITY_MAP[category];</p>

<p>return { category, severity, summary: getSummaryForCategory(category), detail: error.message || 'An unexpected error occurred', code, timestamp: new Date().toISOString(), originalError: error }; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 312.2: Update the Models Barrel File</h3>

<p>Update <code class="inline">src/app/framework/models/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/models/index.ts
<p>// VERSION 9 (Section 312) - Added error notification types</p>

<p>export * from './domain-config.interface'; export * from './column-config.interface'; export * from './filter-config.interface'; export * from './picker-config.interface'; export * from './table-state.interface'; export * from './paginator-state.interface'; export * from './popout.interface'; export * from './user-preferences.interface'; export * from './error-notification.interface';</p>
</code></pre>

<hr>

<h3>Step 312.3: Create the Error Notification Service</h3>

<p>Create the file <code class="inline">src/app/framework/services/error-notification.service.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/error-notification.service.ts
<p>// VERSION 1 (Section 312) - Centralized error notification</p>

<p>import { Injectable, OnDestroy } from '@angular/core'; import { MessageService } from 'primeng/api'; import { ErrorNotification, ErrorCategory, ErrorDisplayOptions, DEFAULT_ERROR_DISPLAY_OPTIONS, createErrorNotificationFromHttpError, createErrorNotificationFromError } from '../models/error-notification.interface';</p>

<p>/**</p>
 <ul><li>Error notification service</li>
</ul> *
 <ul><li>Centralized error notification system using PrimeNG Toast for user-facing</li>
</ul> <ul><li>error messages. Provides error deduplication, categorization, and</li>
</ul> <ul><li>consistent error display.</li>
</ul> *
 <ul><li><strong>Key Features:</strong></li>
</ul> *
 <ul><li>1. <strong>Deduplication</strong> — Same error within 3 seconds is suppressed</li>
</ul> <ul><li>2. <strong>Categorization</strong> — Errors categorized by type for appropriate messaging</li>
</ul> <ul><li>3. <strong>Consistent Display</strong> — All errors shown via PrimeNG Toast</li>
</ul> <ul><li>4. <strong>Debug Logging</strong> — All errors logged to console for debugging</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Show HTTP error</li>
</ul> <ul><li>this.errorNotification.showHttpError(httpError);</li>
</ul> *
 <ul><li>// Show custom error</li>
</ul> <ul><li>this.errorNotification.showError(</li>
</ul> <ul><li>  'Operation Failed',</li>
</ul> <ul><li>  'Unable to save changes. Please try again.'</li>
</ul> <ul><li>);</li>
</ul> *
 <ul><li>// Show warning</li>
</ul> <ul><li>this.errorNotification.showWarning(</li>
</ul> <ul><li>  'Data Modified',</li>
</ul> <ul><li>  'Some fields were automatically corrected.'</li>
</ul> <ul><li>);</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class ErrorNotificationService implements OnDestroy { /**</p>
   <ul><li>Recent error messages for deduplication</li>
</ul>   *
   <ul><li>Maps error signature (hash of message) to timestamp. Used to suppress</li>
</ul>   <ul><li>duplicate errors shown within DEDUPLICATION_WINDOW milliseconds.</li>
</ul>   */
<p>private recentErrors = new Map&lt;string, number&gt;();</p>

<p>/**</p>
   <ul><li>Deduplication window in milliseconds</li>
</ul>   *
   <ul><li>Errors with the same signature within this window are suppressed</li>
</ul>   <ul><li>to prevent notification spam from repeated failures.</li>
</ul>   */
<p>private readonly DEDUPLICATION_WINDOW = 3000; // 3 seconds</p>

<p>/**</p>
   <ul><li>Cleanup interval for recent errors map</li>
</ul>   *
   <ul><li>Interval at which expired entries are removed from recentErrors</li>
</ul>   <ul><li>to prevent unbounded memory growth.</li>
</ul>   */
<p>private readonly CLEANUP_INTERVAL = 10000; // 10 seconds</p>

<p>/**</p>
   <ul><li>Cleanup timer reference</li>
</ul>   */
<p>private cleanupTimer?: ReturnType&lt;typeof setInterval&gt;;</p>

<p>/**</p>
   <ul><li>Constructor for dependency injection</li>
</ul>   *
   <ul><li>@param messageService - PrimeNG MessageService for displaying toast notifications</li>
</ul>   */
<p>constructor(private messageService: MessageService) { this.startCleanupTimer(); }</p>

<p>/**</p>
   <ul><li>Show error notification</li>
</ul>   *
   <ul><li>@param summary - Brief error summary</li>
</ul>   <ul><li>@param detail - Detailed error message</li>
</ul>   <ul><li>@param options - Display options</li>
</ul>   */
<p>showError( summary: string, detail: string, options?: ErrorDisplayOptions ): void { this.show( { category: ErrorCategory.APPLICATION, severity: 'error', summary, detail, timestamp: new Date().toISOString() }, options ); }</p>

<p>/**</p>
   <ul><li>Show warning notification</li>
</ul>   *
   <ul><li>@param summary - Brief warning summary</li>
</ul>   <ul><li>@param detail - Detailed warning message</li>
</ul>   <ul><li>@param options - Display options</li>
</ul>   */
<p>showWarning( summary: string, detail: string, options?: ErrorDisplayOptions ): void { this.show( { category: ErrorCategory.APPLICATION, severity: 'warn', summary, detail, timestamp: new Date().toISOString() }, options ); }</p>

<p>/**</p>
   <ul><li>Show info notification</li>
</ul>   *
   <ul><li>@param summary - Brief info summary</li>
</ul>   <ul><li>@param detail - Detailed info message</li>
</ul>   <ul><li>@param options - Display options</li>
</ul>   */
<p>showInfo( summary: string, detail: string, options?: ErrorDisplayOptions ): void { this.show( { category: ErrorCategory.APPLICATION, severity: 'info', summary, detail, timestamp: new Date().toISOString() }, options ); }</p>

<p>/**</p>
   <ul><li>Show success notification</li>
</ul>   *
   <ul><li>@param summary - Brief success summary</li>
</ul>   <ul><li>@param detail - Detailed success message</li>
</ul>   <ul><li>@param options - Display options</li>
</ul>   */
<p>showSuccess( summary: string, detail: string, options?: ErrorDisplayOptions ): void { this.show( { category: ErrorCategory.APPLICATION, severity: 'success', summary, detail, timestamp: new Date().toISOString() }, options ); }</p>

<p>/**</p>
   <ul><li>Show HTTP error notification</li>
</ul>   *
   <ul><li>Automatically categorizes and formats HTTP errors from the interceptor</li>
</ul>   *
   <ul><li>@param error - HTTP error object from interceptor</li>
</ul>   <ul><li>@param options - Display options</li>
</ul>   */
<p>showHttpError(error: any, options?: ErrorDisplayOptions): void { const notification = createErrorNotificationFromHttpError(error); this.show(notification, options); }</p>

<p>/**</p>
   <ul><li>Show generic error notification</li>
</ul>   *
   <ul><li>Automatically categorizes and formats generic JavaScript errors</li>
</ul>   *
   <ul><li>@param error - Error object</li>
</ul>   <ul><li>@param options - Display options</li>
</ul>   */
<p>showGenericError(error: Error, options?: ErrorDisplayOptions): void { const notification = createErrorNotificationFromError(error); this.show(notification, options); }</p>

<p>/**</p>
   <ul><li>Show custom error notification</li>
</ul>   *
   <ul><li>@param notification - Error notification object</li>
</ul>   <ul><li>@param options - Display options</li>
</ul>   */
<p>show( notification: ErrorNotification, options?: ErrorDisplayOptions ): void { // Check for duplicate if (this.isDuplicate(notification)) { console.debug('Suppressing duplicate error:', notification.summary); return; }</p>

<p>// Record error for deduplication this.recordError(notification);</p>

<p>// Merge options with defaults const displayOptions: ErrorDisplayOptions = { ...DEFAULT_ERROR_DISPLAY_OPTIONS, ...options };</p>

<p>// Display toast notification this.messageService.add({ severity: notification.severity, summary: notification.summary, detail: notification.detail, life: displayOptions.life, closable: displayOptions.closable, sticky: displayOptions.sticky, styleClass: displayOptions.styleClass, key: displayOptions.key });</p>

<p>// Log error details this.logError(notification); }</p>

<p>/**</p>
   <ul><li>Clear all notifications</li>
</ul>   */
<p>clearAll(): void { this.messageService.clear(); }</p>

<p>/**</p>
   <ul><li>Clear notifications by key</li>
</ul>   *
   <ul><li>@param key - Toast key to clear</li>
</ul>   */
<p>clear(key?: string): void { this.messageService.clear(key); }</p>

<p>/**</p>
   <ul><li>Check if error is duplicate</li>
</ul>   *
   <ul><li>@param notification - Error notification</li>
</ul>   <ul><li>@returns True if duplicate within deduplication window</li>
</ul>   */
<p>private isDuplicate(notification: ErrorNotification): boolean { const signature = this.getErrorSignature(notification); const lastTime = this.recentErrors.get(signature);</p>

<p>if (!lastTime) { return false; }</p>

<p>const now = Date.now(); return now - lastTime &lt; this.DEDUPLICATION_WINDOW; }</p>

<p>/**</p>
   <ul><li>Record error for deduplication tracking</li>
</ul>   *
   <ul><li>@param notification - Error notification</li>
</ul>   */
<p>private recordError(notification: ErrorNotification): void { const signature = this.getErrorSignature(notification); this.recentErrors.set(signature, Date.now()); }</p>

<p>/**</p>
   <ul><li>Generate error signature for deduplication</li>
</ul>   *
   <ul><li>@param notification - Error notification</li>
</ul>   <ul><li>@returns Unique signature string</li>
</ul>   */
<p>private getErrorSignature(notification: ErrorNotification): string { // Combine category, summary, and detail for signature return <code class="inline">${notification.category}:${notification.summary}:${notification.detail}</code>; }</p>

<p>/**</p>
   <ul><li>Log error details for debugging</li>
</ul>   *
   <ul><li>@param notification - Error notification</li>
</ul>   */
<p>private logError(notification: ErrorNotification): void { const logData: any = { category: notification.category, severity: notification.severity, summary: notification.summary, detail: notification.detail, timestamp: notification.timestamp || new Date().toISOString() };</p>

<p>// Add optional fields if present if (notification.code) { logData.code = notification.code; } if (notification.url) { logData.url = notification.url; } if (notification.status) { logData.status = notification.status; }</p>

<p>// Log based on severity switch (notification.severity) { case 'error': console.error('[Error Notification]', logData); if (notification.originalError) { console.error('Original error:', notification.originalError); } break; case 'warn': console.warn('[Warning Notification]', logData); break; case 'info': console.info('[Info Notification]', logData); break; case 'success': console.log('[Success Notification]', logData); break; } }</p>

<p>/**</p>
   <ul><li>Start cleanup timer for recent errors map</li>
</ul>   */
<p>private startCleanupTimer(): void { this.cleanupTimer = setInterval(() =&gt; { this.cleanupRecentErrors(); }, this.CLEANUP_INTERVAL); }</p>

<p>/**</p>
   <ul><li>Clean up expired entries from recent errors map</li>
</ul>   */
<p>private cleanupRecentErrors(): void { const now = Date.now(); const expiredKeys: string[] = [];</p>

<p>// Find expired entries this.recentErrors.forEach((timestamp, key) =&gt; { if (now - timestamp &gt; this.DEDUPLICATION_WINDOW * 2) { expiredKeys.push(key); } });</p>

<p>// Remove expired entries expiredKeys.forEach((key) =&gt; { this.recentErrors.delete(key); }); }</p>

<p>/**</p>
   <ul><li>Stop cleanup timer (for cleanup)</li>
</ul>   */
<p>ngOnDestroy(): void { if (this.cleanupTimer) { clearInterval(this.cleanupTimer); } } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 312.4: Update the Services Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 11 (Section 312) - Added ErrorNotificationService</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service'; export * from './popout-context.service'; export * from './popout-manager.service'; export * from './user-preferences.service'; export * from './filter-options.service'; export * from './picker-config-registry.service'; export * from './resource-management.service'; export * from './error-notification.service';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check Files Exist</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/models/error-notification.interface.ts
<p>$ ls -la src/app/framework/services/error-notification.service.ts</p>
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/error-notification.service.ts
</code></pre>

<h3>3. Verify PrimeNG MessageService Provider</h3>

<p>Ensure <code class="inline">MessageService</code> is provided in your <code class="inline">app.module.ts</code>:</p>

<pre class="code-block typescript"><code>import { MessageService } from 'primeng/api';

<p>@NgModule({ providers: [MessageService], // ... }) export class AppModule { }</p>
</code></pre>

<h3>4. Add Toast Component to Template</h3>

<p>Add the PrimeNG Toast component to <code class="inline">app.component.html</code>:</p>

<pre class="code-block html"><code>&lt;p-toast key="app-toast"&gt;&lt;/p-toast&gt;
<p>&lt;router-outlet&gt;&lt;/router-outlet&gt;</p>
</code></pre>

<h3>5. Test Deduplication</h3>

<pre class="code-block typescript"><code>// In any component
<p>constructor(private errorNotification: ErrorNotificationService) { // First error - shows toast this.errorNotification.showError('Test', 'This is a test error');</p>

<p>// Same error within 3 seconds - suppressed setTimeout(() =&gt; { this.errorNotification.showError('Test', 'This is a test error'); console.log('Second error call (should be suppressed)'); }, 1000);</p>

<p>// Same error after 4 seconds - shows toast setTimeout(() =&gt; { this.errorNotification.showError('Test', 'This is a test error'); console.log('Third error call (should show)'); }, 4000); }</p>
</code></pre></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>No toast appears</td> <td>MessageService not provided</td> <td>Add <code class="inline">MessageService</code> to app.module.ts providers</td></p>
</tr>
<p><tr> <td>Toast appears but no styling</td> <td>PrimeNG CSS not imported</td> <td>Import PrimeNG theme in styles.scss</td></p>
</tr>
<p><tr> <td>Multiple toasts for same error</td> <td>Deduplication not working</td> <td>Check signature generation logic</td></p>
</tr>
<p><tr> <td>Memory leak warning</td> <td>Cleanup timer not stopped</td> <td>Ensure <code class="inline">ngOnDestroy</code> clears interval</td></p>
</tr>
<p><tr> <td>Wrong toast position</td> <td>Toast key mismatch</td> <td>Ensure <code class="inline">key</code> matches in both service and template</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Deduplication prevents spam</strong> — Same error within 3 seconds is suppressed</li>
<p><li><strong>Categorization drives messaging</strong> — Error category determines summary text and severity</li> <li><strong>PrimeNG Toast integration</strong> — Wrapping MessageService adds value through deduplication and categorization</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/models/error-notification.interface.ts</code> exists with all types</li>
<p><li>[ ] <code class="inline">src/app/framework/services/error-notification.service.ts</code> exists</li> <li>[ ] Service is <code class="inline">@Injectable({ providedIn: 'root' })</code></li> <li>[ ] <code class="inline">showError()</code> displays error toast</li> <li>[ ] <code class="inline">showWarning()</code> displays warning toast</li> <li>[ ] <code class="inline">showInfo()</code> displays info toast</li> <li>[ ] <code class="inline">showSuccess()</code> displays success toast</li> <li>[ ] <code class="inline">showHttpError()</code> creates notification from HTTP error</li> <li>[ ] <code class="inline">showGenericError()</code> creates notification from Error object</li> <li>[ ] Deduplication prevents same error within 3 seconds</li> <li>[ ] Cleanup timer prevents memory leaks</li> <li>[ ] <code class="inline">ngOnDestroy()</code> clears cleanup timer</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">313-http-error-interceptor.md</code> to create the HTTP interceptor for automatic error handling.</p></div></div>
    <div class="chapter" id="section-313">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>313: HTTP Error Interceptor</h1>
        </div>
<div class="page-content"><h1>313: HTTP Error Interceptor</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 302-api-service, 312-error-notification-service <strong>Blocks:</strong> 314-global-error-handler</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how Angular HTTP interceptors work</li>
<p><li>Know how to implement automatic retry for transient errors</li> <li>Recognize the importance of consistent error formatting</li> <li>Be able to create user-friendly error messages from HTTP status codes</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">HttpErrorInterceptor</code> that provides global error handling for all HTTP requests. This interceptor automatically retries transient errors, formats error responses consistently, and logs errors for debugging.</p>

<hr>

<h2>Why</h2>

<p>Every HTTP request can fail. Without centralized handling, each component must:</p>
<ul><li>Catch errors in its subscription</li>
<p><li>Determine the error type</li> <li>Format user-friendly messages</li> <li>Log for debugging</li> <li>Decide whether to retry</li></p>
</ul>
<p>This leads to duplicated logic and inconsistent error handling.</p>

<h3>The Interceptor Pattern</h3>

<p>Angular's HTTP interceptor pattern allows you to intercept and modify HTTP requests and responses globally. For error handling:</p>

<pre class="code-block text"><code>Request → Interceptor → HTTP → Server Response
<p>↓ Error? → Retry? → Format → Component</p>
</code></pre>

<h3>Automatic Retry for Transient Errors</h3>

<p>Some errors are <strong>transient</strong> — they succeed on retry:</p>

<table>
<p><thead><tr> <th>Status Code</th> <th>Meaning</th> <th>Retryable?</th></p>
</tr></thead>
<p><tbody> <tr> <td>429</td> <td>Too Many Requests</td> <td>Yes — wait and retry</td></p>
</tr>
<p><tr> <td>500</td> <td>Internal Server Error</td> <td>Maybe — server might recover</td></p>
</tr>
<p><tr> <td>502</td> <td>Bad Gateway</td> <td>Yes — proxy might recover</td></p>
</tr>
<p><tr> <td>503</td> <td>Service Unavailable</td> <td>Yes — server restarting</td></p>
</tr>
<p><tr> <td>504</td> <td>Gateway Timeout</td> <td>Yes — might just be slow</td></p>
</tr>
<p><tr> <td>400</td> <td>Bad Request</td> <td>No — client error won't change</td></p>
</tr>
<p><tr> <td>401</td> <td>Unauthorized</td> <td>No — need authentication</td></p>
</tr>
<p><tr> <td>404</td> <td>Not Found</td> <td>No — resource doesn't exist</td></p>
</tr>
</tbody>
</table>

<p>The interceptor automatically retries for status codes 429, 500, 502, 503, 504 up to 2 times before giving up.</p></div><div class="page-content"><h3>Consistent Error Formatting</h3>

<p>The interceptor transforms Angular's <code class="inline">HttpErrorResponse</code> into a consistent format:</p>

<pre class="code-block typescript"><code>// Input: HttpErrorResponse
<p>{ status: 500, statusText: 'Internal Server Error', error: { message: 'Database connection failed' }, url: '/api/vehicles' }</p>

<p>// Output: Formatted error object { code: 'INTERNAL_SERVER_ERROR', message: 'Internal server error. Please try again later.', status: 500, statusText: 'Internal Server Error', url: '/api/vehicles', timestamp: '2024-02-09T12:00:00.000Z' }</p>
</code></pre>

<p>This consistent format makes error handling predictable for:</p>
<ul><li>The ErrorNotificationService</li>
<p><li>Component error handlers</li> <li>Error logging systems</li></p>
</ul>
<h3>Error Code Mapping</h3>

<p>Each HTTP status maps to a semantic error code:</p>

<table>
<p><thead><tr> <th>Status</th> <th>Error Code</th></p>
</tr></thead>
<p><tbody> <tr> <td>400</td> <td><code class="inline">BAD_REQUEST</code></td></p>
</tr>
<p><tr> <td>401</td> <td><code class="inline">UNAUTHORIZED</code></td></p>
</tr>
<p><tr> <td>403</td> <td><code class="inline">FORBIDDEN</code></td></p>
</tr>
<p><tr> <td>404</td> <td><code class="inline">NOT_FOUND</code></td></p>
</tr>
<p><tr> <td>409</td> <td><code class="inline">CONFLICT</code></td></p>
</tr>
<p><tr> <td>422</td> <td><code class="inline">VALIDATION_ERROR</code></td></p>
</tr>
<p><tr> <td>429</td> <td><code class="inline">RATE_LIMIT_EXCEEDED</code></td></p>
</tr>
<p><tr> <td>500</td> <td><code class="inline">INTERNAL_SERVER_ERROR</code></td></p>
</tr>
<p><tr> <td>502</td> <td><code class="inline">BAD_GATEWAY</code></td></p>
</tr>
<p><tr> <td>503</td> <td><code class="inline">SERVICE_UNAVAILABLE</code></td></p>
</tr>
<p><tr> <td>504</td> <td><code class="inline">GATEWAY_TIMEOUT</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>What</h2>

<h3>Step 313.1: Create the HTTP Error Interceptor</h3>

<p>Create the file <code class="inline">src/app/framework/services/http-error.interceptor.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/http-error.interceptor.ts
<p>// VERSION 1 (Section 313) - HTTP error interceptor</p>

<p>import { Injectable } from '@angular/core'; import { HttpErrorResponse, HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http'; import { Observable, throwError } from 'rxjs'; import { catchError, retry } from 'rxjs/operators';</p>

<p>/**</p>
 <ul><li>Configuration for error interceptor retry behavior</li>
</ul> */
<p>export interface RetryConfig { /<em>* Maximum number of retry attempts </em>/ maxRetries: number; /<em>* HTTP status codes that should trigger retry </em>/ retryableStatusCodes: number[]; }</p>

<p>/**</p>
 <ul><li>Default retry configuration</li>
</ul> *
 <ul><li>Retries transient server errors (5xx) and rate limiting (429).</li>
</ul> <ul><li>Does not retry client errors (4xx) as they won't succeed without changes.</li>
</ul> */
<p>const DEFAULT_RETRY_CONFIG: RetryConfig = { maxRetries: 2, retryableStatusCodes: [429, 500, 502, 503, 504] };</p>

<p>/**</p>
 <ul><li>Map HTTP status code to semantic error code</li>
</ul> *
 <ul><li>@param status - HTTP status code</li>
</ul> <ul><li>@returns Semantic error code string</li>
</ul> */
<p>function getErrorCode(status: number): string { switch (status) { case 400: return 'BAD_REQUEST'; case 401: return 'UNAUTHORIZED'; case 403: return 'FORBIDDEN'; case 404: return 'NOT_FOUND'; case 409: return 'CONFLICT'; case 422: return 'VALIDATION_ERROR'; case 429: return 'RATE_LIMIT_EXCEEDED'; case 500: return 'INTERNAL_SERVER_ERROR'; case 502: return 'BAD_GATEWAY'; case 503: return 'SERVICE_UNAVAILABLE'; case 504: return 'GATEWAY_TIMEOUT'; default: return status &gt;= 500 ? 'SERVER_ERROR' : 'CLIENT_ERROR'; } }</p>

<p>/**</p>
 <ul><li>Get user-friendly error message from HTTP error</li>
</ul> *
 <ul><li>Attempts to extract message from error response body,</li>
</ul> <ul><li>falls back to standard messages based on status code.</li>
</ul> *
 <ul><li>@param error - HTTP error response</li>
</ul> <ul><li>@returns User-friendly error message</li>
</ul> */
<p>function getErrorMessage(error: HttpErrorResponse): string { // Try to get message from nested error object if (error.error?.error?.message) { return error.error.error.message; }</p>

<p>// Try to get message from error object if (error.error?.message) { return error.error.message; }</p>

<p>// Fall back to status-based messages switch (error.status) { case 0: return 'Unable to connect to server. Please check your network connection.'; case 400: return 'Invalid request. Please check your input.'; case 401: return 'Authentication required. Please log in.'; case 403: return 'Access denied. You do not have permission to access this resource.'; case 404: return 'Resource not found.'; case 409: return 'Conflict. The resource already exists or is in an invalid state.'; case 422: return 'Validation failed. Please check your input.'; case 429: return 'Too many requests. Please wait and try again.'; case 500: return 'Internal server error. Please try again later.'; case 502: return 'Bad gateway. The server is temporarily unavailable.'; case 503: return 'Service unavailable. Please try again later.'; case 504: return 'Gateway timeout. The server took too long to respond.'; default: return error.message || <code class="inline">HTTP error: ${error.status} ${error.statusText}</code>; } }</p>

<p>/**</p>
 <ul><li>Log error details for debugging</li>
</ul> *
 <ul><li>@param error - HTTP error response</li>
</ul> <ul><li>@param request - Original HTTP request</li>
</ul> <ul><li>@param errorCode - Formatted error code</li>
</ul> <ul><li>@param errorMessage - Formatted error message</li>
</ul> */
<p>function logError( error: HttpErrorResponse, request: HttpRequest&lt;unknown&gt;, errorCode: string, errorMessage: string ): void { const logDetails = { code: errorCode, message: errorMessage, status: error.status, statusText: error.statusText, url: request.url, method: request.method, timestamp: new Date().toISOString() };</p>

<p>console.error('HTTP Error:', logDetails);</p>

<p>// Log response body for additional context if (error.error) { console.error('Error details:', error.error); } }</p>

<p>/**</p>
 <ul><li>Handle HTTP error and format response</li>
</ul> *
 <ul><li>@param error - HTTP error response</li>
</ul> <ul><li>@param request - Original HTTP request</li>
</ul> <ul><li>@returns Observable that throws formatted error</li>
</ul> */
<p>function handleError(error: HttpErrorResponse, request: HttpRequest&lt;unknown&gt;) { let errorMessage: string; let errorCode: string;</p>

<p>// Check if error is client-side (ErrorEvent) or server-side if (error.error instanceof ErrorEvent) { // Client-side error (network issue, etc.) errorCode = 'CLIENT_ERROR'; errorMessage = <code class="inline">Network error: ${error.error.message}</code>; } else { // Server-side error errorCode = getErrorCode(error.status); errorMessage = getErrorMessage(error); }</p>

<p>// Log for debugging logError(error, request, errorCode, errorMessage);</p>

<p>// Return formatted error object return throwError(() =&gt; ({ code: errorCode, message: errorMessage, status: error.status, statusText: error.statusText, url: request.url, timestamp: new Date().toISOString() })); }</p>

<p>/**</p>
 <ul><li>HTTP error interceptor</li>
</ul> *
 <ul><li>Handles global error processing for all HTTP requests:</li>
</ul> <ul><li>- Automatic retry for transient errors (5xx, 429)</li>
</ul> <ul><li>- Consistent error formatting</li>
</ul> <ul><li>- Error logging</li>
</ul> *
 <ul><li><strong>Retry Behavior:</strong></li>
</ul> *
 <ul><li>The interceptor retries failed requests up to 2 times for specific</li>
</ul> <ul><li>status codes (429, 500, 502, 503, 504). This handles transient</li>
</ul> <ul><li>failures that often succeed on retry.</li>
</ul> *
 <ul><li><strong>Error Format:</strong></li>
</ul> *
 <ul><li>All errors are transformed to a consistent format:</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>{</li>
</ul> <ul><li>  code: string;      // Semantic error code (e.g., 'UNAUTHORIZED')</li>
</ul> <ul><li>  message: string;   // User-friendly message</li>
</ul> <ul><li>  status: number;    // HTTP status code</li>
</ul> <ul><li>  statusText: string;</li>
</ul> <ul><li>  url: string;</li>
</ul> <ul><li>  timestamp: string;</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In app.module.ts</li>
</ul> <ul><li>providers: [</li>
</ul> <ul><li>  {</li>
</ul> <ul><li>    provide: HTTP_INTERCEPTORS,</li>
</ul> <ul><li>    useClass: HttpErrorInterceptor,</li>
</ul> <ul><li>    multi: true</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>]</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable() export class HttpErrorInterceptor implements HttpInterceptor { /**</p>
   <ul><li>Intercept HTTP requests and handle errors</li>
</ul>   *
   <ul><li>@param request - Outgoing HTTP request</li>
</ul>   <ul><li>@param next - HTTP handler for the next interceptor</li>
</ul>   <ul><li>@returns Observable of HTTP events</li>
</ul>   */
<p>intercept( request: HttpRequest&lt;unknown&gt;, next: HttpHandler ): Observable&lt;HttpEvent&lt;unknown&gt;&gt; { const retryConfig = DEFAULT_RETRY_CONFIG;</p>

<p>return next.handle(request).pipe( // Retry transient errors retry(retryConfig.maxRetries), // Catch and format errors catchError((error: HttpErrorResponse) =&gt; { return handleError(error, request); }) ); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 313.2: Update the Services Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 12 (Section 313) - Added HttpErrorInterceptor</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service'; export * from './popout-context.service'; export * from './popout-manager.service'; export * from './user-preferences.service'; export * from './filter-options.service'; export * from './picker-config-registry.service'; export * from './resource-management.service'; export * from './error-notification.service'; export * from './http-error.interceptor';</p>
</code></pre>

<hr>

<h3>Step 313.3: Register the Interceptor</h3>

<p>Update <code class="inline">src/app/app.module.ts</code> to register the interceptor:</p>

<pre class="code-block typescript"><code>// src/app/app.module.ts (partial - add to existing)
<p>import { HTTP_INTERCEPTORS } from '@angular/common/http'; import { HttpErrorInterceptor } from './framework/services';</p>

<p>@NgModule({ // ... providers: [ { provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: true } ], // ... }) export class AppModule { }</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/http-error.interceptor.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/http-error.interceptor.ts
</code></pre>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<h3>4. Test Error Handling</h3>

<p>Create a test that triggers an HTTP error:</p>

<pre class="code-block typescript"><code>// In any component
<p>constructor(private api: ApiService) { // Request a non-existent endpoint this.api.get('/api/non-existent-endpoint').subscribe({ next: (data) =&gt; console.log('Data:', data), error: (error) =&gt; { console.log('Caught error:', error); // Error should be formatted as: // { code: 'NOT_FOUND', message: 'Resource not found.', status: 404, ... } } }); }</p>
</code></pre></div><div class="page-content"><h3>5. Verify Retry Behavior</h3>

<p>To test retry, you can temporarily modify your API to return 503:</p>

<pre class="code-block typescript"><code>// In browser DevTools Network tab:
<p>// 1. Enable "Offline" mode briefly // 2. Watch for retry attempts in console logs // 3. See that after 2 retries, error is thrown</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Interceptor not running</td> <td>Not registered in providers</td> <td>Add HTTP_INTERCEPTORS provider to app.module.ts</td></p>
</tr>
<p><tr> <td><code class="inline">multi: true</code> missing</td> <td>Single interceptor overwrites others</td> <td>Always use <code class="inline">multi: true</code> with HTTP_INTERCEPTORS</td></p>
</tr>
<p><tr> <td>Infinite retry loop</td> <td>All errors trigger retry</td> <td>Only retry specific status codes (429, 5xx)</td></p>
</tr>
<p><tr> <td>Error format wrong</td> <td>Custom error handler</td> <td>Ensure components expect the formatted error object</td></p>
</tr>
<p><tr> <td>Retry too fast</td> <td>No exponential backoff</td> <td>Consider adding delay with <code class="inline">timer()</code> in retry</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Interceptors provide global error handling</strong> — Every HTTP request flows through the interceptor</li>
<p><li><strong>Transient errors deserve retries</strong> — 5xx and 429 errors often succeed on retry</li> <li><strong>Consistent formatting simplifies handling</strong> — Components receive the same error shape regardless of source</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/http-error.interceptor.ts</code> exists</li>
<p><li>[ ] Interceptor implements <code class="inline">HttpInterceptor</code> interface</li> <li>[ ] <code class="inline">intercept()</code> method handles requests and errors</li> <li>[ ] Retry logic attempts 2 retries for 429, 500, 502, 503, 504</li> <li>[ ] Error formatting produces consistent object shape</li> <li>[ ] Error codes map correctly (400 → BAD_REQUEST, etc.)</li> <li>[ ] User-friendly messages for each status code</li> <li>[ ] Client-side errors (ErrorEvent) handled separately</li> <li>[ ] Error logging includes request URL and method</li> <li>[ ] Interceptor registered with <code class="inline">HTTP_INTERCEPTORS</code> provider</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all functions</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">314-global-error-handler.md</code> to create the global error handler for unhandled exceptions.</p></div></div>
    <div class="chapter" id="section-314">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>314: Global Error Handler</h1>
        </div>
<div class="page-content"><h1>314: Global Error Handler</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 312-error-notification-service, 313-http-error-interceptor <strong>Blocks:</strong> Phase 8 (Framework Components)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how Angular's ErrorHandler interface works</li>
<p><li>Know how to catch unhandled exceptions globally</li> <li>Recognize different error types (HTTP, chunk load, promise rejection)</li> <li>Be able to provide user-friendly messages for JavaScript errors</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">GlobalErrorHandler</code> that catches all unhandled exceptions in the Angular application and displays user-friendly error messages using the ErrorNotificationService.</p>

<hr>

<h2>Why</h2>

<p>Errors escape individual component handlers for many reasons:</p>
<ul><li>Developers forget to add <code class="inline">.catch()</code> to promises</li>
<p><li>Observable subscriptions don't include error callbacks</li> <li>Third-party libraries throw unexpectedly</li> <li>Template expressions throw during rendering</li></p>
</ul>
<p>Without global error handling, these errors:</p>
<ul><li>Crash silently with cryptic console messages</li>
<p><li>Leave users staring at broken UIs with no feedback</li> <li>Make debugging difficult without context</li></p>
</ul>
<h3>Angular's ErrorHandler</h3>

<p>Angular provides an <code class="inline">ErrorHandler</code> class that catches all unhandled errors. By default, it just logs to console. We replace it with our <code class="inline">GlobalErrorHandler</code> that:</p>

<ul><li><strong>Categorizes errors</strong> — HTTP vs chunk load vs promise rejection vs generic</li>
<p><li><strong>Shows user feedback</strong> — Toast notifications explain what went wrong</li> <li><strong>Logs context</strong> — URL, route, stack trace for debugging</li></p>
</ul>
<h3>Error Types</h3>

<p>The global handler categorizes errors by type:</p>

<table>
<p><thead><tr> <th>Type</th> <th>Detection</th> <th>Example</th></p>
</tr></thead>
<p><tbody> <tr> <td>HTTP Error</td> <td><code class="inline">instanceof HttpErrorResponse</code></td> <td>API returned 500</td></p>
</tr>
<p><tr> <td>Chunk Load Error</td> <td>Message contains "loading chunk"</td> <td>Lazy module failed to load</td></p>
</tr>
<p><tr> <td>Promise Rejection</td> <td>Error has <code class="inline">.rejection</code> property</td> <td>Unhandled async error</td></p>
</tr>
<p><tr> <td>Generic Error</td> <td>Default</td> <td>TypeError, ReferenceError</td></p>
</tr>
</tbody>
</table>

<p>Each type gets appropriate handling:</p>

<table>
<p><thead><tr> <th>Type</th> <th>Display</th> <th>Duration</th></p>
</tr></thead>
<p><tbody> <tr> <td>HTTP Error</td> <td>Error toast</td> <td>5 seconds</td></p>
</tr>
<p><tr> <td>Chunk Load Error</td> <td>Sticky toast (requires action)</td> <td>Until dismissed</td></p>
</tr>
<p><tr> <td>Promise Rejection</td> <td>Error toast</td> <td>7 seconds</td></p>
</tr>
<p><tr> <td>Generic Error</td> <td>Sticky toast</td> <td>Until dismissed</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><h3>The Lazy-Loading Trick</h3>

<p>The GlobalErrorHandler uses Angular's <code class="inline">Injector</code> to get the <code class="inline">ErrorNotificationService</code> instead of constructor injection:</p>

<pre class="code-block typescript"><code>// Wrong - can cause circular dependency
<p>constructor(private errorNotification: ErrorNotificationService) { }</p>

<p>// Right - lazy loading via injector constructor(private injector: Injector) { }</p>

<p>private get errorNotificationService(): ErrorNotificationService { return this.injector.get(ErrorNotificationService); }</p>
</code></pre>

<p>This avoids circular dependency issues because:</p>
<ul><li>ErrorHandler is created very early in Angular's bootstrap</li>
<p><li>ErrorNotificationService may depend on services not yet created</li> <li>Lazy injection defers resolution until first use</li></p>
</ul>
<h3>Chunk Load Errors</h3>

<p>A special case is <strong>chunk load errors</strong> — when lazy-loaded modules fail to load:</p>

<pre class="code-block text"><code>Error: Loading chunk 5 failed.
</code></pre>

<p>These typically happen when:</p>
<ul><li>Network connection drops during navigation</li>
<p><li>Server deployment changed chunk hashes</li> <li>Browser cache serves stale chunk</li></p>
</ul>
<p>The handler shows a sticky message prompting the user to refresh.</p>

<hr>

<h2>What</h2>

<h3>Step 314.1: Create the Global Error Handler</h3>

<p>Create the file <code class="inline">src/app/framework/services/global-error.handler.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/services/global-error.handler.ts
<p>// VERSION 1 (Section 314) - Global error handler</p>

<p>import { ErrorHandler, Injectable, Injector } from '@angular/core'; import { HttpErrorResponse } from '@angular/common/http'; import { ErrorNotificationService } from './error-notification.service'; import { ErrorCategory } from '../models/error-notification.interface';</p>

<p>/**</p>
 <ul><li>Global error handler</li>
</ul> *
 <ul><li>Catches all unhandled errors in the Angular application and displays</li>
</ul> <ul><li>user-friendly error messages using the ErrorNotificationService.</li>
</ul> *
 <ul><li>This handler:</li>
</ul> <ul><li>- Intercepts all unhandled exceptions</li>
</ul> <ul><li>- Categorizes errors by type (HTTP, Promise rejection, component error, etc.)</li>
</ul> <ul><li>- Displays appropriate user-facing messages</li>
</ul> <ul><li>- Logs detailed error information for debugging</li>
</ul> *
 <ul><li><strong>Why Lazy Injection?</strong></li>
</ul> *
 <ul><li>Uses Injector.get() instead of constructor injection to avoid circular</li>
</ul> <ul><li>dependency issues. ErrorHandler is created very early in Angular's</li>
</ul> <ul><li>bootstrap process, before some services are fully initialized.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In app.module.ts</li>
</ul> <ul><li>providers: [</li>
</ul> <ul><li>  {</li>
</ul> <ul><li>    provide: ErrorHandler,</li>
</ul> <ul><li>    useClass: GlobalErrorHandler</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>]</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable() export class GlobalErrorHandler implements ErrorHandler { /**</p>
   <ul><li>ErrorNotificationService instance</li>
</ul>   *
   <ul><li>Lazy-loaded via getter to avoid circular dependency issues.</li>
</ul>   <ul><li>Service is requested from injector on first access.</li>
</ul>   */
<p>private get errorNotificationService(): ErrorNotificationService { return this.injector.get(ErrorNotificationService); }</p>

<p>/**</p>
   <ul><li>Constructor with injector for lazy service loading</li>
</ul>   *
   <ul><li>@param injector - Angular injector for lazy-loading services</li>
</ul>   */
<p>constructor(private injector: Injector) {}</p>

<p>/**</p>
   <ul><li>Handle error</li>
</ul>   *
   <ul><li>Main error handling method called by Angular for all unhandled errors</li>
</ul>   *
   <ul><li>@param error - The error object</li>
</ul>   */
<p>handleError(error: any): void { // Extract actual error from Angular's wrapper const actualError = this.unwrapError(error);</p>

<p>// Log to console for debugging this.logErrorToConsole(actualError);</p>

<p>// Handle different error types if (this.isHttpError(actualError)) { this.handleHttpError(actualError); } else if (this.isChunkLoadError(actualError)) { this.handleChunkLoadError(actualError); } else if (this.isPromiseRejection(error)) { this.handlePromiseRejection(actualError); } else { this.handleGenericError(actualError); } }</p>

<p>/**</p>
   <ul><li>Unwrap error from Angular's ErrorEvent wrapper</li>
</ul>   *
   <ul><li>Angular sometimes wraps errors in objects with <code class="inline">.rejection</code> or <code class="inline">.error</code></li>
</ul>   <ul><li>properties. This extracts the actual error object.</li>
</ul>   *
   <ul><li>@param error - Potentially wrapped error</li>
</ul>   <ul><li>@returns Actual error object</li>
</ul>   */
<p>private unwrapError(error: any): any { // Angular wraps promise rejections in rejection field if (error &amp;&amp; error.rejection) { return error.rejection; }</p>

<p>// Angular wraps errors in error field if (error &amp;&amp; error.error) { return error.error; }</p>

<p>return error; }</p>

<p>/**</p>
   <ul><li>Check if error is HTTP error</li>
</ul>   *
   <ul><li>@param error - Error object</li>
</ul>   <ul><li>@returns True if HTTP error</li>
</ul>   */
<p>private isHttpError(error: any): boolean { return error instanceof HttpErrorResponse; }</p>

<p>/**</p>
   <ul><li>Check if error is chunk load error (lazy-loaded module)</li>
</ul>   *
   <ul><li>Chunk load errors occur when lazy-loaded JavaScript files fail to load.</li>
</ul>   <ul><li>This typically happens due to network issues or server deployments</li>
</ul>   <ul><li>that change chunk hashes.</li>
</ul>   *
   <ul><li>@param error - Error object</li>
</ul>   <ul><li>@returns True if chunk load error</li>
</ul>   */
<p>private isChunkLoadError(error: any): boolean { if (!(error instanceof Error)) { return false; }</p>

<p>const message = error.message.toLowerCase(); return ( message.includes('loading chunk') || message.includes('failed to fetch') || message.includes('dynamically imported module') ); }</p>

<p>/**</p>
   <ul><li>Check if error is promise rejection</li>
</ul>   *
   <ul><li>@param error - Error object</li>
</ul>   <ul><li>@returns True if promise rejection</li>
</ul>   */
<p>private isPromiseRejection(error: any): boolean { return error &amp;&amp; error.promise &amp;&amp; error.rejection; }</p>

<p>/**</p>
   <ul><li>Handle HTTP errors</li>
</ul>   *
   <ul><li>HTTP errors are already handled by the HTTP interceptor, but may</li>
</ul>   <ul><li>bubble up if not caught in component subscriptions.</li>
</ul>   *
   <ul><li>@param error - HTTP error response</li>
</ul>   */
<p>private handleHttpError(error: HttpErrorResponse): void { // Check if error was already formatted by interceptor if (error.error &amp;&amp; error.error.code) { // Already formatted by interceptor this.errorNotificationService.showHttpError(error.error); } else { // Not formatted - format now this.errorNotificationService.showHttpError({ code: 'HTTP_ERROR', message: error.message || 'An HTTP error occurred', status: error.status, statusText: error.statusText, url: error.url || undefined, timestamp: new Date().toISOString() }); } }</p>

<p>/**</p>
   <ul><li>Handle chunk load errors (lazy-loaded modules)</li>
</ul>   *
   <ul><li>These occur when lazy-loaded JavaScript chunks fail to load,</li>
</ul>   <ul><li>typically due to network issues or deployments.</li>
</ul>   *
   <ul><li>Shows a sticky toast prompting the user to refresh.</li>
</ul>   *
   <ul><li>@param error - Chunk load error</li>
</ul>   */
<p>private handleChunkLoadError(error: Error): void { this.errorNotificationService.show( { category: ErrorCategory.NETWORK, severity: 'error', summary: 'Loading Error', detail: 'Failed to load application module. Please refresh the page. ' + 'If the problem persists, clear your browser cache.', code: 'CHUNK_LOAD_ERROR', timestamp: new Date().toISOString(), originalError: error }, { sticky: true, // Don't auto-hide - requires user action life: 0 } ); }</p>

<p>/**</p>
   <ul><li>Handle promise rejections</li>
</ul>   *
   <ul><li>Unhandled promise rejections that weren't caught with .catch()</li>
</ul>   *
   <ul><li>@param error - Rejected promise value</li>
</ul>   */
<p>private handlePromiseRejection(error: any): void { // If it's an HTTP error, handle as HTTP if (this.isHttpError(error)) { this.handleHttpError(error); return; }</p>

<p>// Generic promise rejection this.errorNotificationService.show( { category: ErrorCategory.APPLICATION, severity: 'error', summary: 'Operation Failed', detail: error?.message || 'An asynchronous operation failed. Please try again.', code: 'PROMISE_REJECTION', timestamp: new Date().toISOString(), originalError: error }, { life: 7000 // Longer display for async errors } ); }</p>

<p>/**</p>
   <ul><li>Handle generic errors</li>
</ul>   *
   <ul><li>All other unhandled errors (component errors, TypeError, etc.)</li>
</ul>   *
   <ul><li>Shows a sticky toast for serious programming errors.</li>
</ul>   *
   <ul><li>@param error - Error object</li>
</ul>   */
<p>private handleGenericError(error: any): void { const errorMessage = error?.message || error?.toString() || 'An unexpected error occurred';</p>

<p>// Check for known error patterns const isTypeError = error instanceof TypeError; const isReferenceError = error instanceof ReferenceError;</p>

<p>let detail = errorMessage; if (isTypeError || isReferenceError) { detail += ' This is likely a programming error. Please report this issue.'; }</p>

<p>this.errorNotificationService.show( { category: ErrorCategory.CLIENT, severity: 'error', summary: 'Application Error', detail, code: 'UNHANDLED_ERROR', timestamp: new Date().toISOString(), originalError: error }, { sticky: true, // Keep visible for debugging life: 0 } ); }</p>

<p>/**</p>
   <ul><li>Log error to console for debugging</li>
</ul>   *
   <ul><li>Groups error information for easier debugging in DevTools.</li>
</ul>   *
   <ul><li>@param error - Error object</li>
</ul>   */
<p>private logErrorToConsole(error: any): void { const timestamp = new Date().toISOString();</p>

<p>console.group(<code class="inline">[Global Error Handler] ${timestamp}</code>); console.error('Error caught by global handler:', error);</p>

<p>// Log stack trace if available if (error instanceof Error &amp;&amp; error.stack) { console.error('Stack trace:', error.stack); }</p>

<p>// Log additional context console.error('Error type:', error?.constructor?.name || typeof error);</p>

<p>// Log location information console.error('Location:', { url: window.location.href, route: window.location.pathname });</p>

<p>console.groupEnd(); } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 314.2: Update the Services Barrel File</h3>

<p>Update <code class="inline">src/app/framework/services/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/services/index.ts
<p>// VERSION 13 (Section 314) - Added GlobalErrorHandler</p>

<p>export * from './url-state.service'; export * from './api.service'; export * from './request-coordinator.service'; export * from './domain-config-registry.service'; export * from './domain-config-validator.service'; export * from './popout-context.service'; export * from './popout-manager.service'; export * from './user-preferences.service'; export * from './filter-options.service'; export * from './picker-config-registry.service'; export * from './resource-management.service'; export * from './error-notification.service'; export * from './http-error.interceptor'; export * from './global-error.handler';</p>
</code></pre>

<hr>

<h3>Step 314.3: Register the Global Error Handler</h3>

<p>Update <code class="inline">src/app/app.module.ts</code> to register the handler:</p>

<pre class="code-block typescript"><code>// src/app/app.module.ts (partial - add to existing)
<p>import { ErrorHandler } from '@angular/core'; import { GlobalErrorHandler } from './framework/services';</p>

<p>@NgModule({ // ... providers: [ { provide: ErrorHandler, useClass: GlobalErrorHandler } ], // ... }) export class AppModule { }</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/services/global-error.handler.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/services/global-error.handler.ts
</code></pre>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<h3>4. Test Unhandled Error</h3>

<p>Add temporary code to throw an error:</p>

<pre class="code-block typescript"><code>// In any component ngOnInit
<p>ngOnInit(): void { // Uncomment to test - should show sticky toast // throw new Error('Test unhandled error'); }</p>
</code></pre>

<h3>5. Test Promise Rejection</h3>

<pre class="code-block typescript"><code>// In any component
<p>ngOnInit(): void { // Uncomment to test - should show error toast // Promise.reject(new Error('Test promise rejection')); }</p>
</code></pre>

<h3>6. Test Chunk Load Error</h3>

<p>Simulate by modifying the error check temporarily, or:</p>
<ul><li>Build the application</li>
<p><li>Delete a chunk file from dist</li> <li>Navigate to the route that loads that chunk</li></ul></p></div><div class="page-content"><h3>7. Verify Console Logging</h3>

<p>When an error is caught, check the browser console for grouped log output:</p>

<pre class="code-block text"><code>▼ [Global Error Handler] 2024-02-09T12:00:00.000Z
<p>Error caught by global handler: Error: Test error Stack trace: Error: Test error at Component.ngOnInit (component.ts:15) ... Error type: Error Location: {url: "http://localhost:4200/discover", route: "/discover"}</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Circular dependency error</td> <td>ErrorHandler created too early</td> <td>Use <code class="inline">Injector.get()</code> instead of constructor injection</td></p>
</tr>
<p><tr> <td>No toast appears</td> <td>ErrorNotificationService not provided</td> <td>Ensure MessageService is in app.module.ts providers</td></p>
</tr>
<p><tr> <td>Error handled twice</td> <td>HTTP interceptor + global handler</td> <td>Check if error already formatted (has <code class="inline">.code</code> property)</td></p>
</tr>
<p><tr> <td>Console shows "NullInjectorError"</td> <td>Service not available</td> <td>Ensure all dependencies are provided</td></p>
</tr>
<p><tr> <td>Chunk load error not detected</td> <td>Message pattern changed</td> <td>Update <code class="inline">isChunkLoadError()</code> detection patterns</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Global error handling catches everything</strong> — Even errors developers forgot to handle</li>
<p><li><strong>Lazy injection avoids circular dependencies</strong> — Use <code class="inline">Injector.get()</code> for early-loaded services</li> <li><strong>Error categorization enables appropriate responses</strong> — Chunk errors need refresh, promise errors need retry</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/services/global-error.handler.ts</code> exists</li>
<p><li>[ ] Handler extends Angular's <code class="inline">ErrorHandler</code> interface</li> <li>[ ] <code class="inline">handleError()</code> method catches all unhandled errors</li> <li>[ ] HTTP errors detected and formatted</li> <li>[ ] Chunk load errors show sticky refresh prompt</li> <li>[ ] Promise rejections handled with 7-second display</li> <li>[ ] Generic errors show sticky toast</li> <li>[ ] Console logging includes stack trace and location</li> <li>[ ] Lazy injection via <code class="inline">Injector.get()</code> to avoid circular deps</li> <li>[ ] Handler registered with <code class="inline">provide: ErrorHandler</code> in app.module.ts</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document all methods</li></ul></p></div><div class="page-content"><hr>

<h2>Phase 3C Complete</h2>

<p>Congratulations! You have completed Phase 3C: Error Handling.</p>

<p><strong>What you built:</strong></p>
<ul><li>ErrorNotification interface — Error categorization and display types</li>
<p><li>ErrorNotificationService — Centralized toast notifications with deduplication</li> <li>HttpErrorInterceptor — Automatic retry and consistent error formatting</li> <li>GlobalErrorHandler — Catch-all for unhandled exceptions</li></p>
</ul>
<p><strong>The Aha Moment:</strong> "Errors are inevitable. User-friendly error messages are not."</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">315-popout-token.md</code> to create the injection token for pop-out window detection.</p></div></div>
    <div class="chapter" id="section-315">
        <div class="chapter-header">
            <div class="chapter-category">Services</div>
            <h1>315: Popout Token</h1>
        </div>
<div class="page-content"><h1>315: Pop-Out Token</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 307-popout-context-service <strong>Blocks:</strong> Phase 8 (Framework Components)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how Angular injection tokens work</li>
<p><li>Know when to use tokens vs services for dependency injection</li> <li>Recognize the benefits of compile-time constants for environment detection</li> <li>Be able to create and provide injection tokens</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">IS_POPOUT_TOKEN</code> injection token that provides a boolean indicating whether the current window is a pop-out window. This token is used throughout the application to conditionally render components and enable/disable features based on pop-out context.</p>

<hr>

<h2>Why</h2>

<p>Pop-out windows need to behave differently from the main window:</p>

<table>
<p><thead><tr> <th>Behavior</th> <th>Main Window</th> <th>Pop-Out Window</th></p>
</tr></thead>
<p><tbody> <tr> <td>Navigation header</td> <td>Shown</td> <td>Hidden</td></p>
</tr>
<p><tr> <td>Pop-out buttons</td> <td>Enabled</td> <td>Disabled (already popped out)</td></p>
</tr>
<p><tr> <td>Close button</td> <td>Hidden</td> <td>Shown</td></p>
</tr>
<p><tr> <td>State sync</td> <td>Source</td> <td>Receiver</td></p>
</tr>
</tbody>
</table>

<p>Components need to know "Am I in a pop-out?" to adjust their behavior.</p>

<h3>Option 1: Call a Service Method</h3>

<pre class="code-block typescript"><code>// In every component
<p>constructor(private popoutContext: PopOutContextService) {}</p>

<p>get isPopOut(): boolean { return this.popoutContext.isInPopOut(); }</p>
</code></pre>

<p>Problem: Every component needs to inject the service and call the method.</p>

<h3>Option 2: Use an Injection Token (Our Approach)</h3>

<pre class="code-block typescript"><code>// In any component
<p>constructor(@Inject(IS_POPOUT_TOKEN) public isPopOut: boolean) {}</p>
</code></pre>

<p>Benefits:</p>
<ul><li><strong>Simpler injection</strong> — Just inject the boolean directly</li>
<p><li><strong>Compile-time constant</strong> — Value determined once at bootstrap</li> <li><strong>Template-friendly</strong> — Use directly in templates: <code class="inline">*ngIf="!isPopOut"</code></li> <li><strong>Testable</strong> — Easy to provide different values in tests</li></p>
</ul>
<h3>How It Works</h3>

<ul><li><strong>At bootstrap</strong>, the router URL is checked for <code class="inline">/popout/</code> prefix</li>
<p><li><strong>A factory function</strong> returns <code class="inline">true</code> or <code class="inline">false</code></li> <li><strong>The token is provided</strong> at root level with this value</li> <li><strong>Components inject</strong> the token to get the boolean</li></p>
</ul>
<pre class="code-block typescript"><code>// Factory determines value once
<p>export function isPopOutFactory(router: Router): boolean { return router.url.includes('/popout/'); }</p>

<p>// Provided at root { provide: IS_POPOUT_TOKEN, useFactory: isPopOutFactory, deps: [Router] }</p>

<p>// Injected in component constructor(@Inject(IS_POPOUT_TOKEN) private isPopOut: boolean) { if (this.isPopOut) { // Pop-out specific behavior } }</p>
</code></pre></div><div class="page-content"><h3>Injection Token vs Service</h3>

<table>
<p><thead><tr> <th>Feature</th> <th>Injection Token</th> <th>Service</th></p>
</tr></thead>
<p><tbody> <tr> <td>Value type</td> <td>Primitive (boolean, string, etc.)</td> <td>Object with methods</td></p>
</tr>
<p><tr> <td>Computed</td> <td>Once at creation</td> <td>Can change over time</td></p>
</tr>
<p><tr> <td>Dependencies</td> <td>Via factory function</td> <td>Via constructor</td></p>
</tr>
<p><tr> <td>Use case</td> <td>Static configuration</td> <td>Dynamic behavior</td></p>
</tr>
</tbody>
</table>

<p>For "is this a pop-out?", an injection token is ideal because:</p>
<ul><li>The answer never changes during the window's lifetime</li>
<p><li>It's a simple boolean, not a complex object</li> <li>Components just need to read it, not call methods</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 315.1: Create the Tokens Directory</h3>

<p>Create the tokens directory and barrel file.</p>

<p>Create <code class="inline">src/app/framework/tokens/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/tokens/index.ts
<p>// VERSION 1 (Section 315) - Framework injection tokens</p>

<p>export * from './popout.token';</p>
</code></pre>

<hr>

<h3>Step 315.2: Create the Pop-Out Token</h3>

<p>Create the file <code class="inline">src/app/framework/tokens/popout.token.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/tokens/popout.token.ts
<p>// VERSION 1 (Section 315) - Pop-out window detection token</p>

<p>import { InjectionToken } from '@angular/core';</p>

<p>/**</p>
 <ul><li>Injection token for pop-out window detection</li>
</ul> *
 <ul><li>Provides a boolean indicating whether the current window is a pop-out window.</li>
</ul> <ul><li>This value is determined once at bootstrap based on the URL and never changes.</li>
</ul> *
 <ul><li><strong>Usage:</strong></li>
</ul> *
 <ul><li></code></pre>typescript</li>
</ul> <ul><li>constructor(@Inject(IS_POPOUT_TOKEN) public isPopOut: boolean) {}</li>
</ul> <em> <pre class="code-block text"><code> </em>
 <ul><li><strong>In Templates:</strong></li>
</ul> *
 <ul><li></code></pre>html</li>
</ul> <em> &lt;nav </em>ngIf="!isPopOut"&gt;Main navigation&lt;/nav&gt;
<p><em> &lt;button </em>ngIf="isPopOut" (click)="close()"&gt;Close&lt;/button&gt; <em> <pre class="code-block text"><code> </em></p>
 <ul><li><strong>Providing the Token:</strong></li>
</ul> *
 <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In app.module.ts</li>
</ul> <ul><li>{</li>
</ul> <ul><li>  provide: IS_POPOUT_TOKEN,</li>
</ul> <ul><li>  useFactory: () =&gt; window.location.pathname.includes('/popout/')</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const IS_POPOUT_TOKEN = new InjectionToken&lt;boolean&gt;('IS_POPOUT_TOKEN');</p>
</code></pre>

<hr>

<h3>Step 315.3: Create the Factory Function</h3>

<p>Add a factory function to provide the token value. Update <code class="inline">src/app/framework/tokens/popout.token.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/tokens/popout.token.ts
<p>// VERSION 2 (Section 315) - Added factory function</p>

<p>import { InjectionToken } from '@angular/core';</p>

<p>/**</p>
 <ul><li>Injection token for pop-out window detection</li>
</ul> *
 <ul><li>Provides a boolean indicating whether the current window is a pop-out window.</li>
</ul> <ul><li>This value is determined once at bootstrap based on the URL and never changes.</li>
</ul> *
 <ul><li><strong>Usage:</strong></li>
</ul> *
 <ul><li></code></pre>typescript</li>
</ul> <ul><li>constructor(@Inject(IS_POPOUT_TOKEN) public isPopOut: boolean) {}</li>
</ul> <em> <pre class="code-block text"><code> </em>
 <ul><li><strong>In Templates:</strong></li>
</ul> *
 <ul><li></code></pre>html</li>
</ul> <em> &lt;nav </em>ngIf="!isPopOut"&gt;Main navigation&lt;/nav&gt;
<p><em> &lt;button </em>ngIf="isPopOut" (click)="close()"&gt;Close&lt;/button&gt; <em> <pre class="code-block text"><code> </em>/ export const IS_POPOUT_TOKEN = new InjectionToken&lt;boolean&gt;('IS_POPOUT_TOKEN');</p>

<p>/**</p>
 <ul><li>Factory function to determine if current window is a pop-out</li>
</ul> *
 <ul><li>Checks the current URL pathname for the <code class="inline">/popout/</code> prefix.</li>
</ul> <ul><li>This is called once during application bootstrap.</li>
</ul> *
 <ul><li>@returns True if the current window is a pop-out window</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// In app.module.ts</li>
</ul> <ul><li>{</li>
</ul> <ul><li>  provide: IS_POPOUT_TOKEN,</li>
</ul> <ul><li>  useFactory: isPopOutFactory</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export function isPopOutFactory(): boolean { // Check URL for popout prefix // Pop-out routes follow pattern: /popout/:panelId/:viewType return window.location.pathname.includes('/popout/'); }</p>

<p>/**</p>
 <ul><li>Provider configuration for IS_POPOUT_TOKEN</li>
</ul> *
 <ul><li>Use this in your app.module.ts providers array.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>import { IS_POPOUT_PROVIDER } from './framework/tokens';</li>
</ul> *
 <ul><li>@NgModule({</li>
</ul> <ul><li>  providers: [IS_POPOUT_PROVIDER]</li>
</ul> <ul><li>})</li>
</ul> <ul><li>export class AppModule { }</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const IS_POPOUT_PROVIDER = { provide: IS_POPOUT_TOKEN, useFactory: isPopOutFactory };</p>
</code></pre>

<hr>

<h3>Step 315.4: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/framework/tokens/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/tokens/index.ts
<p>// VERSION 1 (Section 315) - Framework injection tokens</p>

<p>export * from './popout.token';</p>
</code></pre>

<hr>

<h3>Step 315.5: Register the Provider</h3>

<p>Update <code class="inline">src/app/app.module.ts</code> to provide the token:</p>

<pre class="code-block typescript"><code>// src/app/app.module.ts (partial - add to existing)
<p>import { IS_POPOUT_PROVIDER } from './framework/tokens';</p>

<p>@NgModule({ // ... providers: [ IS_POPOUT_PROVIDER // ... other providers ], // ... }) export class AppModule { }</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check Files Exist</h3>

<pre class="code-block bash"><code>$ ls -la src/app/framework/tokens/
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>total 12
<p>drwxr-xr-x 2 user user 4096 Feb  9 12:00 . drwxr-xr-x 5 user user 4096 Feb  9 12:00 .. -rw-r--r-- 1 user user  123 Feb  9 12:00 index.ts -rw-r--r-- 1 user user 1456 Feb  9 12:00 popout.token.ts</p>
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/framework/tokens/popout.token.ts
</code></pre>

<h3>3. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<h3>4. Test Token Injection</h3>

<p>Add temporary test code:</p>

<pre class="code-block typescript"><code>// In any component
<p>import { Inject } from '@angular/core'; import { IS_POPOUT_TOKEN } from './framework/tokens';</p>

<p>@Component({...}) export class TestComponent { constructor(@Inject(IS_POPOUT_TOKEN) private isPopOut: boolean) { console.log('Is pop-out window:', this.isPopOut); } }</p>
</code></pre>

<h3>5. Verify Pop-Out Detection</h3>

<ul><li>Navigate to <code class="inline">http://localhost:4200/discover</code> → Console shows <code class="inline">false</code></li>
<p><li>Navigate to <code class="inline">http://localhost:4200/popout/panel-1/chart</code> → Console shows <code class="inline">true</code></li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">NullInjectorError: No provider for IS_POPOUT_TOKEN</code></td> <td>Token not provided</td> <td>Add <code class="inline">IS_POPOUT_PROVIDER</code> to app.module.ts</td></p>
</tr>
<p><tr> <td>Token always <code class="inline">false</code></td> <td>URL checked before navigation</td> <td>Factory uses <code class="inline">window.location.pathname</code>, not Router</td></p>
</tr>
<p><tr> <td>Token value changes</td> <td>Token recreated per component</td> <td>Ensure <code class="inline">providedIn: 'root'</code> behavior via app.module.ts</td></p>
</tr>
<p><tr> <td>TypeScript error on <code class="inline">@Inject</code></td> <td>Missing import</td> <td>Import <code class="inline">Inject</code> from <code class="inline">@angular/core</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Injection tokens provide primitive values</strong> — Use when you need a simple value, not a service</li>
<p><li><strong>Factory functions compute values once</strong> — The pop-out check runs at bootstrap only</li> <li><strong>Tokens simplify component code</strong> — No service method calls, just inject the boolean</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/framework/tokens/popout.token.ts</code> exists</li>
<p><li>[ ] <code class="inline">IS_POPOUT_TOKEN</code> defined as <code class="inline">InjectionToken&lt;boolean&gt;</code></li> <li>[ ] <code class="inline">isPopOutFactory()</code> function returns boolean based on URL</li> <li>[ ] <code class="inline">IS_POPOUT_PROVIDER</code> object ready for app.module.ts</li> <li>[ ] Barrel file exports all token-related items</li> <li>[ ] Token correctly detects <code class="inline">/popout/</code> in URL pathname</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments document usage patterns</li></ul></p></div><div class="page-content"><hr>

<h2>Phase 3 Complete</h2>

<p>Congratulations! You have completed Phase 3: Framework Services.</p>

<p><strong>What you built:</strong></p>

<p><strong>Phase 3A - Core Services:</strong></p>
<ul><li>UrlStateService — URL-First state management</li>
<p><li>ApiService — HTTP request wrapper</li> <li>RequestCoordinatorService — Cache, deduplication, retry</li> <li>DomainConfigRegistry — Domain configuration storage</li> <li>DomainConfigValidator — Runtime configuration validation</li> <li>ResourceManagementService — Core state orchestrator</li></p>
</ul>
<p><strong>Phase 3B - Popout &amp; Specialized Services:</strong></p>
<ul><li>PopOutContextService — Pop-out window detection</li>
<p><li>PopOutManagerService — Pop-out window management</li> <li>UserPreferencesService — localStorage preferences</li> <li>FilterOptionsService — Filter dropdown caching</li> <li>PickerConfigRegistry — Picker configuration lookup</li></p>
</ul>
<p><strong>Phase 3C - Error Handling:</strong></p>
<ul><li>ErrorNotificationService — Toast notifications with deduplication</li>
<p><li>HttpErrorInterceptor — Automatic retry and error formatting</li> <li>GlobalErrorHandler — Catch-all for unhandled exceptions</li> <li>IS_POPOUT_TOKEN — Pop-out window detection token</li></p>
</ul>
<p><strong>The Aha Moment:</strong> "Services are the nervous system of the application. They coordinate state, handle errors, and enable features to work together seamlessly."</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">401-base-model-interface.md</code> to begin Phase 4: Domain Models.</p></div></div>
    <div class="chapter" id="section-401">
        <div class="chapter-header">
            <div class="chapter-category">Models</div>
            <h1>401: Base Model Interface</h1>
        </div>
<div class="page-content"><h1>401: Base Model Interface</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 402-domain-data-models, 403-domain-filter-statistics-models</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand why domain models use classes instead of interfaces</li>
<p><li>Know how to implement the class-with-partial-constructor pattern</li> <li>Recognize the benefits of <code class="inline">fromApiResponse()</code> static factory methods</li> <li>Be able to create domain-agnostic base patterns for data models</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Establish the base patterns for domain data models that all specific domain models will follow. This section defines the conventions for creating type-safe, API-aware data classes.</p>

<hr>

<h2>Why</h2>

<p>Domain models represent the data your application works with. In Vvroom, the primary domain is <strong>automobiles</strong> — vehicles, manufacturers, models, body classes, and VIN instances.</p>

<h3>The Interface vs Class Decision</h3>

<p>TypeScript offers two ways to define data shapes:</p>

<p><strong>Interfaces:</strong></p>
<pre class="code-block typescript"><code>interface Vehicle {
<p>vehicle_id: string; manufacturer: string; model: string; year: number; }</p>
</code></pre>

<p><strong>Classes:</strong></p>
<pre class="code-block typescript"><code>class Vehicle {
<p>vehicle_id!: string; manufacturer!: string; model!: string; year!: number; }</p>
</code></pre>

<p>At first glance, interfaces seem simpler. But classes provide crucial advantages:</p>

<table>
<p><thead><tr> <th>Feature</th> <th>Interface</th> <th>Class</th></p>
</tr></thead>
<p><tbody> <tr> <td>Runtime existence</td> <td>No (erased)</td> <td>Yes</td></p>
</tr>
<p><tr> <td>Methods</td> <td>No</td> <td>Yes</td></p>
</tr>
<p><tr> <td>Computed properties</td> <td>No</td> <td>Yes (getters)</td></p>
</tr>
<p><tr> <td>Factory methods</td> <td>No</td> <td>Yes (static)</td></p>
</tr>
<p><tr> <td>Type guard with <code class="inline">instanceof</code></td> <td>No</td> <td>Yes</td></p>
</tr>
<p><tr> <td>Partial initialization</td> <td>Manual</td> <td>Constructor pattern</td></p>
</tr>
<p><tr> <td>API transformation</td> <td>External function</td> <td><code class="inline">fromApiResponse()</code></td></p>
</tr>
</tbody>
</table>

<p>For domain models that need methods, transformation logic, and computed properties, classes are the better choice.</p>

<h3>The Partial Constructor Pattern</h3>

<p>Domain models often come from APIs with varied data. The partial constructor pattern handles this:</p>

<pre class="code-block typescript"><code>class Vehicle {
<p>vehicle_id!: string; manufacturer!: string; model!: string; year!: number;</p>

<p>constructor(partial?: Partial&lt;Vehicle&gt;) { if (partial) { Object.assign(this, partial); } } }</p>
</code></pre>

<p>Benefits:</p>
<ul><li><strong>Optional initialization</strong> — Create empty instances or full ones</li>
<p><li><strong>Flexible merging</strong> — <code class="inline">new Vehicle({ ...existing, year: 2024 })</code></li> <li><strong>Type safety</strong> — <code class="inline">Partial&lt;Vehicle&gt;</code> ensures only valid properties</li> <li><strong>IDE support</strong> — Autocomplete works for constructor params</li></ul></p></div><div class="page-content"><h3>The Static Factory Pattern</h3>

<p>APIs often return data with different field naming conventions:</p>

<pre class="code-block json"><code>{
<p>"vehicle_id": "TOY-CAM-2024", "manufacturer": "Toyota", "model_year": 2024, "body_class": "Sedan" }</p>
</code></pre>

<p>The <code class="inline">fromApiResponse()</code> static method handles transformation:</p>

<pre class="code-block typescript"><code>class Vehicle {
<p>// ...</p>

<p>static fromApiResponse(data: any): Vehicle { return new Vehicle({ vehicle_id: data.vehicle_id || data.id, manufacturer: data.manufacturer, model: data.model, year: Number(data.model_year || data.year), body_class: data.body_class || data.bodyClass }); } }</p>
</code></pre>

<p>Benefits:</p>
<ul><li><strong>Single transformation point</strong> — All API normalization in one place</li>
<p><li><strong>Handles both formats</strong> — <code class="inline">model_year</code> and <code class="inline">year</code> both work</li> <li><strong>Type coercion</strong> — <code class="inline">Number()</code> ensures numeric types</li> <li><strong>Testable</strong> — Easy to unit test transformation logic</li></p>
</ul>
<h3>Instance Methods for Computed Values</h3>

<p>Classes can include methods for computed values:</p>

<pre class="code-block typescript"><code>class Vehicle {
<p>// ...</p>

<p>getDisplayName(): string { return <code class="inline">${this.manufacturer} ${this.model} ${this.year}</code>; }</p>

<p>getAge(): number { return new Date().getFullYear() - this.year; }</p>

<p>isCurrentYear(): boolean { return this.year === new Date().getFullYear(); } }</p>
</code></pre>

<p>This encapsulates business logic in the model itself, making it reusable across components.</p>

<hr>

<h2>What</h2>

<h3>Step 401.1: Establish Model Conventions</h3>

<p>Before creating specific models, establish the patterns all domain models will follow.</p>

<p><strong>Convention 1: Class with Non-Null Assertion</strong></p>

<p>Use <code class="inline">!</code> for required properties to indicate they will be set:</p>

<pre class="code-block typescript"><code>class Model {
<p>required_field!: string;  // Will be set by constructor optional_field?: number;  // May or may not be set }</p>
</code></pre>

<p><strong>Convention 2: Partial Constructor</strong></p>

<p>Every model class has a partial constructor:</p>

<pre class="code-block typescript"><code>constructor(partial?: Partial&lt;ModelClass&gt;) {
<p>if (partial) { Object.assign(this, partial); } }</p>
</code></pre>

<p><strong>Convention 3: Static Factory Method</strong></p>

<p>Models that come from APIs have <code class="inline">fromApiResponse()</code>:</p>

<pre class="code-block typescript"><code>static fromApiResponse(data: any): ModelClass {
<p>return new ModelClass({ // Map API fields to class properties }); }</p>
</code></pre>

<p><strong>Convention 4: Display Methods</strong></p>

<p>Models with display requirements have getter methods:</p>

<pre class="code-block typescript"><code>getDisplayName(): string { ... }
<p>getFullDescription(): string { ... }</p>
</code></pre>

<p><strong>Convention 5: JSDoc Documentation</strong></p>

<p>Every property and method has JSDoc:</p>

<pre class="code-block typescript"><code>/**
 <ul><li>Vehicle manufacturer name</li>
</ul> *
 <ul><li>@example 'Toyota', 'Honda', 'Ford'</li>
</ul> */
<p>manufacturer!: string;</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 401.2: Create the Domain Models Directory</h3>

<p>Create the directory structure for automobile domain models.</p>

<pre class="code-block bash"><code>$ mkdir -p src/app/domains/automobile/models
<p>$ touch src/app/domains/automobile/models/index.ts</p>
</code></pre>

<p>Create the barrel file <code class="inline">src/app/domains/automobile/models/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domains/automobile/models/index.ts
<p>// VERSION 1 (Section 401) - Automobile domain models barrel</p>

<p>// Data models (Section 402) // export * from './automobile.data';</p>

<p>// Filter and statistics models (Section 403) // export * from './automobile.filters'; // export * from './automobile.statistics';</p>
</code></pre>

<hr>

<h3>Step 401.3: Document the Model Pattern</h3>

<p>Create a reference document showing the complete model pattern.</p>

<p>The complete model pattern looks like this:</p>

<pre class="code-block typescript"><code>/**
 <ul><li>[Model Name]</li>
</ul> *
 <ul><li>[Description of what this model represents]</li>
</ul> *
 <ul><li>Domain: [Domain Name]</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const instance: ModelClass = {</li>
</ul> <ul><li>  field1: 'value1',</li>
</ul> <ul><li>  field2: 123</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export class ModelClass { /**</p>
   <ul><li>[Field description]</li>
</ul>   *
   <ul><li>@example 'example value'</li>
</ul>   */
<p>field1!: string;</p>

<p>/**</p>
   <ul><li>[Optional field description]</li>
</ul>   *
   <ul><li>@example 123</li>
</ul>   */
<p>field2?: number;</p>

<p>/**</p>
   <ul><li>Constructor with partial data</li>
</ul>   *
   <ul><li>@param partial - Partial ModelClass object</li>
</ul>   */
<p>constructor(partial?: Partial&lt;ModelClass&gt;) { if (partial) { Object.assign(this, partial); } }</p>

<p>/**</p>
   <ul><li>Create ModelClass from API response</li>
</ul>   *
   <ul><li>@param data - Raw API response data</li>
</ul>   <ul><li>@returns ModelClass instance</li>
</ul>   */
<p>static fromApiResponse(data: any): ModelClass { return new ModelClass({ field1: data.field1 || data.field_1, field2: data.field2 !== undefined ? Number(data.field2) : undefined }); }</p>

<p>/**</p>
   <ul><li>Get display name</li>
</ul>   *
   <ul><li>@returns Formatted display string</li>
</ul>   */
<p>getDisplayName(): string { return this.field1; } }</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check Directory Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domains/automobile/models/
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>total 8
<p>drwxr-xr-x 2 user user 4096 Feb  9 12:00 . drwxr-xr-x 3 user user 4096 Feb  9 12:00 .. -rw-r--r-- 1 user user  200 Feb  9 12:00 index.ts</p>
</code></pre></div><div class="page-content"><h3>2. TypeScript Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/domains/automobile/models/index.ts
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Property has no initializer</code></td> <td>Missing <code class="inline">!</code> on required field</td> <td>Add <code class="inline">!</code> or make optional with <code class="inline">?</code></td></p>
</tr>
<p><tr> <td><code class="inline">Partial&lt;T&gt;</code> not accepting field</td> <td>Wrong field name</td> <td>Ensure field names match exactly</td></p>
</tr>
<p><tr> <td>API fields not mapping</td> <td>Missing transformation</td> <td>Add case in <code class="inline">fromApiResponse()</code></td></p>
</tr>
<p><tr> <td>Methods not available</td> <td>Using interface instead of class</td> <td>Convert to class with methods</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Classes over interfaces for domain models</strong> — Enable methods, factories, and instanceof checks</li>
<p><li><strong>Partial constructor pattern</strong> — Flexible initialization with type safety</li> <li><strong>Static factory for API data</strong> — Single point for API field normalization</li> <li><strong>Instance methods for computed values</strong> — Encapsulate business logic in the model</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] Domain models directory structure created</li>
<p><li>[ ] <code class="inline">src/app/domains/automobile/models/index.ts</code> exists</li> <li>[ ] Model conventions documented and understood:</li></p>
</ul>  <ul><li>[ ] Non-null assertion for required fields</li>
</ul>  <ul><li>[ ] Optional marker for optional fields</li>
</ul>  <ul><li>[ ] Partial constructor pattern</li>
</ul>  <ul><li>[ ] Static <code class="inline">fromApiResponse()</code> factory</li>
</ul>  <ul><li>[ ] Instance methods for computed values</li>
</ul>  <ul><li>[ ] JSDoc documentation on all members</li>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">402-domain-data-models.md</code> to create the vehicle and VIN instance data models.</p></div></div>
    <div class="chapter" id="section-402">
        <div class="chapter-header">
            <div class="chapter-category">Models</div>
            <h1>402: Domain Data Models</h1>
        </div>
<div class="page-content"><h1>402: Domain Data Models</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 401-base-model-interface <strong>Blocks:</strong> 403-domain-filter-statistics-models, Phase 5 (Domain Adapters)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to model domain entities as TypeScript classes</li>
<p><li>Know how to handle API response transformation for different naming conventions</li> <li>Recognize the relationship between aggregate data (VehicleResult) and detail data (VinInstance)</li> <li>Be able to implement utility methods that encapsulate business logic</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the core data models for the automobile domain: <code class="inline">VehicleResult</code> for vehicle configurations and <code class="inline">VinInstance</code> for individual VIN records.</p>

<hr>

<h2>Why</h2>

<p>The automobile domain centers on two core entities:</p>

<h3>VehicleResult — The Aggregate</h3>

<p>A <code class="inline">VehicleResult</code> represents a <strong>unique vehicle configuration</strong> — a specific combination of:</p>
<ul><li>Manufacturer (Toyota, Honda, Ford)</li>
<p><li>Model (Camry, Accord, F-150)</li> <li>Year (2024, 2023, 2022)</li> <li>Body Class (Sedan, SUV, Truck)</li></p>
</ul>
<p>Each configuration has an <code class="inline">instance_count</code> showing how many individual vehicles (VINs) exist for that configuration.</p>

<pre class="code-block text"><code>Toyota Camry 2024 Sedan — 156 instances
<p>Honda Accord 2023 Sedan — 89 instances Ford F-150 2024 Truck — 234 instances</p>
</code></pre>

<h3>VinInstance — The Detail</h3>

<p>A <code class="inline">VinInstance</code> represents a <strong>single vehicle</strong> with a unique VIN (Vehicle Identification Number). When users expand a row in the data table, they see individual VINs for that vehicle configuration.</p>

<pre class="code-block text"><code>1HGCM82633A123456 — Toyota Camry 2024
<p>1HGCM82633A123457 — Toyota Camry 2024 1HGCM82633A123458 — Toyota Camry 2024</p>
</code></pre>

<h3>The Relationship</h3>

<pre class="code-block text"><code>VehicleResult (1) ———— (many) VinInstance
<p>↓ manufacturer: Toyota model: Camry year: 2024 body_class: Sedan instance_count: 156 ↓ Links to 156 VinInstance records</p>
</code></pre>

<h3>API Response Handling</h3>

<p>The API may return data in different formats:</p>

<pre class="code-block json"><code>// snake_case from backend
<p>{ "vehicle_id": "TOY-CAM-2024-SED", "body_class": "Sedan", "instance_count": 156, "first_seen": "2024-01-15T10:30:00Z" }</p>

<p>// camelCase from some endpoints { "vehicleId": "TOY-CAM-2024-SED", "bodyClass": "Sedan", "instanceCount": 156, "firstSeen": "2024-01-15T10:30:00Z" }</p>
</code></pre>

<p>The <code class="inline">fromApiResponse()</code> method handles both:</p>

<pre class="code-block typescript"><code>static fromApiResponse(data: any): VehicleResult {
<p>return new VehicleResult({ vehicle_id: data.vehicle_id || data.vehicleId || data.id, body_class: data.body_class || data.bodyClass, instance_count: Number(data.instance_count || data.instanceCount || 0), first_seen: data.first_seen || data.firstSeen }); }</p>
</code></pre></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 402.1: Create the Vehicle Result Model</h3>

<p>Create the file <code class="inline">src/app/domains/automobile/models/automobile.data.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domains/automobile/models/automobile.data.ts
<p>// VERSION 1 (Section 402) - Automobile domain data models</p>

<p>/**</p>
 <ul><li>Vehicle result data</li>
</ul> *
 <ul><li>Represents a unique vehicle configuration with aggregated VIN instance count.</li>
</ul> <ul><li>Each record represents a distinct combination of manufacturer, model, year, and body class.</li>
</ul> *
 <ul><li>Domain: Automobile Discovery</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const vehicle: VehicleResult = {</li>
</ul> <ul><li>  vehicle_id: 'TOY-CAM-2024-SED',</li>
</ul> <ul><li>  manufacturer: 'Toyota',</li>
</ul> <ul><li>  model: 'Camry',</li>
</ul> <ul><li>  year: 2024,</li>
</ul> <ul><li>  body_class: 'Sedan',</li>
</ul> <ul><li>  instance_count: 156,</li>
</ul> <ul><li>  first_seen: '2024-01-15T10:30:00Z',</li>
</ul> <ul><li>  last_seen: '2024-11-20T14:22:00Z'</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export class VehicleResult { /**</p>
   <ul><li>Unique vehicle identifier</li>
</ul>   <ul><li>Composite key: manufacturer-model-year-bodyclass</li>
</ul>   *
   <ul><li>@example 'TOY-CAM-2024-SED', 'HON-ACC-2023-SED'</li>
</ul>   */
<p>vehicle_id!: string;</p>

<p>/**</p>
   <ul><li>Vehicle manufacturer name</li>
</ul>   *
   <ul><li>@example 'Toyota', 'Honda', 'Ford', 'Chevrolet'</li>
</ul>   */
<p>manufacturer!: string;</p>

<p>/**</p>
   <ul><li>Vehicle model name</li>
</ul>   *
   <ul><li>@example 'Camry', 'Accord', 'F-150', 'Silverado'</li>
</ul>   */
<p>model!: string;</p>

<p>/**</p>
   <ul><li>Vehicle model year</li>
</ul>   *
   <ul><li>@example 2024, 2023, 2022</li>
</ul>   */
<p>year!: number;</p>

<p>/**</p>
   <ul><li>Vehicle body class/type</li>
</ul>   *
   <ul><li>@example 'Sedan', 'SUV', 'Truck', 'Coupe', 'Wagon', 'Van'</li>
</ul>   */
<p>body_class!: string;</p>

<p>/**</p>
   <ul><li>Number of VIN instances for this vehicle configuration</li>
</ul>   <ul><li>Represents how many individual vehicles (VINs) exist for this configuration</li>
</ul>   *
   <ul><li>@example 156 (means 156 unique VINs for this vehicle config)</li>
</ul>   */
<p>instance_count!: number;</p>

<p>/**</p>
   <ul><li>Date/time this vehicle configuration was first seen in the system</li>
</ul>   <ul><li>ISO 8601 format</li>
</ul>   *
   <ul><li>@example '2024-01-15T10:30:00Z'</li>
</ul>   */
<p>first_seen?: string;</p>

<p>/**</p>
   <ul><li>Date/time this vehicle configuration was last updated</li>
</ul>   <ul><li>ISO 8601 format</li>
</ul>   *
   <ul><li>@example '2024-11-20T14:22:00Z'</li>
</ul>   */
<p>last_seen?: string;</p>

<p>/**</p>
   <ul><li>Drive type</li>
</ul>   <ul><li>@example 'FWD', 'RWD', 'AWD', '4WD'</li>
</ul>   */
<p>drive_type?: string;</p>

<p>/**</p>
   <ul><li>Engine configuration</li>
</ul>   <ul><li>@example 'V6', 'I4', 'V8', 'Electric'</li>
</ul>   */
<p>engine?: string;</p>

<p>/**</p>
   <ul><li>Transmission type</li>
</ul>   <ul><li>@example 'Automatic', 'Manual', 'CVT'</li>
</ul>   */
<p>transmission?: string;</p>

<p>/**</p>
   <ul><li>Fuel type</li>
</ul>   <ul><li>@example 'Gasoline', 'Diesel', 'Electric', 'Hybrid'</li>
</ul>   */
<p>fuel_type?: string;</p>

<p>/**</p>
   <ul><li>Vehicle class/category</li>
</ul>   <ul><li>@example 'Passenger Car', 'Light Truck', 'Commercial Vehicle'</li>
</ul>   */
<p>vehicle_class?: string;</p>

<p>/**</p>
   <ul><li>Constructor with partial data</li>
</ul>   *
   <ul><li>@param partial - Partial VehicleResult object</li>
</ul>   */
<p>constructor(partial?: Partial&lt;VehicleResult&gt;) { if (partial) { Object.assign(this, partial); } }</p>

<p>/**</p>
   <ul><li>Create VehicleResult from API response</li>
</ul>   *
   <ul><li>Handles both snake_case and camelCase field names from API.</li>
</ul>   *
   <ul><li>@param data - Raw API response data</li>
</ul>   <ul><li>@returns VehicleResult instance</li>
</ul>   */
<p>static fromApiResponse(data: any): VehicleResult { return new VehicleResult({ vehicle_id: data.vehicle_id || data.vehicleId || data.id, manufacturer: data.manufacturer, model: data.model, year: Number(data.year), body_class: data.body_class || data.bodyClass, instance_count: Number(data.instance_count || data.instanceCount || 0), first_seen: data.first_seen || data.firstSeen, last_seen: data.last_seen || data.lastSeen, drive_type: data.drive_type || data.driveType, engine: data.engine, transmission: data.transmission, fuel_type: data.fuel_type || data.fuelType, vehicle_class: data.vehicle_class || data.vehicleClass }); }</p>

<p>/**</p>
   <ul><li>Get display name for vehicle</li>
</ul>   *
   <ul><li>@returns Formatted display string</li>
</ul>   <ul><li>@example 'Toyota Camry 2024'</li>
</ul>   */
<p>getDisplayName(): string { return <code class="inline">${this.manufacturer} ${this.model} ${this.year}</code>; }</p>

<p>/**</p>
   <ul><li>Get full description for vehicle</li>
</ul>   *
   <ul><li>@returns Detailed description string</li>
</ul>   <ul><li>@example 'Toyota Camry 2024 Sedan (156 instances)'</li>
</ul>   */
<p>getFullDescription(): string { return <code class="inline">${this.manufacturer} ${this.model} ${this.year} ${this.body_class} (${this.instance_count} instances)</code>; }</p>

<p>/**</p>
   <ul><li>Check if vehicle has VIN instances</li>
</ul>   *
   <ul><li>@returns True if instance_count &gt; 0</li>
</ul>   */
<p>hasInstances(): boolean { return this.instance_count &gt; 0; }</p>

<p>/**</p>
   <ul><li>Get age of vehicle in years</li>
</ul>   *
   <ul><li>@returns Age in years from current year</li>
</ul>   */
<p>getAge(): number { const currentYear = new Date().getFullYear(); return currentYear - this.year; }</p>

<p>/**</p>
   <ul><li>Check if vehicle is current year</li>
</ul>   *
   <ul><li>@returns True if year matches current year</li>
</ul>   */
<p>isCurrentYear(): boolean { return this.year === new Date().getFullYear(); } }</p>

<p>/**</p>
 <ul><li>VIN instance detail</li>
</ul> *
 <ul><li>Represents a single VIN instance for a vehicle configuration.</li>
</ul> <ul><li>Used in row expansion to show individual VINs.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const vin: VinInstance = {</li>
</ul> <ul><li>  vin: '1HGCM82633A123456',</li>
</ul> <ul><li>  vehicle_id: 'HON-ACC-2023-SED',</li>
</ul> <ul><li>  registration_date: '2023-05-10',</li>
</ul> <ul><li>  registration_state: 'CA',</li>
</ul> <ul><li>  odometer_reading: 15234</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export class VinInstance { /**</p>
   <ul><li>Vehicle Identification Number (17 characters)</li>
</ul>   *
   <ul><li>@example '1HGCM82633A123456'</li>
</ul>   */
<p>vin!: string;</p>

<p>/**</p>
   <ul><li>Associated vehicle configuration ID</li>
</ul>   <ul><li>Links to VehicleResult.vehicle_id</li>
</ul>   *
   <ul><li>@example 'HON-ACC-2023-SED'</li>
</ul>   */
<p>vehicle_id!: string;</p>

<p>/**</p>
   <ul><li>Registration date</li>
</ul>   <ul><li>@example '2023-05-10'</li>
</ul>   */
<p>registration_date?: string;</p>

<p>/**</p>
   <ul><li>Registration state/province</li>
</ul>   <ul><li>@example 'CA', 'TX', 'NY'</li>
</ul>   */
<p>registration_state?: string;</p>

<p>/**</p>
   <ul><li>Odometer reading (miles)</li>
</ul>   <ul><li>@example 15234</li>
</ul>   */
<p>odometer_reading?: number;</p>

<p>/**</p>
   <ul><li>Vehicle status</li>
</ul>   <ul><li>@example 'Active', 'Salvage', 'Totaled', 'Stolen'</li>
</ul>   */
<p>status?: string;</p>

<p>/**</p>
   <ul><li>Color</li>
</ul>   <ul><li>@example 'White', 'Black', 'Silver'</li>
</ul>   */
<p>color?: string;</p>

<p>/**</p>
   <ul><li>Current owner/registrant (anonymized)</li>
</ul>   <ul><li>@example 'Owner-12345'</li>
</ul>   */
<p>owner_id?: string;</p>

<p>/**</p>
   <ul><li>Last update timestamp</li>
</ul>   <ul><li>@example '2024-11-20T10:30:00Z'</li>
</ul>   */
<p>last_updated?: string;</p>

<p>/**</p>
   <ul><li>Constructor with partial data</li>
</ul>   *
   <ul><li>@param partial - Partial VinInstance object</li>
</ul>   */
<p>constructor(partial?: Partial&lt;VinInstance&gt;) { if (partial) { Object.assign(this, partial); } }</p>

<p>/**</p>
   <ul><li>Create VinInstance from API response</li>
</ul>   *
   <ul><li>@param data - Raw API response data</li>
</ul>   <ul><li>@returns VinInstance instance</li>
</ul>   */
<p>static fromApiResponse(data: any): VinInstance { return new VinInstance({ vin: data.vin, vehicle_id: data.vehicle_id || data.vehicleId, registration_date: data.registration_date || data.registrationDate, registration_state: data.registration_state || data.registrationState, odometer_reading: data.odometer_reading || data.odometerReading, status: data.status, color: data.color, owner_id: data.owner_id || data.ownerId, last_updated: data.last_updated || data.lastUpdated }); }</p>

<p>/**</p>
   <ul><li>Get formatted VIN (groups of 4 characters)</li>
</ul>   *
   <ul><li>@returns Formatted VIN string</li>
</ul>   <ul><li>@example '1HGC M826 33A1 2345 6'</li>
</ul>   */
<p>getFormattedVin(): string { return this.vin.match(/.{1,4}/g)?.join(' ') || this.vin; }</p>

<p>/**</p>
   <ul><li>Check if VIN is valid length</li>
</ul>   *
   <ul><li>@returns True if VIN is 17 characters</li>
</ul>   */
<p>isValidLength(): boolean { return this.vin?.length === 17; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 402.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/domains/automobile/models/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domains/automobile/models/index.ts
<p>// VERSION 2 (Section 402) - Added data models</p>

<p>export * from './automobile.data';</p>

<p>// Filter and statistics models (Section 403) // export * from './automobile.filters'; // export * from './automobile.statistics';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domains/automobile/models/automobile.data.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/domains/automobile/models/automobile.data.ts
</code></pre>

<h3>3. Test Model Usage</h3>

<p>Create a temporary test:</p>

<pre class="code-block typescript"><code>// In any component or test file
<p>import { VehicleResult, VinInstance } from '@app/domains/automobile/models';</p>

<p>// Test VehicleResult const vehicle = VehicleResult.fromApiResponse({ vehicle_id: 'TOY-CAM-2024-SED', manufacturer: 'Toyota', model: 'Camry', year: '2024', // String from API body_class: 'Sedan', instance_count: '156' // String from API });</p>

<p>console.log('Display name:', vehicle.getDisplayName()); // Output: 'Toyota Camry 2024'</p>

<p>console.log('Full description:', vehicle.getFullDescription()); // Output: 'Toyota Camry 2024 Sedan (156 instances)'</p>

<p>console.log('Age:', vehicle.getAge()); // Output: 0 (if current year is 2024)</p>

<p>// Test VinInstance const vin = new VinInstance({ vin: '1HGCM82633A123456', vehicle_id: 'HON-ACC-2023-SED' });</p>

<p>console.log('Formatted VIN:', vin.getFormattedVin()); // Output: '1HGC M826 33A1 2345 6'</p>

<p>console.log('Valid length:', vin.isValidLength()); // Output: true</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">year</code> is string not number</td> <td>API returns string</td> <td>Use <code class="inline">Number()</code> in <code class="inline">fromApiResponse()</code></td></p>
</tr>
<p><tr> <td><code class="inline">instance_count</code> is <code class="inline">NaN</code></td> <td>Missing or null from API</td> <td>Default to 0: <code class="inline">Number(data.instance_count</td> <td></td> <td>0)</code></td></p>
</tr>
<p><tr> <td><code class="inline">body_class</code> undefined</td> <td>Different API field name</td> <td>Check for both <code class="inline">body_class</code> and <code class="inline">bodyClass</code></td></p>
</tr>
<p><tr> <td>Methods not available on object</td> <td>Plain object, not class instance</td> <td>Use <code class="inline">fromApiResponse()</code> or <code class="inline">new VehicleResult()</code></td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Classes enable methods and transformation</strong> — <code class="inline">getDisplayName()</code>, <code class="inline">getAge()</code>, etc.</li>
<p><li><strong>Handle both API naming conventions</strong> — Check for <code class="inline">body_class</code> and <code class="inline">bodyClass</code></li> <li><strong>Type coercion is essential</strong> — API sends strings, models need numbers</li> <li><strong>Instance methods encapsulate logic</strong> — Business rules live in the model</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domains/automobile/models/automobile.data.ts</code> exists</li>
<p><li>[ ] <code class="inline">VehicleResult</code> class with all required fields</li> <li>[ ] <code class="inline">VinInstance</code> class with all required fields</li> <li>[ ] Both classes have partial constructor</li> <li>[ ] Both classes have <code class="inline">fromApiResponse()</code> static method</li> <li>[ ] <code class="inline">VehicleResult</code> has utility methods:</li></p>
</ul>  <ul><li>[ ] <code class="inline">getDisplayName()</code></li>
</ul>  <ul><li>[ ] <code class="inline">getFullDescription()</code></li>
</ul>  <ul><li>[ ] <code class="inline">hasInstances()</code></li>
</ul>  <ul><li>[ ] <code class="inline">getAge()</code></li>
</ul>  <ul><li>[ ] <code class="inline">isCurrentYear()</code></li>
<p><li>[ ] <code class="inline">VinInstance</code> has utility methods:</li></p>
</ul>  <ul><li>[ ] <code class="inline">getFormattedVin()</code></li>
</ul>  <ul><li>[ ] <code class="inline">isValidLength()</code></li>
<p><li>[ ] Barrel file exports both classes</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments on all properties and methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">403-domain-filter-statistics-models.md</code> to create the filter and statistics models.</p></div></div>
    <div class="chapter" id="section-403">
        <div class="chapter-header">
            <div class="chapter-category">Models</div>
            <h1>403: Domain Filter Statistics Models</h1>
        </div>
<div class="page-content"><h1>403: Domain Filter and Statistics Models</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 401-base-model-interface, 402-domain-data-models <strong>Blocks:</strong> Phase 5 (Domain Adapters), Phase 6 (Charts)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the difference between filter models and data models</li>
<p><li>Know how to model search filters with pagination and sorting</li> <li>Recognize the structure of aggregated statistics for chart data</li> <li>Be able to implement highlight filters for segmented chart data</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the filter model (<code class="inline">AutoSearchFilters</code>) for search parameters and the statistics models (<code class="inline">VehicleStatistics</code>, <code class="inline">ManufacturerStat</code>, etc.) for chart and analytics data.</p>

<hr>

<h2>Why</h2>

<h3>Filter Models</h3>

<p>When users search for vehicles, they apply filters:</p>
<ul><li>Manufacturer (Toyota)</li>
<p><li>Year range (2020-2024)</li> <li>Body class (Sedan, SUV)</li> <li>Page number (1)</li> <li>Sort field (manufacturer)</li></p>
</ul>
<p>These filters:</p>
<ul><li><strong>Map to URL parameters</strong> — Filters persist in the URL</li>
<p><li><strong>Map to API query strings</strong> — Sent to backend for filtering</li> <li><strong>Support multiple data types</strong> — Strings, numbers, arrays</li></p>
</ul>
<p>The <code class="inline">AutoSearchFilters</code> class models all filter options with utility methods for checking if filters are active.</p>

<h3>Highlight Filters</h3>

<p>Vvroom supports <strong>chart highlighting</strong> — showing a subset of data emphasized within the total:</p>

<pre class="code-block text"><code>Total vehicles by manufacturer:
<p>┌──────────────────────────────────────────────┐ │ Toyota    ██████████████████░░░░░ 234 (45 highlighted) │ │ Honda     ████████████████░░░░░░░ 187 (32 highlighted) │ │ Ford      ████████████░░░░░░░░░░░ 156 (0 highlighted)  │ └──────────────────────────────────────────────┘</p>
</code></pre>

<p>Highlight filters are sent to the API with <code class="inline">h_</code> prefix:</p>
<ul><li><code class="inline">?h_manufacturer=Toyota</code> — Highlight Toyota vehicles</li>
<p><li><code class="inline">?h_yearMin=2020&amp;h_yearMax=2024</code> — Highlight 2020-2024 vehicles</li></p>
</ul>
<p>The API returns segmented data: <code class="inline">{ total: 234, highlighted: 45 }</code></p>

<h3>Statistics Models</h3>

<p>Statistics provide aggregated data for:</p>
<ul><li><strong>Summary cards</strong> — Total vehicles, total VINs, manufacturer count</li>
<p><li><strong>Charts</strong> — Top manufacturers, body class distribution, year distribution</li> <li><strong>Filters</strong> — Year range for slider min/max</li></p>
</ul>
<p>Statistics models handle two API response formats:</p>

<p><strong>Format 1: Array-based</strong> (simpler endpoints)</p>
<pre class="code-block json"><code>{
<p>"total_vehicles": 1247, "top_manufacturers": [ { "name": "Toyota", "count": 234 } ] }</p>
</code></pre>

<p><strong>Format 2: Segmented</strong> (chart-ready)</p>
<pre class="code-block json"><code>{
<p>"byManufacturer": { "Toyota": { "total": 234, "highlighted": 45 }, "Honda": { "total": 187, "highlighted": 32 } } }</p>
</code></pre>

<p>The <code class="inline">VehicleStatistics.fromApiResponse()</code> method detects and handles both formats.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 403.1: Create the Filter Models</h3>

<p>Create the file <code class="inline">src/app/domains/automobile/models/automobile.filters.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domains/automobile/models/automobile.filters.ts
<p>// VERSION 1 (Section 403) - Automobile domain filter models</p>

<p>/**</p>
 <ul><li>Highlight Filters</li>
</ul> *
 <ul><li>Parameters for segmented statistics computation.</li>
</ul> <em> Sent to backend API as h_</em> query parameters.
<p>*</p>
 <ul><li>Purpose: Request segmented statistics with {total, highlighted} format</li>
</ul> <ul><li>for chart visualization showing highlighted vs total data.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const highlights: HighlightFilters = {</li>
</ul> <ul><li>  manufacturer: 'Ford',</li>
</ul> <ul><li>  yearMin: 2020,</li>
</ul> <ul><li>  yearMax: 2024</li>
</ul> <ul><li>};</li>
</ul> <ul><li>// URL: ?h_manufacturer=Ford&amp;h_yearMin=2020&amp;h_yearMax=2024</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export interface HighlightFilters { /**</p>
   <ul><li>Year range highlighting (minimum)</li>
</ul>   <ul><li>URL parameter: h_yearMin</li>
</ul>   */
<p>yearMin?: number;</p>

<p>/**</p>
   <ul><li>Year range highlighting (maximum)</li>
</ul>   <ul><li>URL parameter: h_yearMax</li>
</ul>   */
<p>yearMax?: number;</p>

<p>/**</p>
   <ul><li>Manufacturer highlighting</li>
</ul>   <ul><li>URL parameter: h_manufacturer</li>
</ul>   */
<p>manufacturer?: string;</p>

<p>/**</p>
   <ul><li>Model combinations highlighting</li>
</ul>   <ul><li>Format: Manufacturer:Model,Manufacturer:Model</li>
</ul>   <ul><li>URL parameter: h_modelCombos</li>
</ul>   */
<p>modelCombos?: string;</p>

<p>/**</p>
   <ul><li>Body class highlighting</li>
</ul>   <ul><li>URL parameter: h_bodyClass</li>
</ul>   */
<p>bodyClass?: string; }</p>

<p>/**</p>
 <ul><li>Automobile search filters</li>
</ul> *
 <ul><li>Comprehensive filter model for searching and filtering vehicle data.</li>
</ul> <ul><li>All fields are optional to support partial filtering.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const filters: AutoSearchFilters = {</li>
</ul> <ul><li>  manufacturer: 'Toyota',</li>
</ul> <ul><li>  yearMin: 2020,</li>
</ul> <ul><li>  yearMax: 2024,</li>
</ul> <ul><li>  bodyClass: 'SUV',</li>
</ul> <ul><li>  page: 1,</li>
</ul> <ul><li>  size: 20,</li>
</ul> <ul><li>  sort: 'year',</li>
</ul> <ul><li>  sortDirection: 'desc'</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export class AutoSearchFilters { /**</p>
   <ul><li>Vehicle manufacturer name</li>
</ul>   <ul><li>Case-insensitive partial match</li>
</ul>   *
   <ul><li>@example 'Toyota', 'Honda', 'Ford'</li>
</ul>   */
<p>manufacturer?: string;</p>

<p>/**</p>
   <ul><li>Vehicle model name</li>
</ul>   <ul><li>Case-insensitive partial match</li>
</ul>   *
   <ul><li>@example 'Camry', 'Accord', 'F-150'</li>
</ul>   */
<p>model?: string;</p>

<p>/**</p>
   <ul><li>Minimum year (inclusive)</li>
</ul>   *
   <ul><li>@example 2020</li>
</ul>   */
<p>yearMin?: number;</p>

<p>/**</p>
   <ul><li>Maximum year (inclusive)</li>
</ul>   *
   <ul><li>@example 2024</li>
</ul>   */
<p>yearMax?: number;</p>

<p>/**</p>
   <ul><li>Vehicle body class/type (supports multiple selections)</li>
</ul>   <ul><li>Case-insensitive partial match</li>
</ul>   <ul><li>Can be a single value or array for multi-select</li>
</ul>   *
   <ul><li>@example 'Sedan', ['SUV', 'Truck'], 'Coupe'</li>
</ul>   */
<p>bodyClass?: string | string[];</p>

<p>/**</p>
   <ul><li>Minimum VIN instance count</li>
</ul>   <ul><li>Filter vehicles with at least this many VIN instances</li>
</ul>   *
   <ul><li>@example 10</li>
</ul>   */
<p>instanceCountMin?: number;</p>

<p>/**</p>
   <ul><li>Maximum VIN instance count</li>
</ul>   <ul><li>Filter vehicles with at most this many VIN instances</li>
</ul>   *
   <ul><li>@example 1000</li>
</ul>   */
<p>instanceCountMax?: number;</p>

<p>/**</p>
   <ul><li>Page number (1-indexed)</li>
</ul>   <ul><li>Used for pagination</li>
</ul>   *
   <ul><li>@default 1</li>
</ul>   */
<p>page?: number;</p>

<p>/**</p>
   <ul><li>Page size (number of results per page)</li>
</ul>   <ul><li>Used for pagination</li>
</ul>   *
   <ul><li>@default 20</li>
</ul>   */
<p>size?: number;</p>

<p>/**</p>
   <ul><li>Sort field</li>
</ul>   <ul><li>Field name to sort by</li>
</ul>   *
   <ul><li>@example 'manufacturer', 'model', 'year', 'instance_count'</li>
</ul>   */
<p>sort?: string;</p>

<p>/**</p>
   <ul><li>Sort direction</li>
</ul>   <ul><li>Ascending or descending order</li>
</ul>   *
   <ul><li>@default 'asc'</li>
</ul>   */
<p>sortDirection?: 'asc' | 'desc';</p>

<p>/**</p>
   <ul><li>Search query (global search)</li>
</ul>   <ul><li>Searches across multiple fields (manufacturer, model, body class)</li>
</ul>   *
   <ul><li>@example 'Toyota Camry'</li>
</ul>   */
<p>search?: string;</p>

<p>/**</p>
   <ul><li>Model combinations (from picker)</li>
</ul>   <ul><li>Comma-separated manufacturer:model pairs</li>
</ul>   *
   <ul><li>@example 'Ford:F-150,Toyota:Camry,Honda:Accord'</li>
</ul>   */
<p>modelCombos?: string;</p>

<p>/**</p>
   <ul><li>Constructor with default values</li>
</ul>   *
   <ul><li>@param partial - Partial AutoSearchFilters object</li>
</ul>   */
<p>constructor(partial?: Partial&lt;AutoSearchFilters&gt;) { Object.assign(this, partial); }</p>

<p>/**</p>
   <ul><li>Create filters from partial object</li>
</ul>   *
   <ul><li>@param partial - Partial filter object</li>
</ul>   <ul><li>@returns AutoSearchFilters instance</li>
</ul>   */
<p>static fromPartial(partial: Partial&lt;AutoSearchFilters&gt;): AutoSearchFilters { return new AutoSearchFilters(partial); }</p>

<p>/**</p>
   <ul><li>Get default filters</li>
</ul>   *
   <ul><li>@returns Default filter values</li>
</ul>   */
<p>static getDefaults(): AutoSearchFilters { return new AutoSearchFilters({ page: 1, size: 20, sort: 'manufacturer', sortDirection: 'asc' }); }</p>

<p>/**</p>
   <ul><li>Check if filters are empty (no active filters except pagination/sort)</li>
</ul>   *
   <ul><li>@returns True if no search filters are active</li>
</ul>   */
<p>isEmpty(): boolean { const hasBodyClass = Array.isArray(this.bodyClass) ? this.bodyClass.length &gt; 0 : !!this.bodyClass;</p>

<p>return ( !this.manufacturer &amp;&amp; !this.model &amp;&amp; !this.yearMin &amp;&amp; !this.yearMax &amp;&amp; !hasBodyClass &amp;&amp; !this.instanceCountMin &amp;&amp; !this.instanceCountMax &amp;&amp; !this.search &amp;&amp; !this.modelCombos ); }</p>

<p>/**</p>
   <ul><li>Clone filters</li>
</ul>   *
   <ul><li>@returns New AutoSearchFilters instance with same values</li>
</ul>   */
<p>clone(): AutoSearchFilters { return new AutoSearchFilters({ ...this }); }</p>

<p>/**</p>
   <ul><li>Merge with other filters</li>
</ul>   *
   <ul><li>@param other - Filters to merge</li>
</ul>   <ul><li>@returns New AutoSearchFilters with merged values</li>
</ul>   */
<p>merge(other: Partial&lt;AutoSearchFilters&gt;): AutoSearchFilters { return new AutoSearchFilters({ ...this, ...other }); }</p>

<p>/**</p>
   <ul><li>Clear all filters except pagination and sort</li>
</ul>   *
   <ul><li>@returns New AutoSearchFilters with only pagination/sort</li>
</ul>   */
<p>clearSearch(): AutoSearchFilters { return new AutoSearchFilters({ page: this.page, size: this.size, sort: this.sort, sortDirection: this.sortDirection }); }</p>

<p>/**</p>
   <ul><li>Get active filter count</li>
</ul>   *
   <ul><li>@returns Number of active search filters</li>
</ul>   */
<p>getActiveFilterCount(): number { let count = 0; if (this.manufacturer) count++; if (this.model) count++; if (this.yearMin) count++; if (this.yearMax) count++; if (this.bodyClass) count++; if (this.instanceCountMin) count++; if (this.instanceCountMax) count++; if (this.search) count++; if (this.modelCombos) count++; return count; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 403.2: Create the Statistics Models</h3>

<p>Create the file <code class="inline">src/app/domains/automobile/models/automobile.statistics.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domains/automobile/models/automobile.statistics.ts
<p>// VERSION 1 (Section 403) - Automobile domain statistics models</p>

<p>/**</p>
 <ul><li>Manufacturer statistic</li>
</ul> *
 <ul><li>Aggregated data for a single manufacturer</li>
</ul> */
<p>export class ManufacturerStat { /**</p>
   <ul><li>Manufacturer name</li>
</ul>   <ul><li>@example 'Toyota'</li>
</ul>   */
<p>name!: string;</p>

<p>/**</p>
   <ul><li>Number of vehicle configurations</li>
</ul>   <ul><li>@example 234</li>
</ul>   */
<p>count!: number;</p>

<p>/**</p>
   <ul><li>Total VIN instances</li>
</ul>   <ul><li>@example 8456</li>
</ul>   */
<p>instanceCount?: number;</p>

<p>/**</p>
   <ul><li>Percentage of total</li>
</ul>   <ul><li>@example 18.8</li>
</ul>   */
<p>percentage!: number;</p>

<p>/**</p>
   <ul><li>Number of unique models</li>
</ul>   <ul><li>@example 42</li>
</ul>   */
<p>modelCount?: number;</p>

<p>constructor(partial?: Partial&lt;ManufacturerStat&gt;) { if (partial) { Object.assign(this, partial); } }</p>

<p>static fromApiResponse(data: any): ManufacturerStat { return new ManufacturerStat({ name: data.name || data.manufacturer, count: Number(data.count || data.vehicle_count || 0), instanceCount: data.instance_count || data.instanceCount, percentage: Number(data.percentage || 0), modelCount: data.model_count || data.modelCount }); } }</p>

<p>/**</p>
 <ul><li>Model statistic</li>
</ul> *
 <ul><li>Aggregated data for a single vehicle model</li>
</ul> */
<p>export class ModelStat { /**</p>
   <ul><li>Model name</li>
</ul>   <ul><li>@example 'Camry'</li>
</ul>   */
<p>name!: string;</p>

<p>/**</p>
   <ul><li>Manufacturer name</li>
</ul>   <ul><li>@example 'Toyota'</li>
</ul>   */
<p>manufacturer!: string;</p>

<p>/**</p>
   <ul><li>Number of vehicle configurations</li>
</ul>   <ul><li>@example 15</li>
</ul>   */
<p>count!: number;</p>

<p>/**</p>
   <ul><li>Total VIN instances</li>
</ul>   <ul><li>@example 3456</li>
</ul>   */
<p>instanceCount!: number;</p>

<p>/**</p>
   <ul><li>Percentage of total instances</li>
</ul>   <ul><li>@example 7.6</li>
</ul>   */
<p>percentage!: number;</p>

<p>constructor(partial?: Partial&lt;ModelStat&gt;) { if (partial) { Object.assign(this, partial); } }</p>

<p>static fromApiResponse(data: any): ModelStat { return new ModelStat({ name: data.name || data.model, manufacturer: data.manufacturer, count: Number(data.count || data.vehicle_count || 0), instanceCount: Number(data.instance_count || data.instanceCount || 0), percentage: Number(data.percentage || 0) }); }</p>

<p>/**</p>
   <ul><li>Get full model name including manufacturer</li>
</ul>   <ul><li>@returns Full name (e.g., "Toyota Camry")</li>
</ul>   */
<p>getFullName(): string { return <code class="inline">${this.manufacturer} ${this.name}</code>; } }</p>

<p>/**</p>
 <ul><li>Body class statistic</li>
</ul> *
 <ul><li>Aggregated data for a single body class</li>
</ul> */
<p>export class BodyClassStat { /**</p>
   <ul><li>Body class name</li>
</ul>   <ul><li>@example 'Sedan'</li>
</ul>   */
<p>name!: string;</p>

<p>/**</p>
   <ul><li>Number of vehicle configurations</li>
</ul>   <ul><li>@example 456</li>
</ul>   */
<p>count!: number;</p>

<p>/**</p>
   <ul><li>Total VIN instances</li>
</ul>   <ul><li>@example 16789</li>
</ul>   */
<p>instanceCount?: number;</p>

<p>/**</p>
   <ul><li>Percentage of total</li>
</ul>   <ul><li>@example 36.6</li>
</ul>   */
<p>percentage!: number;</p>

<p>constructor(partial?: Partial&lt;BodyClassStat&gt;) { if (partial) { Object.assign(this, partial); } }</p>

<p>static fromApiResponse(data: any): BodyClassStat { return new BodyClassStat({ name: data.name || data.body_class || data.bodyClass, count: Number(data.count || data.vehicle_count || 0), instanceCount: data.instance_count || data.instanceCount, percentage: Number(data.percentage || 0) }); } }</p>

<p>/**</p>
 <ul><li>Year statistic</li>
</ul> *
 <ul><li>Aggregated data for a single vehicle year</li>
</ul> */
<p>export class YearStat { /**</p>
   <ul><li>Vehicle year</li>
</ul>   <ul><li>@example 2024</li>
</ul>   */
<p>year!: number;</p>

<p>/**</p>
   <ul><li>Number of vehicle configurations</li>
</ul>   <ul><li>@example 89</li>
</ul>   */
<p>count!: number;</p>

<p>/**</p>
   <ul><li>Total VIN instances</li>
</ul>   <ul><li>@example 3245</li>
</ul>   */
<p>instanceCount?: number;</p>

<p>/**</p>
   <ul><li>Percentage of total</li>
</ul>   <ul><li>@example 7.1</li>
</ul>   */
<p>percentage!: number;</p>

<p>constructor(partial?: Partial&lt;YearStat&gt;) { if (partial) { Object.assign(this, partial); } }</p>

<p>static fromApiResponse(data: any): YearStat { return new YearStat({ year: Number(data.year), count: Number(data.count || data.vehicle_count || 0), instanceCount: data.instance_count || data.instanceCount, percentage: Number(data.percentage || 0) }); }</p>

<p>/**</p>
   <ul><li>Check if this year is current year</li>
</ul>   */
<p>isCurrentYear(): boolean { return this.year === new Date().getFullYear(); }</p>

<p>/**</p>
   <ul><li>Get age of vehicles from this year</li>
</ul>   */
<p>getAge(): number { return new Date().getFullYear() - this.year; } }</p>

<p>/**</p>
 <ul><li>Vehicle statistics</li>
</ul> *
 <ul><li>Aggregated statistics across all filtered vehicles.</li>
</ul> <ul><li>Provides high-level metrics and distributions for analysis.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const stats: VehicleStatistics = {</li>
</ul> <ul><li>  totalVehicles: 1247,</li>
</ul> <ul><li>  totalInstances: 45623,</li>
</ul> <ul><li>  manufacturerCount: 23,</li>
</ul> <ul><li>  modelCount: 412,</li>
</ul> <ul><li>  yearRange: { min: 2010, max: 2024 },</li>
</ul> <ul><li>  averageInstancesPerVehicle: 36.6</li>
</ul> <ul><li>};</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export class VehicleStatistics { /**</p>
   <ul><li>Total number of unique vehicle configurations</li>
</ul>   <ul><li>@example 1247</li>
</ul>   */
<p>totalVehicles!: number;</p>

<p>/**</p>
   <ul><li>Total number of VIN instances across all vehicles</li>
</ul>   <ul><li>@example 45623</li>
</ul>   */
<p>totalInstances!: number;</p>

<p>/**</p>
   <ul><li>Number of unique manufacturers</li>
</ul>   <ul><li>@example 23</li>
</ul>   */
<p>manufacturerCount!: number;</p>

<p>/**</p>
   <ul><li>Number of unique models</li>
</ul>   <ul><li>@example 412</li>
</ul>   */
<p>modelCount!: number;</p>

<p>/**</p>
   <ul><li>Number of unique body classes</li>
</ul>   <ul><li>@example 8</li>
</ul>   */
<p>bodyClassCount?: number;</p>

<p>/**</p>
   <ul><li>Year range (min and max years in dataset)</li>
</ul>   */
<p>yearRange!: { min: number; max: number; };</p>

<p>/**</p>
   <ul><li>Average VIN instances per vehicle configuration</li>
</ul>   <ul><li>@example 36.6</li>
</ul>   */
<p>averageInstancesPerVehicle!: number;</p>

<p>/**</p>
   <ul><li>Median VIN instances per vehicle configuration</li>
</ul>   <ul><li>@example 28</li>
</ul>   */
<p>medianInstancesPerVehicle?: number;</p>

<p>/**</p>
   <ul><li>Top manufacturers by vehicle count (top 20)</li>
</ul>   */
<p>topManufacturers?: ManufacturerStat[];</p>

<p>/**</p>
   <ul><li>Top models by instance count (top 20)</li>
</ul>   */
<p>topModels?: ModelStat[];</p>

<p>/**</p>
   <ul><li>Distribution by body class</li>
</ul>   */
<p>bodyClassDistribution?: BodyClassStat[];</p>

<p>/**</p>
   <ul><li>Distribution by year</li>
</ul>   */
<p>yearDistribution?: YearStat[];</p>

<p>/**</p>
   <ul><li>Complete manufacturer distribution</li>
</ul>   */
<p>manufacturerDistribution?: ManufacturerStat[];</p>

<p>/**</p>
   <ul><li>Raw segmented statistics by manufacturer</li>
</ul>   <ul><li>Format: { "Toyota": { total: 234, highlighted: 45 } }</li>
</ul>   */
<p>byManufacturer?: Record&lt;string, { total: number; highlighted: number }&gt;;</p>

<p>/**</p>
   <ul><li>Raw segmented statistics by body class</li>
</ul>   */
<p>byBodyClass?: Record&lt;string, { total: number; highlighted: number }&gt;;</p>

<p>/**</p>
   <ul><li>Raw segmented statistics by year</li>
</ul>   */
<p>byYearRange?: Record&lt;string, { total: number; highlighted: number }&gt;;</p>

<p>/**</p>
   <ul><li>Raw segmented statistics by model per manufacturer</li>
</ul>   */
<p>modelsByManufacturer?: Record&lt;string, Record&lt;string, { total: number; highlighted: number }&gt;&gt;;</p>

<p>constructor(partial?: Partial&lt;VehicleStatistics&gt;) { if (partial) { Object.assign(this, partial); } }</p>

<p>/**</p>
   <ul><li>Create VehicleStatistics from API response</li>
</ul>   *
   <ul><li>Handles two formats:</li>
</ul>   <ul><li>1. Array-based statistics (topManufacturers, etc.)</li>
</ul>   <ul><li>2. Segmented statistics (byManufacturer, modelsByManufacturer, etc.)</li>
</ul>   *
   <ul><li>@param data - Raw API response data</li>
</ul>   <ul><li>@returns VehicleStatistics instance</li>
</ul>   */
<p>static fromApiResponse(data: any): VehicleStatistics { // Check if segmented format const byYearData = data.byYearRange || data.byYear; if (data.byManufacturer || data.modelsByManufacturer || data.byBodyClass || byYearData) { return VehicleStatistics.fromSegmentedStats(data); }</p>

<p>// Array-based format return new VehicleStatistics({ totalVehicles: Number(data.total_vehicles || data.totalVehicles || 0), totalInstances: Number(data.total_instances || data.totalInstances || 0), manufacturerCount: Number(data.manufacturer_count || data.manufacturerCount || 0), modelCount: Number(data.model_count || data.modelCount || 0), bodyClassCount: data.body_class_count || data.bodyClassCount, yearRange: { min: Number(data.year_range?.min || data.yearRange?.min || 0), max: Number(data.year_range?.max || data.yearRange?.max || 0) }, averageInstancesPerVehicle: Number( data.average_instances_per_vehicle || data.averageInstancesPerVehicle || 0 ), medianInstancesPerVehicle: data.median_instances_per_vehicle || data.medianInstancesPerVehicle, topManufacturers: data.top_manufacturers?.map((m: any) =&gt; ManufacturerStat.fromApiResponse(m) ) || data.topManufacturers?.map((m: any) =&gt; ManufacturerStat.fromApiResponse(m) ), topModels: data.top_models?.map((m: any) =&gt; ModelStat.fromApiResponse(m) ) || data.topModels?.map((m: any) =&gt; ModelStat.fromApiResponse(m) ), bodyClassDistribution: data.body_class_distribution?.map((b: any) =&gt; BodyClassStat.fromApiResponse(b) ) || data.bodyClassDistribution?.map((b: any) =&gt; BodyClassStat.fromApiResponse(b) ), yearDistribution: data.year_distribution?.map((y: any) =&gt; YearStat.fromApiResponse(y) ) || data.yearDistribution?.map((y: any) =&gt; YearStat.fromApiResponse(y) ) }); }</p>

<p>/**</p>
   <ul><li>Create from segmented statistics format</li>
</ul>   */
<p>private static fromSegmentedStats(data: any): VehicleStatistics { const byYearData = data.byYearRange || data.byYear;</p>

<p>const topManufacturers = VehicleStatistics.transformByManufacturer(data.byManufacturer); const topModels = VehicleStatistics.transformModelsByManufacturer(data.modelsByManufacturer); const bodyClassDistribution = VehicleStatistics.transformByBodyClass(data.byBodyClass); const yearDistribution = VehicleStatistics.transformByYearRange(byYearData);</p>

<p>const totalVehicles = data.totalCount || 0; const manufacturerCount = topManufacturers?.length || 0; const modelCount = topModels?.length || 0; const bodyClassCount = bodyClassDistribution?.length || 0;</p>

<p>const years = yearDistribution?.map(y =&gt; y.year) || []; const yearRange = years.length &gt; 0 ? { min: Math.min(...years), max: Math.max(...years) } : { min: 0, max: 0 };</p>

<p>return new VehicleStatistics({ totalVehicles, totalInstances: totalVehicles, manufacturerCount, modelCount, bodyClassCount, yearRange, averageInstancesPerVehicle: 0, topManufacturers, topModels, bodyClassDistribution, yearDistribution, manufacturerDistribution: topManufacturers, byManufacturer: data.byManufacturer, byBodyClass: data.byBodyClass, byYearRange: byYearData, modelsByManufacturer: data.modelsByManufacturer }); }</p>

<p>/**</p>
   <ul><li>Transform byManufacturer object to ManufacturerStat array</li>
</ul>   */
<p>private static transformByManufacturer( byManufacturer: Record&lt;string, any&gt; | undefined ): ManufacturerStat[] | undefined { if (!byManufacturer) return undefined;</p>

<p>const stats = Object.entries(byManufacturer).map(([name, countOrStats]) =&gt; { const count = typeof countOrStats === 'object' ? (countOrStats.total || 0) : (countOrStats || 0);</p>

<p>return new ManufacturerStat({ name, count, instanceCount: count, percentage: 0, modelCount: 0 }); });</p>

<p>stats.sort((a, b) =&gt; b.count - a.count);</p>

<p>const totalCount = stats.reduce((sum, s) =&gt; sum + s.count, 0); stats.forEach(s =&gt; { s.percentage = totalCount &gt; 0 ? (s.count / totalCount) * 100 : 0; });</p>

<p>return stats.slice(0, 20); }</p>

<p>/**</p>
   <ul><li>Transform modelsByManufacturer to ModelStat array</li>
</ul>   */
<p>private static transformModelsByManufacturer( modelsByManufacturer: Record&lt;string, Record&lt;string, any&gt;&gt; | undefined ): ModelStat[] | undefined { if (!modelsByManufacturer) return undefined;</p>

<p>const stats: ModelStat[] = []; let totalCount = 0;</p>

<p>Object.entries(modelsByManufacturer).forEach(([manufacturer, models]) =&gt; { Object.entries(models).forEach(([modelName, countOrStats]) =&gt; { const instanceCount = typeof countOrStats === 'object' ? (countOrStats.total || 0) : (countOrStats || 0); totalCount += instanceCount; stats.push(new ModelStat({ name: modelName, manufacturer, count: 1, instanceCount, percentage: 0 })); }); });</p>

<p>stats.sort((a, b) =&gt; b.instanceCount - a.instanceCount);</p>

<p>stats.forEach(s =&gt; { s.percentage = totalCount &gt; 0 ? (s.instanceCount / totalCount) * 100 : 0; });</p>

<p>return stats.slice(0, 20); }</p>

<p>/**</p>
   <ul><li>Transform byBodyClass to BodyClassStat array</li>
</ul>   */
<p>private static transformByBodyClass( byBodyClass: Record&lt;string, any&gt; | undefined ): BodyClassStat[] | undefined { if (!byBodyClass) return undefined;</p>

<p>const stats = Object.entries(byBodyClass).map(([name, countOrStats]) =&gt; { const count = typeof countOrStats === 'object' ? (countOrStats.total || 0) : (countOrStats || 0);</p>

<p>return new BodyClassStat({ name, count, instanceCount: count, percentage: 0 }); });</p>

<p>const totalCount = stats.reduce((sum, s) =&gt; sum + s.count, 0); stats.forEach(s =&gt; { s.percentage = totalCount &gt; 0 ? (s.count / totalCount) * 100 : 0; });</p>

<p>stats.sort((a, b) =&gt; b.count - a.count);</p>

<p>return stats; }</p>

<p>/**</p>
   <ul><li>Transform byYearRange to YearStat array</li>
</ul>   */
<p>private static transformByYearRange( byYearRange: Record&lt;string, any&gt; | undefined ): YearStat[] | undefined { if (!byYearRange) return undefined;</p>

<p>const stats = Object.entries(byYearRange).map(([yearStr, countOrStats]) =&gt; { const count = typeof countOrStats === 'object' ? (countOrStats.total || 0) : (countOrStats || 0);</p>

<p>return new YearStat({ year: parseInt(yearStr, 10), count, instanceCount: count, percentage: 0 }); });</p>

<p>const totalCount = stats.reduce((sum, s) =&gt; sum + s.count, 0); stats.forEach(s =&gt; { s.percentage = totalCount &gt; 0 ? (s.count / totalCount) * 100 : 0; });</p>

<p>stats.sort((a, b) =&gt; a.year - b.year);</p>

<p>return stats; }</p>

<p>/**</p>
   <ul><li>Get year span (number of years covered)</li>
</ul>   */
<p>getYearSpan(): number { return this.yearRange.max - this.yearRange.min + 1; }</p>

<p>/**</p>
   <ul><li>Get average vehicles per manufacturer</li>
</ul>   */
<p>getAverageVehiclesPerManufacturer(): number { return this.manufacturerCount &gt; 0 ? this.totalVehicles / this.manufacturerCount : 0; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 403.3: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/domains/automobile/models/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domains/automobile/models/index.ts
<p>// VERSION 3 (Section 403) - Complete domain models</p>

<p>export * from './automobile.data'; export * from './automobile.filters'; export * from './automobile.statistics';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check Files Exist</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domains/automobile/models/
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>total 20
<p>drwxr-xr-x 2 user user 4096 Feb  9 12:00 . drwxr-xr-x 3 user user 4096 Feb  9 12:00 .. -rw-r--r-- 1 user user 4567 Feb  9 12:00 automobile.data.ts -rw-r--r-- 1 user user 3456 Feb  9 12:00 automobile.filters.ts -rw-r--r-- 1 user user 8901 Feb  9 12:00 automobile.statistics.ts -rw-r--r-- 1 user user  200 Feb  9 12:00 index.ts</p>
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/domains/automobile/models/index.ts
</code></pre>

<h3>3. Test Filter Usage</h3>

<pre class="code-block typescript"><code>import { AutoSearchFilters } from '@app/domains/automobile/models';

<p>// Create filters const filters = new AutoSearchFilters({ manufacturer: 'Toyota', yearMin: 2020, yearMax: 2024, page: 1, size: 20 });</p>

<p>console.log('Is empty:', filters.isEmpty()); // Output: false</p>

<p>console.log('Active count:', filters.getActiveFilterCount()); // Output: 3 (manufacturer, yearMin, yearMax)</p>

<p>// Clone and modify const newFilters = filters.merge({ bodyClass: 'SUV' }); console.log('Body class:', newFilters.bodyClass); // Output: 'SUV'</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Statistics empty</td> <td>Wrong API format detection</td> <td>Check for <code class="inline">byManufacturer</code> vs <code class="inline">topManufacturers</code></td></p>
</tr>
<p><tr> <td>Percentages all zero</td> <td>Total count is zero</td> <td>Check totalCount calculation</td></p>
</tr>
<p><tr> <td>Year range wrong</td> <td>Years not parsed as numbers</td> <td>Use <code class="inline">parseInt()</code> for year keys</td></p>
</tr>
<p><tr> <td>Highlight data missing</td> <td>Not preserved in transformation</td> <td>Keep raw <code class="inline">byManufacturer</code> etc.</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Filter models map to URL and API</strong> — Same structure for URL params and query strings</li>
<p><li><strong>Statistics handle two formats</strong> — Array-based and segmented for charts</li> <li><strong>Highlight filters enable chart segmentation</strong> — <code class="inline">h_*</code> prefix for API parameters</li> <li><strong>Transformation preserves raw data</strong> — Keep segmented data for chart highlighting</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domains/automobile/models/automobile.filters.ts</code> exists</li>
<p><li>[ ] <code class="inline">HighlightFilters</code> interface defined</li> <li>[ ] <code class="inline">AutoSearchFilters</code> class with all filter fields</li> <li>[ ] Filter utility methods: <code class="inline">isEmpty()</code>, <code class="inline">clone()</code>, <code class="inline">merge()</code>, <code class="inline">clearSearch()</code></li> <li>[ ] <code class="inline">src/app/domains/automobile/models/automobile.statistics.ts</code> exists</li> <li>[ ] Statistic classes: <code class="inline">ManufacturerStat</code>, <code class="inline">ModelStat</code>, <code class="inline">BodyClassStat</code>, <code class="inline">YearStat</code></li> <li>[ ] <code class="inline">VehicleStatistics</code> class with all aggregation fields</li> <li>[ ] <code class="inline">fromApiResponse()</code> handles both array and segmented formats</li> <li>[ ] Segmented data preserved for chart highlighting</li> <li>[ ] Barrel file exports all models</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments on all properties and methods</li></p>
</ul>
<hr>

<h2>Phase 4 Complete</h2>

<p>Congratulations! You have completed Phase 4: Domain Models.</p>

<p><strong>What you built:</strong></p>
<ul><li>Base model patterns with partial constructors</li>
<p><li><code class="inline">VehicleResult</code> and <code class="inline">VinInstance</code> data models</li> <li><code class="inline">AutoSearchFilters</code> filter model</li> <li><code class="inline">VehicleStatistics</code> and distribution stat models</li> <li>API response transformation for multiple formats</li></p>
</ul>
<p><strong>The Aha Moment:</strong> "Domain models are more than data containers — they encapsulate transformation logic, business rules, and computed values."</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">501-domain-adapter-pattern.md</code> to begin Phase 5: Domain Adapters.</p></div></div>
    <div class="chapter" id="section-501">
        <div class="chapter-header">
            <div class="chapter-category">Adapters</div>
            <h1>501: Domain Adapter Pattern</h1>
        </div>
<div class="page-content"><h1>501: Domain Adapter Pattern</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 306-resource-management-service, 403-domain-filter-statistics-models <strong>Blocks:</strong> 502-url-mapper-adapter, 503-api-adapter</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the Adapter pattern and why it enables domain-agnostic framework code</li>
<p><li>Know the three adapter interfaces: IFilterUrlMapper, IApiAdapter, ICacheKeyBuilder</li> <li>Recognize how adapters bridge domain-specific logic to framework services</li> <li>Be able to design domain adapters for new business domains</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Establish the adapter pattern that allows the framework's <code class="inline">ResourceManagementService</code> to work with any business domain. Define the interfaces that domain-specific adapters must implement.</p>

<hr>

<h2>Why</h2>

<p>The <code class="inline">ResourceManagementService</code> (Section 306) provides:</p>
<ul><li>URL-First state management</li>
<p><li>Automatic data fetching on filter changes</li> <li>Response caching and deduplication</li> <li>Loading/error state management</li></p>
</ul>
<p>But this service doesn't know about vehicles, manufacturers, or body classes. It doesn't know how to:</p>
<ul><li>Convert filters to URL parameters</li>
<p><li>Make API calls for vehicle data</li> <li>Build cache keys for specific queries</li></p>
</ul>
<h3>The Adapter Pattern</h3>

<p>Adapters bridge the gap between generic framework code and domain-specific logic:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────┐
<p>│                    ResourceManagementService                 │ │  (Generic: works with any TFilters, TData, TStatistics)     │ └──────────────────────────────────────────────────────────────┘ │ │ uses interfaces ▼ ┌──────────────────────────────────────────────────────────────┐ │  IFilterUrlMapper    IApiAdapter      ICacheKeyBuilder       │ │  (interface)         (interface)      (interface)            │ └──────────────────────────────────────────────────────────────┘ │ │ implemented by ▼ ┌──────────────────────────────────────────────────────────────┐ │  AutomobileUrlMapper  AutomobileApiAdapter  AutomobileCacheKeyBuilder │ │  (concrete)           (concrete)            (concrete)                │ └──────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>The framework depends on <strong>interfaces</strong> (abstractions), not concrete implementations. Domain modules provide concrete implementations.</p></div><div class="page-content"><h3>Why Three Adapters?</h3>

<p>Each adapter handles one responsibility:</p>

<table>
<p><thead><tr> <th>Adapter</th> <th>Responsibility</th> <th>Interface</th></p>
</tr></thead>
<p><tbody> <tr> <td>URL Mapper</td> <td>Convert filters ↔ URL params</td> <td><code class="inline">IFilterUrlMapper&lt;TFilters&gt;</code></td></p>
</tr>
<p><tr> <td>API Adapter</td> <td>Fetch data from backend</td> <td><code class="inline">IApiAdapter&lt;TFilters, TData, TStats&gt;</code></td></p>
</tr>
<p><tr> <td>Cache Key Builder</td> <td>Create unique cache keys</td> <td><code class="inline">ICacheKeyBuilder&lt;TFilters&gt;</code></td></p>
</tr>
</tbody>
</table>

<p><strong>Separation of concerns:</strong> Each adapter does one thing well. This makes them:</p>
<ul><li>Easy to test individually</li>
<p><li>Easy to replace or mock</li> <li>Easy to understand</li></p>
</ul>
<h3>Interface-Based Polymorphism</h3>

<p>The framework uses TypeScript generics to work with any domain:</p>

<pre class="code-block typescript"><code>// Framework service (domain-agnostic)
<p>class ResourceManagementService&lt;TFilters, TData, TStatistics&gt; { private urlMapper: IFilterUrlMapper&lt;TFilters&gt;; private apiAdapter: IApiAdapter&lt;TFilters, TData, TStatistics&gt;;</p>

<p>// Works with any domain that provides adapters updateFilters(partial: Partial&lt;TFilters&gt;): void { ... } fetchData(): void { ... } }</p>

<p>// Automobile domain provides concrete types type AutoFilters = AutoSearchFilters; type AutoData = VehicleResult; type AutoStats = VehicleStatistics;</p>

<p>// ResourceManagementService&lt;AutoFilters, AutoData, AutoStats&gt;</p>
</code></pre>

<hr>

<h2>What</h2>

<h3>Step 501.1: Review the Adapter Interfaces</h3>

<p>The adapter interfaces are defined in <code class="inline">src/app/framework/models/resource-management.interface.ts</code>. Review them to understand the contract each adapter must fulfill.</p>

<p><strong>IFilterUrlMapper Interface:</strong></p>

<pre class="code-block typescript"><code>/**
 <ul><li>Adapter for mapping filters to/from URL parameters</li>
</ul> */
<p>export interface IFilterUrlMapper&lt;TFilters&gt; { /**</p>
   <ul><li>Convert filters to URL query parameters</li>
</ul>   */
<p>toUrlParams(filters: TFilters): Params;</p>

<p>/**</p>
   <ul><li>Convert URL query parameters to filters</li>
</ul>   */
<p>fromUrlParams(params: Params): TFilters;</p>

<p>/**</p>
   <ul><li>Extract highlight filters from URL parameters (optional)</li>
</ul>   */
<p>extractHighlights?(params: Params): any; }</p>
</code></pre>

<p><strong>IApiAdapter Interface:</strong></p>

<pre class="code-block typescript"><code>/**
 <ul><li>Adapter for fetching data from API</li>
</ul> */
<p>export interface IApiAdapter&lt;TFilters, TData, TStatistics = any&gt; { /**</p>
   <ul><li>Fetch data from API based on filters</li>
</ul>   */
<p>fetchData( filters: TFilters, highlights?: any ): Observable&lt;ApiAdapterResponse&lt;TData, TStatistics&gt;&gt;; }</p>

<p>/**</p>
 <ul><li>Response from API adapter</li>
</ul> */
<p>export interface ApiAdapterResponse&lt;TData, TStatistics = any&gt; { results: TData[]; total: number; statistics?: TStatistics; }</p>
</code></pre>

<p><strong>ICacheKeyBuilder Interface:</strong></p>

<pre class="code-block typescript"><code>/**
 <ul><li>Adapter for building cache keys from filters</li>
</ul> */
<p>export interface ICacheKeyBuilder&lt;TFilters&gt; { /**</p>
   <ul><li>Build a unique cache key from filters</li>
</ul>   */
<p>buildKey(filters: TFilters, highlights?: any): string; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 501.2: Create the Adapters Directory</h3>

<p>Create the directory structure for automobile domain adapters:</p>

<pre class="code-block bash"><code>$ mkdir -p src/app/domains/automobile/adapters
<p>$ touch src/app/domains/automobile/adapters/index.ts</p>
</code></pre>

<p>Create the barrel file <code class="inline">src/app/domains/automobile/adapters/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domains/automobile/adapters/index.ts
<p>// VERSION 1 (Section 501) - Automobile domain adapters barrel</p>

<p>// URL Mapper (Section 502) // export * from './automobile-url-mapper';</p>

<p>// API Adapter (Section 503) // export * from './automobile-api.adapter';</p>

<p>// Cache Key Builder (Section 503) // export * from './automobile-cache-key.builder';</p>
</code></pre>

<hr>

<h3>Step 501.3: Understand Adapter Usage</h3>

<p>The adapters are provided to <code class="inline">ResourceManagementService</code> via a configuration object:</p>

<pre class="code-block typescript"><code>// In domain config factory
<p>const resourceConfig: ResourceManagementConfig&lt; AutoSearchFilters, VehicleResult, VehicleStatistics &gt; = { filterMapper: new AutomobileUrlMapper(), apiAdapter: new AutomobileApiAdapter(apiService, baseUrl), cacheKeyBuilder: new AutomobileCacheKeyBuilder(), defaultFilters: AutoSearchFilters.getDefaults(), autoFetch: true, cacheTTL: 30000 };</p>

<p>// ResourceManagementService uses these adapters const resourceService = new ResourceManagementService( urlStateService, requestCoordinator, resourceConfig );</p>
</code></pre>

<p>The adapters form the bridge between:</p>
<ul><li><strong>URL</strong> (user-facing state)</li>
<p><li><strong>Filters</strong> (domain-specific parameters)</li> <li><strong>API</strong> (backend data source)</li> <li><strong>Cache</strong> (request deduplication)</li></p>
</ul>
<hr>

<h2>Verification</h2>

<h3>1. Check Directory Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domains/automobile/adapters/
</code></pre>

<h3>2. Review Interface File</h3>

<pre class="code-block bash"><code>$ cat src/app/framework/models/resource-management.interface.ts
</code></pre>

<p>Ensure the interface exports include:</p>
<ul><li><code class="inline">IFilterUrlMapper&lt;TFilters&gt;</code></li>
<p><li><code class="inline">IApiAdapter&lt;TFilters, TData, TStatistics&gt;</code></li> <li><code class="inline">ICacheKeyBuilder&lt;TFilters&gt;</code></li> <li><code class="inline">ApiAdapterResponse&lt;TData, TStatistics&gt;</code></li> <li><code class="inline">ResourceManagementConfig&lt;TFilters, TData, TStatistics&gt;</code></li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Generic type requires arguments"</td> <td>Missing type parameters</td> <td>Provide <code class="inline">&lt;TFilters, TData&gt;</code> when implementing</td></p>
</tr>
<p><tr> <td>Method signature mismatch</td> <td>Wrong parameter/return types</td> <td>Match interface signature exactly</td></p>
</tr>
<p><tr> <td>Cannot find interface</td> <td>Import path wrong</td> <td>Import from <code class="inline">@app/framework/models</code></td></p>
</tr>
<p><tr> <td>"Property is missing"</td> <td>Interface not fully implemented</td> <td>Implement all required methods</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Adapters enable domain-agnostic frameworks</strong> — Framework code works with interfaces, not implementations</li>
<p><li><strong>Three adapters, three responsibilities</strong> — URL mapping, API fetching, cache key building</li> <li><strong>TypeScript generics preserve type safety</strong> — <code class="inline">IApiAdapter&lt;AutoFilters, VehicleResult&gt;</code> is type-safe</li> <li><strong>Separation enables testing</strong> — Each adapter can be unit tested in isolation</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] Adapter interfaces understood: IFilterUrlMapper, IApiAdapter, ICacheKeyBuilder</li>
<p><li>[ ] Adapters directory created: <code class="inline">src/app/domains/automobile/adapters/</code></li> <li>[ ] Barrel file created with placeholder exports</li> <li>[ ] Adapter usage pattern understood (configuration object)</li> <li>[ ] Type parameters understood: TFilters, TData, TStatistics</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">502-url-mapper-adapter.md</code> to implement the automobile URL mapper.</p></div></div>
    <div class="chapter" id="section-502">
        <div class="chapter-header">
            <div class="chapter-category">Adapters</div>
            <h1>502: URL Mapper Adapter</h1>
        </div>
<div class="page-content"><h1>502: URL Mapper Adapter</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 501-domain-adapter-pattern, 403-domain-filter-statistics-models <strong>Blocks:</strong> 503-api-adapter, Phase 8 (Framework Components)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to map domain filters to URL query parameters</li>
<p><li>Know how to handle bidirectional type conversion (strings ↔ numbers)</li> <li>Recognize the importance of parameter naming consistency (URL ↔ API)</li> <li>Be able to implement highlight filter extraction for chart segmentation</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">AutomobileUrlMapper</code> that provides bidirectional conversion between <code class="inline">AutoSearchFilters</code> objects and URL query parameters. This adapter enables URL-First state management for the automobile domain.</p>

<hr>

<h2>Why</h2>

<p>The URL-First architecture stores application state in the URL. When a user applies filters:</p>

<ul><li><strong>Filter object created:</strong> <code class="inline">{ manufacturer: 'Toyota', yearMin: 2020, page: 1 }</code></li>
<p><li><strong>URL updated:</strong> <code class="inline">?manufacturer=Toyota&amp;yearMin=2020&amp;page=1</code></li> <li><strong>URL is shareable:</strong> Copy/paste the URL to share the exact filter state</li></p>
</ul>
<p>When a user navigates to a URL with parameters:</p>

<ul><li><strong>URL parsed:</strong> <code class="inline">?manufacturer=Toyota&amp;yearMin=2020</code></li>
<p><li><strong>Filter object created:</strong> <code class="inline">{ manufacturer: 'Toyota', yearMin: 2020 }</code></li> <li><strong>Data fetched:</strong> API called with filter values</li></p>
</ul>
<h3>Bidirectional Mapping</h3>

<p>The URL mapper handles two directions:</p>

<table>
<p><thead><tr> <th>Direction</th> <th>Method</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td>Filters → URL</td> <td><code class="inline">toUrlParams()</code></td> <td>Generate URL from filter state</td></p>
</tr>
<p><tr> <td>URL → Filters</td> <td><code class="inline">fromUrlParams()</code></td> <td>Parse URL into filter state</td></p>
</tr>
</tbody>
</table>

<h3>Type Conversion</h3>

<p>URL parameters are always strings. Filter objects have typed fields:</p>

<pre class="code-block typescript"><code>// URL: ?yearMin=2020&amp;page=1
<p>// Params: { yearMin: '2020', page: '1' }</p>

<p>// Filter object needs: // { yearMin: 2020, page: 1 } (numbers, not strings)</p>
</code></pre>

<p>The mapper handles:</p>
<ul><li><strong>String → Number:</strong> <code class="inline">'2020'</code> → <code class="inline">2020</code></li>
<p><li><strong>Number → String:</strong> <code class="inline">2020</code> → <code class="inline">'2020'</code></li> <li><strong>Array → String:</strong> <code class="inline">['Sedan', 'SUV']</code> → <code class="inline">'Sedan,SUV'</code></li> <li><strong>String → Array:</strong> <code class="inline">'Sedan,SUV'</code> → <code class="inline">['Sedan', 'SUV']</code></li></ul></p></div><div class="page-content"><h3>Parameter Naming</h3>

<p>URL parameters should match API parameters for consistency:</p>

<pre class="code-block text"><code>URL:     ?yearMin=2020&amp;yearMax=2024&amp;sortBy=manufacturer
<p>API:     GET /vehicles?yearMin=2020&amp;yearMax=2024&amp;sortBy=manufacturer</p>
</code></pre>

<p>This allows the URL to be directly usable as API query string (with minor adjustments).</p>

<h3>Highlight Filters</h3>

<p>For chart highlighting, the mapper extracts <code class="inline">h_</code> prefixed parameters:</p>

<pre class="code-block text"><code>URL: ?manufacturer=Toyota&amp;h_yearMin=2022&amp;h_yearMax=2024
</code></pre>

<p>Extracted highlights: <code class="inline">{ yearMin: 2022, yearMax: 2024 }</code></p>

<p>These are sent to the API for segmented statistics: <code class="inline">{ total: 234, highlighted: 45 }</code></p>

<hr>

<h2>What</h2>

<h3>Step 502.1: Create the URL Mapper</h3>

<p>Create the file <code class="inline">src/app/domains/automobile/adapters/automobile-url-mapper.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domains/automobile/adapters/automobile-url-mapper.ts
<p>// VERSION 1 (Section 502) - Automobile URL mapper adapter</p>

<p>import { Injectable } from '@angular/core'; import { Params } from '@angular/router'; import { IFilterUrlMapper } from '../../../framework/models/resource-management.interface'; import { AutoSearchFilters } from '../models/automobile.filters';</p>

<p>/**</p>
 <ul><li>Automobile filter URL mapper</li>
</ul> *
 <ul><li>Bidirectional conversion between filter objects and URL query parameters.</li>
</ul> <ul><li>URL parameter names match backend API parameter names (camelCase).</li>
</ul> *
 <ul><li><strong>URL Parameter Mapping:</strong></li>
</ul> <ul><li>- manufacturer → manufacturer</li>
</ul> <ul><li>- model → model</li>
</ul> <ul><li>- yearMin → yearMin</li>
</ul> <ul><li>- yearMax → yearMax</li>
</ul> <ul><li>- bodyClass → bodyClass</li>
</ul> <ul><li>- page → page</li>
</ul> <ul><li>- size → size</li>
</ul> <ul><li>- sortBy → sort (filter property)</li>
</ul> <ul><li>- sortOrder → sortDirection (filter property)</li>
</ul> *
 <ul><li><strong>Highlight Parameters:</strong></li>
</ul> <ul><li>- h_yearMin, h_yearMax, h_manufacturer, etc.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const mapper = new AutomobileUrlMapper();</li>
</ul> *
 <ul><li>// To URL</li>
</ul> <ul><li>const filters = new AutoSearchFilters({</li>
</ul> <ul><li>  manufacturer: 'Toyota',</li>
</ul> <ul><li>  yearMin: 2020,</li>
</ul> <ul><li>  page: 1</li>
</ul> <ul><li>});</li>
</ul> <ul><li>const params = mapper.toUrlParams(filters);</li>
</ul> <ul><li>// { manufacturer: 'Toyota', yearMin: '2020', page: '1' }</li>
</ul> *
 <ul><li>// From URL</li>
</ul> <ul><li>const urlParams = { manufacturer: 'Toyota', yearMin: '2020', page: '1' };</li>
</ul> <ul><li>const filters = mapper.fromUrlParams(urlParams);</li>
</ul> <ul><li>// AutoSearchFilters { manufacturer: 'Toyota', yearMin: 2020, page: 1 }</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Injectable({ providedIn: 'root' }) export class AutomobileUrlMapper implements IFilterUrlMapper&lt;AutoSearchFilters&gt; { /**</p>
   <ul><li>URL parameter names (match backend API parameter names)</li>
</ul>   */
<p>private readonly PARAM_NAMES = { manufacturer: 'manufacturer', model: 'model', yearMin: 'yearMin', yearMax: 'yearMax', bodyClass: 'bodyClass', instanceCountMin: 'instanceCountMin', instanceCountMax: 'instanceCountMax', search: 'search', modelCombos: 'modelCombos', page: 'page', size: 'size', sort: 'sortBy', sortDirection: 'sortOrder' };</p>

<p>/**</p>
   <ul><li>Convert filters to URL query parameters</li>
</ul>   *
   <ul><li>Maps filter object fields to URL parameter names.</li>
</ul>   <ul><li>Only includes non-null/undefined values.</li>
</ul>   <ul><li>Converts all values to strings for URL compatibility.</li>
</ul>   *
   <ul><li>@param filters - Filter object</li>
</ul>   <ul><li>@returns URL query parameters</li>
</ul>   */
<p>toUrlParams(filters: AutoSearchFilters): Params { const params: Params = {};</p>

<p>// Search filters if (filters.manufacturer !== undefined &amp;&amp; filters.manufacturer !== null) { params[this.PARAM_NAMES.manufacturer] = filters.manufacturer; }</p>

<p>if (filters.model !== undefined &amp;&amp; filters.model !== null) { params[this.PARAM_NAMES.model] = filters.model; }</p>

<p>if (filters.yearMin !== undefined &amp;&amp; filters.yearMin !== null) { params[this.PARAM_NAMES.yearMin] = String(filters.yearMin); }</p>

<p>if (filters.yearMax !== undefined &amp;&amp; filters.yearMax !== null) { params[this.PARAM_NAMES.yearMax] = String(filters.yearMax); }</p>

<p>if (filters.bodyClass !== undefined &amp;&amp; filters.bodyClass !== null) { // Handle array values (multiselect) - join with comma if (Array.isArray(filters.bodyClass)) { if (filters.bodyClass.length &gt; 0) { params[this.PARAM_NAMES.bodyClass] = filters.bodyClass.join(','); } } else { params[this.PARAM_NAMES.bodyClass] = filters.bodyClass; } }</p>

<p>if (filters.instanceCountMin !== undefined &amp;&amp; filters.instanceCountMin !== null) { params[this.PARAM_NAMES.instanceCountMin] = String(filters.instanceCountMin); }</p>

<p>if (filters.instanceCountMax !== undefined &amp;&amp; filters.instanceCountMax !== null) { params[this.PARAM_NAMES.instanceCountMax] = String(filters.instanceCountMax); }</p>

<p>if (filters.search !== undefined &amp;&amp; filters.search !== null) { params[this.PARAM_NAMES.search] = filters.search; }</p>

<p>if (filters.modelCombos !== undefined &amp;&amp; filters.modelCombos !== null) { params[this.PARAM_NAMES.modelCombos] = filters.modelCombos; }</p>

<p>// Pagination if (filters.page !== undefined &amp;&amp; filters.page !== null) { params[this.PARAM_NAMES.page] = String(filters.page); }</p>

<p>if (filters.size !== undefined &amp;&amp; filters.size !== null) { params[this.PARAM_NAMES.size] = String(filters.size); }</p>

<p>// Sorting if (filters.sort !== undefined &amp;&amp; filters.sort !== null) { params[this.PARAM_NAMES.sort] = filters.sort; }</p>

<p>if (filters.sortDirection !== undefined &amp;&amp; filters.sortDirection !== null) { params[this.PARAM_NAMES.sortDirection] = filters.sortDirection; }</p>

<p>return params; }</p>

<p>/**</p>
   <ul><li>Convert URL query parameters to filters</li>
</ul>   *
   <ul><li>Maps URL parameter names back to filter object fields.</li>
</ul>   <ul><li>Performs type conversion (strings to numbers).</li>
</ul>   <ul><li>Returns filter object with only defined values.</li>
</ul>   *
   <ul><li>@param params - URL query parameters</li>
</ul>   <ul><li>@returns Filter object</li>
</ul>   */
<p>fromUrlParams(params: Params): AutoSearchFilters { const filters = new AutoSearchFilters();</p>

<p>// Search filters if (params[this.PARAM_NAMES.manufacturer]) { filters.manufacturer = String(params[this.PARAM_NAMES.manufacturer]); }</p>

<p>if (params[this.PARAM_NAMES.model]) { filters.model = String(params[this.PARAM_NAMES.model]); }</p>

<p>if (params[this.PARAM_NAMES.yearMin]) { const value = this.parseNumber(params[this.PARAM_NAMES.yearMin]); if (value !== null) { filters.yearMin = value; } }</p>

<p>if (params[this.PARAM_NAMES.yearMax]) { const value = this.parseNumber(params[this.PARAM_NAMES.yearMax]); if (value !== null) { filters.yearMax = value; } }</p>

<p>if (params[this.PARAM_NAMES.bodyClass]) { const bodyClassParam = String(params[this.PARAM_NAMES.bodyClass]); // Check if it contains comma (multiple values) if (bodyClassParam.includes(',')) { filters.bodyClass = bodyClassParam.split(',').map(v =&gt; v.trim()); } else { // Single value - return as array for consistency with multiselect filters.bodyClass = [bodyClassParam]; } }</p>

<p>if (params[this.PARAM_NAMES.instanceCountMin]) { const value = this.parseNumber(params[this.PARAM_NAMES.instanceCountMin]); if (value !== null) { filters.instanceCountMin = value; } }</p>

<p>if (params[this.PARAM_NAMES.instanceCountMax]) { const value = this.parseNumber(params[this.PARAM_NAMES.instanceCountMax]); if (value !== null) { filters.instanceCountMax = value; } }</p>

<p>if (params[this.PARAM_NAMES.search]) { filters.search = String(params[this.PARAM_NAMES.search]); }</p>

<p>if (params[this.PARAM_NAMES.modelCombos]) { filters.modelCombos = String(params[this.PARAM_NAMES.modelCombos]); }</p>

<p>// Pagination if (params[this.PARAM_NAMES.page]) { const value = this.parseNumber(params[this.PARAM_NAMES.page]); if (value !== null) { filters.page = value; } }</p>

<p>if (params[this.PARAM_NAMES.size]) { const value = this.parseNumber(params[this.PARAM_NAMES.size]); if (value !== null) { filters.size = value; } }</p>

<p>// Sorting if (params[this.PARAM_NAMES.sort]) { filters.sort = String(params[this.PARAM_NAMES.sort]); }</p>

<p>if (params[this.PARAM_NAMES.sortDirection]) { const direction = String(params[this.PARAM_NAMES.sortDirection]); if (direction === 'asc' || direction === 'desc') { filters.sortDirection = direction; } }</p>

<p>return filters; }</p>

<p>/**</p>
   <ul><li>Extract highlight filters from URL parameters</li>
</ul>   *
   <ul><li>Looks for 'h_' prefixed parameters for chart highlighting.</li>
</ul>   <ul><li>These enable segmented statistics (total vs highlighted).</li>
</ul>   *
   <ul><li>@param params - URL query parameters</li>
</ul>   <ul><li>@returns Highlight filters object</li>
</ul>   */
<p>extractHighlights(params: Params): Record&lt;string, any&gt; { const highlights: Record&lt;string, any&gt; = {}; const prefix = 'h_';</p>

<p>Object.keys(params).forEach(key =&gt; { if (key.startsWith(prefix)) { const highlightKey = key.substring(prefix.length); let value = params[key];</p>

<p>// Normalize separators: Convert pipes to commas if (typeof value === 'string' &amp;&amp; value.includes('|')) { value = value.replace(/\|/g, ','); }</p>

<p>highlights[highlightKey] = value; } });</p>

<p>return highlights; }</p>

<p>/**</p>
   <ul><li>Parse number from URL parameter value</li>
</ul>   *
   <ul><li>@param value - URL parameter value</li>
</ul>   <ul><li>@returns Parsed number or null</li>
</ul>   */
<p>private parseNumber(value: any): number | null { if (value === null || value === undefined || value === '') { return null; }</p>

<p>const num = Number(value); return isNaN(num) ? null : num; }</p>

<p>/**</p>
   <ul><li>Get parameter name mapping</li>
</ul>   *
   <ul><li>@returns Parameter name mapping object</li>
</ul>   */
<p>getParameterMapping(): Record&lt;string, string&gt; { return { ...this.PARAM_NAMES }; }</p>

<p>/**</p>
   <ul><li>Build shareable URL from filters</li>
</ul>   *
   <ul><li>@param baseUrl - Base URL (e.g., '/discover')</li>
</ul>   <ul><li>@param filters - Filter object</li>
</ul>   <ul><li>@returns Complete URL with query parameters</li>
</ul>   */
<p>buildShareableUrl(baseUrl: string, filters: AutoSearchFilters): string { const params = this.toUrlParams(filters); const queryString = Object.entries(params) .map(([key, value]) =&gt; <code class="inline">${key}=${encodeURIComponent(value)}</code>) .join('&amp;');</p>

<p>return queryString ? <code class="inline">${baseUrl}?${queryString}</code> : baseUrl; }</p>

<p>/**</p>
   <ul><li>Validate URL parameters</li>
</ul>   *
   <ul><li>@param params - URL query parameters</li>
</ul>   <ul><li>@returns Validation result with errors</li>
</ul>   */
<p>validateUrlParams(params: Params): { valid: boolean; errors: string[] } { const errors: string[] = [];</p>

<p>// Check numeric fields const numericFields = [ this.PARAM_NAMES.yearMin, this.PARAM_NAMES.yearMax, this.PARAM_NAMES.instanceCountMin, this.PARAM_NAMES.instanceCountMax, this.PARAM_NAMES.page, this.PARAM_NAMES.size ];</p>

<p>numericFields.forEach(field =&gt; { if (params[field] !== undefined &amp;&amp; params[field] !== null) { const value = this.parseNumber(params[field]); if (value === null) { errors.push(<code class="inline">Invalid numeric value for ${field}: ${params[field]}</code>); } } });</p>

<p>// Check sort direction if (params[this.PARAM_NAMES.sortDirection]) { const direction = String(params[this.PARAM_NAMES.sortDirection]); if (direction !== 'asc' &amp;&amp; direction !== 'desc') { errors.push(<code class="inline">Invalid sort direction: ${direction}. Must be 'asc' or 'desc'.</code>); } }</p>

<p>// Check year range if (params[this.PARAM_NAMES.yearMin] &amp;&amp; params[this.PARAM_NAMES.yearMax]) { const min = this.parseNumber(params[this.PARAM_NAMES.yearMin]); const max = this.parseNumber(params[this.PARAM_NAMES.yearMax]); if (min !== null &amp;&amp; max !== null &amp;&amp; min &gt; max) { errors.push(<code class="inline">Year minimum (${min}) cannot be greater than maximum (${max})</code>); } }</p>

<p>return { valid: errors.length === 0, errors }; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 502.2: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/domains/automobile/adapters/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domains/automobile/adapters/index.ts
<p>// VERSION 2 (Section 502) - Added URL mapper</p>

<p>export * from './automobile-url-mapper';</p>

<p>// API Adapter (Section 503) // export * from './automobile-api.adapter';</p>

<p>// Cache Key Builder (Section 503) // export * from './automobile-cache-key.builder';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Exists</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domains/automobile/adapters/automobile-url-mapper.ts
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/domains/automobile/adapters/automobile-url-mapper.ts
</code></pre>

<h3>3. Test Mapping</h3>

<pre class="code-block typescript"><code>import { AutomobileUrlMapper } from '@app/domains/automobile/adapters';
<p>import { AutoSearchFilters } from '@app/domains/automobile/models';</p>

<p>const mapper = new AutomobileUrlMapper();</p>

<p>// Test toUrlParams const filters = new AutoSearchFilters({ manufacturer: 'Toyota', yearMin: 2020, yearMax: 2024, bodyClass: ['Sedan', 'SUV'], page: 1, size: 20 });</p>

<p>const params = mapper.toUrlParams(filters); console.log('URL params:', params); // { manufacturer: 'Toyota', yearMin: '2020', yearMax: '2024', //   bodyClass: 'Sedan,SUV', page: '1', size: '20' }</p>

<p>// Test fromUrlParams const urlParams = { manufacturer: 'Honda', yearMin: '2022', page: '2' };</p>

<p>const parsedFilters = mapper.fromUrlParams(urlParams); console.log('Parsed filters:', parsedFilters); // AutoSearchFilters { manufacturer: 'Honda', yearMin: 2022, page: 2 }</p>

<p>// Test highlight extraction const highlightParams = { manufacturer: 'Ford', h_yearMin: '2023', h_yearMax: '2024' };</p>

<p>const highlights = mapper.extractHighlights(highlightParams); console.log('Highlights:', highlights); // { yearMin: '2023', yearMax: '2024' }</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Numbers come back as strings</td> <td>Missing <code class="inline">parseNumber()</code> call</td> <td>Use <code class="inline">parseNumber()</code> for numeric fields</td></p>
</tr>
<p><tr> <td>Array comes back as string</td> <td>Missing comma split</td> <td>Check for comma and split</td></p>
</tr>
<p><tr> <td>Highlight params not extracted</td> <td>Wrong prefix check</td> <td>Ensure <code class="inline">h_</code> prefix matching</td></p>
</tr>
<p><tr> <td>Empty string in URL</td> <td>Null/undefined not filtered</td> <td>Check for null/undefined before adding</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Bidirectional mapping is essential</strong> — Filters ↔ URL must work both ways</li>
<p><li><strong>Type conversion is critical</strong> — URL strings must become proper types</li> <li><strong>Parameter naming matters</strong> — Consistency between URL and API simplifies debugging</li> <li><strong>Highlight extraction enables charts</strong> — <code class="inline">h_</code> prefix separates highlight from filter params</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domains/automobile/adapters/automobile-url-mapper.ts</code> exists</li>
<p><li>[ ] Implements <code class="inline">IFilterUrlMapper&lt;AutoSearchFilters&gt;</code> interface</li> <li>[ ] <code class="inline">toUrlParams()</code> converts all filter fields to URL params</li> <li>[ ] <code class="inline">fromUrlParams()</code> parses all URL params to filter fields</li> <li>[ ] Numeric fields properly converted (string ↔ number)</li> <li>[ ] Array fields properly handled (bodyClass multiselect)</li> <li>[ ] <code class="inline">extractHighlights()</code> finds <code class="inline">h_</code> prefixed params</li> <li>[ ] Validation method checks for invalid values</li> <li>[ ] Barrel file exports the mapper</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments on all public methods</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">503-api-adapter.md</code> to implement the automobile API adapter.</p></div></div>
    <div class="chapter" id="section-503">
        <div class="chapter-header">
            <div class="chapter-category">Adapters</div>
            <h1>503: API Adapter</h1>
        </div>
<div class="page-content"><h1>503: API Adapter</h1>

<p><strong>Status:</strong> Complete <strong>Depends On:</strong> 501-domain-adapter-pattern, 502-url-mapper-adapter, 302-api-service <strong>Blocks:</strong> Phase 8 (Framework Components), Phase 9 (Feature Components)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to implement domain-specific API adapters</li>
<p><li>Know how to transform API responses to domain models</li> <li>Recognize the difference between services and adapter classes</li> <li>Be able to implement cache key builders for request deduplication</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the <code class="inline">AutomobileApiAdapter</code> for fetching vehicle data and the <code class="inline">AutomobileCacheKeyBuilder</code> for generating unique cache keys. These adapters complete the domain adapter layer.</p>

<hr>

<h2>Why</h2>

<h3>API Adapter: Domain-Specific Fetching</h3>

<p>The framework's <code class="inline">ResourceManagementService</code> knows <em>when</em> to fetch data (on filter changes), but not <em>how</em> to fetch automobile data. The API adapter provides:</p>

<ul><li><strong>Endpoint knowledge</strong> — Which URL to call (<code class="inline">/vehicles/details</code>)</li>
<p><li><strong>Parameter mapping</strong> — How to convert filters to API params</li> <li><strong>Response transformation</strong> — How to convert API JSON to domain models</li></p>
</ul>
<pre class="code-block typescript"><code>// Framework calls:
<p>apiAdapter.fetchData(filters, highlights)</p>

<p>// Adapter implements: fetchData(filters) { const params = this.filtersToApiParams(filters); return this.api.get('/vehicles/details', params).pipe( map(response =&gt; ({ results: response.results.map(r =&gt; VehicleResult.fromApiResponse(r)), total: response.total, statistics: VehicleStatistics.fromApiResponse(response.statistics) })) ); }</p>
</code></pre>

<h3>Not an Angular Service</h3>

<p>The API adapter is a <strong>plain class</strong>, not an <code class="inline">@Injectable()</code> service. This is intentional:</p>

<table>
<p><thead><tr> <th>Aspect</th> <th>Service</th> <th>Adapter Class</th></p>
</tr></thead>
<p><tbody> <tr> <td>Lifecycle</td> <td>Singleton</td> <td>Created per config</td></p>
</tr>
<p><tr> <td>Constructor</td> <td>DI by Angular</td> <td>Manual with args</td></p>
</tr>
<p><tr> <td>Testability</td> <td>Needs TestBed</td> <td>Plain new()</td></p>
</tr>
<p><tr> <td>Configuration</td> <td>Environment-based</td> <td>Constructor params</td></p>
</tr>
</tbody>
</table>

<p>The adapter is instantiated in the domain config factory with specific configuration (base URL, API service).</p></div><div class="page-content"><h3>Cache Key Builder</h3>

<p>The <code class="inline">RequestCoordinatorService</code> deduplicates identical requests. It needs a unique key for each request. The cache key builder creates this key from filters:</p>

<pre class="code-block typescript"><code>// Same filters = same cache key = deduplicated
<p>buildKey({ manufacturer: 'Toyota', page: 1 }) // → 'vehicles:manufacturer=Toyota|page=1'</p>

<p>buildKey({ manufacturer: 'Toyota', page: 1 }) // → 'vehicles:manufacturer=Toyota|page=1' (same, deduplicated)</p>

<p>buildKey({ manufacturer: 'Honda', page: 1 }) // → 'vehicles:manufacturer=Honda|page=1' (different, new request)</p>
</code></pre>

<h3>Highlight Parameters in Cache Key</h3>

<p>Highlight filters must be included in the cache key because they affect the response:</p>

<pre class="code-block typescript"><code>// Different highlights = different cache key
<p>buildKey({ manufacturer: 'Toyota' }, { yearMin: 2020 }) // → 'vehicles:manufacturer=Toyota|h_yearMin=2020'</p>

<p>buildKey({ manufacturer: 'Toyota' }, { yearMin: 2022 }) // → 'vehicles:manufacturer=Toyota|h_yearMin=2022' (different)</p>
</code></pre>

<hr>

<h2>What</h2>

<h3>Step 503.1: Create the API Adapter</h3>

<p>Create the file <code class="inline">src/app/domains/automobile/adapters/automobile-api.adapter.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domains/automobile/adapters/automobile-api.adapter.ts
<p>// VERSION 1 (Section 503) - Automobile API adapter</p>

<p>import { Observable } from 'rxjs'; import { map } from 'rxjs/operators'; import { IApiAdapter, ApiAdapterResponse } from '../../../framework/models/resource-management.interface'; import { ApiResponse } from '../../../framework/models/api-response.interface'; import { ApiService } from '../../../framework/services/api.service'; import { AutoSearchFilters } from '../models/automobile.filters'; import { VehicleResult } from '../models/automobile.data'; import { VehicleStatistics } from '../models/automobile.statistics';</p>

<p>/**</p>
 <ul><li>Automobile API adapter</li>
</ul> *
 <ul><li>Fetches vehicle data from the automobile discovery API.</li>
</ul> <ul><li>Transforms API responses into domain models.</li>
</ul> *
 <ul><li>NOTE: This is NOT an Angular service. It's instantiated manually</li>
</ul> <ul><li>in the domain config factory with the base URL.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const adapter = new AutomobileApiAdapter(apiService, 'http://api.example.com/v1');</li>
</ul> <ul><li>const filters = new AutoSearchFilters({ manufacturer: 'Toyota' });</li>
</ul> *
 <ul><li>adapter.fetchData(filters).subscribe(response =&gt; {</li>
</ul> <ul><li>  console.log('Vehicles:', response.results);</li>
</ul> <ul><li>  console.log('Total:', response.total);</li>
</ul> <ul><li>  console.log('Statistics:', response.statistics);</li>
</ul> <ul><li>});</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export class AutomobileApiAdapter implements IApiAdapter&lt;AutoSearchFilters, VehicleResult, VehicleStatistics&gt; { /**</p>
   <ul><li>API endpoint for vehicle search</li>
</ul>   */
<p>private readonly VEHICLES_ENDPOINT = '/vehicles/details';</p>

<p>/**</p>
   <ul><li>API endpoint for statistics only</li>
</ul>   */
<p>private readonly STATISTICS_ENDPOINT = '/statistics';</p>

<p>/**</p>
   <ul><li>Base URL for API requests</li>
</ul>   */
<p>private baseUrl: string;</p>

<p>/**</p>
   <ul><li>API service for making HTTP requests</li>
</ul>   */
<p>private apiService: ApiService;</p>

<p>/**</p>
   <ul><li>Constructor</li>
</ul>   *
   <ul><li>@param apiService - Injected API service for HTTP requests</li>
</ul>   <ul><li>@param baseUrl - Base URL for automobile API</li>
</ul>   */
<p>constructor(apiService: ApiService, baseUrl: string) { this.apiService = apiService; this.baseUrl = baseUrl; }</p>

<p>/**</p>
   <ul><li>Fetch vehicle data from API</li>
</ul>   *
   <ul><li>@param filters - Search filters</li>
</ul>   <em> @param highlights - Optional highlight filters (h_</em> parameters)
   <ul><li>@returns Observable of vehicle results with statistics</li>
</ul>   */
<p>fetchData( filters: AutoSearchFilters, highlights?: any ): Observable&lt;ApiAdapterResponse&lt;VehicleResult, VehicleStatistics&gt;&gt; { // Convert filters to API parameters const params = this.filtersToApiParams(filters, highlights); const url = <code class="inline">${this.baseUrl}${this.VEHICLES_ENDPOINT}</code>;</p>

<p>// Fetch vehicle data return this.apiService.get&lt;VehicleResult&gt;(url, { params }).pipe( map((apiResponse: ApiResponse&lt;VehicleResult&gt;) =&gt; { // Transform API response to adapter response return { results: apiResponse.results.map(item =&gt; VehicleResult.fromApiResponse(item) ), total: apiResponse.total, statistics: apiResponse.statistics ? VehicleStatistics.fromApiResponse(apiResponse.statistics) : undefined }; }) ); }</p>

<p>/**</p>
   <ul><li>Fetch statistics only (without vehicle data)</li>
</ul>   *
   <ul><li>Useful for refreshing statistics panel without reloading table data.</li>
</ul>   *
   <ul><li>@param filters - Search filters</li>
</ul>   <ul><li>@returns Observable of statistics</li>
</ul>   */
<p>fetchStatistics(filters: AutoSearchFilters): Observable&lt;VehicleStatistics&gt; { const params = this.filtersToApiParams(filters);</p>

<p>return this.apiService .get&lt;VehicleStatistics&gt;(<code class="inline">${this.baseUrl}${this.STATISTICS_ENDPOINT}</code>, params) .pipe( map((response: any) =&gt; { // API might return statistics directly or wrapped const statsData = response.statistics || response; return VehicleStatistics.fromApiResponse(statsData); }) ); }</p>

<p>/**</p>
   <ul><li>Convert filter object to API query parameters</li>
</ul>   *
   <ul><li>@param filters - Domain filters</li>
</ul>   <em> @param highlights - Optional highlight filters (h_</em> parameters)
   <ul><li>@returns API query parameters</li>
</ul>   */
<p>private filtersToApiParams( filters: AutoSearchFilters, highlights?: any ): Record&lt;string, any&gt; { const params: Record&lt;string, any&gt; = {};</p>

<p>// Search filters if (filters.manufacturer) { params['manufacturer'] = filters.manufacturer; }</p>

<p>if (filters.model) { params['model'] = filters.model; }</p>

<p>if (filters.yearMin !== undefined &amp;&amp; filters.yearMin !== null) { params['yearMin'] = filters.yearMin; }</p>

<p>if (filters.yearMax !== undefined &amp;&amp; filters.yearMax !== null) { params['yearMax'] = filters.yearMax; }</p>

<p>if (filters.bodyClass) { params['bodyClass'] = filters.bodyClass; }</p>

<p>if (filters.instanceCountMin !== undefined &amp;&amp; filters.instanceCountMin !== null) { params['instanceCountMin'] = filters.instanceCountMin; }</p>

<p>if (filters.instanceCountMax !== undefined &amp;&amp; filters.instanceCountMax !== null) { params['instanceCountMax'] = filters.instanceCountMax; }</p>

<p>if (filters.search) { params['search'] = filters.search; }</p>

<p>// Model combinations from picker if (filters.modelCombos) { params['models'] = filters.modelCombos; }</p>

<p>// Pagination if (filters.page !== undefined &amp;&amp; filters.page !== null) { params['page'] = filters.page; }</p>

<p>if (filters.size !== undefined &amp;&amp; filters.size !== null) { params['size'] = filters.size; }</p>

<p>// Sorting if (filters.sort) { params['sortBy'] = filters.sort; }</p>

<p>if (filters.sortDirection) { params['sortOrder'] = filters.sortDirection; }</p>

<p>// Highlight parameters (h_* prefix for segmented statistics) if (highlights) { if (highlights.yearMin !== undefined &amp;&amp; highlights.yearMin !== null) { params['h_yearMin'] = String(highlights.yearMin); }</p>

<p>if (highlights.yearMax !== undefined &amp;&amp; highlights.yearMax !== null) { params['h_yearMax'] = String(highlights.yearMax); }</p>

<p>if (highlights.manufacturer) { params['h_manufacturer'] = highlights.manufacturer; }</p>

<p>if (highlights.modelCombos) { params['h_modelCombos'] = highlights.modelCombos; }</p>

<p>if (highlights.bodyClass) { params['h_bodyClass'] = highlights.bodyClass; } }</p>

<p>return params; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 503.2: Create the Cache Key Builder</h3>

<p>Create the file <code class="inline">src/app/domains/automobile/adapters/automobile-cache-key.builder.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domains/automobile/adapters/automobile-cache-key.builder.ts
<p>// VERSION 1 (Section 503) - Automobile cache key builder</p>

<p>import { ICacheKeyBuilder } from '../../../framework/models/resource-management.interface'; import { AutoSearchFilters } from '../models/automobile.filters';</p>

<p>/**</p>
 <ul><li>Automobile cache key builder</li>
</ul> *
 <ul><li>Creates unique cache keys from filter objects for request deduplication.</li>
</ul> <ul><li>Keys are deterministic: same filters always produce the same key.</li>
</ul> *
 <ul><li>Key format: <code class="inline">vehicles:{filter1}={value1}|{filter2}={value2}|...</code></li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>const builder = new AutomobileCacheKeyBuilder();</li>
</ul> *
 <ul><li>const key = builder.buildKey({ manufacturer: 'Toyota', page: 1 });</li>
</ul> <ul><li>// → 'vehicles:manufacturer=Toyota|page=1'</li>
</ul> *
 <ul><li>const keyWithHighlights = builder.buildKey(</li>
</ul> <ul><li>  { manufacturer: 'Toyota' },</li>
</ul> <ul><li>  { yearMin: 2020 }</li>
</ul> <ul><li>);</li>
</ul> <ul><li>// → 'vehicles:manufacturer=Toyota|h_yearMin=2020'</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export class AutomobileCacheKeyBuilder implements ICacheKeyBuilder&lt;AutoSearchFilters&gt; { /**</p>
   <ul><li>Prefix for all automobile cache keys</li>
</ul>   */
<p>private readonly PREFIX = 'vehicles';</p>

<p>/**</p>
   <ul><li>Build a unique cache key from filters</li>
</ul>   *
   <ul><li>@param filters - Filter object</li>
</ul>   <ul><li>@param highlights - Optional highlight filters</li>
</ul>   <ul><li>@returns Cache key string</li>
</ul>   */
<p>buildKey(filters: AutoSearchFilters, highlights?: any): string { const parts: string[] = [];</p>

<p>// Add filter parts (sorted for consistency) if (filters.manufacturer) { parts.push(<code class="inline">manufacturer=${filters.manufacturer}</code>); }</p>

<p>if (filters.model) { parts.push(<code class="inline">model=${filters.model}</code>); }</p>

<p>if (filters.yearMin !== undefined &amp;&amp; filters.yearMin !== null) { parts.push(<code class="inline">yearMin=${filters.yearMin}</code>); }</p>

<p>if (filters.yearMax !== undefined &amp;&amp; filters.yearMax !== null) { parts.push(<code class="inline">yearMax=${filters.yearMax}</code>); }</p>

<p>if (filters.bodyClass) { const bodyClassValue = Array.isArray(filters.bodyClass) ? filters.bodyClass.join(',') : filters.bodyClass; parts.push(<code class="inline">bodyClass=${bodyClassValue}</code>); }</p>

<p>if (filters.instanceCountMin !== undefined &amp;&amp; filters.instanceCountMin !== null) { parts.push(<code class="inline">instanceCountMin=${filters.instanceCountMin}</code>); }</p>

<p>if (filters.instanceCountMax !== undefined &amp;&amp; filters.instanceCountMax !== null) { parts.push(<code class="inline">instanceCountMax=${filters.instanceCountMax}</code>); }</p>

<p>if (filters.search) { parts.push(<code class="inline">search=${filters.search}</code>); }</p>

<p>if (filters.modelCombos) { parts.push(<code class="inline">modelCombos=${filters.modelCombos}</code>); }</p>

<p>// Pagination if (filters.page !== undefined &amp;&amp; filters.page !== null) { parts.push(<code class="inline">page=${filters.page}</code>); }</p>

<p>if (filters.size !== undefined &amp;&amp; filters.size !== null) { parts.push(<code class="inline">size=${filters.size}</code>); }</p>

<p>// Sorting if (filters.sort) { parts.push(<code class="inline">sort=${filters.sort}</code>); }</p>

<p>if (filters.sortDirection) { parts.push(<code class="inline">sortDir=${filters.sortDirection}</code>); }</p>

<p>// Add highlight parts (with h_ prefix) if (highlights) { if (highlights.yearMin !== undefined &amp;&amp; highlights.yearMin !== null) { parts.push(<code class="inline">h_yearMin=${highlights.yearMin}</code>); }</p>

<p>if (highlights.yearMax !== undefined &amp;&amp; highlights.yearMax !== null) { parts.push(<code class="inline">h_yearMax=${highlights.yearMax}</code>); }</p>

<p>if (highlights.manufacturer) { parts.push(<code class="inline">h_manufacturer=${highlights.manufacturer}</code>); }</p>

<p>if (highlights.modelCombos) { parts.push(<code class="inline">h_modelCombos=${highlights.modelCombos}</code>); }</p>

<p>if (highlights.bodyClass) { parts.push(<code class="inline">h_bodyClass=${highlights.bodyClass}</code>); } }</p>

<p>// Build final key return parts.length &gt; 0 ? <code class="inline">${this.PREFIX}:${parts.join('|')}</code> : this.PREFIX; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 503.3: Update the Barrel File</h3>

<p>Update <code class="inline">src/app/domains/automobile/adapters/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domains/automobile/adapters/index.ts
<p>// VERSION 3 (Section 503) - Complete adapters</p>

<p>export * from './automobile-url-mapper'; export * from './automobile-api.adapter'; export * from './automobile-cache-key.builder';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check Files Exist</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domains/automobile/adapters/
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>total 20
<p>drwxr-xr-x 2 user user 4096 Feb  9 12:00 . drwxr-xr-x 3 user user 4096 Feb  9 12:00 .. -rw-r--r-- 1 user user 4567 Feb  9 12:00 automobile-api.adapter.ts -rw-r--r-- 1 user user 2345 Feb  9 12:00 automobile-cache-key.builder.ts -rw-r--r-- 1 user user 6789 Feb  9 12:00 automobile-url-mapper.ts -rw-r--r-- 1 user user  200 Feb  9 12:00 index.ts</p>
</code></pre>

<h3>2. TypeScript Compilation Check</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit src/app/domains/automobile/adapters/index.ts
</code></pre>

<h3>3. Test API Adapter</h3>

<pre class="code-block typescript"><code>import { AutomobileApiAdapter } from '@app/domains/automobile/adapters';
<p>import { ApiService } from '@app/framework/services'; import { AutoSearchFilters } from '@app/domains/automobile/models';</p>

<p>// Create adapter (normally done in domain config factory) const adapter = new AutomobileApiAdapter(apiService, 'http://localhost:3000/api/v1');</p>

<p>// Test fetch const filters = new AutoSearchFilters({ manufacturer: 'Toyota', yearMin: 2020, page: 1, size: 20 });</p>

<p>adapter.fetchData(filters).subscribe(response =&gt; { console.log('Results:', response.results.length); console.log('Total:', response.total); console.log('First vehicle:', response.results[0]?.getDisplayName()); });</p>
</code></pre>

<h3>4. Test Cache Key Builder</h3>

<pre class="code-block typescript"><code>import { AutomobileCacheKeyBuilder } from '@app/domains/automobile/adapters';
<p>import { AutoSearchFilters } from '@app/domains/automobile/models';</p>

<p>const builder = new AutomobileCacheKeyBuilder();</p>

<p>// Test basic key const key1 = builder.buildKey(new AutoSearchFilters({ manufacturer: 'Toyota', page: 1 })); console.log('Key 1:', key1); // → 'vehicles:manufacturer=Toyota|page=1'</p>

<p>// Test with highlights const key2 = builder.buildKey( new AutoSearchFilters({ manufacturer: 'Toyota' }), { yearMin: 2020, yearMax: 2024 } ); console.log('Key 2:', key2); // → 'vehicles:manufacturer=Toyota|h_yearMin=2020|h_yearMax=2024'</p>

<p>// Test determinism (same filters = same key) const key3 = builder.buildKey(new AutoSearchFilters({ manufacturer: 'Toyota', page: 1 })); console.log('Keys match:', key1 === key3); // → true</p>
</code></pre></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot read property 'get'"</td> <td>ApiService not passed</td> <td>Pass ApiService to constructor</td></p>
</tr>
<p><tr> <td>Results not transformed</td> <td>Missing <code class="inline">fromApiResponse()</code></td> <td>Call model's static factory</td></p>
</tr>
<p><tr> <td>Cache key collision</td> <td>Missing filter in key</td> <td>Add filter to <code class="inline">buildKey()</code></td></p>
</tr>
<p><tr> <td>Highlights not in cache key</td> <td>Highlights not added</td> <td>Include h_* params in key</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Adapters are plain classes, not services</strong> — Enables manual construction with config</li>
<p><li><strong>Response transformation uses domain models</strong> — <code class="inline">VehicleResult.fromApiResponse()</code></li> <li><strong>Cache keys must be deterministic</strong> — Same filters always produce same key</li> <li><strong>Highlights affect cache keys</strong> — Different highlights = different cached response</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domains/automobile/adapters/automobile-api.adapter.ts</code> exists</li>
<p><li>[ ] Implements <code class="inline">IApiAdapter&lt;AutoSearchFilters, VehicleResult, VehicleStatistics&gt;</code></li> <li>[ ] <code class="inline">fetchData()</code> makes API call and transforms response</li> <li>[ ] Response transformation uses <code class="inline">VehicleResult.fromApiResponse()</code></li> <li>[ ] Statistics transformation uses <code class="inline">VehicleStatistics.fromApiResponse()</code></li> <li>[ ] <code class="inline">src/app/domains/automobile/adapters/automobile-cache-key.builder.ts</code> exists</li> <li>[ ] Implements <code class="inline">ICacheKeyBuilder&lt;AutoSearchFilters&gt;</code></li> <li>[ ] <code class="inline">buildKey()</code> produces deterministic keys</li> <li>[ ] Cache key includes highlight parameters</li> <li>[ ] Barrel file exports all adapters</li> <li>[ ] TypeScript compilation succeeds</li> <li>[ ] JSDoc comments on all public methods</li></p>
</ul>
<hr>

<h2>Phase 5 Complete</h2>

<p>Congratulations! You have completed Phase 5: Domain Adapters.</p>

<p><strong>What you built:</strong></p>
<ul><li>Adapter pattern understanding and interfaces</li>
<p><li><code class="inline">AutomobileUrlMapper</code> for URL ↔ filter conversion</li> <li><code class="inline">AutomobileApiAdapter</code> for API data fetching</li> <li><code class="inline">AutomobileCacheKeyBuilder</code> for request deduplication</li></p>
</ul>
<p><strong>The Aha Moment:</strong> "Adapters are the bridge between generic framework code and domain-specific logic. They enable reusability without sacrificing type safety."</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">801-base-table-component.md</code> to begin Phase 8: Framework Components.</p></div></div>
    <div class="chapter" id="section-601">
        <div class="chapter-header">
            <div class="chapter-category">Domain Config</div>
            <h1>601: Filter Definitions</h1>
        </div>
<div class="page-content"><h1>601: Filter Definitions</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 401-automobile-filters-model, 203-filter-definition-interface <strong>Blocks:</strong> 604-query-control-filters, 607-domain-config-assembly</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how declarative filter definitions drive UI component generation</li>
<p><li>Know how to configure different filter types (autocomplete, range, multiselect, text)</li> <li>Recognize the pattern of separating filter metadata from filter state</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the automobile filter definitions array that tells the Query Panel component which filters to display and how to configure them. These definitions are pure data — they describe what filters exist, not how to render them.</p>

<hr>

<h2>Why</h2>

<p>In traditional applications, you might create a separate component for each filter: ManufacturerFilterComponent, YearRangeFilterComponent, BodyClassFilterComponent. This approach leads to:</p>

<ul><li><strong>Code duplication</strong> — Each filter component has similar structure (label, input, validation)</li>
<p><li><strong>Tight coupling</strong> — Adding a new filter requires writing new component code</li> <li><strong>Inconsistent UX</strong> — Different developers implement filters differently</li></p>
</ul>
<p>The configuration-driven approach solves these problems:</p>

<ul><li><strong>Single component, multiple instances</strong> — One QueryPanelComponent renders all filters</li>
<p><li><strong>Loose coupling</strong> — Adding a new filter means adding a new object to an array</li> <li><strong>Consistent UX</strong> — All filters use the same rendering logic</li></p>
</ul>
<p><strong>This is the Phase 6 "Aha Moment":</strong> Configuration is declarative code. You describe what you want, not how to get it. The filter definitions say "I need an autocomplete for manufacturer with these options" — they don't say "create an input element, attach a keyup listener, debounce for 300ms, call the API..."</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-01">Style 03-01</a>: Use consistent naming for symbols</li>
<p><li>Configuration objects are a recognized Angular pattern for customizing component behavior</li></ul></p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 601.1: Create the Filter Definitions File</h3>

<p>Create the file that will contain all automobile filter definitions.</p>

<p>Create <code class="inline">src/app/domain-config/automobile/configs/automobile.filter-definitions.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/configs/automobile.filter-definitions.ts

<p>/**</p>
 <ul><li>Automobile Domain - Filter Definitions</li>
</ul> *
 <ul><li>Defines query control filters for the automobile discovery interface.</li>
</ul> <ul><li>These are UI filters that users can interact with to refine their search.</li>
</ul> *
 <ul><li>Domain: Automobile Discovery</li>
</ul> */

<p>import { FilterDefinition } from '../../../framework/models/filter-definition.interface';</p>

<p>/**</p>
 <ul><li>Automobile filter definitions</li>
</ul> *
 <ul><li>Array of filter controls for the query panel.</li>
</ul> <ul><li>Users can combine these filters to search for specific vehicles.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>&lt;div class="filter-panel"&gt;</li>
</ul> <ul><li>  &lt;app-filter-control</li>
</ul> <em>     </em>ngFor="let filter of AUTOMOBILE_FILTER_DEFINITIONS"
 <ul><li>    [definition]="filter"</li>
</ul> <ul><li>    [(value)]="filterValues[filter.id]"&gt;</li>
</ul> <ul><li>  &lt;/app-filter-control&gt;</li>
</ul> <ul><li>&lt;/div&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const AUTOMOBILE_FILTER_DEFINITIONS: FilterDefinition[] = [ /**</p>
   <ul><li>Manufacturer filter</li>
</ul>   */
<p>{ id: 'manufacturer', label: 'Manufacturer', type: 'autocomplete', placeholder: 'Enter manufacturer name...', autocompleteEndpoint: 'filters/manufacturers', autocompleteMinChars: 1, operators: ['contains', 'equals', 'startsWith'], defaultOperator: 'contains', validation: { minLength: 1, maxLength: 100 } },</p>

<p>/**</p>
   <ul><li>Model filter</li>
</ul>   *
   <ul><li>Uses autocomplete with progressive refinement:</li>
</ul>   <ul><li>- User types 2+ characters</li>
</ul>   <ul><li>- Backend returns top 10 matching models</li>
</ul>   <ul><li>- Results narrow as user types more</li>
</ul>   */
<p>{ id: 'model', label: 'Model', type: 'autocomplete', placeholder: 'Type to search models...', autocompleteEndpoint: 'filters/models', autocompleteMinChars: 1, operators: ['contains', 'equals', 'startsWith'], defaultOperator: 'contains', validation: { minLength: 1, maxLength: 100 } },</p>

<p>/**</p>
   <ul><li>Year range filter</li>
</ul>   *
   <ul><li>Uses format.number.useGrouping: false to prevent thousand separators</li>
</ul>   <ul><li>(displays "1980" instead of "1,980")</li>
</ul>   *
   <ul><li>Note: id is 'year' so Query Panel looks for 'yearMin'/'yearMax' in currentFilters,</li>
</ul>   <ul><li>which matches the actual filter model field names (AutoSearchFilters.yearMin/yearMax)</li>
</ul>   */
<p>{ id: 'year', label: 'Year Range', type: 'range', min: 1900, max: new Date().getFullYear() + 1, // Include next year for upcoming models step: 1, format: { number: { useGrouping: false, // No commas in years minimumFractionDigits: 0, maximumFractionDigits: 0 } } },</p>

<p>/**</p>
   <ul><li>Body class filter (multi-select)</li>
</ul>   *
   <ul><li>Uses optionsEndpoint to load options dynamically from the backend.</li>
</ul>   <ul><li>This ensures all body classes in the data are available as options.</li>
</ul>   <ul><li>Allows selecting multiple body classes with checkboxes.</li>
</ul>   */
<p>{ id: 'bodyClass', label: 'Body Class', type: 'multiselect', placeholder: 'Select body classes...', format: { caseSensitive: false, // Match "Coupe", "coupe", "COUPE" equally transform: 'titlecase' // Normalize to "Coupe" format }, optionsEndpoint: 'body_class' // Loads from /api/specs/v1/agg/body_class },</p>

<p>/**</p>
   <ul><li>Instance count range filter</li>
</ul>   *
   <ul><li>Uses format.number.useGrouping: true to show thousand separators</li>
</ul>   <ul><li>(displays "1,000" instead of "1000")</li>
</ul>   */
<p>{ id: 'instanceCountRange', label: 'VIN Count Range', type: 'range', min: 0, max: 10000, step: 1, format: { number: { useGrouping: true, // Show commas for VIN counts minimumFractionDigits: 0, maximumFractionDigits: 0 } } },</p>

<p>/**</p>
   <ul><li>Global search filter</li>
</ul>   */
<p>{ id: 'search', label: 'Search', type: 'text', placeholder: 'Search manufacturer, model, or body class...', operators: ['contains'], defaultOperator: 'contains', validation: { minLength: 1, maxLength: 200 } } ];</p>

<p>/**</p>
 <ul><li>Quick filter presets</li>
</ul> *
 <ul><li>Predefined filter combinations for common searches</li>
</ul> */
<p>export const AUTOMOBILE_QUICK_FILTERS = { /**</p>
   <ul><li>Recent vehicles (last 5 years)</li>
</ul>   */
<p>recent: { label: 'Recent Vehicles', filters: { yearMin: new Date().getFullYear() - 5, yearMax: new Date().getFullYear() } },</p>

<p>/**</p>
   <ul><li>Popular vehicles (high instance count)</li>
</ul>   */
<p>popular: { label: 'Popular Vehicles', filters: { instanceCountMin: 100 } },</p>

<p>/**</p>
   <ul><li>Classic vehicles (pre-2000)</li>
</ul>   */
<p>classic: { label: 'Classic Vehicles', filters: { yearMax: 2000 } },</p>

<p>/**</p>
   <ul><li>SUVs only</li>
</ul>   */
<p>suvs: { label: 'SUVs', filters: { bodyClass: 'SUV' } },</p>

<p>/**</p>
   <ul><li>Trucks only</li>
</ul>   */
<p>trucks: { label: 'Trucks', filters: { bodyClass: 'Truck' } },</p>

<p>/**</p>
   <ul><li>Sedans only</li>
</ul>   */
<p>sedans: { label: 'Sedans', filters: { bodyClass: 'Sedan' } } };</p>

<p>/**</p>
 <ul><li>Filter groups</li>
</ul> *
 <ul><li>Organize filters into logical groups for better UX</li>
</ul> */
<p>export const AUTOMOBILE_FILTER_GROUPS = { /**</p>
   <ul><li>Vehicle identification filters</li>
</ul>   */
<p>identification: { label: 'Vehicle Identification', filters: ['manufacturer', 'model', 'bodyClass'] },</p>

<p>/**</p>
   <ul><li>Time-based filters</li>
</ul>   */
<p>temporal: { label: 'Year', filters: ['year'] },</p>

<p>/**</p>
   <ul><li>Quantity filters</li>
</ul>   */
<p>quantity: { label: 'VIN Count', filters: ['instanceCountRange'] },</p>

<p>/**</p>
   <ul><li>General search</li>
</ul>   */
<p>general: { label: 'General Search', filters: ['search'] } };</p>

<p>/**</p>
 <ul><li>Filter validation rules</li>
</ul> *
 <ul><li>Additional validation beyond basic type validation</li>
</ul> */
<p>export const AUTOMOBILE_FILTER_VALIDATION = { /**</p>
   <ul><li>Validate year range</li>
</ul>   */
<p>yearRange: (min: number, max: number): boolean =&gt; { if (min &amp;&amp; max &amp;&amp; min &gt; max) { return false; // Min cannot be greater than max } const currentYear = new Date().getFullYear(); if (min &amp;&amp; (min &lt; 1900 || min &gt; currentYear + 1)) { return false; // Year out of valid range } if (max &amp;&amp; (max &lt; 1900 || max &gt; currentYear + 1)) { return false; // Year out of valid range } return true; },</p>

<p>/**</p>
   <ul><li>Validate instance count range</li>
</ul>   */
<p>instanceCountRange: (min: number, max: number): boolean =&gt; { if (min &amp;&amp; max &amp;&amp; min &gt; max) { return false; // Min cannot be greater than max } if (min &amp;&amp; min &lt; 0) { return false; // Cannot be negative } if (max &amp;&amp; max &lt; 0) { return false; // Cannot be negative } return true; } };</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 601.2: Understand the Filter Definition Structure</h3>

<p>Each filter definition object follows this pattern:</p>

<table>
<p><thead><tr> <th>Property</th> <th>Required</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">id</code></td> <td>Yes</td> <td>Unique identifier, used as key in filter state</td></p>
</tr>
<p><tr> <td><code class="inline">label</code></td> <td>Yes</td> <td>Display text shown to users</td></p>
</tr>
<p><tr> <td><code class="inline">type</code></td> <td>Yes</td> <td>Filter type: 'autocomplete', 'text', 'range', 'multiselect'</td></p>
</tr>
<p><tr> <td><code class="inline">placeholder</code></td> <td>No</td> <td>Placeholder text for input fields</td></p>
</tr>
<p><tr> <td><code class="inline">operators</code></td> <td>No</td> <td>Comparison operators for text filters</td></p>
</tr>
<p><tr> <td><code class="inline">validation</code></td> <td>No</td> <td>Validation rules (minLength, maxLength, pattern)</td></p>
</tr>
<p><tr> <td><code class="inline">format</code></td> <td>No</td> <td>Number/date formatting options</td></p>
</tr>
<p><tr> <td><code class="inline">optionsEndpoint</code></td> <td>No</td> <td>API endpoint for multiselect options</td></p>
</tr>
<p><tr> <td><code class="inline">autocompleteEndpoint</code></td> <td>No</td> <td>API endpoint for autocomplete suggestions</td></p>
</tr>
</tbody>
</table>

<p><strong>Filter Types:</strong></p>

<table>
<p><thead><tr> <th>Type</th> <th>Use Case</th> <th>Example</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">autocomplete</code></td> <td>Free text with suggestions</td> <td>Manufacturer, Model</td></p>
</tr>
<p><tr> <td><code class="inline">text</code></td> <td>Free text without suggestions</td> <td>Search</td></p>
</tr>
<p><tr> <td><code class="inline">range</code></td> <td>Numeric range (min/max)</td> <td>Year, VIN Count</td></p>
</tr>
<p><tr> <td><code class="inline">multiselect</code></td> <td>Pick from list</td> <td>Body Class</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 601.3: Understanding the Quick Filters</h3>

<p>Quick filters are predefined filter combinations that users can apply with one click:</p>

<pre class="code-block typescript"><code>// Apply quick filter
<p>applyQuickFilter(quickFilter: { label: string; filters: Partial&lt;AutoSearchFilters&gt; }) { this.resourceService.updateFilters(quickFilter.filters); }</p>
</code></pre>

<p>This pattern is useful for:</p>
<ul><li>Common search patterns (e.g., "Recent Vehicles")</li>
<p><li>User onboarding (help new users discover filter capabilities)</li> <li>Power user shortcuts (reduce repetitive filter selection)</li></p>
</ul>
<hr>

<h3>Step 601.4: Understanding Filter Groups</h3>

<p>Filter groups organize related filters in the UI:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────┐
<p>│ Vehicle Identification                                   │ │ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐        │ │ │ Manufacturer│ │    Model    │ │ Body Class  │        │ │ └─────────────┘ └─────────────┘ └─────────────┘        │ ├─────────────────────────────────────────────────────────┤ │ Year                                                     │ │ ┌─────────────────────────────────────┐                 │ │ │          Year Range                  │                 │ │ └─────────────────────────────────────┘                 │ ├─────────────────────────────────────────────────────────┤ │ VIN Count                                                │ │ ┌─────────────────────────────────────┐                 │ │ │        VIN Count Range               │                 │ │ └─────────────────────────────────────┘                 │ └─────────────────────────────────────────────────────────┘</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Verify File Created</h3>

<pre class="code-block bash"><code>$ cat src/app/domain-config/automobile/configs/automobile.filter-definitions.ts | head -20
</code></pre>

<p>Expected: First 20 lines of the file shown without errors.</p>

<h3>2. Verify TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/domain-config/automobile/configs/automobile.filter-definitions.ts</p>
</code></pre>

<p>Expected: No compilation errors.</p>

<h3>3. Verify Export Count</h3>

<pre class="code-block bash"><code>$ grep "^export const" src/app/domain-config/automobile/configs/automobile.filter-definitions.ts | wc -l
</code></pre>

<p>Expected: <code class="inline">4</code> (AUTOMOBILE_FILTER_DEFINITIONS, AUTOMOBILE_QUICK_FILTERS, AUTOMOBILE_FILTER_GROUPS, AUTOMOBILE_FILTER_VALIDATION)</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot find module '../../../framework/models/filter-definition.interface'"</td> <td>Framework models not yet created</td> <td>Ensure Phase 2 (document 203) is complete</td></p>
</tr>
<p><tr> <td>TypeScript error on <code class="inline">FilterDefinition[]</code></td> <td>Interface doesn't match object shape</td> <td>Verify filter objects match interface properties</td></p>
</tr>
<p><tr> <td><code class="inline">autocompleteEndpoint</code> unused</td> <td>No autocomplete component consuming it</td> <td>This is expected; components come in Phase 8</td></p>
</tr>
<p><tr> <td>Year shows as "2,024"</td> <td><code class="inline">useGrouping: true</code> in year format</td> <td>Set <code class="inline">useGrouping: false</code> for year filters</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Configuration is data, not code</strong> — Filter definitions are objects in an array, not component classes</li>
<p><li><strong>The framework interprets configuration</strong> — QueryPanelComponent reads definitions and generates UI</li> <li><strong>Adding filters is additive</strong> — To add a new filter, add an object to the array; no component code needed</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domain-config/automobile/configs/automobile.filter-definitions.ts</code> exists</li>
<p><li>[ ] <code class="inline">AUTOMOBILE_FILTER_DEFINITIONS</code> array contains 6 filter definitions</li> <li>[ ] Each filter has <code class="inline">id</code>, <code class="inline">label</code>, and <code class="inline">type</code> properties</li> <li>[ ] <code class="inline">AUTOMOBILE_QUICK_FILTERS</code> contains 6 presets (recent, popular, classic, suvs, trucks, sedans)</li> <li>[ ] <code class="inline">AUTOMOBILE_FILTER_GROUPS</code> organizes filters into 4 groups</li> <li>[ ] <code class="inline">AUTOMOBILE_FILTER_VALIDATION</code> contains validation functions for year and instance count ranges</li> <li>[ ] File compiles without TypeScript errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">602-table-config.md</code> to define the automobile results table configuration.</p></div></div>
    <div class="chapter" id="section-602">
        <div class="chapter-header">
            <div class="chapter-category">Domain Config</div>
            <h1>602: Table Config</h1>
        </div>
<div class="page-content"><h1>602: Table Config</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 402-automobile-data-model, 204-table-config-interface <strong>Blocks:</strong> 607-domain-config-assembly</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how table configuration separates data structure from presentation</li>
<p><li>Know how to define columns with sorting, filtering, and width properties</li> <li>Recognize the pattern of lazy loading for large datasets</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the automobile table configuration that defines how vehicle results are displayed in the data table. This configuration controls columns, pagination, sorting, row expansion, and state persistence.</p>

<hr>

<h2>Why</h2>

<p>Data tables are one of the most common UI patterns in enterprise applications. Without configuration, you might hard-code table structure:</p>

<pre class="code-block html"><code>&lt;!-- Hard-coded table (anti-pattern) --&gt;
<p>&lt;table&gt; &lt;tr&gt; &lt;th&gt;Manufacturer&lt;/th&gt; &lt;th&gt;Model&lt;/th&gt; &lt;th&gt;Year&lt;/th&gt; &lt;/tr&gt; &lt;tr *ngFor="let v of vehicles"&gt; &lt;td&gt;{{ v.manufacturer }}&lt;/td&gt; &lt;td&gt;{{ v.model }}&lt;/td&gt; &lt;td&gt;{{ v.year }}&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;</p>
</code></pre>

<p>This approach has problems:</p>

<ul><li><strong>No reusability</strong> — Every domain needs its own table template</li>
<p><li><strong>No flexibility</strong> — Adding columns requires template changes</li> <li><strong>Missing features</strong> — Sorting, filtering, pagination require custom code</li></p>
</ul>
<p>The configuration-driven approach:</p>

<pre class="code-block typescript"><code>&lt;app-results-table
<p>[config]="AUTOMOBILE_TABLE_CONFIG" [data]="vehicles"&gt; &lt;/app-results-table&gt;</p>
</code></pre>

<p>One generic component, unlimited configurations.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-05-14">Style 05-14</a>: Put logic in services, not components</li>
<p><li>Configuration objects follow this principle by moving table structure to data</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 602.1: Create the Table Configuration File</h3>

<p>Create the file that will define the automobile results table.</p>

<p>Create <code class="inline">src/app/domain-config/automobile/configs/automobile.table-config.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/configs/automobile.table-config.ts

<p>/**</p>
 <ul><li>Automobile Domain - Table Configuration</li>
</ul> *
 <ul><li>Defines the main data table for displaying vehicle results.</li>
</ul> <ul><li>Configures columns, pagination, sorting, filtering, and row expansion.</li>
</ul> *
 <ul><li>Domain: Automobile Discovery</li>
</ul> */

<p>import { TableConfig } from '../../../framework/models/table-config.interface'; import { VehicleResult } from '../models/automobile.data';</p>

<p>/**</p>
 <ul><li>Automobile table configuration</li>
</ul> *
 <ul><li>Main table for displaying vehicle search results.</li>
</ul> <ul><li>Supports pagination, sorting, filtering, and row expansion for VIN details.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>&lt;p-table</li>
</ul> <ul><li>  [value]="vehicles"</li>
</ul> <ul><li>  [columns]="AUTOMOBILE_TABLE_CONFIG.columns"</li>
</ul> <ul><li>  [dataKey]="AUTOMOBILE_TABLE_CONFIG.dataKey"</li>
</ul> <ul><li>  [stateStorage]="AUTOMOBILE_TABLE_CONFIG.stateStorage"</li>
</ul> <ul><li>  [stateKey]="AUTOMOBILE_TABLE_CONFIG.stateKey"&gt;</li>
</ul> <ul><li>&lt;/p-table&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const AUTOMOBILE_TABLE_CONFIG: TableConfig&lt;VehicleResult&gt; = { /**</p>
   <ul><li>Unique table identifier</li>
</ul>   */
<p>tableId: 'automobile-vehicles-table',</p>

<p>/**</p>
   <ul><li>State persistence key</li>
</ul>   <ul><li>Saves column widths, order, visibility, filters, sorting, pagination</li>
</ul>   */
<p>stateKey: 'auto-vehicles-state',</p>

<p>/**</p>
   <ul><li>Data key field (must be unique per row)</li>
</ul>   <ul><li>Used for row expansion, selection, and state management</li>
</ul>   */
<p>dataKey: 'vehicle_id',</p>

<p>/**</p>
   <ul><li>Table columns configuration</li>
</ul>   */
<p>columns: [ { field: 'manufacturer', header: 'Manufacturer', sortable: true, filterable: true, filterMatchMode: 'contains', reorderable: true, width: '150px' }, { field: 'model', header: 'Model', sortable: true, filterable: true, filterMatchMode: 'contains', reorderable: true, width: '150px' }, { field: 'year', header: 'Year', sortable: true, filterable: true, filterMatchMode: 'equals', reorderable: true, width: '100px' }, { field: 'body_class', header: 'Body Class', sortable: true, filterable: true, filterMatchMode: 'contains', reorderable: true, width: '120px' }, { field: 'instance_count', header: 'VIN Count', sortable: true, filterable: false, reorderable: true, width: '100px' } ],</p>

<p>/**</p>
   <ul><li>Row expansion enabled</li>
</ul>   <ul><li>Clicking expand button shows VIN instances for the vehicle</li>
</ul>   */
<p>expandable: true,</p>

<p>/**</p>
   <ul><li>Row selection disabled</li>
</ul>   <ul><li>Enable if you need multi-select functionality</li>
</ul>   */
<p>selectable: false,</p>

<p>/**</p>
   <ul><li>Selection mode (if selectable=true)</li>
</ul>   */
<p>selectionMode: undefined,</p>

<p>/**</p>
   <ul><li>Pagination enabled</li>
</ul>   */
<p>paginator: true,</p>

<p>/**</p>
   <ul><li>Default rows per page</li>
</ul>   */
<p>rows: 20,</p>

<p>/**</p>
   <ul><li>Rows per page options</li>
</ul>   */
<p>rowsPerPageOptions: [10, 20, 50, 100],</p>

<p>/**</p>
   <ul><li>Lazy loading enabled</li>
</ul>   <ul><li>Data fetched on demand (pagination, sorting, filtering)</li>
</ul>   */
<p>lazy: true,</p>

<p>/**</p>
   <ul><li>State persistence</li>
</ul>   <ul><li>Saves table state to localStorage</li>
</ul>   */
<p>stateStorage: 'local',</p>

<p>/**</p>
   <ul><li>Table style class</li>
</ul>   <ul><li>PrimeNG classes for styling</li>
</ul>   */
<p>styleClass: 'p-datatable-striped p-datatable-gridlines',</p>

<p>/**</p>
   <ul><li>Responsive layout</li>
</ul>   */
<p>responsiveLayout: 'scroll',</p>

<p>/**</p>
   <ul><li>Show grid lines</li>
</ul>   */
<p>gridlines: true,</p>

<p>/**</p>
   <ul><li>Striped rows</li>
</ul>   */
<p>stripedRows: true,</p>

<p>/**</p>
   <ul><li>Loading indicator</li>
</ul>   */
<p>loading: false };</p>

<p>/**</p>
 <ul><li>Column visibility presets</li>
</ul> *
 <ul><li>Predefined column visibility configurations for different use cases</li>
</ul> */
<p>export const AUTOMOBILE_TABLE_COLUMN_PRESETS = { /**</p>
   <ul><li>All columns visible</li>
</ul>   */
<p>all: AUTOMOBILE_TABLE_CONFIG.columns,</p>

<p>/**</p>
   <ul><li>Minimal view (core fields only)</li>
</ul>   */
<p>minimal: AUTOMOBILE_TABLE_CONFIG.columns.filter((col) =&gt; ['manufacturer', 'model', 'year', 'instance_count'].includes(col.field) ),</p>

<p>/**</p>
   <ul><li>Summary view (no VIN count)</li>
</ul>   */
<p>summary: AUTOMOBILE_TABLE_CONFIG.columns.filter( (col) =&gt; col.field !== 'instance_count' ) };</p>

<p>/**</p>
 <ul><li>Default sort configuration</li>
</ul> */
<p>export const AUTOMOBILE_TABLE_DEFAULT_SORT = { field: 'manufacturer', order: 1 // 1 = ascending, -1 = descending };</p>

<p>/**</p>
 <ul><li>Export format configurations</li>
</ul> *
 <ul><li>Define which columns to include in exports</li>
</ul> */
<p>export const AUTOMOBILE_TABLE_EXPORT_CONFIG = { /**</p>
   <ul><li>CSV export column configuration</li>
</ul>   */
<p>csv: { columns: [ { field: 'manufacturer', header: 'Manufacturer' }, { field: 'model', header: 'Model' }, { field: 'year', header: 'Year' }, { field: 'body_class', header: 'Body Class' }, { field: 'instance_count', header: 'VIN Count' } ], filename: 'automobile-vehicles' },</p>

<p>/**</p>
   <ul><li>Excel export column configuration</li>
</ul>   */
<p>excel: { columns: [ { field: 'vehicle_id', header: 'Vehicle ID' }, { field: 'manufacturer', header: 'Manufacturer' }, { field: 'model', header: 'Model' }, { field: 'year', header: 'Year' }, { field: 'body_class', header: 'Body Class' }, { field: 'instance_count', header: 'VIN Count' }, { field: 'first_seen', header: 'First Seen' }, { field: 'last_seen', header: 'Last Seen' } ], filename: 'automobile-vehicles', sheetName: 'Vehicles' } };</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 602.2: Understand the Column Configuration</h3>

<p>Each column definition controls how that column behaves:</p>

<table>
<p><thead><tr> <th>Property</th> <th>Type</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">field</code></td> <td><code class="inline">string</code></td> <td>Property name in data object (e.g., 'manufacturer')</td></p>
</tr>
<p><tr> <td><code class="inline">header</code></td> <td><code class="inline">string</code></td> <td>Display text in column header (e.g., 'Manufacturer')</td></p>
</tr>
<p><tr> <td><code class="inline">sortable</code></td> <td><code class="inline">boolean</code></td> <td>Enable column sorting</td></p>
</tr>
<p><tr> <td><code class="inline">filterable</code></td> <td><code class="inline">boolean</code></td> <td>Enable column filtering</td></p>
</tr>
<p><tr> <td><code class="inline">filterMatchMode</code></td> <td><code class="inline">string</code></td> <td>Filter comparison: 'contains', 'equals', 'startsWith'</td></p>
</tr>
<p><tr> <td><code class="inline">reorderable</code></td> <td><code class="inline">boolean</code></td> <td>Allow drag-and-drop column reordering</td></p>
</tr>
<p><tr> <td><code class="inline">width</code></td> <td><code class="inline">string</code></td> <td>Column width (CSS units)</td></p>
</tr>
</tbody>
</table>

<p><strong>Field Mapping:</strong></p>

<p>The <code class="inline">field</code> property maps to the <code class="inline">VehicleResult</code> interface:</p>

<pre class="code-block typescript"><code>interface VehicleResult {
<p>vehicle_id: string;     // field: 'vehicle_id' manufacturer: string;   // field: 'manufacturer' model: string;          // field: 'model' year: number;           // field: 'year' body_class: string;     // field: 'body_class' instance_count: number; // field: 'instance_count' }</p>
</code></pre>

<hr>

<h3>Step 602.3: Understanding Lazy Loading</h3>

<p>The <code class="inline">lazy: true</code> setting is critical for performance with large datasets:</p>

<pre class="code-block text"><code>┌────────────────────────────────────────────────────────────┐
<p>│                    Without Lazy Loading                     │ ├────────────────────────────────────────────────────────────┤ │ 1. API returns ALL 100,000 vehicles                        │ │ 2. Browser holds ALL in memory                             │ │ 3. Table renders first 20                                  │ │ 4. Slow initial load, high memory usage                    │ └────────────────────────────────────────────────────────────┘</p>

<p>┌────────────────────────────────────────────────────────────┐ │                    With Lazy Loading                        │ ├────────────────────────────────────────────────────────────┤ │ 1. API returns only 20 vehicles (page 1)                   │ │ 2. Browser holds 20 in memory                              │ │ 3. Table renders 20                                        │ │ 4. User clicks "Next" → API returns next 20                │ │ 5. Fast loads, low memory usage                            │ └────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>When <code class="inline">lazy: true</code>:</p>
<ul><li>The table emits <code class="inline">onLazyLoad</code> events with pagination/sort/filter parameters</li>
<p><li>Your service calls the API with these parameters</li> <li>The API returns only the requested page</li></ul></p></div><div class="page-content"><hr>

<h3>Step 602.4: Understanding State Persistence</h3>

<p>The <code class="inline">stateStorage: 'local'</code> and <code class="inline">stateKey: 'auto-vehicles-state'</code> settings save table state:</p>

<p><strong>What gets saved:</strong></p>
<ul><li>Column widths (after user resizes)</li>
<p><li>Column order (after user reorders)</li> <li>Sort column and direction</li> <li>Current page number</li> <li>Rows per page selection</li> <li>Column filters</li></p>
</ul>
<p><strong>Where it's saved:</strong></p>
<ul><li><code class="inline">localStorage</code> with key <code class="inline">auto-vehicles-state</code></li>
</ul>
<p><strong>When it's restored:</strong></p>
<ul><li>On page reload, the table returns to the user's last state</li>
</ul>
<p>This provides a personalized experience without requiring server-side storage.</p>

<hr>

<h3>Step 602.5: Understanding Row Expansion</h3>

<p>The <code class="inline">expandable: true</code> and <code class="inline">dataKey: 'vehicle_id'</code> settings enable row expansion:</p>

<pre class="code-block text"><code>┌────────────────┬────────────┬──────┬────────────┬───────────┐
<p>│ Manufacturer   │ Model      │ Year │ Body Class │ VIN Count │ ├────────────────┼────────────┼──────┼────────────┼───────────┤ │ ▶ Toyota       │ Camry      │ 2023 │ Sedan      │ 1,234     │ ├────────────────┼────────────┼──────┼────────────┼───────────┤ │ ▼ Honda        │ Civic      │ 2022 │ Sedan      │ 987       │ │   ┌──────────────────────────────────────────────────────┐  │ │   │ VIN Instances (987 total)                            │  │ │   │ ┌──────────────────────────────────────────────────┐ │  │ │   │ │ 1HGBH41JXMN109186 │ First Seen: 2022-01-15      │ │  │ │   │ │ 1HGBH41JXMN109187 │ First Seen: 2022-01-16      │ │  │ │   │ │ 1HGBH41JXMN109188 │ First Seen: 2022-01-17      │ │  │ │   │ └──────────────────────────────────────────────────┘ │  │ │   └──────────────────────────────────────────────────────┘  │ ├────────────────┼────────────┼──────┼────────────┼───────────┤ │ ▶ Ford         │ F-150      │ 2023 │ Truck      │ 2,345     │ └────────────────┴────────────┴──────┴────────────┴───────────┘</p>
</code></pre>

<p>The <code class="inline">dataKey</code> identifies which row is expanded. Without a unique key, expansion state would be lost on sort/filter.</p>

<hr>

<h2>Verification</h2>

<h3>1. Verify File Created</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/configs/automobile.table-config.ts
</code></pre>

<p>Expected: File exists with correct size.</p></div><div class="page-content"><h3>2. Verify TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/domain-config/automobile/configs/automobile.table-config.ts</p>
</code></pre>

<p>Expected: No compilation errors.</p>

<h3>3. Verify Column Count</h3>

<pre class="code-block bash"><code>$ grep -c "field:" src/app/domain-config/automobile/configs/automobile.table-config.ts
</code></pre>

<p>Expected: <code class="inline">13</code> (5 table columns + 5 CSV columns + 8 Excel columns - some overlap)</p>

<h3>4. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export const" src/app/domain-config/automobile/configs/automobile.table-config.ts | wc -l
</code></pre>

<p>Expected: <code class="inline">4</code> (AUTOMOBILE_TABLE_CONFIG, AUTOMOBILE_TABLE_COLUMN_PRESETS, AUTOMOBILE_TABLE_DEFAULT_SORT, AUTOMOBILE_TABLE_EXPORT_CONFIG)</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot find module '../models/automobile.data'"</td> <td>Data model not yet created</td> <td>Ensure Phase 4 (document 402) is complete</td></p>
</tr>
<p><tr> <td>"Property 'vehicle_id' does not exist on type 'VehicleResult'"</td> <td>Field name mismatch</td> <td>Verify field names match VehicleResult interface</td></p>
</tr>
<p><tr> <td>Table shows "No records found"</td> <td>Lazy loading not wired up</td> <td>Ensure component calls API on onLazyLoad events</td></p>
</tr>
<p><tr> <td>Column widths not persisting</td> <td>State key conflict</td> <td>Use unique stateKey per table</td></p>
</tr>
<p><tr> <td>Sort not working</td> <td>Missing sortable: true</td> <td>Add sortable: true to column definition</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Table configuration is data</strong> — Column definitions, pagination, and sorting are all configuration objects</li>
<p><li><strong>Lazy loading is essential for large datasets</strong> — Only fetch what the user can see</li> <li><strong>State persistence provides personalization</strong> — Users don't lose their column preferences on reload</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domain-config/automobile/configs/automobile.table-config.ts</code> exists</li>
<p><li>[ ] <code class="inline">AUTOMOBILE_TABLE_CONFIG</code> has 5 column definitions (manufacturer, model, year, body_class, instance_count)</li> <li>[ ] <code class="inline">lazy: true</code> is set for lazy loading</li> <li>[ ] <code class="inline">stateStorage: 'local'</code> and <code class="inline">stateKey</code> are configured for state persistence</li> <li>[ ] <code class="inline">expandable: true</code> and <code class="inline">dataKey: 'vehicle_id'</code> enable row expansion</li> <li>[ ] <code class="inline">AUTOMOBILE_TABLE_COLUMN_PRESETS</code> provides 3 presets (all, minimal, summary)</li> <li>[ ] <code class="inline">AUTOMOBILE_TABLE_EXPORT_CONFIG</code> defines CSV and Excel export formats</li> <li>[ ] File compiles without TypeScript errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">603-picker-configs.md</code> to define the automobile picker configurations for selecting manufacturer-model combinations.</p></div></div>
    <div class="chapter" id="section-603">
        <div class="chapter-header">
            <div class="chapter-category">Domain Config</div>
            <h1>603: Picker Configs</h1>
        </div>
<div class="page-content"><h1>603: Picker Configs</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 205-picker-config-interface, 302-api-service <strong>Blocks:</strong> 607-domain-config-assembly</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the picker pattern for selecting related data from searchable tables</li>
<p><li>Know how to configure server-side pagination for large option sets</li> <li>Recognize URL serialization patterns for complex multi-value selections</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the automobile picker configuration for selecting manufacturer-model combinations. Pickers are searchable, paginated tables that allow users to select one or more items from a large dataset.</p>

<hr>

<h2>Why</h2>

<p>Simple dropdowns work for small option sets (10-50 items). But what happens when you have:</p>

<ul><li>2,000+ manufacturers</li>
<p><li>50,000+ manufacturer-model combinations</li> <li>Options that change frequently (new models added)</li></p>
</ul>
<p>Loading all options into a dropdown is impractical:</p>

<pre class="code-block html"><code>&lt;!-- Anti-pattern: Loading 50,000 options into a dropdown --&gt;
<p>&lt;select&gt; &lt;option *ngFor="let combo of allCombinations"&gt; {{ combo.manufacturer }}: {{ combo.model }} &lt;/option&gt; &lt;/select&gt;</p>
</code></pre>

<p>Problems:</p>
<ul><li><strong>Slow initial load</strong> — Fetching 50,000 items takes seconds</li>
<p><li><strong>Poor UX</strong> — Scrolling through 50,000 items is unusable</li> <li><strong>Memory bloat</strong> — 50,000 DOM elements consume significant memory</li></p>
</ul>
<p>The picker pattern solves this:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│ Select Manufacturer &amp; Model                                [X]  │ ├─────────────────────────────────────────────────────────────────┤ │ [Search: Toyota Cam____________________]                         │ ├─────────────────────────────────────────────────────────────────┤ │ [ ] Manufacturer          Model                  Count          │ ├─────────────────────────────────────────────────────────────────┤ │ [x] Toyota                Camry                  1,234          │ │ [x] Toyota                Camry Hybrid           567            │ │ [ ] Toyota                Camry Solara           89             │ │ [ ] Toyota                Camry XLE              234            │ ├─────────────────────────────────────────────────────────────────┤ │ Showing 1-20 of 47 results        [&lt;] [1] [2] [3] [&gt;]           │ ├─────────────────────────────────────────────────────────────────┤ │                              [Cancel]  [Apply 2 Selected]        │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>Benefits:</p>
<ul><li><strong>Server-side pagination</strong> — Only 20 items loaded at a time</li>
<p><li><strong>Search</strong> — Type to filter without loading all options</li> <li><strong>Multi-select</strong> — Check multiple items before applying</li></ul></p></div><div class="page-content"><h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-05-14">Style 05-14</a>: Put complex logic in services</li>
<p><li>Picker configuration keeps selection logic in configuration, not component code</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 603.1: Create the Picker Configurations File</h3>

<p>Create the file that will define automobile picker configurations.</p>

<p>Create <code class="inline">src/app/domain-config/automobile/configs/automobile.picker-configs.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/configs/automobile.picker-configs.ts

<p>/**</p>
 <ul><li>Automobile Domain - Picker Configurations</li>
</ul> *
 <ul><li>Defines picker components for selecting related data.</li>
</ul> <ul><li>Pickers are searchable tables with multi-select capabilities.</li>
</ul> *
 <ul><li>Domain: Automobile Discovery</li>
</ul> */

<p>import { PickerConfig } from '../../../framework/models/picker-config.interface'; import { Injector } from '@angular/core'; import { ApiService } from '../../../framework/services'; import { environment } from '../../../environments/environment';</p>

<p>/**</p>
 <ul><li>Manufacturer/Model row data type</li>
</ul> *
 <ul><li>Represents a manufacturer-model combination with count</li>
</ul> */
<p>export interface ManufacturerModelRow { /**</p>
   <ul><li>Manufacturer name (e.g., "Toyota", "Honda", "BMW")</li>
</ul>   */
<p>manufacturer: string;</p>

<p>/**</p>
   <ul><li>Vehicle model name (e.g., "Camry", "Civic", "X5")</li>
</ul>   */
<p>model: string;</p>

<p>/**</p>
   <ul><li>Number of vehicles matching this manufacturer-model combination</li>
</ul>   */
<p>count: number; }</p>

<p>/**</p>
 <ul><li>Create Manufacturer-Model Picker Configuration</li>
</ul> *
 <ul><li>Factory function that creates picker config with injected dependencies.</li>
</ul> <ul><li>Allows selection of manufacturer-model combinations for filtering.</li>
</ul> *
 <ul><li>@param apiService - Injected API service</li>
</ul> <ul><li>@param configId - Unique config ID for this picker instance</li>
</ul> <ul><li>@returns Configured picker</li>
</ul> */
<p>export function createManufacturerModelPickerConfig( apiService: ApiService, configId: string = 'manufacturer-model-picker' ): PickerConfig&lt;ManufacturerModelRow&gt; { return { id: configId, displayName: 'Select Manufacturer &amp; Model',</p>

<p>// Column definitions (PrimeNGColumn format) columns: [ { field: 'manufacturer', header: 'Manufacturer', sortable: true, filterable: true, width: '40%' }, { field: 'model', header: 'Model', sortable: true, filterable: true, width: '40%' }, { field: 'count', header: 'Count', sortable: true, filterable: false, width: '20%' } ],</p>

<p>// API configuration // Server-side pagination: API returns { data, total, page, size, totalPages } api: { fetchData: (params) =&gt; { const endpoint = <code class="inline">${environment.apiBaseUrl}/manufacturer-model-combinations</code>; return apiService.get&lt;any&gt;(endpoint, { params: { page: params.page + 1, // API is 1-indexed, picker is 0-indexed size: params.size, search: params.search || undefined, sortBy: params.sortField || 'manufacturer', sortOrder: params.sortOrder === -1 ? 'desc' : 'asc' } }); },</p>

<p>responseTransformer: (response) =&gt; { return { results: response.data || [], total: response.total || 0, page: response.page, size: response.size, totalPages: response.totalPages }; } },</p>

<p>// Row key configuration row: { keyGenerator: (row) =&gt; <code class="inline">${row.manufacturer}:${row.model}</code>, keyParser: (key) =&gt; { const [manufacturer, model] = key.split(':'); return { manufacturer, model } as Partial&lt;ManufacturerModelRow&gt;; } },</p>

<p>// Selection configuration selection: { mode: 'multiple', urlParam: 'modelCombos',</p>

<p>// Serialize selected items to URL serializer: (items) =&gt; { if (!items || items.length === 0) return ''; return items.map(item =&gt; <code class="inline">${item.manufacturer}:${item.model}</code>).join(','); },</p>

<p>// Deserialize URL to partial items (for hydration) deserializer: (urlValue) =&gt; { if (!urlValue) return []; return urlValue.split(',').map(combo =&gt; { const [manufacturer, model] = combo.split(':'); return { manufacturer, model } as Partial&lt;ManufacturerModelRow&gt;; }); },</p>

<p>// Optional: Custom key generator (defaults to row.keyGenerator) keyGenerator: (item) =&gt; <code class="inline">${item.manufacturer}:${item.model}</code> },</p>

<p>// Pagination configuration // Server-side pagination: fetches only current page from API pagination: { mode: 'server', defaultPageSize: 20, pageSizeOptions: [10, 20, 50, 100] },</p>

<p>// Search configuration showSearch: true, searchPlaceholder: 'Search manufacturer or model...' }; }</p>

<p>/**</p>
 <ul><li>Register all automobile picker configurations</li>
</ul> *
 <ul><li>@param injector - Angular injector for dependency resolution</li>
</ul> <ul><li>@param configIdPrefix - Optional prefix to make config IDs unique per page</li>
</ul> <ul><li>@returns Array of picker configurations</li>
</ul> */
<p>export function createAutomobilePickerConfigs(injector: Injector, configIdPrefix?: string): PickerConfig&lt;any&gt;[] { const apiService = injector.get(ApiService); const pickerId = configIdPrefix ? <code class="inline">${configIdPrefix}-manufacturer-model-picker</code> : 'manufacturer-model-picker';</p>

<p>return [ createManufacturerModelPickerConfig(apiService, pickerId) // Add more pickers here as needed ]; }</p>

<p>/**</p>
 <ul><li>Static export for backwards compatibility</li>
</ul> <ul><li>Populated dynamically by domain config factory</li>
</ul> */
<p>export const AUTOMOBILE_PICKER_CONFIGS: PickerConfig&lt;any&gt;[] = [];</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 603.2: Understand the Picker Configuration Structure</h3>

<p>Each picker configuration has several key sections:</p>

<p><strong>Identity:</strong></p>
<pre class="code-block typescript"><code>{
<p>id: 'manufacturer-model-picker', displayName: 'Select Manufacturer &amp; Model' }</p>
</code></pre>

<p><strong>Column Definitions:</strong></p>
<pre class="code-block typescript"><code>columns: [
<p>{ field: 'manufacturer', header: 'Manufacturer', sortable: true, width: '40%' } ]</p>
</code></pre>

<p><strong>API Configuration:</strong></p>
<pre class="code-block typescript"><code>api: {
<p>fetchData: (params) =&gt; { /<em> Call API with page, size, search, sort </em>/ }, responseTransformer: (response) =&gt; { /<em> Normalize response shape </em>/ } }</p>
</code></pre>

<p><strong>Row Key Generation:</strong></p>
<pre class="code-block typescript"><code>row: {
<p>keyGenerator: (row) =&gt; <code class="inline">${row.manufacturer}:${row.model}</code>,  // Create unique key keyParser: (key) =&gt; { /<em> Parse key back to partial object </em>/ } }</p>
</code></pre>

<p><strong>Selection Serialization:</strong></p>
<pre class="code-block typescript"><code>selection: {
<p>serializer: (items) =&gt; /<em> Convert selected items to URL string </em>/, deserializer: (urlValue) =&gt; /<em> Convert URL string back to items </em>/ }</p>
</code></pre>

<hr>

<h3>Step 603.3: Understanding URL Serialization</h3>

<p>Selected items must be serialized to the URL for URL-First architecture:</p>

<pre class="code-block text"><code>Before selection: /automobiles/discover
<p>After selection:  /automobiles/discover?modelCombos=Toyota:Camry,Honda:Civic</p>
</code></pre>

<p>The serialization flow:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│                     SELECTION → URL                              │ ├─────────────────────────────────────────────────────────────────┤ │                                                                  │ │  User selects:                                                   │ │  [x] Toyota - Camry                                              │ │  [x] Honda - Civic                                               │ │                                                                  │ │  ↓ serializer()                                                  │ │                                                                  │ │  URL: ?modelCombos=Toyota:Camry,Honda:Civic                     │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘</p>

<p>┌─────────────────────────────────────────────────────────────────┐ │                     URL → SELECTION                              │ ├─────────────────────────────────────────────────────────────────┤ │                                                                  │ │  URL: ?modelCombos=Toyota:Camry,Honda:Civic                     │ │                                                                  │ │  ↓ deserializer()                                                │ │                                                                  │ │  Partial items:                                                  │ │  [ { manufacturer: 'Toyota', model: 'Camry' },                  │ │    { manufacturer: 'Honda', model: 'Civic' } ]                  │ │                                                                  │ │  ↓ Picker hydrates with full data from API                      │ │                                                                  │ │  Full items:                                                     │ │  [ { manufacturer: 'Toyota', model: 'Camry', count: 1234 },     │ │    { manufacturer: 'Honda', model: 'Civic', count: 987 } ]      │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 603.4: Understanding Server-Side Pagination</h3>

<p>The picker uses server-side pagination:</p>

<pre class="code-block typescript"><code>api: {
<p>fetchData: (params) =&gt; { return apiService.get(endpoint, { params: { page: params.page + 1,  // Convert 0-indexed to 1-indexed size: params.size,       // e.g., 20 search: params.search,   // User's search term sortBy: params.sortField, sortOrder: params.sortOrder === -1 ? 'desc' : 'asc' } }); } }</p>
</code></pre>

<p>When user searches "Toyota":</p>
<ul><li>Picker sends: <code class="inline">GET /manufacturer-model-combinations?page=1&amp;size=20&amp;search=Toyota</code></li>
<p><li>API returns: <code class="inline">{ data: [/<em> 20 Toyota results </em>/], total: 47, page: 1, size: 20, totalPages: 3 }</code></li> <li>Picker displays 20 results with pagination: "Showing 1-20 of 47"</li></p>
</ul>
<hr>

<h3>Step 603.5: Understanding Factory Pattern</h3>

<p>The picker uses a factory function pattern:</p>

<pre class="code-block typescript"><code>export function createManufacturerModelPickerConfig(
<p>apiService: ApiService, configId: string = 'manufacturer-model-picker' ): PickerConfig&lt;ManufacturerModelRow&gt; { return { /<em> config </em>/ }; }</p>
</code></pre>

<p><strong>Why a factory function instead of a constant?</strong></p>

<p>The picker needs the <code class="inline">ApiService</code> to make API calls. Angular's dependency injection provides the service at runtime, but configuration constants are created at module load time (before injection is available).</p>

<p>The factory pattern solves this:</p>

<pre class="code-block typescript"><code>// In domain config factory
<p>export function createAutomobileDomainConfig(injector: Injector) { const apiService = injector.get(ApiService);</p>

<p>return { // ... pickers: createAutomobilePickerConfigs(injector) }; }</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Verify File Created</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/configs/automobile.picker-configs.ts
</code></pre>

<p>Expected: File exists.</p>

<h3>2. Verify TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/domain-config/automobile/configs/automobile.picker-configs.ts</p>
</code></pre>

<p>Expected: No compilation errors.</p>

<h3>3. Verify Interface Export</h3>

<pre class="code-block bash"><code>$ grep "^export interface" src/app/domain-config/automobile/configs/automobile.picker-configs.ts
</code></pre>

<p>Expected: <code class="inline">export interface ManufacturerModelRow {</code></p></div><div class="page-content"><h3>4. Verify Function Exports</h3>

<pre class="code-block bash"><code>$ grep "^export function" src/app/domain-config/automobile/configs/automobile.picker-configs.ts
</code></pre>

<p>Expected: Two function exports (createManufacturerModelPickerConfig, createAutomobilePickerConfigs)</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot find module '../../../framework/services'"</td> <td>Services not yet created</td> <td>Ensure Phase 3 is complete</td></p>
</tr>
<p><tr> <td>"Property 'get' does not exist on type 'ApiService'"</td> <td>ApiService interface mismatch</td> <td>Verify ApiService has get&lt;T&gt;() method</td></p>
</tr>
<p><tr> <td>Picker shows empty</td> <td>API endpoint not responding</td> <td>Check API URL and network tab</td></p>
</tr>
<p><tr> <td>Selection not persisting to URL</td> <td>serializer/deserializer mismatch</td> <td>Ensure serializer output matches deserializer input</td></p>
</tr>
<p><tr> <td>Page numbers wrong</td> <td>0-indexed vs 1-indexed mismatch</td> <td>Picker is 0-indexed, API is 1-indexed; convert</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Pickers handle large option sets</strong> — Server-side pagination and search make 50,000+ items usable</li>
<p><li><strong>URL serialization enables sharing</strong> — Selected items are in the URL, so users can share links</li> <li><strong>Factory pattern enables dependency injection</strong> — Services are injected at runtime, not import time</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domain-config/automobile/configs/automobile.picker-configs.ts</code> exists</li>
<p><li>[ ] <code class="inline">ManufacturerModelRow</code> interface defines manufacturer, model, and count properties</li> <li>[ ] <code class="inline">createManufacturerModelPickerConfig()</code> factory function returns picker configuration</li> <li>[ ] Picker configuration includes 3 columns (manufacturer, model, count)</li> <li>[ ] <code class="inline">api.fetchData</code> function handles pagination, search, and sorting parameters</li> <li>[ ] <code class="inline">selection.serializer</code> converts items to URL string format "Manufacturer:Model,..."</li> <li>[ ] <code class="inline">selection.deserializer</code> parses URL string back to partial items</li> <li>[ ] <code class="inline">createAutomobilePickerConfigs()</code> returns array with manufacturer-model picker</li> <li>[ ] File compiles without TypeScript errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">604-query-control-filters.md</code> to define the query control filter definitions for dialog-based filter editing.</p></div></div>
    <div class="chapter" id="section-604">
        <div class="chapter-header">
            <div class="chapter-category">Domain Config</div>
            <h1>604: Query Control Filters</h1>
        </div>
<div class="page-content"><h1>604: Query Control Filters</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 203-filter-definition-interface, 401-automobile-filters-model <strong>Blocks:</strong> 607-domain-config-assembly</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how query control filters differ from simple filter definitions</li>
<p><li>Know how to configure API endpoints for fetching filter options dynamically</li> <li>Recognize the pattern of transforming API responses into filter option formats</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the query control filter definitions that power the "Add Filter" dialog. These definitions tell the QueryControlComponent which filters are available, how to fetch their options, and how to serialize selections to the URL.</p>

<hr>

<h2>Why</h2>

<p>Document 601 defined filter definitions for the Query Panel (always-visible filter controls). But what about filters that users add on demand?</p>

<p>The QueryControlComponent provides a "chip-based" filter UI:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│ ┌─────────────┐ ┌──────────────────┐ ┌───────────────────┐      │ │ │ Ford    [x] │ │ Year: 2020-2023 │ │ Body: SUV, Truck │ [+]  │ │ └─────────────┘ └──────────────────┘ └───────────────────┘      │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>Clicking [+] opens a dialog:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│ Add Filter                                                 [X]  │ ├─────────────────────────────────────────────────────────────────┤ │                                                                  │ │   ○ Manufacturer                                                 │ │   ○ Model                                                        │ │   ○ Body Class                                                   │ │   ○ Year                                                         │ │   ○ Manufacturer &amp; Model                                         │ │                                                                  │ ├─────────────────────────────────────────────────────────────────┤ │                                        [Cancel]  [Next]          │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>Selecting "Manufacturer" and clicking "Next" opens the filter value dialog:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│ Select Manufacturer                                        [X]  │ │ Select one or more manufacturers to filter results.             │ ├─────────────────────────────────────────────────────────────────┤ │ [Search: ________________________________________]               │ ├─────────────────────────────────────────────────────────────────┤ │ [x] Ford                                                         │ │ [ ] Toyota                                                       │ │ [ ] Honda                                                        │ │ [ ] BMW                                                          │ │ [ ] Mercedes-Benz                                                │ ├─────────────────────────────────────────────────────────────────┤ │                                      [Cancel]  [Apply Filter]    │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>Query control filters define:</p>
<ul><li>Which filters appear in the "Add Filter" list</li>
<p><li>Where to fetch options for each filter</li> <li>How to transform API responses into option format</li> <li>How to serialize/deserialize values to/from URL</li></ul></p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 604.1: Create the Query Control Filters File</h3>

<p>Create the file that will define query control filter configurations.</p>

<p>Create <code class="inline">src/app/domain-config/automobile/configs/automobile.query-control-filters.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/configs/automobile.query-control-filters.ts

<p>/**</p>
 <ul><li>Automobile Domain - Query Control Filter Definitions</li>
</ul> *
 <ul><li>Defines filter definitions for the Query Control component.</li>
</ul> <ul><li>These filters allow users to manually add/remove/edit filters via dialogs.</li>
</ul> *
 <ul><li>Domain: Automobile Discovery</li>
</ul> */

<p>import { FilterDefinition, FilterOption } from '../../../framework/models/filter-definition.interface'; import { AutoSearchFilters } from '../models/automobile.filters'; import { environment } from '../../../environments/environment';</p>

<p>/**</p>
 <ul><li>Query Control filter definitions</li>
</ul> *
 <ul><li>Each definition specifies:</li>
</ul> <ul><li>- Which field it filters</li>
</ul> <ul><li>- What type of UI control to display (multiselect, range, etc.)</li>
</ul> <ul><li>- Where to fetch options from (API endpoint)</li>
</ul> <ul><li>- How to transform API responses</li>
</ul> <ul><li>- URL parameter names</li>
</ul> *
 <ul><li>These are used by the QueryControlComponent to dynamically render filter dialogs.</li>
</ul> */
<p>export const AUTOMOBILE_QUERY_CONTROL_FILTERS: FilterDefinition&lt;AutoSearchFilters&gt;[] = [ /**</p>
   <ul><li>Manufacturer filter (Multiselect)</li>
</ul>   */
<p>{ field: 'manufacturer', label: 'Manufacturer', type: 'multiselect', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/filters/manufacturers</code>, optionsTransformer: (response: any): FilterOption[] =&gt; { if (response &amp;&amp; response.manufacturers) { return response.manufacturers.map((m: string) =&gt; ({ value: m, label: m })); } return []; }, urlParams: 'manufacturer', searchPlaceholder: 'Type to search manufacturers...', dialogSubtitle: 'Select one or more manufacturers to filter results.' },</p>

<p>/**</p>
   <ul><li>Model filter (Multiselect)</li>
</ul>   */
<p>{ field: 'model', label: 'Model', type: 'multiselect', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/filters/models</code>, optionsTransformer: (response: any): FilterOption[] =&gt; { if (response &amp;&amp; response.models) { return response.models.map((m: string) =&gt; ({ value: m, label: m })); } return []; }, urlParams: 'model', searchPlaceholder: 'Type to search models...', dialogSubtitle: 'Select one or more models to filter results.' },</p>

<p>/**</p>
   <ul><li>Body Class filter (Multiselect)</li>
</ul>   */
<p>{ field: 'bodyClass', label: 'Body Class', type: 'multiselect', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/filters/body-classes</code>, optionsTransformer: (response: any): FilterOption[] =&gt; { if (response &amp;&amp; response.body_classes) { return response.body_classes.map((b: string) =&gt; ({ value: b, label: b })); } return []; }, urlParams: 'bodyClass', searchPlaceholder: 'Type to search body classes...', dialogSubtitle: 'Select one or more body classes to filter results.' },</p>

<p>/**</p>
   <ul><li>Year Range filter (Range)</li>
</ul>   *
   <ul><li>Note: This uses yearMin as the field, but actually manages both yearMin and yearMax</li>
</ul>   */
<p>{ field: 'yearMin', label: 'Year', type: 'range', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/filters/year-range</code>, urlParams: { min: 'yearMin', max: 'yearMax' }, dialogTitle: 'Select Year Range', dialogSubtitle: 'Select a year range to filter results. You can select just a start year, end year, or both.', rangeConfig: { valueType: 'integer', minLabel: 'Start Year', maxLabel: 'End Year', minPlaceholder: 'e.g., 1980', maxPlaceholder: 'e.g., 2023', step: 1, useGrouping: false, defaultRange: { min: 1900, max: new Date().getFullYear() } } },</p>

<p>/**</p>
   <ul><li>Manufacturer-Model Combinations filter (Multiselect)</li>
</ul>   *
   <ul><li>Used to display chips when selections are made via Manufacturer-Model Picker</li>
</ul>   <ul><li>Format: "Manufacturer:Model" (e.g., "Ford:F-150")</li>
</ul>   */
<p>{ field: 'modelCombos', label: 'Manufacturer &amp; Model', type: 'multiselect', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/manufacturer-model-combinations?page=1&amp;size=100</code>, optionsTransformer: (response: any): FilterOption[] =&gt; { // Response structure: { total, data: [ { manufacturer, count, models: [ { model, count } ] } ] } if (response &amp;&amp; response.data) { const options: FilterOption[] = []; for (const mfr of response.data) { for (const modelObj of mfr.models || []) { options.push({ value: <code class="inline">${mfr.manufacturer}:${modelObj.model}</code>, label: <code class="inline">${mfr.manufacturer}: ${modelObj.model}</code> }); } } return options; } return []; }, urlParams: 'modelCombos', searchPlaceholder: 'Type to search manufacturer-model combinations...', dialogSubtitle: 'Select one or more manufacturer-model combinations. Tip: Use the Manufacturer-Model Picker panel for easier selection.' } ];</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 604.2: Understand the Query Control Filter Structure</h3>

<p>Each query control filter definition has these key properties:</p>

<table>
<p><thead><tr> <th>Property</th> <th>Type</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">field</code></td> <td><code class="inline">string</code></td> <td>Property name in AutoSearchFilters</td></p>
</tr>
<p><tr> <td><code class="inline">label</code></td> <td><code class="inline">string</code></td> <td>Display text in filter list and dialog title</td></p>
</tr>
<p><tr> <td><code class="inline">type</code></td> <td><code class="inline">'multiselect' \</td> <td>'range'</code></td> <td>Filter UI type</td></p>
</tr>
<p><tr> <td><code class="inline">optionsEndpoint</code></td> <td><code class="inline">string</code></td> <td>API endpoint to fetch options</td></p>
</tr>
<p><tr> <td><code class="inline">optionsTransformer</code></td> <td><code class="inline">function</code></td> <td>Transform API response to FilterOption[]</td></p>
</tr>
<p><tr> <td><code class="inline">urlParams</code></td> <td><code class="inline">string \</td> <td>object</code></td> <td>URL parameter name(s) for this filter</td></p>
</tr>
<p><tr> <td><code class="inline">searchPlaceholder</code></td> <td><code class="inline">string</code></td> <td>Placeholder text in search input</td></p>
</tr>
<p><tr> <td><code class="inline">dialogSubtitle</code></td> <td><code class="inline">string</code></td> <td>Help text shown in filter dialog</td></p>
</tr>
</tbody>
</table>

<p><strong>For Range Filters:</strong></p>

<table>
<p><thead><tr> <th>Property</th> <th>Type</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">rangeConfig.valueType</code></td> <td><code class="inline">'integer' \</td> <td>'float'</code></td> <td>Numeric type</td></p>
</tr>
<p><tr> <td><code class="inline">rangeConfig.minLabel</code></td> <td><code class="inline">string</code></td> <td>Label for min input</td></p>
</tr>
<p><tr> <td><code class="inline">rangeConfig.maxLabel</code></td> <td><code class="inline">string</code></td> <td>Label for max input</td></p>
</tr>
<p><tr> <td><code class="inline">rangeConfig.step</code></td> <td><code class="inline">number</code></td> <td>Input step value</td></p>
</tr>
<p><tr> <td><code class="inline">rangeConfig.useGrouping</code></td> <td><code class="inline">boolean</code></td> <td>Use thousand separators</td></p>
</tr>
<p><tr> <td><code class="inline">rangeConfig.defaultRange</code></td> <td><code class="inline">{ min, max }</code></td> <td>Default range limits</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 604.3: Understanding the Options Transformer</h3>

<p>The <code class="inline">optionsTransformer</code> function converts API responses to the standard <code class="inline">FilterOption[]</code> format:</p>

<pre class="code-block typescript"><code>// API Response (raw)
<p>{ manufacturers: ["Ford", "Toyota", "Honda", "BMW"] }</p>

<p>// After optionsTransformer [ { value: "Ford", label: "Ford" }, { value: "Toyota", label: "Toyota" }, { value: "Honda", label: "Honda" }, { value: "BMW", label: "BMW" } ]</p>
</code></pre>

<p><strong>Why this pattern?</strong></p>

<p>Different APIs return data in different formats:</p>
<ul><li>Some return arrays of strings</li>
<p><li>Some return arrays of objects with id/name</li> <li>Some return nested structures</li></p>
</ul>
<p>The transformer normalizes all formats to <code class="inline">{ value, label }</code>.</p>

<p><strong>Complex Example (Model Combinations):</strong></p>

<pre class="code-block typescript"><code>// API Response (raw)
<p>{ data: [ { manufacturer: "Ford", count: 100, models: [ { model: "F-150", count: 50 }, { model: "Mustang", count: 30 } ] }, { manufacturer: "Toyota", count: 80, models: [ { model: "Camry", count: 40 } ] } ] }</p>

<p>// After optionsTransformer [ { value: "Ford:F-150", label: "Ford: F-150" }, { value: "Ford:Mustang", label: "Ford: Mustang" }, { value: "Toyota:Camry", label: "Toyota: Camry" } ]</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 604.4: Understanding URL Parameter Mapping</h3>

<p>The <code class="inline">urlParams</code> property defines how filter values appear in the URL:</p>

<p><strong>Simple (string):</strong></p>
<pre class="code-block typescript"><code>urlParams: 'manufacturer'
<p>// Selected: ["Ford", "Toyota"] // URL: ?manufacturer=Ford,Toyota</p>
</code></pre>

<p><strong>Range (object):</strong></p>
<pre class="code-block typescript"><code>urlParams: { min: 'yearMin', max: 'yearMax' }
<p>// Selected: { min: 2020, max: 2023 } // URL: ?yearMin=2020&amp;yearMax=2023</p>
</code></pre>

<p>This separation allows:</p>
<ul><li>Filter field names to differ from URL parameter names</li>
<p><li>Range filters to use two separate URL parameters</li></p>
</ul>
<hr>

<h3>Step 604.5: Understanding Filter Type Differences</h3>

<p><strong>Multiselect vs Range:</strong></p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│                        MULTISELECT                               │ ├─────────────────────────────────────────────────────────────────┤ │ • User selects 0 to N items from a list                         │ │ • Options fetched from API                                       │ │ • URL: ?manufacturer=Ford,Toyota,Honda                          │ │ • Chip: "Manufacturer: Ford, Toyota, Honda"                     │ └─────────────────────────────────────────────────────────────────┘</p>

<p>┌─────────────────────────────────────────────────────────────────┐ │                          RANGE                                   │ ├─────────────────────────────────────────────────────────────────┤ │ • User enters min and/or max values                              │ │ • No options fetched (user types values)                         │ │ • URL: ?yearMin=2020&amp;yearMax=2023                                │ │ • Chip: "Year: 2020 - 2023"                                      │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Verify File Created</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/configs/automobile.query-control-filters.ts
</code></pre>

<p>Expected: File exists.</p>

<h3>2. Verify TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/domain-config/automobile/configs/automobile.query-control-filters.ts</p>
</code></pre>

<p>Expected: No compilation errors.</p></div><div class="page-content"><h3>3. Verify Filter Count</h3>

<pre class="code-block bash"><code>$ grep -c "field:" src/app/domain-config/automobile/configs/automobile.query-control-filters.ts
</code></pre>

<p>Expected: <code class="inline">5</code> (manufacturer, model, bodyClass, yearMin, modelCombos)</p>

<h3>4. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export const" src/app/domain-config/automobile/configs/automobile.query-control-filters.ts
</code></pre>

<p>Expected: <code class="inline">export const AUTOMOBILE_QUERY_CONTROL_FILTERS</code></p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot find module '../models/automobile.filters'"</td> <td>Filters model not yet created</td> <td>Ensure Phase 4 (document 401) is complete</td></p>
</tr>
<p><tr> <td>Options not loading</td> <td>API endpoint incorrect</td> <td>Verify optionsEndpoint matches actual API</td></p>
</tr>
<p><tr> <td>Transformer returns empty array</td> <td>API response structure changed</td> <td>Update optionsTransformer to match actual response</td></p>
</tr>
<p><tr> <td>Chip shows "[object Object]"</td> <td>Label not set correctly</td> <td>Ensure optionsTransformer sets label property</td></p>
</tr>
<p><tr> <td>Year filter shows commas</td> <td>useGrouping not set to false</td> <td>Set rangeConfig.useGrouping: false</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Query control filters are on-demand</strong> — Users add them via dialog, unlike always-visible filter panel</li>
<p><li><strong>Options are fetched dynamically</strong> — optionsEndpoint and optionsTransformer handle API integration</li> <li><strong>URL params can differ from field names</strong> — urlParams provides the URL-side mapping</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domain-config/automobile/configs/automobile.query-control-filters.ts</code> exists</li>
<p><li>[ ] <code class="inline">AUTOMOBILE_QUERY_CONTROL_FILTERS</code> array contains 5 filter definitions</li> <li>[ ] Manufacturer, Model, Body Class filters are type 'multiselect'</li> <li>[ ] Year filter is type 'range' with rangeConfig</li> <li>[ ] Model Combinations filter handles nested API response structure</li> <li>[ ] Each filter has optionsEndpoint and optionsTransformer</li> <li>[ ] Each filter has urlParams for URL serialization</li> <li>[ ] File compiles without TypeScript errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">605-highlight-filters.md</code> to define highlight filter definitions for chart segmentation.</p></div></div>
    <div class="chapter" id="section-605">
        <div class="chapter-header">
            <div class="chapter-category">Domain Config</div>
            <h1>605: Highlight Filters</h1>
        </div>
<div class="page-content"><h1>605: Highlight Filters</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 203-filter-definition-interface, 401-automobile-filters-model <strong>Blocks:</strong> 607-domain-config-assembly</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the purpose of highlight filters for chart segmentation</li>
<p><li>Know the naming convention for highlight URL parameters (h_ prefix)</li> <li>Recognize how highlight data flows from URL to API to chart visualization</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the highlight filter definitions that enable chart segmentation. Highlight filters use the same structure as query control filters but generate URL parameters with the <code class="inline">h_</code> prefix, triggering special API behavior that returns segmented statistics.</p>

<hr>

<h2>Why</h2>

<p>Regular filters narrow results: "Show only Ford vehicles" removes all non-Ford data.</p>

<p>Highlight filters segment results: "Highlight Ford in the charts" keeps all data but colors Ford differently.</p>

<p><strong>Visual comparison:</strong></p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│                    WITHOUT HIGHLIGHTS                            │ │                                                                  │ │  Manufacturer Distribution                                       │ │  ┌─────────────────────────────────────────────────────────┐    │ │  │ ████████████ Ford (25%)                                  │    │ │  │ ██████████ Toyota (20%)                                  │    │ │  │ ████████ Honda (16%)                                     │    │ │  │ ██████ BMW (12%)                                         │    │ │  └─────────────────────────────────────────────────────────┘    │ │                                                                  │ │  All bars are the same color (blue)                             │ └─────────────────────────────────────────────────────────────────┘</p>

<p>┌─────────────────────────────────────────────────────────────────┐ │                    WITH HIGHLIGHTS                               │ │                    h_manufacturer=Ford                           │ │                                                                  │ │  Manufacturer Distribution                                       │ │  ┌─────────────────────────────────────────────────────────┐    │ │  │ ████████████ Ford (25%) [ORANGE - HIGHLIGHTED]           │    │ │  │ ██████████ Toyota (20%) [BLUE - OTHER]                   │    │ │  │ ████████ Honda (16%) [BLUE - OTHER]                      │    │ │  │ ██████ BMW (12%) [BLUE - OTHER]                          │    │ │  └─────────────────────────────────────────────────────────┘    │ │                                                                  │ │  Ford is highlighted in orange; others remain blue              │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p><strong>Use cases:</strong></p>

<ul><li><strong>Competitive analysis</strong> — Highlight your company vs competitors</li>
<p><li><strong>Focus attention</strong> — Draw user's eye to specific data points</li> <li><strong>Before/after comparison</strong> — Highlight a year range to show trends</li></p>
</ul>
<p><strong>API behavior:</strong></p>

<p>When the API receives highlight parameters, it returns segmented statistics:</p></div><div class="page-content"><pre class="code-block json"><code>// Without highlights: GET /vehicles/statistics
<p>{ "manufacturers": [ { "name": "Ford", "count": 1000 }, { "name": "Toyota", "count": 800 } ] }</p>

<p>// With highlights: GET /vehicles/statistics?h_manufacturer=Ford { "manufacturers": [ { "name": "Ford", "count": 1000, "highlighted": 1000 }, { "name": "Toyota", "count": 800, "highlighted": 0 } ] }</p>
</code></pre>

<p>The <code class="inline">highlighted</code> field indicates how much of the count matches the highlight criteria.</p>

<hr>

<h2>What</h2>

<h3>Step 605.1: Create the Highlight Filters File</h3>

<p>Create the file that will define highlight filter configurations.</p>

<p>Create <code class="inline">src/app/domain-config/automobile/configs/automobile.highlight-filters.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/configs/automobile.highlight-filters.ts

<p>/**</p>
 <ul><li>Automobile Domain - Highlight Filter Definitions</li>
</ul> *
 <ul><li>Defines highlight filter definitions for the Query Control component.</li>
</ul> <em> Highlight filters allow users to add h_</em> parameters to segment statistics
 <ul><li>in charts (showing highlighted vs other data in stacked bars).</li>
</ul> *
 <ul><li>Domain: Automobile Discovery</li>
</ul> */

<p>import { FilterDefinition, FilterOption } from '../../../framework/models/filter-definition.interface'; import { HighlightFilters } from '../models/automobile.filters'; import { environment } from '../../../environments/environment';</p>

<p>/**</p>
 <ul><li>Highlight filter definitions</li>
</ul> *
 <ul><li>Each definition specifies:</li>
</ul> <ul><li>- Which highlight field it manages (h_manufacturer, h_modelCombos, etc.)</li>
</ul> <ul><li>- What type of UI control to display (multiselect, range, etc.)</li>
</ul> <ul><li>- Where to fetch options from (API endpoint)</li>
</ul> <ul><li>- How to transform API responses</li>
</ul> <ul><li>- URL parameter names (with h_ prefix)</li>
</ul> *
 <ul><li>These are used by the QueryControlComponent to dynamically render highlight filter dialogs.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// User adds "Highlight Manufacturer: Ford" filter</li>
</ul> <ul><li>// URL updates to: ?h_manufacturer=Ford</li>
</ul> <ul><li>// API receives: GET /vehicles/details?h_manufacturer=Ford</li>
</ul> <ul><li>// Returns segmented statistics: {"Ford": {"total": 665, "highlighted": 665}, ...}</li>
</ul> <ul><li>// Charts render stacked bars showing highlighted (Ford) vs other manufacturers</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const AUTOMOBILE_HIGHLIGHT_FILTERS: FilterDefinition&lt;HighlightFilters&gt;[] = [ /**</p>
   <ul><li>Highlight Manufacturer filter (Multiselect)</li>
</ul>   <ul><li>URL parameter: h_manufacturer</li>
</ul>   */
<p>{ field: 'manufacturer', label: 'Highlight Manufacturer', type: 'multiselect', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/filters/manufacturers</code>, optionsTransformer: (response: any): FilterOption[] =&gt; { if (response &amp;&amp; response.manufacturers) { return response.manufacturers.map((m: string) =&gt; ({ value: m, label: m })); } return []; }, urlParams: 'h_manufacturer', searchPlaceholder: 'Type to search manufacturers...', dialogSubtitle: 'Select one or more manufacturers to highlight in charts.' },</p>

<p>/**</p>
   <ul><li>Highlight Model Combinations filter (Multiselect)</li>
</ul>   <ul><li>URL parameter: h_modelCombos</li>
</ul>   <ul><li>Format: Manufacturer:Model,Manufacturer:Model (e.g., Ford:F-150,Toyota:Camry)</li>
</ul>   */
<p>{ field: 'modelCombos', label: 'Highlight Models', type: 'multiselect', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/manufacturer-model-combinations</code>, optionsTransformer: (response: any): FilterOption[] =&gt; { const options: FilterOption[] = []; if (response &amp;&amp; response.data) { // Flatten nested structure: data[].manufacturer + data[].models[].model for (const manufacturerGroup of response.data) { const manufacturer = manufacturerGroup.manufacturer; if (manufacturerGroup.models) { for (const modelObj of manufacturerGroup.models) { const model = modelObj.model; options.push({ value: <code class="inline">${manufacturer}:${model}</code>, label: <code class="inline">${manufacturer}:${model}</code> }); } } } } return options; }, urlParams: 'h_modelCombos', searchPlaceholder: 'Type to search model combinations...', dialogSubtitle: 'Select one or more model combinations to highlight in charts.' },</p>

<p>/**</p>
   <ul><li>Highlight Body Class filter (Multiselect)</li>
</ul>   <ul><li>URL parameter: h_bodyClass</li>
</ul>   */
<p>{ field: 'bodyClass', label: 'Highlight Body Class', type: 'multiselect', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/filters/body-classes</code>, optionsTransformer: (response: any): FilterOption[] =&gt; { if (response &amp;&amp; response.body_classes) { return response.body_classes.map((b: string) =&gt; ({ value: b, label: b })); } return []; }, urlParams: 'h_bodyClass', searchPlaceholder: 'Type to search body classes...', dialogSubtitle: 'Select one or more body classes to highlight in charts.' },</p>

<p>/**</p>
   <ul><li>Highlight Year Range filter (Range)</li>
</ul>   <ul><li>URL parameters: h_yearMin, h_yearMax</li>
</ul>   *
   <ul><li>Note: This uses yearMin as the field, but actually manages both yearMin and yearMax</li>
</ul>   */
<p>{ field: 'yearMin', label: 'Highlight Year', type: 'range', optionsEndpoint: <code class="inline">${environment.apiBaseUrl}/filters/year-range</code>, urlParams: { min: 'h_yearMin', max: 'h_yearMax' }, dialogTitle: 'Highlight Year Range', dialogSubtitle: 'Select a year range to highlight in charts. You can select just a start year, end year, or both.', rangeConfig: { valueType: 'integer', minLabel: 'Start Year', maxLabel: 'End Year', minPlaceholder: 'e.g., 1980', maxPlaceholder: 'e.g., 2023', step: 1, useGrouping: false, defaultRange: { min: 1900, max: new Date().getFullYear() } } } ];</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 605.2: Understand the Highlight Filter Structure</h3>

<p>Highlight filters use the same structure as query control filters with one key difference: the <code class="inline">urlParams</code> values have the <code class="inline">h_</code> prefix.</p>

<p><strong>Query Control Filter:</strong></p>
<pre class="code-block typescript"><code>{
<p>field: 'manufacturer', urlParams: 'manufacturer'  // URL: ?manufacturer=Ford }</p>
</code></pre>

<p><strong>Highlight Filter:</strong></p>
<pre class="code-block typescript"><code>{
<p>field: 'manufacturer', urlParams: 'h_manufacturer'  // URL: ?h_manufacturer=Ford }</p>
</code></pre>

<p>The <code class="inline">h_</code> prefix signals to the API adapter that this is a highlight filter, not a regular filter.</p>

<hr>

<h3>Step 605.3: Understanding the URL Parameter Convention</h3>

<p>The <code class="inline">h_</code> prefix is a convention used throughout the application:</p>

<table>
<p><thead><tr> <th>Regular Filter</th> <th>Highlight Filter</th> <th>Effect</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">manufacturer=Ford</code></td> <td><code class="inline">h_manufacturer=Ford</code></td> <td>Filter: Only Ford</td> <td>Highlight: All data, Ford colored</td></p>
</tr>
<p><tr> <td><code class="inline">yearMin=2020&amp;yearMax=2023</code></td> <td><code class="inline">h_yearMin=2020&amp;h_yearMax=2023</code></td> <td>Filter: Only 2020-2023</td> <td>Highlight: All years, 2020-2023 colored</td></p>
</tr>
<p><tr> <td><code class="inline">bodyClass=SUV</code></td> <td><code class="inline">h_bodyClass=SUV</code></td> <td>Filter: Only SUVs</td> <td>Highlight: All body classes, SUV colored</td></p>
</tr>
</tbody>
</table>

<p><strong>Combined example:</strong></p>
<pre class="code-block text"><code>?manufacturer=Ford&amp;h_bodyClass=SUV

<p>Result:</p>
<ul><li>Data filtered to Ford vehicles only</li>
<p><li>Charts show all Ford body classes</li> <li>SUV bars highlighted in orange, other Ford body classes in blue</li></p>
</ul></code></pre>

<hr>

<h3>Step 605.4: Understanding the Data Flow</h3>

<p>The complete flow from URL to visualization:</p></div><div class="page-content"><pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│ 1. USER ACTION                                                   │ │                                                                  │ │    User adds highlight filter: "Highlight Manufacturer: Ford"   │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────────────────┐ │ 2. URL UPDATE                                                    │ │                                                                  │ │    /automobiles/discover?h_manufacturer=Ford                    │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────────────────┐ │ 3. URL MAPPER PARSES                                             │ │                                                                  │ │    AutomobileUrlMapper.parseUrl() extracts:                     │ │    {                                                             │ │      filters: { },                                               │ │      highlights: { manufacturer: ['Ford'] }                     │ │    }                                                             │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────────────────┐ │ 4. API ADAPTER BUILDS REQUEST                                    │ │                                                                  │ │    GET /vehicles/statistics?h_manufacturer=Ford                 │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────────────────┐ │ 5. API RETURNS SEGMENTED DATA                                    │ │                                                                  │ │    {                                                             │ │      "manufacturers": [                                          │ │        { "name": "Ford", "count": 1000, "highlighted": 1000 },  │ │        { "name": "Toyota", "count": 800, "highlighted": 0 },    │ │        { "name": "Honda", "count": 600, "highlighted": 0 }      │ │      ]                                                           │ │    }                                                             │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────────────────┐ │ 6. CHART DATA SOURCE TRANSFORMS                                  │ │                                                                  │ │    ManufacturerChartDataSource creates stacked bar data:        │ │    - Trace 1 (orange): highlighted values                        │ │    - Trace 2 (blue): count - highlighted                        │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘ ↓ ┌─────────────────────────────────────────────────────────────────┐ │ 7. CHART RENDERS                                                 │ │                                                                  │ │    ████████████ Ford (100% highlighted)   [ORANGE]              │ │    ██████████ Toyota (0% highlighted)     [BLUE]                │ │    ████████ Honda (0% highlighted)        [BLUE]                │ │                                                                  │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 605.5: Comparing Query Control Filters vs Highlight Filters</h3>

<p><strong>Document 604 (Query Control Filters):</strong></p>
<ul><li>Narrow the dataset</li>
<p><li>Remove non-matching rows</li> <li>URL params: <code class="inline">manufacturer</code>, <code class="inline">model</code>, <code class="inline">yearMin</code>, etc.</li></p>
</ul>
<p><strong>Document 605 (Highlight Filters):</strong></p>
<ul><li>Segment the visualization</li>
<p><li>Keep all rows, color matching rows differently</li> <li>URL params: <code class="inline">h_manufacturer</code>, <code class="inline">h_model</code>, <code class="inline">h_yearMin</code>, etc.</li></p>
</ul>
<p><strong>They share:</strong></p>
<ul><li>Same structure (FilterDefinition interface)</li>
<p><li>Same options endpoints</li> <li>Same options transformers</li> <li>Same UI dialogs (QueryControlComponent handles both)</li></p>
</ul>
<p><strong>They differ:</strong></p>
<ul><li>URL parameter names (with/without <code class="inline">h_</code> prefix)</li>
<p><li>API behavior (filter vs segment)</li> <li>Visual effect (hide vs color)</li></p>
</ul>
<hr>

<h2>Verification</h2>

<h3>1. Verify File Created</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/configs/automobile.highlight-filters.ts
</code></pre>

<p>Expected: File exists.</p>

<h3>2. Verify TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/domain-config/automobile/configs/automobile.highlight-filters.ts</p>
</code></pre>

<p>Expected: No compilation errors.</p>

<h3>3. Verify Filter Count</h3>

<pre class="code-block bash"><code>$ grep -c "field:" src/app/domain-config/automobile/configs/automobile.highlight-filters.ts
</code></pre>

<p>Expected: <code class="inline">4</code> (manufacturer, modelCombos, bodyClass, yearMin)</p>

<h3>4. Verify h_ Prefix</h3>

<pre class="code-block bash"><code>$ grep "h_" src/app/domain-config/automobile/configs/automobile.highlight-filters.ts | wc -l
</code></pre>

<p>Expected: At least 6 occurrences (h_manufacturer, h_modelCombos, h_bodyClass, h_yearMin, h_yearMax in code and comments)</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Highlights not appearing in charts</td> <td>API not returning highlighted field</td> <td>Verify API supports h_ parameters</td></p>
</tr>
<p><tr> <td>Same color for highlighted and non-highlighted</td> <td>Chart data source not using highlighted field</td> <td>Update chart data source to check for segmented data</td></p>
</tr>
<p><tr> <td>Filter and highlight interfering</td> <td>Using wrong prefix</td> <td>Filter params no prefix, highlight params h_ prefix</td></p>
</tr>
<p><tr> <td>"Cannot find 'HighlightFilters'"</td> <td>Model not imported</td> <td>Ensure automobile.filters.ts exports HighlightFilters</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Highlight filters segment, they don't filter</strong> — All data remains; selected items are visually distinguished</li>
<p><li><strong>The h_ prefix is the convention</strong> — URL parameters starting with h_ trigger highlight behavior</li> <li><strong>Same structure, different purpose</strong> — Highlight filters reuse the FilterDefinition interface with different urlParams</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domain-config/automobile/configs/automobile.highlight-filters.ts</code> exists</li>
<p><li>[ ] <code class="inline">AUTOMOBILE_HIGHLIGHT_FILTERS</code> array contains 4 filter definitions</li> <li>[ ] All urlParams values start with <code class="inline">h_</code> prefix</li> <li>[ ] Manufacturer and Body Class filters are type 'multiselect'</li> <li>[ ] Model Combinations filter handles nested API response</li> <li>[ ] Year filter is type 'range' with h_yearMin and h_yearMax params</li> <li>[ ] Label text includes "Highlight" to distinguish from regular filters</li> <li>[ ] File compiles without TypeScript errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">606-chart-configs.md</code> to define the chart configurations for the statistics panel.</p></div></div>
    <div class="chapter" id="section-606">
        <div class="chapter-header">
            <div class="chapter-category">Domain Config</div>
            <h1>606: Chart Configs</h1>
        </div>
<div class="page-content"><h1>606: Chart Configs</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface <strong>Blocks:</strong> 607-domain-config-assembly, 651-manufacturer-chart-source</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how chart configurations separate visualization metadata from data transformation</li>
<p><li>Know the relationship between chart configs and chart data sources</li> <li>Recognize the pattern of declarative chart definition</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the automobile chart configurations that define which charts appear in the statistics panel. These configurations specify chart identity, type, dimensions, and which data source transforms the statistics into chart data.</p>

<hr>

<h2>Why</h2>

<p>Visualizations help users understand data patterns. For automobiles, we want charts showing:</p>

<ul><li><strong>Manufacturer distribution</strong> — Which manufacturers have the most vehicles?</li>
<p><li><strong>Model distribution</strong> — Which specific models are most common?</li> <li><strong>Year distribution</strong> — How are vehicles distributed across years?</li> <li><strong>Body class distribution</strong> — What types of vehicles are in the data?</li></p>
</ul>
<p>Without configuration, you might create each chart as a separate component:</p>

<pre class="code-block typescript"><code>@Component({
<p>template: <code class="inline"> &lt;div class="chart-container"&gt; &lt;h3&gt;Manufacturers&lt;/h3&gt; &lt;plotly-plot [data]="manufacturerData" [layout]="layout"&gt;&lt;/plotly-plot&gt; &lt;/div&gt;</p>
  </code>
<p>}) export class ManufacturerChartComponent { // Transform statistics to chart data // Handle Plotly configuration // Manage visibility // ...50+ lines of code }</p>
</code></pre>

<p>Four charts = four components = 200+ lines of similar code.</p>

<p>With configuration:</p>

<pre class="code-block typescript"><code>export const AUTOMOBILE_CHART_CONFIGS: ChartConfig[] = [
<p>{ id: 'manufacturer-distribution', title: 'Manufacturers', dataSourceId: 'manufacturer', ... }, { id: 'year-distribution', title: 'Year', dataSourceId: 'year', ... }, // ... ];</p>
</code></pre>

<p>One generic <code class="inline">BaseChartComponent</code> + configuration = minimal code.</p>

<p><strong>This is the Phase 6 Aha Moment again:</strong> Configuration is declarative code. You describe what charts you want, not how to render them.</p></div><div class="page-content"><h3>Angular Style Guide References</h3>

<ul><li>Configuration objects follow the same pattern as Angular's built-in configurations (routes, providers)</li>
</ul>
<hr>

<h2>What</h2>

<h3>Step 606.1: Create the Chart Configurations File</h3>

<p>Create the file that will define automobile chart configurations.</p>

<p>Create <code class="inline">src/app/domain-config/automobile/configs/automobile.chart-configs.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domain-config/automobile/configs/automobile.chart-configs.ts

<p>/**</p>
 <ul><li>Automobile Domain - Chart Configurations (Plotly.js)</li>
</ul> *
 <ul><li>Defines chart visualizations for automobile statistics using Plotly.js.</li>
</ul> <ul><li>Charts display aggregated data and distributions.</li>
</ul> *
 <ul><li>Domain: Automobile Discovery</li>
</ul> */

<p>import { ChartConfig } from '../../../framework/models/domain-config.interface';</p>

<p>/**</p>
 <ul><li>Automobile chart configurations</li>
</ul> *
 <ul><li>Array of chart definitions for the statistics panel.</li>
</ul> <ul><li>Each chart visualizes a different aspect of the vehicle data.</li>
</ul> *
 <ul><li>NOTE: These configs work with Plotly.js via BaseChartComponent.</li>
</ul> <ul><li>Data transformation is handled by chart data sources in chart-sources/ directory.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>&lt;app-statistics-panel-2 [domainConfig]="domainConfig"&gt;</li>
</ul> <ul><li>&lt;/app-statistics-panel-2&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const AUTOMOBILE_CHART_CONFIGS: ChartConfig[] = [ /**</p>
   <ul><li>Manufacturer distribution (vertical stacked bar chart)</li>
</ul>   */
<p>{ id: 'manufacturer-distribution', title: 'Manufacturers', type: 'bar', dataSourceId: 'manufacturer', height: 400, width: '100%', visible: true, collapsible: true },</p>

<p>/**</p>
   <ul><li>Top models by VIN count (vertical stacked bar chart)</li>
</ul>   */
<p>{ id: 'top-models', title: 'Models', type: 'bar', dataSourceId: 'top-models', height: 400, width: '100%', visible: true, collapsible: true },</p>

<p>/**</p>
   <ul><li>Year distribution (vertical stacked bar chart)</li>
</ul>   */
<p>{ id: 'year-distribution', title: 'Year', type: 'bar', dataSourceId: 'year', height: 400, width: '100%', visible: true, collapsible: true },</p>

<p>/**</p>
   <ul><li>Body class distribution (vertical stacked bar chart)</li>
</ul>   */
<p>{ id: 'body-class-distribution', title: 'Body Class', type: 'bar', dataSourceId: 'body-class', height: 400, width: '100%', visible: true, collapsible: true } ];</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 606.2: Understand the Chart Configuration Structure</h3>

<p>Each chart configuration defines a visualization:</p>

<table>
<p><thead><tr> <th>Property</th> <th>Type</th> <th>Description</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">id</code></td> <td><code class="inline">string</code></td> <td>Unique identifier for the chart</td></p>
</tr>
<p><tr> <td><code class="inline">title</code></td> <td><code class="inline">string</code></td> <td>Display title shown above the chart</td></p>
</tr>
<p><tr> <td><code class="inline">type</code></td> <td><code class="inline">'bar' \</td> <td>'line' \</td> <td>'pie' \</td> <td>'scatter'</code></td> <td>Plotly chart type</td></p>
</tr>
<p><tr> <td><code class="inline">dataSourceId</code></td> <td><code class="inline">string</code></td> <td>Key to look up in chartDataSources map</td></p>
</tr>
<p><tr> <td><code class="inline">height</code></td> <td><code class="inline">number</code></td> <td>Chart height in pixels</td></p>
</tr>
<p><tr> <td><code class="inline">width</code></td> <td><code class="inline">string</code></td> <td>Chart width (CSS value)</td></p>
</tr>
<p><tr> <td><code class="inline">visible</code></td> <td><code class="inline">boolean</code></td> <td>Initial visibility state</td></p>
</tr>
<p><tr> <td><code class="inline">collapsible</code></td> <td><code class="inline">boolean</code></td> <td>Can user collapse/expand the chart</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 606.3: Understanding the Chart/Data Source Relationship</h3>

<p>Chart configs and chart data sources are separate concerns:</p>

<p><strong>Chart Config (this file):</strong></p>
<ul><li>Defines chart metadata (id, title, type, dimensions)</li>
<p><li>Says "render a bar chart called 'Manufacturers'"</li> <li>Does NOT know how to transform statistics to chart data</li></p>
</ul>
<p><strong>Chart Data Source (Phase 7, documents 651-654):</strong></p>
<ul><li>Transforms statistics into Plotly trace format</li>
<p><li>Knows the structure of VehicleStatistics</li> <li>Handles highlight segmentation</li></p>
</ul>
<p>The connection is the <code class="inline">dataSourceId</code>:</p>

<pre class="code-block typescript"><code>// Chart config (document 606)
<p>{ id: 'manufacturer-distribution', dataSourceId: 'manufacturer', ... }</p>

<p>// Domain config (document 607) connects them chartDataSources: { 'manufacturer': new ManufacturerChartDataSource(),  // Phase 7 // ... }</p>
</code></pre>

<p><strong>Data Flow:</strong></p>

<pre class="code-block text"><code>┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
<p>│  ChartConfig    │     │ ChartDataSource │     │ BaseChartComp   │ │                 │     │                 │     │                 │ │ dataSourceId:   │────▶│ transform()     │────▶│ Plotly.js       │ │ 'manufacturer'  │     │ returns traces  │     │ render          │ └─────────────────┘     └─────────────────┘     └─────────────────┘</p>
</code></pre>

<hr>

<h3>Step 606.4: Understanding Chart Types</h3>

<p>All automobile charts use <code class="inline">type: 'bar'</code>, but the framework supports multiple types:</p>

<p><strong>Bar Charts (used here):</strong></p>
<pre class="code-block text"><code>     │
<p>50 │ ████ │ ████ ████ 25 │ ████ ████ ████ │ ████ ████ ████ ████ 0 └───────────────────── Ford Toyota Honda BMW</p>
</code></pre>

<p>Best for: Comparing categories (manufacturers, body classes)</p>

<p><strong>Line Charts:</strong></p>
<pre class="code-block text"><code>     │
<p>50 │         /\ │    /\  /  \ 25 │   /  \/    \ │  /          \____ 0 └───────────────────── 2018 2019 2020 2021 2022</p>
</code></pre>

<p>Best for: Showing trends over time</p>

<p><strong>Pie Charts:</strong></p>
<pre class="code-block text"><code>        ╭─────────────╮
<p>/    Ford     \ │     25%       │ │               │ \    Toyota    / \   20%      / ╰─────────╯</p>
</code></pre>

<p>Best for: Showing proportions of a whole</p></div><div class="page-content"><hr>

<h3>Step 606.5: Understanding Stacked Bar Charts with Highlights</h3>

<p>When highlights are active, bar charts become stacked:</p>

<p><strong>Without highlights:</strong></p>
<pre class="code-block text"><code>Manufacturers
<p>│ 100 │ ████ │ ████ ████ 50 │ ████ ████ ████ │ ████ ████ ████ ████ 0 └───────────────────── Ford Toyota Honda BMW</p>
</code></pre>

<p><strong>With h_manufacturer=Ford:</strong></p>
<pre class="code-block text"><code>Manufacturers
<p>│ 100 │ ████ (orange: highlighted) │ ████ ░░░░ 50 │ ████ ░░░░ ░░░░ │ ████ ░░░░ ░░░░ ░░░░ 0 └───────────────────── Ford Toyota Honda BMW</p>

<p>Legend: ████ = Highlighted (Ford) ░░░░ = Other</p>
</code></pre>

<p>The stacking is handled by the chart data source (Phase 7), not the chart config.</p>

<hr>

<h3>Step 606.6: Understanding Chart Dimensions</h3>

<p>The <code class="inline">height</code> and <code class="inline">width</code> properties control chart sizing:</p>

<pre class="code-block typescript"><code>{
<p>height: 400,   // Fixed 400px height width: '100%'  // Responsive width (fills container) }</p>
</code></pre>

<p><strong>Why fixed height, responsive width?</strong></p>

<ul><li><strong>Fixed height</strong>: Charts need consistent vertical space for readability</li>
<p><li><strong>Responsive width</strong>: Charts should adapt to container width (desktop vs mobile)</li></p>
</ul>
<p>The statistics panel uses a grid layout:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│ Statistics Panel                                                 │ ├─────────────────────────────────┬───────────────────────────────┤ │ ┌─────────────────────────────┐ │ ┌─────────────────────────────┐│ │ │     Manufacturers           │ │ │        Models               ││ │ │     height: 400px           │ │ │        height: 400px        ││ │ │     width: 100%             │ │ │        width: 100%          ││ │ └─────────────────────────────┘ │ └─────────────────────────────┘│ ├─────────────────────────────────┼───────────────────────────────┤ │ ┌─────────────────────────────┐ │ ┌─────────────────────────────┐│ │ │        Year                 │ │ │      Body Class             ││ │ │     height: 400px           │ │ │        height: 400px        ││ │ │     width: 100%             │ │ │        width: 100%          ││ │ └─────────────────────────────┘ │ └─────────────────────────────┘│ └─────────────────────────────────┴───────────────────────────────┘</p>
</code></pre>

<p>Each chart fills its grid cell horizontally but maintains 400px height.</p></div><div class="page-content"><hr>

<h3>Step 606.7: Understanding Collapsible Charts</h3>

<p>The <code class="inline">collapsible: true</code> property allows users to minimize charts:</p>

<pre class="code-block text"><code>┌─────────────────────────────────────────────────────────────────┐
<p>│ ▼ Manufacturers                                            [−]  │ ├─────────────────────────────────────────────────────────────────┤ │ ████████████████████████████████████████████████████████████    │ │ ██████████████████████████████████████████████                  │ │ ████████████████████████████████                                │ └─────────────────────────────────────────────────────────────────┘</p>

<p>After clicking [−]:</p>

<p>┌─────────────────────────────────────────────────────────────────┐ │ ▶ Manufacturers                                            [+]  │ └─────────────────────────────────────────────────────────────────┘</p>
</code></pre>

<p>Benefits:</p>
<ul><li>Users can hide charts they don't need</li>
<p><li>Saves vertical space for charts they do use</li> <li>State can be persisted in user preferences</li></p>
</ul>
<hr>

<h2>Verification</h2>

<h3>1. Verify File Created</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/configs/automobile.chart-configs.ts
</code></pre>

<p>Expected: File exists.</p>

<h3>2. Verify TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/domain-config/automobile/configs/automobile.chart-configs.ts</p>
</code></pre>

<p>Expected: No compilation errors.</p>

<h3>3. Verify Chart Count</h3>

<pre class="code-block bash"><code>$ grep -c "id:" src/app/domain-config/automobile/configs/automobile.chart-configs.ts
</code></pre>

<p>Expected: <code class="inline">4</code> (manufacturer-distribution, top-models, year-distribution, body-class-distribution)</p>

<h3>4. Verify Data Source IDs</h3>

<pre class="code-block bash"><code>$ grep "dataSourceId:" src/app/domain-config/automobile/configs/automobile.chart-configs.ts
</code></pre>

<p>Expected: Four dataSourceId values (manufacturer, top-models, year, body-class)</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot find module '../../../framework/models/domain-config.interface'"</td> <td>Interface not yet created</td> <td>Ensure Phase 2 (document 201) is complete</td></p>
</tr>
<p><tr> <td>Chart not rendering</td> <td>dataSourceId not found in chartDataSources</td> <td>Verify dataSourceId matches key in domain config</td></p>
</tr>
<p><tr> <td>Chart too tall/short</td> <td>Incorrect height value</td> <td>Adjust height to appropriate pixel value</td></p>
</tr>
<p><tr> <td>Chart not collapsing</td> <td>collapsible: false</td> <td>Set collapsible: true</td></p>
</tr>
<p><tr> <td>"ChartConfig is not a type"</td> <td>Import missing</td> <td>Add import for ChartConfig from domain-config.interface</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Chart configs are pure metadata</strong> — They describe what to render, not how</li>
<p><li><strong>Data sources handle transformation</strong> — The dataSourceId links to code that transforms statistics</li> <li><strong>All charts use consistent dimensions</strong> — height: 400, width: '100%' for uniform appearance</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domain-config/automobile/configs/automobile.chart-configs.ts</code> exists</li>
<p><li>[ ] <code class="inline">AUTOMOBILE_CHART_CONFIGS</code> array contains 4 chart definitions</li> <li>[ ] Each chart has id, title, type, dataSourceId, height, width, visible, collapsible</li> <li>[ ] All charts use type: 'bar' for consistent visualization</li> <li>[ ] dataSourceId values are: manufacturer, top-models, year, body-class</li> <li>[ ] All charts have height: 400 and width: '100%'</li> <li>[ ] All charts have visible: true and collapsible: true</li> <li>[ ] File compiles without TypeScript errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">607-domain-config-assembly.md</code> to assemble all configurations into the complete automobile domain config.</p></div></div>
    <div class="chapter" id="section-607">
        <div class="chapter-header">
            <div class="chapter-category">Domain Config</div>
            <h1>607: Domain Config Assembly</h1>
        </div>
<div class="page-content"><h1>607: Domain Config Assembly</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface, 401-403 (models), 501-503 (adapters), 601-606 (configs) <strong>Blocks:</strong> 608-domain-providers, 902-automobile-landing</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how the domain config factory pattern assembles all domain pieces</li>
<p><li>Know how Angular's Injector enables runtime dependency resolution</li> <li>Recognize the complete structure of a DomainConfig object</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the automobile domain configuration factory function that assembles all models, adapters, and UI configurations into a single DomainConfig object. This is the central integration point for everything automobile-related.</p>

<hr>

<h2>Why</h2>

<p>Throughout Phase 4, 5, and 6, you created many separate pieces:</p>

<p><strong>Phase 4 (Models):</strong></p>
<ul><li>AutoSearchFilters</li>
<p><li>VehicleResult</li> <li>VehicleStatistics</li></p>
</ul>
<p><strong>Phase 5 (Adapters):</strong></p>
<ul><li>AutomobileUrlMapper</li>
<p><li>AutomobileApiAdapter</li> <li>AutomobileCacheKeyBuilder</li></p>
</ul>
<p><strong>Phase 6 (Configs):</strong></p>
<ul><li>AUTOMOBILE_FILTER_DEFINITIONS</li>
<p><li>AUTOMOBILE_TABLE_CONFIG</li> <li>AUTOMOBILE_PICKER_CONFIGS (factory)</li> <li>AUTOMOBILE_QUERY_CONTROL_FILTERS</li> <li>AUTOMOBILE_HIGHLIGHT_FILTERS</li> <li>AUTOMOBILE_CHART_CONFIGS</li></p>
</ul>
<p>Now you need to assemble these pieces into a single object that the framework can consume.</p>

<p><strong>Why a factory function instead of a constant?</strong></p>

<p>Some pieces need Angular services (like ApiService for the ApiAdapter and pickers). Angular's dependency injection provides services at runtime, not at module load time. A factory function receives the Injector and can resolve dependencies dynamically.</p>

<pre class="code-block typescript"><code>// This won't work - ApiService isn't available at import time
<p>export const DOMAIN_CONFIG = { apiAdapter: new AutomobileApiAdapter(apiService) // Error: apiService undefined };</p>

<p>// This works - Injector provides ApiService at runtime export function createAutomobileDomainConfig(injector: Injector) { const apiService = injector.get(ApiService); return { apiAdapter: new AutomobileApiAdapter(apiService) }; }</p>
</code></pre></div><div class="page-content"><h3>Angular Style Guide References</h3>

<ul><li>Factory functions are a recognized Angular pattern for complex object creation</li>
<p><li>The Provider pattern (<code class="inline">useFactory</code> with <code class="inline">deps</code>) is documented in Angular DI guide</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 607.1: Create the Domain Config File</h3>

<p>Create the file that assembles the complete automobile domain configuration.</p>

<p>Create <code class="inline">src/app/domain-config/automobile/automobile.domain-config.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/automobile.domain-config.ts

<p>/**</p>
 <ul><li>Automobile Domain Configuration</li>
</ul> *
 <ul><li>Complete domain configuration combining all models, adapters, and UI configs</li>
</ul> <ul><li>from milestones D1-D4.</li>
</ul> */

<p>import { Injector } from '@angular/core'; import { DomainConfig } from '../../framework/models'; import { ApiService } from '../../framework/services'; import { environment } from '../../environments/environment'; import { AutoSearchFilters, VehicleResult, VehicleStatistics } from './models'; import { AutomobileApiAdapter, AutomobileUrlMapper, AutomobileCacheKeyBuilder } from './adapters'; import { AUTOMOBILE_TABLE_CONFIG, AUTOMOBILE_FILTER_DEFINITIONS, AUTOMOBILE_QUERY_CONTROL_FILTERS, AUTOMOBILE_HIGHLIGHT_FILTERS, AUTOMOBILE_CHART_CONFIGS, createAutomobilePickerConfigs } from './configs'; import { ManufacturerChartDataSource, TopModelsChartDataSource, BodyClassChartDataSource, YearChartDataSource } from './chart-sources'; import { Provider } from '@angular/core'; import { DOMAIN_CONFIG } from '../../framework/services';</p>

<p>/**</p>
 <ul><li>Factory function to create Automobile Domain Configuration</li>
</ul> *
 <ul><li>This factory creates the domain configuration with properly injected dependencies.</li>
</ul> <ul><li>Must be called with Angular's Injector to resolve service dependencies.</li>
</ul> *
 <ul><li>@param injector - Angular injector for resolving dependencies</li>
</ul> <ul><li>@returns Complete automobile domain configuration</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li>// In app module</li>
</ul> <ul><li>providers: [</li>
</ul> <ul><li>  {</li>
</ul> <ul><li>    provide: DOMAIN_CONFIG,</li>
</ul> <ul><li>    useFactory: createAutomobileDomainConfig,</li>
</ul> <ul><li>    deps: [Injector]</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>]</li>
</ul> */
<p>export function createAutomobileDomainConfig(injector: Injector): DomainConfig&lt; AutoSearchFilters, VehicleResult, VehicleStatistics &gt; { const apiService = injector.get(ApiService); const apiBaseUrl = environment.apiBaseUrl;</p>

<p>return { // ==================== Identity ==================== domainName: 'automobile', domainLabel: 'Automobile Discovery', apiBaseUrl: apiBaseUrl,</p>

<p>// ==================== Type Models ==================== filterModel: AutoSearchFilters, dataModel: VehicleResult, statisticsModel: VehicleStatistics,</p>

<p>// ==================== Adapters ==================== apiAdapter: new AutomobileApiAdapter(apiService, apiBaseUrl), urlMapper: new AutomobileUrlMapper(), cacheKeyBuilder: new AutomobileCacheKeyBuilder(),</p>

<p>// ==================== UI Configuration ==================== tableConfig: AUTOMOBILE_TABLE_CONFIG, pickers: createAutomobilePickerConfigs(injector), filters: AUTOMOBILE_FILTER_DEFINITIONS, queryControlFilters: AUTOMOBILE_QUERY_CONTROL_FILTERS, highlightFilters: AUTOMOBILE_HIGHLIGHT_FILTERS, charts: AUTOMOBILE_CHART_CONFIGS, chartDataSources: { 'manufacturer': new ManufacturerChartDataSource(), 'top-models': new TopModelsChartDataSource(), 'body-class': new BodyClassChartDataSource(), 'year': new YearChartDataSource() },</p>

<p>// ==================== Feature Flags ==================== features: { // Required features highlights: true, popOuts: true, rowExpansion: true,</p>

<p>// Optional features statistics: true, export: true, columnManagement: true, statePersistence: true },</p>

<p>// ==================== Metadata ==================== metadata: { version: '1.0.0', description: 'Automobile vehicle discovery and analysis', author: 'Vvroom Development Team', createdAt: '2026-02-09', updatedAt: '2026-02-09' } }; }</p>

<p>/**</p>
 <ul><li>Angular dependency injection provider for Automobile Domain Configuration</li>
</ul> *
 <ul><li>Pre-configured provider that can be used directly in Angular module declarations</li>
</ul> <ul><li>to register the automobile domain configuration with the dependency injection container.</li>
</ul> *
 <ul><li>@constant {Provider} DOMAIN_PROVIDER</li>
</ul> <ul><li>@remarks</li>
</ul> <ul><li>This is an Angular Provider object that:</li>
</ul> <ul><li>- Provides the DOMAIN_CONFIG injection token</li>
</ul> <ul><li>- Uses a factory function to create the configuration instance</li>
</ul> <ul><li>- Automatically resolves the Injector dependency</li>
</ul> *
 <ul><li><strong>Usage in Module</strong>:</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>@NgModule({</li>
</ul> <ul><li>  providers: [DOMAIN_PROVIDER] // Add to any module</li>
</ul> <ul><li>})</li>
</ul> <ul><li>export class AppModule { }</li>
</ul> <em> <pre class="code-block text"><code> </em>
 <ul><li><strong>Internally</strong>:</li>
</ul> <ul><li>- provide: Points to the DOMAIN_CONFIG injection token</li>
</ul> <ul><li>- useFactory: References createAutomobileDomainConfig function</li>
</ul> <ul><li>- deps: Specifies that Injector should be injected into the factory</li>
</ul> *
 <ul><li>@see createAutomobileDomainConfig - The factory function that creates the configuration</li>
</ul> <ul><li>@see DomainConfig - The interface describing configuration structure</li>
</ul> <ul><li>@see DOMAIN_CONFIG - The injection token this provider uses</li>
</ul> */
<p>export const DOMAIN_PROVIDER: Provider = { provide: DOMAIN_CONFIG, useFactory: createAutomobileDomainConfig, deps: [Injector], };</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 607.2: Create the Barrel Export</h3>

<p>Create the index file that exports the domain config.</p>

<p>Create <code class="inline">src/app/domain-config/automobile/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domain-config/automobile/index.ts

<p>export * from './automobile.domain-config';</p>
</code></pre>

<hr>

<h3>Step 607.3: Understand the DomainConfig Structure</h3>

<p>The complete domain config has several sections:</p>

<p><strong>Identity:</strong></p>
<pre class="code-block typescript"><code>{
<p>domainName: 'automobile',      // URL-safe identifier domainLabel: 'Automobile Discovery',  // Human-readable name apiBaseUrl: 'http://...'       // API base URL from environment }</p>
</code></pre>

<p><strong>Type Models:</strong></p>
<pre class="code-block typescript"><code>{
<p>filterModel: AutoSearchFilters,    // Class reference for filter type dataModel: VehicleResult,          // Class reference for data type statisticsModel: VehicleStatistics // Class reference for stats type }</p>
</code></pre>

<p>These are class references (not instances) used for TypeScript type checking.</p>

<p><strong>Adapters:</strong></p>
<pre class="code-block typescript"><code>{
<p>apiAdapter: new AutomobileApiAdapter(apiService, apiBaseUrl), urlMapper: new AutomobileUrlMapper(), cacheKeyBuilder: new AutomobileCacheKeyBuilder() }</p>
</code></pre>

<p>These are instances created with dependencies.</p>

<p><strong>UI Configuration:</strong></p>
<pre class="code-block typescript"><code>{
<p>tableConfig: AUTOMOBILE_TABLE_CONFIG, pickers: createAutomobilePickerConfigs(injector), filters: AUTOMOBILE_FILTER_DEFINITIONS, queryControlFilters: AUTOMOBILE_QUERY_CONTROL_FILTERS, highlightFilters: AUTOMOBILE_HIGHLIGHT_FILTERS, charts: AUTOMOBILE_CHART_CONFIGS, chartDataSources: { /<em> ... </em>/ } }</p>
</code></pre>

<p><strong>Feature Flags:</strong></p>
<pre class="code-block typescript"><code>{
<p>features: { highlights: true,        // Enable highlight filters popOuts: true,           // Enable pop-out windows rowExpansion: true,      // Enable row expansion in table statistics: true,        // Enable statistics panel export: true,            // Enable data export columnManagement: true,  // Enable column visibility toggle statePersistence: true   // Enable state saving to localStorage } }</p>
</code></pre>

<p><strong>Metadata:</strong></p>
<pre class="code-block typescript"><code>{
<p>metadata: { version: '1.0.0', description: 'Automobile vehicle discovery and analysis', author: 'Vvroom Development Team', createdAt: '2026-02-09', updatedAt: '2026-02-09' } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 607.4: Understanding the Provider Pattern</h3>

<p>The <code class="inline">DOMAIN_PROVIDER</code> constant is an Angular Provider:</p>

<pre class="code-block typescript"><code>export const DOMAIN_PROVIDER: Provider = {
<p>provide: DOMAIN_CONFIG,           // Token to inject useFactory: createAutomobileDomainConfig,  // Factory function deps: [Injector],                 // Dependencies for factory };</p>
</code></pre>

<p>This is equivalent to:</p>

<pre class="code-block typescript"><code>@NgModule({
<p>providers: [ { provide: DOMAIN_CONFIG, useFactory: createAutomobileDomainConfig, deps: [Injector] } ] })</p>
</code></pre>

<p>But exported as a constant for reuse.</p>

<p><strong>How it works:</strong></p>

<ul><li>Angular sees <code class="inline">provide: DOMAIN_CONFIG</code></li>
<p><li>Angular calls <code class="inline">createAutomobileDomainConfig(injector)</code></li> <li>The factory returns the domain config object</li> <li>Any component/service can inject <code class="inline">DOMAIN_CONFIG</code> to get the config</li></p>
</ul>
<pre class="code-block typescript"><code>// In a component
<p>constructor(@Inject(DOMAIN_CONFIG) private config: DomainConfig&lt;...&gt;) { console.log(config.domainName); // 'automobile' }</p>
</code></pre>

<hr>

<h3>Step 607.5: Understanding Chart Data Sources Mapping</h3>

<p>The <code class="inline">chartDataSources</code> object maps dataSourceId to data source instances:</p>

<pre class="code-block typescript"><code>chartDataSources: {
<p>'manufacturer': new ManufacturerChartDataSource(), 'top-models': new TopModelsChartDataSource(), 'body-class': new BodyClassChartDataSource(), 'year': new YearChartDataSource() }</p>
</code></pre>

<p>This connects to chart configs from document 606:</p>

<pre class="code-block typescript"><code>// Chart config
<p>{ id: 'manufacturer-distribution', dataSourceId: 'manufacturer', ... }</p>

<p>// Resolution const dataSource = chartDataSources['manufacturer']; const traces = dataSource.transform(statistics);</p>
</code></pre>

<p><strong>Note:</strong> Chart data sources are implemented in Phase 7 (documents 651-654). This file references them but they don't exist yet. You'll create placeholder classes or add them after Phase 7.</p>

<hr>

<h3>Step 607.6: Understanding Feature Flags</h3>

<p>Feature flags enable/disable functionality without code changes:</p>

<pre class="code-block typescript"><code>features: {
<p>highlights: true,        // Show highlight filter options popOuts: true,           // Show "pop out" buttons on panels rowExpansion: true,      // Show expand button on table rows statistics: true,        // Show statistics panel export: true,            // Show export buttons columnManagement: true,  // Show column visibility menu statePersistence: true   // Save/restore table state }</p>
</code></pre>

<p>Components check these flags:</p>

<pre class="code-block typescript"><code>// In StatisticsPanelComponent
<p>&lt;div *ngIf="domainConfig.features.statistics"&gt; &lt;!-- Chart content --&gt; &lt;/div&gt;</p>

<p>// In TableComponent &lt;button *ngIf="domainConfig.features.export" (click)="exportCsv()"&gt; Export CSV &lt;/button&gt;</p>
</code></pre>

<p>This allows:</p>
<ul><li>A/B testing features</li>
<p><li>Disabling features for certain domains</li> <li>Progressive feature rollout</li></ul></p></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Verify Files Created</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/automobile.domain-config.ts
<p>$ ls -la src/app/domain-config/automobile/index.ts</p>
</code></pre>

<p>Expected: Both files exist.</p>

<h3>2. Verify TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/domain-config/automobile/automobile.domain-config.ts</p>
</code></pre>

<p>Expected: No compilation errors.</p>

<h3>3. Verify Exports</h3>

<pre class="code-block bash"><code>$ grep "^export" src/app/domain-config/automobile/automobile.domain-config.ts
</code></pre>

<p>Expected: Two exports (createAutomobileDomainConfig function, DOMAIN_PROVIDER constant)</p>

<h3>4. Verify Index Exports</h3>

<pre class="code-block bash"><code>$ cat src/app/domain-config/automobile/index.ts
</code></pre>

<p>Expected: <code class="inline">export * from './automobile.domain-config';</code></p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot find module './models'"</td> <td>Models barrel export missing</td> <td>Create models/index.ts with exports</td></p>
</tr>
<p><tr> <td>"Cannot find module './adapters'"</td> <td>Adapters barrel export missing</td> <td>Create adapters/index.ts with exports</td></p>
</tr>
<p><tr> <td>"Cannot find module './configs'"</td> <td>Configs barrel export missing</td> <td>Create configs/index.ts with exports</td></p>
</tr>
<p><tr> <td>"Cannot find module './chart-sources'"</td> <td>Chart sources not yet created</td> <td>Add after Phase 7 or create placeholder</td></p>
</tr>
<p><tr> <td>"DOMAIN_CONFIG is not a type"</td> <td>Injection token not imported</td> <td>Import DOMAIN_CONFIG from framework/services</td></p>
</tr>
<p><tr> <td>"Injector has no provider for ApiService"</td> <td>ApiService not provided</td> <td>Ensure ApiService is in root providers</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>The domain config is the integration point</strong> — All domain pieces connect through this one object</li>
<p><li><strong>Factory pattern enables dependency injection</strong> — Services are resolved at runtime, not import time</li> <li><strong>Feature flags provide runtime control</strong> — Enable/disable features without code changes</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domain-config/automobile/automobile.domain-config.ts</code> exists</li>
<p><li>[ ] <code class="inline">createAutomobileDomainConfig()</code> factory function is exported</li> <li>[ ] Factory receives Injector and resolves ApiService</li> <li>[ ] DomainConfig includes all sections: identity, models, adapters, UI config, features, metadata</li> <li>[ ] <code class="inline">DOMAIN_PROVIDER</code> constant is exported with correct provider shape</li> <li>[ ] <code class="inline">src/app/domain-config/automobile/index.ts</code> exports the domain config</li> <li>[ ] Chart data sources are mapped with correct keys matching dataSourceIds</li> <li>[ ] Feature flags include all required flags (highlights, popOuts, rowExpansion, statistics, export, columnManagement, statePersistence)</li> <li>[ ] File compiles without TypeScript errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">608-domain-providers.md</code> to create the domain providers registry that collects all domain configurations.</p></div></div>
    <div class="chapter" id="section-608">
        <div class="chapter-header">
            <div class="chapter-category">Domain Config</div>
            <h1>608: Domain Providers</h1>
        </div>
<div class="page-content"><h1>608: Domain Providers</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 607-domain-config-assembly <strong>Blocks:</strong> 906-app-config</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the purpose of a domain providers registry</li>
<p><li>Know how to add new domains to the application</li> <li>Recognize the pattern of collecting providers from multiple sources</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the domain providers file that exports an array of all domain configuration providers. This is the single point where all domains are registered for the application.</p>

<hr>

<h2>Why</h2>

<p>The vvroom application is designed to support multiple domains. While we only have automobiles now, the architecture anticipates:</p>

<ul><li>Agriculture (crops, yields, regions)</li>
<p><li>Chemistry (compounds, reactions)</li> <li>Physics (particles, experiments)</li> <li>Finance (stocks, portfolios)</li></p>
</ul>
<p>Each domain has its own <code class="inline">DOMAIN_PROVIDER</code>. The domain providers file collects them all:</p>

<pre class="code-block typescript"><code>// Without domain providers registry
<p>@NgModule({ providers: [ automobileDomainProvider, agricultureDomainProvider, chemistryDomainProvider, // ... manually list each one ] })</p>
</code></pre>

<pre class="code-block typescript"><code>// With domain providers registry
<p>import { DOMAIN_PROVIDERS } from '../domain-config/domain-providers';</p>

<p>@NgModule({ providers: [ ...DOMAIN_PROVIDERS  // Spread all domain providers ] })</p>
</code></pre>

<p>Benefits:</p>
<ul><li><strong>Single source of truth</strong> — All domains listed in one file</li>
<p><li><strong>Easy to add domains</strong> — Add one line to add a new domain</li> <li><strong>Clear inventory</strong> — Easy to see what domains exist</li></p>
</ul>
<h3>For Vvroom (Automobile Only)</h3>

<p>Since vvroom only has automobiles, the domain providers file is simple. But the pattern prepares for future expansion.</p>

<hr>

<h2>What</h2>

<h3>Step 608.1: Create the Domain Providers File</h3>

<p>Create the file that exports all domain providers.</p>

<p>Create <code class="inline">src/app/domain-config/domain-providers.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domain-config/domain-providers.ts

<p>import { Provider } from '@angular/core'; import { DOMAIN_PROVIDER as automobileDomainProvider } from './automobile';</p>

<p>/**</p>
 <ul><li>Array of all domain configuration providers.</li>
</ul> *
 <ul><li>Each domain should export a <code class="inline">DOMAIN_PROVIDER</code> that can be added to this array.</li>
</ul> <ul><li>This allows for dynamic registration of domains at application startup.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>// Add a new domain</li>
</ul> <ul><li>import { DOMAIN_PROVIDER as newDomainProvider } from './new-domain';</li>
</ul> *
 <ul><li>export const DOMAIN_PROVIDERS: Provider[] = [</li>
</ul> <ul><li>  automobileDomainProvider,</li>
</ul> <ul><li>  newDomainProvider</li>
</ul> <ul><li>];</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export const DOMAIN_PROVIDERS: Provider[] = [ automobileDomainProvider, ];</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 608.2: Understand the Provider Array Pattern</h3>

<p>The <code class="inline">DOMAIN_PROVIDERS</code> array is a collection of Angular Provider objects:</p>

<pre class="code-block typescript"><code>// Each item is a Provider
<p>const automobileDomainProvider: Provider = { provide: DOMAIN_CONFIG, useFactory: createAutomobileDomainConfig, deps: [Injector] };</p>

<p>// The array collects all providers export const DOMAIN_PROVIDERS: Provider[] = [ automobileDomainProvider, // future: agricultureDomainProvider, // future: chemistryDomainProvider, ];</p>
</code></pre>

<p>When used in a module:</p>

<pre class="code-block typescript"><code>@NgModule({
<p>providers: [ ...DOMAIN_PROVIDERS  // Spreads all providers into the module ] })</p>
</code></pre>

<p>This is equivalent to:</p>

<pre class="code-block typescript"><code>@NgModule({
<p>providers: [ { provide: DOMAIN_CONFIG, useFactory: createAutomobileDomainConfig, deps: [Injector] } // All other domain providers... ] })</p>
</code></pre>

<hr>

<h3>Step 608.3: Understanding Single vs Multi Providers</h3>

<p>Currently, <code class="inline">DOMAIN_PROVIDERS</code> contains one provider. In a multi-domain app, you might want the <code class="inline">DOMAIN_CONFIG</code> token to provide multiple configs.</p>

<p>Angular supports this with <code class="inline">multi: true</code>:</p>

<pre class="code-block typescript"><code>// Single provider (current approach)
<p>{ provide: DOMAIN_CONFIG, useFactory: createAutomobileDomainConfig, deps: [Injector] }</p>

<p>// Multi-provider (for multiple domains) { provide: DOMAIN_CONFIG, useFactory: createAutomobileDomainConfig, deps: [Injector], multi: true }, { provide: DOMAIN_CONFIG, useFactory: createAgricultureDomainConfig, deps: [Injector], multi: true }</p>
</code></pre>

<p>With <code class="inline">multi: true</code>, injecting <code class="inline">DOMAIN_CONFIG</code> provides an array:</p>

<pre class="code-block typescript"><code>constructor(@Inject(DOMAIN_CONFIG) private configs: DomainConfig[]) {
<p>// configs is an array of all registered domain configs }</p>
</code></pre>

<p>For vvroom, we use single providers because we only have one domain. The pattern is established for future expansion.</p>

<hr>

<h3>Step 608.4: Understanding the Import Pattern</h3>

<p>Note the import pattern:</p>

<pre class="code-block typescript"><code>import { DOMAIN_PROVIDER as automobileDomainProvider } from './automobile';
</code></pre>

<p>Each domain exports a <code class="inline">DOMAIN_PROVIDER</code>. We rename them on import to avoid conflicts:</p>

<pre class="code-block typescript"><code>// If we had multiple domains:
<p>import { DOMAIN_PROVIDER as automobileDomainProvider } from './automobile'; import { DOMAIN_PROVIDER as agricultureDomainProvider } from './agriculture'; import { DOMAIN_PROVIDER as chemistryDomainProvider } from './chemistry';</p>

<p>export const DOMAIN_PROVIDERS: Provider[] = [ automobileDomainProvider, agricultureDomainProvider, chemistryDomainProvider, ];</p>
</code></pre>

<p>The <code class="inline">as</code> keyword prevents naming conflicts when all domains export the same <code class="inline">DOMAIN_PROVIDER</code> name.</p></div><div class="page-content"><hr>

<h3>Step 608.5: Understanding Usage in App Config</h3>

<p>The domain providers are used in the application configuration:</p>

<pre class="code-block typescript"><code>// src/app/app.config.ts (document 906)
<p>import { DOMAIN_PROVIDERS } from '../domain-config/domain-providers';</p>

<p>export const appConfig: ApplicationConfig = { providers: [ provideRouter(routes), provideHttpClient(), ...DOMAIN_PROVIDERS,  // Register all domain configs ] };</p>
</code></pre>

<p>This makes the domain configuration available throughout the application via dependency injection.</p>

<hr>

<h3>Step 608.6: Adding a New Domain (Future)</h3>

<p>To add a new domain in the future, you would:</p>

<ul><li>Create the domain directory: <code class="inline">src/app/domain-config/new-domain/</code></li>
<p><li>Implement models, adapters, and configs (Phases 4-6 for new domain)</li> <li>Export <code class="inline">DOMAIN_PROVIDER</code> from <code class="inline">new-domain/index.ts</code></li> <li>Add to domain-providers.ts:</li></p>
</ul>
<pre class="code-block typescript"><code>import { DOMAIN_PROVIDER as automobileDomainProvider } from './automobile';
<p>import { DOMAIN_PROVIDER as newDomainProvider } from './new-domain';</p>

<p>export const DOMAIN_PROVIDERS: Provider[] = [ automobileDomainProvider, newDomainProvider,  // Add new domain ];</p>
</code></pre>

<ul><li>Add routes for the new domain in <code class="inline">app.routes.ts</code></li>
</ul>
<p>That's it. No changes to framework code.</p>

<hr>

<h2>Verification</h2>

<h3>1. Verify File Created</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/domain-providers.ts
</code></pre>

<p>Expected: File exists.</p>

<h3>2. Verify TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npx tsc --noEmit src/app/domain-config/domain-providers.ts</p>
</code></pre>

<p>Expected: No compilation errors.</p>

<h3>3. Verify Export</h3>

<pre class="code-block bash"><code>$ grep "^export const DOMAIN_PROVIDERS" src/app/domain-config/domain-providers.ts
</code></pre>

<p>Expected: <code class="inline">export const DOMAIN_PROVIDERS: Provider[] = [</code></p>

<h3>4. Verify Provider Count</h3>

<pre class="code-block bash"><code>$ grep -c "DomainProvider" src/app/domain-config/domain-providers.ts
</code></pre>

<p>Expected: <code class="inline">1</code> (automobileDomainProvider only)</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot find module './automobile'"</td> <td>Barrel export missing</td> <td>Ensure automobile/index.ts exists and exports DOMAIN_PROVIDER</td></p>
</tr>
<p><tr> <td>"DOMAIN_PROVIDER is not exported"</td> <td>Export missing from domain config</td> <td>Add <code class="inline">export const DOMAIN_PROVIDER</code> to automobile.domain-config.ts</td></p>
</tr>
<p><tr> <td>"Provider[] is not a type"</td> <td>Missing import</td> <td>Add <code class="inline">import { Provider } from '@angular/core';</code></td></p>
</tr>
<p><tr> <td>Circular dependency error</td> <td>Domain imports from framework that imports domain</td> <td>Check import paths; domain should only import from framework</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Domain providers registry centralizes registration</strong> — One file lists all domain providers</li>
<p><li><strong>The pattern scales to multiple domains</strong> — Add imports and array entries to add domains</li> <li><strong>Framework code remains unchanged</strong> — New domains only require domain-config changes</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/domain-config/domain-providers.ts</code> exists</li>
<p><li>[ ] File imports <code class="inline">DOMAIN_PROVIDER</code> from automobile domain</li> <li>[ ] <code class="inline">DOMAIN_PROVIDERS</code> array is exported</li> <li>[ ] Array contains automobile domain provider</li> <li>[ ] Documentation comments explain the pattern</li> <li>[ ] Example shows how to add new domains</li> <li>[ ] File compiles without TypeScript errors</li></p>
</ul>
<hr>

<h2>Phase 6 Checkpoint</h2>

<p>Congratulations! You have completed Phase 6: Automobile Domain Configs.</p>

<p><strong>What you created:</strong></p>
<table>
<p><thead><tr> <th>Document</th> <th>File</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td>601</td> <td>automobile.filter-definitions.ts</td> <td>Query panel filter controls</td></p>
</tr>
<p><tr> <td>602</td> <td>automobile.table-config.ts</td> <td>Results table columns and behavior</td></p>
</tr>
<p><tr> <td>603</td> <td>automobile.picker-configs.ts</td> <td>Manufacturer-model picker</td></p>
</tr>
<p><tr> <td>604</td> <td>automobile.query-control-filters.ts</td> <td>Add filter dialog definitions</td></p>
</tr>
<p><tr> <td>605</td> <td>automobile.highlight-filters.ts</td> <td>Chart segmentation filters</td></p>
</tr>
<p><tr> <td>606</td> <td>automobile.chart-configs.ts</td> <td>Statistics panel charts</td></p>
</tr>
<p><tr> <td>607</td> <td>automobile.domain-config.ts</td> <td>Assembly of all domain pieces</td></p>
</tr>
<p><tr> <td>608</td> <td>domain-providers.ts</td> <td>Domain registration</td></p>
</tr>
</tbody>
</table>

<p><strong>The Phase 6 Aha Moment:</strong></p>

<p>&gt; "Configuration is declarative code. You describe what you want, not how to get it."</p>

<p>You defined filters, tables, pickers, and charts using configuration objects. The framework components (which you'll build in Phase 8) will interpret these configurations to generate the actual UI.</p>

<p><strong>What's next:</strong></p>

<ul><li>Phase 7: Chart Data Sources (documents 651-654) — Transform statistics into Plotly trace format</li>
<p><li>Phase 8: Framework Components (documents 801-809) — Build the generic UI components</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">651-manufacturer-chart-source.md</code> to implement the first chart data source.</p></div></div>
    <div class="chapter" id="section-651">
        <div class="chapter-header">
            <div class="chapter-category">Chart Sources</div>
            <h1>651: Manufacturer Chart Source</h1>
        </div>
<div class="page-content"><h1>651: Manufacturer Chart Source</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 403-automobile-statistics-model, 606-chart-configs <strong>Blocks:</strong> 801-base-chart-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how chart data sources transform domain statistics into visualization-ready formats</li>
<p><li>Know how to implement the abstract <code class="inline">ChartDataSource</code> class for a specific data type</li> <li>Be able to handle both simple and segmented (highlighted) statistics in chart transformations</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the manufacturer chart data source that transforms vehicle statistics into a Plotly.js vertical stacked bar chart showing vehicle count by manufacturer. This chart source handles both simple counts and segmented statistics (with highlighted vs. non-highlighted data).</p>

<hr>

<h2>Why</h2>

<p>Charts are one of the most powerful ways to communicate data insights. However, raw statistics from an API rarely match the exact format that charting libraries expect. We need a transformation layer between our domain data and our visualization library.</p>

<p><strong>The Chart Data Source Pattern:</strong></p>

<pre class="code-block text"><code>VehicleStatistics  →  ManufacturerChartDataSource  →  Plotly Chart Data
<p>(domain)              (transformer)                 (visualization)</p>
</code></pre>

<p>This separation provides several benefits:</p>

<ul><li><strong>Single Responsibility</strong> — The chart component handles rendering; the data source handles transformation</li>
<p><li><strong>Testability</strong> — Data transformations can be unit tested without rendering actual charts</li> <li><strong>Reusability</strong> — The same <code class="inline">BaseChartComponent</code> works with any data source</li> <li><strong>Flexibility</strong> — Changing the chart appearance only requires modifying the data source, not the component</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>Chart sources connect to the URL-First pattern through click handling. When a user clicks a bar in the manufacturer chart, the data source converts that click into URL parameters (e.g., <code class="inline">manufacturer=Toyota</code>), which then updates the URL and triggers a new data fetch. This creates an interactive filtering experience where charts become navigation controls.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 651.1: Create the Manufacturer Chart Source File</h3>

<p>Create the file <code class="inline">src/app/domain-config/automobile/chart-sources/manufacturer-chart-source.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/chart-sources/manufacturer-chart-source.ts

<p>/**</p>
 <ul><li>Manufacturer Chart Data Source</li>
</ul> *
 <ul><li>Transforms vehicle statistics into Plotly.js vertical stacked bar chart</li>
</ul> <ul><li>showing vehicle count by manufacturer with highlighted vs other.</li>
</ul> *
 <ul><li>Domain: Automobile</li>
</ul> */

<p>import { ChartDataSource, ChartData } from '../../../framework/components/base-chart/base-chart.component'; import { VehicleStatistics } from '../models/automobile.statistics';</p>

<p>/**</p>
 <ul><li>Manufacturer distribution chart data source</li>
</ul> *
 <ul><li>Creates a vertical stacked bar chart of manufacturers by vehicle count.</li>
</ul> <ul><li>Matches the visual style from the reference application.</li>
</ul> */
<p>export class ManufacturerChartDataSource extends ChartDataSource&lt;VehicleStatistics&gt; { /**</p>
   <ul><li>Transform statistics into Plotly chart data</li>
</ul>   */
<p>transform( statistics: VehicleStatistics | null, highlights: any, _selectedValue: string | null, _containerWidth: number ): ChartData | null { if (!statistics || !statistics.byManufacturer) { return null; }</p>

<p>const entries = Object.entries(statistics.byManufacturer);</p>

<p>// Check if data has server-side segmented format ({total, highlighted}) const isSegmented = entries.length &gt; 0 &amp;&amp; typeof entries[0][1] === 'object' &amp;&amp; 'total' in entries[0][1];</p>

<p>let traces: Plotly.Data[] = [];</p>

<p>if (isSegmented) { // Server-side segmented statistics: use backend data directly const sorted = entries .sort((a, b) =&gt; { const aTotal = (a[1] as any).total || 0; const bTotal = (b[1] as any).total || 0; return bTotal - aTotal; }) .slice(0, 20);</p>

<p>const manufacturers = sorted.map(([name]) =&gt; name); const highlightedCounts = sorted.map(([, stats]: [string, any]) =&gt; stats.highlighted || 0); const otherCounts = sorted.map(([, stats]: [string, any]) =&gt; (stats.total || 0) - (stats.highlighted || 0) );</p>

<p>// Create stacked bar traces (Highlighted first at bottom, then Other on top) traces = [ { type: 'bar', name: 'Highlighted', x: manufacturers, y: highlightedCounts, marker: { color: '#3B82F6' }, // Blue hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Highlighted: %{y}&lt;extra&gt;&lt;/extra&gt;' }, { type: 'bar', name: 'Other', x: manufacturers, y: otherCounts, marker: { color: '#9CA3AF' }, // Gray hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Other: %{y}&lt;extra&gt;&lt;/extra&gt;' } ]; } else { // No highlights: simple blue bars using simple number format const sorted = entries .map(([name, count]) =&gt; [name, typeof count === 'number' ? count : 0] as [string, number]) .sort((a, b) =&gt; b[1] - a[1]) .slice(0, 20);</p>

<p>const manufacturers = sorted.map(([name]) =&gt; name); const counts = sorted.map(([, count]) =&gt; count);</p>

<p>traces = [{ type: 'bar', x: manufacturers, y: counts, marker: { color: '#3B82F6' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Count: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;' }]; }</p>

<p>// Create layout const layout: Partial&lt;Plotly.Layout&gt; = { barmode: isSegmented ? 'stack' : undefined, xaxis: { tickangle: -45, automargin: true, color: '#FFFFFF', gridcolor: '#333333' }, yaxis: { title: { text: '' }, gridcolor: '#333333', automargin: true, color: '#FFFFFF' }, margin: { l: 60, r: 40, t: 40, b: 120 }, plot_bgcolor: '#000000', paper_bgcolor: '#1a1a1a', font: { color: '#FFFFFF' }, showlegend: isSegmented };</p>

<p>return { traces: traces, layout: layout }; }</p>

<p>/**</p>
   <ul><li>Get chart title</li>
</ul>   */
<p>getTitle(): string { return 'Vehicles by Manufacturer'; }</p>

<p>/**</p>
   <ul><li>Handle chart click event</li>
</ul>   *
   <ul><li>Supports both single-click and box selection.</li>
</ul>   <ul><li>Returns comma-separated manufacturers for OR filtering.</li>
</ul>   <ul><li>Backend API supports comma-separated values.</li>
</ul>   */
<p>handleClick(event: any): string | null { if (event.points &amp;&amp; event.points.length &gt; 0) { // Extract all manufacturer names from selected points const manufacturers: string[] = event.points.map((point: any) =&gt; point.x as string);</p>

<p>// Remove duplicates (box selection may select both stacked bars) const uniqueManufacturers: string[] = [...new Set(manufacturers)];</p>

<p>// Return comma-separated list (backend supports OR logic) return uniqueManufacturers.join(',') || null; } return null; }</p>

<p>/**</p>
   <ul><li>Convert clicked value to URL parameters</li>
</ul>   */
<p>toUrlParams(value: string, isHighlightMode: boolean): Record&lt;string, any&gt; { const paramName = isHighlightMode ? 'h_manufacturer' : 'manufacturer'; return { [paramName]: value }; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 651.2: Understanding the Transform Method</h3>

<p>The <code class="inline">transform</code> method is the heart of any chart data source. Let's break down its logic:</p>

<p><strong>Input Parameters:</strong></p>

<table>
<p><thead><tr> <th>Parameter</th> <th>Type</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">statistics</code></td> <td><code class="inline">VehicleStatistics \</td> <td>null</code></td> <td>Domain statistics from the API</td></p>
</tr>
<p><tr> <td><code class="inline">highlights</code></td> <td><code class="inline">any</code></td> <td>Highlight filter state (for visual distinction)</td></p>
</tr>
<p><tr> <td><code class="inline">_selectedValue</code></td> <td><code class="inline">string \</td> <td>null</code></td> <td>Currently selected value (for active state)</td></p>
</tr>
<p><tr> <td><code class="inline">_containerWidth</code></td> <td><code class="inline">number</code></td> <td>Container width for responsive sizing</td></p>
</tr>
</tbody>
</table>

<p><strong>Null Check:</strong></p>

<pre class="code-block typescript"><code>if (!statistics || !statistics.byManufacturer) {
<p>return null; }</p>
</code></pre>

<p>If statistics are missing or the <code class="inline">byManufacturer</code> property is absent, return <code class="inline">null</code>. The chart component will handle this gracefully by showing an empty state.</p>

<p><strong>Segmentation Detection:</strong></p>

<pre class="code-block typescript"><code>const isSegmented = entries.length &gt; 0 &amp;&amp;
<p>typeof entries[0][1] === 'object' &amp;&amp; 'total' in entries[0][1];</p>
</code></pre>

<p>The API can return manufacturer data in two formats:</p>

<ul><li><strong>Simple format:</strong> <code class="inline">{ "Toyota": 234, "Honda": 187 }</code> — just counts</li>
<p><li><strong>Segmented format:</strong> <code class="inline">{ "Toyota": { total: 234, highlighted: 45 }, ... }</code> — with highlight breakdown</li></p>
</ul>
<p>We detect which format we have by checking if the first value is an object with a <code class="inline">total</code> property.</p>

<hr>

<h3>Step 651.3: Understanding the Trace Structure</h3>

<p>Plotly charts use "traces" — each trace is a data series. For the segmented case, we create two traces:</p>

<pre class="code-block typescript"><code>traces = [
<p>{ type: 'bar', name: 'Highlighted', x: manufacturers,       // Category labels on X axis y: highlightedCounts,   // Values on Y axis marker: { color: '#3B82F6' },  // Blue color hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Highlighted: %{y}&lt;extra&gt;&lt;/extra&gt;' }, { type: 'bar', name: 'Other', x: manufacturers, y: otherCounts, marker: { color: '#9CA3AF' },  // Gray color hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Other: %{y}&lt;extra&gt;&lt;/extra&gt;' } ];</p>
</code></pre>

<p><strong>Why Two Traces?</strong></p>

<p>When highlight filters are active, we want to show how much of each manufacturer's data matches the highlight criteria. The blue "Highlighted" bars show matching data; the gray "Other" bars show non-matching data. Stacking them shows the total while distinguishing the segments.</p>

<p><strong>The Hover Template:</strong></p>

<pre class="code-block text"><code>&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Highlighted: %{y}&lt;extra&gt;&lt;/extra&gt;
</code></pre>

<ul><li><code class="inline">&lt;b&gt;%{x}&lt;/b&gt;</code> — Bold manufacturer name</li>
<p><li><code class="inline">&lt;br&gt;</code> — Line break</li> <li><code class="inline">Highlighted: %{y}</code> — Label and value</li> <li><code class="inline">&lt;extra&gt;&lt;/extra&gt;</code> — Hides the trace name (which would otherwise appear)</li></ul></p></div><div class="page-content"><hr>

<h3>Step 651.4: Understanding URL Parameter Mapping</h3>

<p>The <code class="inline">toUrlParams</code> method converts a clicked chart value into URL query parameters:</p>

<pre class="code-block typescript"><code>toUrlParams(value: string, isHighlightMode: boolean): Record&lt;string, any&gt; {
<p>const paramName = isHighlightMode ? 'h_manufacturer' : 'manufacturer'; return { [paramName]: value }; }</p>
</code></pre>

<p><strong>Filter Mode vs Highlight Mode:</strong></p>

<ul><li><strong>Filter mode</strong> (default): Click filters the dataset → <code class="inline">manufacturer=Toyota</code></li>
<p><li><strong>Highlight mode</strong> (h key held): Click adds a highlight → <code class="inline">h_manufacturer=Toyota</code></li></p>
</ul>
<p>This dual-mode interaction follows the URL-First pattern: user actions translate directly to URL changes.</p>

<hr>

<h2>Verification</h2>

<h3>1. TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. File Location</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/chart-sources/
</code></pre>

<p>Expected:</p>

<pre class="code-block text"><code>-rw-r--r-- 1 user user  4567 Feb  9 17:00 manufacturer-chart-source.ts
</code></pre>

<h3>3. Export Check</h3>

<p>Once the chart configs are updated (document 606), verify the class is importable:</p>

<pre class="code-block typescript"><code>import { ManufacturerChartDataSource } from './chart-sources/manufacturer-chart-source';
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module '../../../framework/components/base-chart/base-chart.component'</code></td> <td>BaseChartComponent not yet created</td> <td>This is expected until Phase 8 (document 801)</td></p>
</tr>
<p><tr> <td><code class="inline">Cannot find module '../models/automobile.statistics'</code></td> <td>VehicleStatistics not created</td> <td>Complete document 403 first</td></p>
</tr>
<p><tr> <td><code class="inline">Property 'byManufacturer' does not exist on type 'VehicleStatistics'</code></td> <td>Missing property in statistics model</td> <td>Add <code class="inline">byManufacturer</code> property to VehicleStatistics</td></p>
</tr>
<p><tr> <td>TypeScript error on <code class="inline">Plotly.Data</code></td> <td>Plotly types not installed</td> <td>Run <code class="inline">npm install --save-dev @types/plotly.js</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Chart data sources are transformers</strong> — They convert domain data into visualization-ready formats</li>
<p><li><strong>Handle both simple and segmented data</strong> — Statistics can come in multiple formats; check dynamically</li> <li><strong>URL parameters enable interactivity</strong> — Clicks on charts become filter or highlight URL changes</li></ul></p></div><div class="page-content"><hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] File exists at <code class="inline">src/app/domain-config/automobile/chart-sources/manufacturer-chart-source.ts</code></li>
<p><li>[ ] Class <code class="inline">ManufacturerChartDataSource</code> extends <code class="inline">ChartDataSource&lt;VehicleStatistics&gt;</code></li> <li>[ ] <code class="inline">transform</code> method handles both simple and segmented statistics</li> <li>[ ] <code class="inline">getTitle</code> returns <code class="inline">'Vehicles by Manufacturer'</code></li> <li>[ ] <code class="inline">handleClick</code> extracts manufacturer names from Plotly click events</li> <li>[ ] <code class="inline">toUrlParams</code> maps values to <code class="inline">manufacturer</code> or <code class="inline">h_manufacturer</code> parameters</li> <li>[ ] Code compiles without TypeScript errors (after dependencies are created)</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">652-year-chart-source.md</code> to create the year distribution chart source.</p></div></div>
    <div class="chapter" id="section-652">
        <div class="chapter-header">
            <div class="chapter-category">Chart Sources</div>
            <h1>652: Year Chart Source</h1>
        </div>
<div class="page-content"><h1>652: Year Chart Source</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 403-automobile-statistics-model, 651-manufacturer-chart-source <strong>Blocks:</strong> 801-base-chart-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to handle time-series data in chart transformations</li>
<p><li>Know how to implement range selection for year-based filtering</li> <li>Be able to convert multi-value selections into URL parameters</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the year chart data source that transforms vehicle statistics into a Plotly.js bar chart showing vehicle distribution over time. This chart source handles year-based data and supports both single-year clicks and range selections.</p>

<hr>

<h2>Why</h2>

<p>Time-series data presents unique visualization and interaction challenges:</p>

<ul><li><strong>Chronological ordering</strong> — Years must be sorted ascending (oldest to newest), unlike other charts that sort by count</li>
<p><li><strong>Range selection</strong> — Users often want to filter by a range of years, not just a single year</li> <li><strong>Different URL parameter format</strong> — Year ranges require two parameters (<code class="inline">yearMin</code> and <code class="inline">yearMax</code>) instead of one</li></p>
</ul>
<p>The year chart demonstrates how a single abstract interface (<code class="inline">ChartDataSource</code>) can accommodate domain-specific requirements through concrete implementations.</p>

<h3>Design Decision: Bar Chart for Years</h3>

<p>While line charts are common for time series, we use a bar chart for years because:</p>

<ul><li><strong>Discrete values</strong> — Vehicle model years are discrete integers, not continuous data</li>
<p><li><strong>Highlight support</strong> — Stacked bars clearly show highlighted vs. non-highlighted segments</li> <li><strong>Consistency</strong> — Matches the visual style of other charts in the application</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>The year chart implements range selection by returning a pipe-delimited string (<code class="inline">2010|2020</code>) from <code class="inline">handleClick</code>, which <code class="inline">toUrlParams</code> then splits into separate <code class="inline">yearMin</code> and <code class="inline">yearMax</code> parameters. This demonstrates how chart sources can produce complex URL structures from simple user interactions.</p>

<hr>

<h2>What</h2>

<h3>Step 652.1: Create the Year Chart Source File</h3>

<p>Create the file <code class="inline">src/app/domain-config/automobile/chart-sources/year-chart-source.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/chart-sources/year-chart-source.ts

<p>/**</p>
 <ul><li>Year Chart Data Source</li>
</ul> *
 <ul><li>Transforms vehicle statistics into Plotly.js line chart</li>
</ul> <ul><li>showing vehicle distribution over time.</li>
</ul> *
 <ul><li>Domain: Automobile</li>
</ul> */

<p>import { ChartDataSource, ChartData } from '../../../framework/components/base-chart/base-chart.component'; import { VehicleStatistics } from '../models/automobile.statistics';</p>

<p>/**</p>
 <ul><li>Year distribution chart data source</li>
</ul> *
 <ul><li>Creates a line chart showing vehicle count by year.</li>
</ul> */
<p>export class YearChartDataSource extends ChartDataSource&lt;VehicleStatistics&gt; { /**</p>
   <ul><li>Transform statistics into Plotly chart data</li>
</ul>   */
<p>transform( statistics: VehicleStatistics | null, _highlights: any, _selectedValue: string | null, _containerWidth: number ): ChartData | null { if (!statistics || !statistics.byYearRange) { return null; }</p>

<p>const entries = Object.entries(statistics.byYearRange);</p>

<p>// Check if data has server-side segmented format ({total, highlighted}) const isSegmented = entries.length &gt; 0 &amp;&amp; typeof entries[0][1] === 'object' &amp;&amp; 'total' in entries[0][1];</p>

<p>let traces: Plotly.Data[] = [];</p>

<p>if (isSegmented) { // Server-side segmented statistics: use backend data directly const sorted = entries .sort((a, b) =&gt; parseInt(a[0], 10) - parseInt(b[0], 10)); // Sort by year ascending</p>

<p>const years = sorted.map(([year]) =&gt; year); const highlightedCounts = sorted.map(([, stats]: [string, any]) =&gt; stats.highlighted || 0); const otherCounts = sorted.map(([, stats]: [string, any]) =&gt; (stats.total || 0) - (stats.highlighted || 0) );</p>

<p>// Create stacked bar traces (Highlighted first at bottom, then Other on top) traces = [ { type: 'bar', name: 'Highlighted', x: years, y: highlightedCounts, marker: { color: '#3B82F6' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Highlighted: %{y}&lt;extra&gt;&lt;/extra&gt;' }, { type: 'bar', name: 'Other', x: years, y: otherCounts, marker: { color: '#9CA3AF' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Other: %{y}&lt;extra&gt;&lt;/extra&gt;' } ]; } else { // No highlights: simple blue bars using simple number format const sorted = entries .map(([year, count]) =&gt; [year, typeof count === 'number' ? count : 0] as [string, number]) .sort((a, b) =&gt; parseInt(a[0], 10) - parseInt(b[0], 10));</p>

<p>const years = sorted.map(([year]) =&gt; year); const counts = sorted.map(([, count]) =&gt; count);</p>

<p>traces = [{ type: 'bar', x: years, y: counts, marker: { color: '#3B82F6' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Count: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;' }]; }</p>

<p>// Create layout const layout: Partial&lt;Plotly.Layout&gt; = { barmode: isSegmented ? 'stack' : undefined, xaxis: { title: { text: '' }, gridcolor: '#333333', type: 'category', color: '#FFFFFF' }, yaxis: { title: { text: '' }, gridcolor: '#333333', rangemode: 'tozero', automargin: true, color: '#FFFFFF' }, margin: { l: 60, r: 40, t: 40, b: 60 }, plot_bgcolor: '#000000', paper_bgcolor: '#1a1a1a', font: { color: '#FFFFFF' }, showlegend: isSegmented };</p>

<p>return { traces: traces, layout: layout }; }</p>

<p>/**</p>
   <ul><li>Get chart title</li>
</ul>   */
<p>getTitle(): string { return 'Vehicles by Year'; }</p>

<p>/**</p>
   <ul><li>Handle chart click event</li>
</ul>   *
   <ul><li>Supports both single-click and box selection.</li>
</ul>   <ul><li>For box selection, returns year range as "min|max".</li>
</ul>   */
<p>handleClick(event: any): string | null { if (event.points &amp;&amp; event.points.length &gt; 0) { // Extract all years from selected points const years: number[] = event.points.map((point: any) =&gt; parseInt(point.x, 10));</p>

<p>// Remove duplicates (box selection may select both stacked bars) const uniqueYears: number[] = [...new Set(years)].sort((a, b) =&gt; a - b);</p>

<p>if (uniqueYears.length === 1) { // Single year selected return uniqueYears[0].toString(); } else { // Multiple years: return as range min|max const min = uniqueYears[0]; const max = uniqueYears[uniqueYears.length - 1]; return <code class="inline">${min}|${max}</code>; } } return null; }</p>

<p>/**</p>
   <ul><li>Convert clicked value to URL parameters</li>
</ul>   *
   <ul><li>Handles both single year and year range (min|max format).</li>
</ul>   */
<p>toUrlParams(value: string, isHighlightMode: boolean): Record&lt;string, any&gt; { if (value.includes('|')) { // Year range: split into min/max params const [min, max] = value.split('|'); return isHighlightMode ? { h_yearMin: min, h_yearMax: max } : { yearMin: min, yearMax: max }; } // Single year const paramName = isHighlightMode ? 'h_year' : 'year'; return { [paramName]: value }; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 652.2: Understanding Chronological Sorting</h3>

<p>Unlike the manufacturer chart (which sorts by count descending), the year chart sorts chronologically:</p>

<pre class="code-block typescript"><code>const sorted = entries
<p>.sort((a, b) =&gt; parseInt(a[0], 10) - parseInt(b[0], 10)); // Sort by year ascending</p>
</code></pre>

<p><strong>Why ascending order?</strong></p>

<p>Time flows forward. Users expect to see older years on the left and newer years on the right. This matches mental models of timelines and makes trends (growth or decline over time) immediately visible.</p>

<hr>

<h3>Step 652.3: Understanding Category Type for X-Axis</h3>

<p>Notice the layout configuration for the x-axis:</p>

<pre class="code-block typescript"><code>xaxis: {
<p>title: { text: '' }, gridcolor: '#333333', type: 'category',  // Treat years as categories, not numbers color: '#FFFFFF' }</p>
</code></pre>

<p><strong>Why <code class="inline">type: 'category'</code>?</strong></p>

<p>Without this setting, Plotly would treat years as continuous numbers and might:</p>
<ul><li>Add decimal ticks (2015.5)</li>
<p><li>Create gaps for missing years</li> <li>Misalign bars with labels</li></p>
</ul>
<p>By specifying <code class="inline">type: 'category'</code>, each year becomes a discrete label with evenly spaced bars.</p>

<hr>

<h3>Step 652.4: Understanding Range Selection</h3>

<p>The <code class="inline">handleClick</code> method demonstrates sophisticated selection handling:</p>

<pre class="code-block typescript"><code>handleClick(event: any): string | null {
<p>if (event.points &amp;&amp; event.points.length &gt; 0) { // Extract all years from selected points const years: number[] = event.points.map((point: any) =&gt; parseInt(point.x, 10));</p>

<p>// Remove duplicates (box selection may select both stacked bars) const uniqueYears: number[] = [...new Set(years)].sort((a, b) =&gt; a - b);</p>

<p>if (uniqueYears.length === 1) { // Single year selected return uniqueYears[0].toString(); } else { // Multiple years: return as range min|max const min = uniqueYears[0]; const max = uniqueYears[uniqueYears.length - 1]; return <code class="inline">${min}|${max}</code>; } } return null; }</p>
</code></pre>

<p><strong>Single Click vs Box Selection:</strong></p>

<table>
<p><thead><tr> <th>Selection Type</th> <th>Points Array</th> <th>Return Value</th></p>
</tr></thead>
<p><tbody> <tr> <td>Single click on 2020</td> <td><code class="inline">[{x: '2020'}]</code></td> <td><code class="inline">'2020'</code></td></p>
</tr>
<p><tr> <td>Box select 2015-2020</td> <td><code class="inline">[{x: '2015'}, {x: '2016'}, ...]</code></td> <td><code class="inline">'2015</td> <td>2020'</code></td></p>
</tr>
</tbody>
</table>

<p><strong>Duplicate Removal:</strong></p>

<p>When a stacked bar chart has box selection, clicking might return the same year twice (once for each trace). Using <code class="inline">[...new Set(years)]</code> ensures each year appears only once.</p></div><div class="page-content"><hr>

<h3>Step 652.5: Understanding URL Parameter Conversion</h3>

<p>The <code class="inline">toUrlParams</code> method handles both formats:</p>

<pre class="code-block typescript"><code>toUrlParams(value: string, isHighlightMode: boolean): Record&lt;string, any&gt; {
<p>if (value.includes('|')) { // Year range: split into min/max params const [min, max] = value.split('|'); return isHighlightMode ? { h_yearMin: min, h_yearMax: max } : { yearMin: min, yearMax: max }; } // Single year const paramName = isHighlightMode ? 'h_year' : 'year'; return { [paramName]: value }; }</p>
</code></pre>

<p><strong>URL Examples:</strong></p>

<table>
<p><thead><tr> <th>User Action</th> <th>Return Value</th> <th>URL Parameters</th></p>
</tr></thead>
<p><tbody> <tr> <td>Click 2020</td> <td><code class="inline">'2020'</code></td> <td><code class="inline">?year=2020</code></td></p>
</tr>
<p><tr> <td>Click 2020 (highlight mode)</td> <td><code class="inline">'2020'</code></td> <td><code class="inline">?h_year=2020</code></td></p>
</tr>
<p><tr> <td>Box select 2015-2020</td> <td><code class="inline">'2015</td> <td>2020'</code></td> <td><code class="inline">?yearMin=2015&amp;yearMax=2020</code></td></p>
</tr>
<p><tr> <td>Box select 2015-2020 (highlight mode)</td> <td><code class="inline">'2015</td> <td>2020'</code></td> <td><code class="inline">?h_yearMin=2015&amp;h_yearMax=2020</code></td></p>
</tr>
</tbody>
</table>

<p>This demonstrates how a single abstract method can produce varied URL structures based on the interaction pattern.</p>

<hr>

<h2>Verification</h2>

<h3>1. TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. File Location</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/chart-sources/
</code></pre>

<p>Expected:</p>

<pre class="code-block text"><code>-rw-r--r-- 1 user user  4567 Feb  9 17:00 manufacturer-chart-source.ts
<p>-rw-r--r-- 1 user user  4123 Feb  9 17:05 year-chart-source.ts</p>
</code></pre>

<h3>3. Sorting Verification</h3>

<p>Mentally trace through the code with sample data:</p>

<pre class="code-block typescript"><code>// Input (unsorted):
<p>byYearRange: { "2022": 50, "2020": 100, "2021": 75 }</p>

<p>// After sorting: // years = ["2020", "2021", "2022"] // counts = [100, 75, 50]</p>
</code></pre>

<p>The chart will show 2020 on the left with 100 vehicles, progressing to 2022 on the right with 50.</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Years appear in random order</td> <td>Missing or incorrect sort</td> <td>Verify <code class="inline">parseInt(a[0], 10) - parseInt(b[0], 10)</code> sorts ascending</td></p>
</tr>
<p><tr> <td>Decimal year labels (2020.5)</td> <td>X-axis type not set to category</td> <td>Add <code class="inline">type: 'category'</code> to xaxis config</td></p>
</tr>
<p><tr> <td>Range selection returns duplicates</td> <td>Missing duplicate removal</td> <td>Ensure <code class="inline">[...new Set(years)]</code> is present</td></p>
</tr>
<p><tr> <td><code class="inline">yearMin=2020&amp;yearMax=2020</code> for single click</td> <td>Pipe split on non-pipe string</td> <td>Check for <code class="inline"></td> <td></code> before splitting</td></p>
</tr>
<p><tr> <td><code class="inline">Cannot find module '../models/automobile.statistics'</code></td> <td>VehicleStatistics not created</td> <td>Complete document 403 first</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Time data requires chronological sorting</strong> — Unlike counts, years have an inherent order that users expect</li>
<p><li><strong>Range selections need special handling</strong> — Convert multi-point selections into min/max pairs</li> <li><strong>URL parameters can be polymorphic</strong> — The same method produces single or multi-parameter outputs based on input</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] File exists at <code class="inline">src/app/domain-config/automobile/chart-sources/year-chart-source.ts</code></li>
<p><li>[ ] Class <code class="inline">YearChartDataSource</code> extends <code class="inline">ChartDataSource&lt;VehicleStatistics&gt;</code></li> <li>[ ] Years are sorted chronologically (ascending) in the chart</li> <li>[ ] X-axis uses category type for discrete year labels</li> <li>[ ] <code class="inline">handleClick</code> returns single year or <code class="inline">min|max</code> format for ranges</li> <li>[ ] <code class="inline">toUrlParams</code> handles both single year and range formats</li> <li>[ ] Highlight mode produces <code class="inline">h_year</code>, <code class="inline">h_yearMin</code>, <code class="inline">h_yearMax</code> parameters</li> <li>[ ] Code compiles without TypeScript errors (after dependencies are created)</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">653-body-class-chart-source.md</code> to create the body class distribution chart source.</p></div></div>
    <div class="chapter" id="section-653">
        <div class="chapter-header">
            <div class="chapter-category">Chart Sources</div>
            <h1>653: Body Class Chart Source</h1>
        </div>
<div class="page-content"><h1>653: Body Class Chart Source</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 403-automobile-statistics-model, 652-year-chart-source <strong>Blocks:</strong> 801-base-chart-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to maintain unused code for future flexibility (color mappings)</li>
<p><li>Know how to implement multi-value selection for categorical data</li> <li>Recognize patterns that repeat across chart sources and opportunities for refactoring</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the body class chart data source that transforms vehicle statistics into a Plotly.js bar chart showing distribution by body class (Sedan, SUV, Truck, etc.). This chart source handles categorical data and supports comma-separated multi-selection.</p>

<hr>

<h2>Why</h2>

<p>Body class represents a categorical dimension of vehicle data. Unlike manufacturers (which can number in the dozens) or years (which span decades), body classes form a small, fixed set of categories. This affects our design choices:</p>

<ul><li><strong>Color scheme preparation</strong> — Although we currently use uniform blue bars, we define a color mapping for potential future use (e.g., distinct colors per body class)</li>
<p><li><strong>Full display</strong> — We show all body classes rather than limiting to "top 20" since the set is naturally small</li> <li><strong>Descending count sort</strong> — Like manufacturers, we sort by count (most common body classes first)</li></p>
</ul>
<h3>Design Decision: Bar Chart Over Pie Chart</h3>

<p>The original file comment mentions "pie chart," but the implementation uses a bar chart. Why?</p>

<ul><li><strong>Comparison accuracy</strong> — Humans judge bar heights more accurately than pie slice angles</li>
<p><li><strong>Highlight support</strong> — Stacked bars work better than segmented pie slices for showing highlighted vs. non-highlighted data</li> <li><strong>Consistency</strong> — Matches the visual style of manufacturer and year charts</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>Body class filtering uses comma-separated values for OR logic: <code class="inline">bodyClass=Sedan,SUV</code> matches vehicles that are either Sedans OR SUVs. This supports intuitive multi-selection where clicking multiple bars expands rather than narrows the result set.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 653.1: Create the Body Class Chart Source File</h3>

<p>Create the file <code class="inline">src/app/domain-config/automobile/chart-sources/body-class-chart-source.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/chart-sources/body-class-chart-source.ts

<p>/**</p>
 <ul><li>Body Class Chart Data Source</li>
</ul> *
 <ul><li>Transforms vehicle statistics into Plotly.js pie chart</li>
</ul> <ul><li>showing distribution by body class.</li>
</ul> *
 <ul><li>Domain: Automobile</li>
</ul> */

<p>import { ChartDataSource, ChartData } from '../../../framework/components/base-chart/base-chart.component'; import { VehicleStatistics } from '../models/automobile.statistics';</p>

<p>/**</p>
 <ul><li>Body class distribution chart data source</li>
</ul> *
 <ul><li>Creates a pie chart showing vehicle distribution by body class.</li>
</ul> */
<p>export class BodyClassChartDataSource extends ChartDataSource&lt;VehicleStatistics&gt; { /**</p>
   <ul><li>Color scheme for body classes</li>
</ul>   */
<p>private readonly BODY_CLASS_COLORS: Record&lt;string, string&gt; = { 'Sedan': '#3B82F6', 'SUV': '#10B981', 'Truck': '#F59E0B', 'Pickup': '#F59E0B', 'Coupe': '#EF4444', 'Wagon': '#8B5CF6', 'Van': '#EC4899', 'Minivan': '#06B6D4', 'Convertible': '#84CC16', 'Hatchback': '#F97316' };</p>

<p>/**</p>
   <ul><li>Transform statistics into Plotly chart data</li>
</ul>   */
<p>transform( statistics: VehicleStatistics | null, _highlights: any, _selectedValue: string | null, _containerWidth: number ): ChartData | null { if (!statistics || !statistics.byBodyClass) { return null; }</p>

<p>const entries = Object.entries(statistics.byBodyClass);</p>

<p>// Check if data has server-side segmented format ({total, highlighted}) const isSegmented = entries.length &gt; 0 &amp;&amp; typeof entries[0][1] === 'object' &amp;&amp; 'total' in entries[0][1];</p>

<p>let traces: Plotly.Data[] = [];</p>

<p>if (isSegmented) { // Server-side segmented statistics: use backend data directly const sorted = entries .sort((a, b) =&gt; { const aTotal = (a[1] as any).total || 0; const bTotal = (b[1] as any).total || 0; return bTotal - aTotal; });</p>

<p>const labels = sorted.map(([name]) =&gt; name); const highlightedCounts = sorted.map(([, stats]: [string, any]) =&gt; stats.highlighted || 0); const otherCounts = sorted.map(([, stats]: [string, any]) =&gt; (stats.total || 0) - (stats.highlighted || 0) );</p>

<p>// Create stacked bar traces (Highlighted first at bottom, then Other on top) traces = [ { type: 'bar', name: 'Highlighted', x: labels, y: highlightedCounts, marker: { color: '#3B82F6' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Highlighted: %{y}&lt;extra&gt;&lt;/extra&gt;' }, { type: 'bar', name: 'Other', x: labels, y: otherCounts, marker: { color: '#9CA3AF' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Other: %{y}&lt;extra&gt;&lt;/extra&gt;' } ]; } else { // No highlights: simple blue bars using simple number format const sorted = entries .map(([name, count]) =&gt; [name, typeof count === 'number' ? count : 0] as [string, number]) .sort((a, b) =&gt; b[1] - a[1]);</p>

<p>const labels = sorted.map(([name]) =&gt; name); const counts = sorted.map(([, count]) =&gt; count);</p>

<p>traces = [{ type: 'bar', x: labels, y: counts, marker: { color: '#3B82F6' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Count: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;' }]; }</p>

<p>// Create layout const layout: Partial&lt;Plotly.Layout&gt; = { barmode: isSegmented ? 'stack' : undefined, xaxis: { tickangle: -45, automargin: true, color: '#FFFFFF', gridcolor: '#333333' }, yaxis: { title: { text: '' }, gridcolor: '#333333', automargin: true, color: '#FFFFFF' }, margin: { l: 60, r: 40, t: 40, b: 100 }, plot_bgcolor: '#000000', paper_bgcolor: '#1a1a1a', font: { color: '#FFFFFF' }, showlegend: isSegmented };</p>

<p>return { traces: traces, layout: layout }; }</p>

<p>/**</p>
   <ul><li>Get chart title</li>
</ul>   */
<p>getTitle(): string { return 'Vehicles by Body Class'; }</p>

<p>/**</p>
   <ul><li>Handle chart click event</li>
</ul>   *
   <ul><li>Supports both single-click and box selection.</li>
</ul>   <ul><li>Returns comma-separated body classes for OR filtering.</li>
</ul>   <ul><li>Backend API v1.0.1+ supports comma-separated values.</li>
</ul>   */
<p>handleClick(event: any): string | null { if (event.points &amp;&amp; event.points.length &gt; 0) { // Extract all body class names from selected points const bodyClasses: string[] = event.points.map((point: any) =&gt; point.x as string);</p>

<p>// Remove duplicates (box selection may select both stacked bars) const uniqueBodyClasses: string[] = [...new Set(bodyClasses)];</p>

<p>// Return comma-separated list (backend supports OR logic as of v1.0.1) return uniqueBodyClasses.join(',') || null; } return null; }</p>

<p>/**</p>
   <ul><li>Convert clicked value to URL parameters</li>
</ul>   */
<p>toUrlParams(value: string, isHighlightMode: boolean): Record&lt;string, any&gt; { const paramName = isHighlightMode ? 'h_bodyClass' : 'bodyClass'; return { [paramName]: value }; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 653.2: Understanding the Color Scheme</h3>

<p>Notice the unused <code class="inline">BODY_CLASS_COLORS</code> property:</p>

<pre class="code-block typescript"><code>private readonly BODY_CLASS_COLORS: Record&lt;string, string&gt; = {
<p>'Sedan': '#3B82F6', 'SUV': '#10B981', 'Truck': '#F59E0B', 'Pickup': '#F59E0B', 'Coupe': '#EF4444', 'Wagon': '#8B5CF6', 'Van': '#EC4899', 'Minivan': '#06B6D4', 'Convertible': '#84CC16', 'Hatchback': '#F97316' };</p>
</code></pre>

<p><strong>Why include unused code?</strong></p>

<p>This is a deliberate design choice. The color mapping:</p>

<ul><li><strong>Documents intent</strong> — Shows that distinct colors per body class were considered</li>
<p><li><strong>Enables future enhancement</strong> — Can be activated without research into appropriate colors</li> <li><strong>Provides consistency</strong> — Truck and Pickup share the same orange (#F59E0B), indicating semantic similarity</li></p>
</ul>
<p>Currently, the code uses uniform blue bars for consistency with other charts. The color scheme remains available for future features like:</p>
<ul><li>Color-coded bars when highlights are not active</li>
<p><li>Legend entries matching body class colors</li> <li>Tooltips with color indicators</li></p>
</ul>
<hr>

<h3>Step 653.3: Comparing Chart Sources</h3>

<p>By now, you may notice similarities between chart sources. Let's compare:</p>

<table>
<p><thead><tr> <th>Aspect</th> <th>Manufacturer</th> <th>Year</th> <th>Body Class</th></p>
</tr></thead>
<p><tbody> <tr> <td>Data property</td> <td><code class="inline">byManufacturer</code></td> <td><code class="inline">byYearRange</code></td> <td><code class="inline">byBodyClass</code></td></p>
</tr>
<p><tr> <td>Sort order</td> <td>Count descending</td> <td>Year ascending</td> <td>Count descending</td></p>
</tr>
<p><tr> <td>Limit</td> <td>Top 20</td> <td>All</td> <td>All</td></p>
</tr>
<p><tr> <td>X-axis labels</td> <td>Angled (-45)</td> <td>Normal</td> <td>Angled (-45)</td></p>
</tr>
<p><tr> <td>Bottom margin</td> <td>120px</td> <td>60px</td> <td>100px</td></p>
</tr>
<p><tr> <td>URL parameter</td> <td><code class="inline">manufacturer</code></td> <td><code class="inline">year</code>/<code class="inline">yearMin</code>/<code class="inline">yearMax</code></td> <td><code class="inline">bodyClass</code></td></p>
</tr>
</tbody>
</table>

<p><strong>Patterns to Notice:</strong></p>

<ul><li><strong>Same structure</strong> — All three follow the same <code class="inline">transform</code> → <code class="inline">getTitle</code> → <code class="inline">handleClick</code> → <code class="inline">toUrlParams</code> pattern</li>
<p><li><strong>Same segmentation logic</strong> — The <code class="inline">isSegmented</code> check is identical</li> <li><strong>Same trace structure</strong> — Blue for highlighted, gray for other</li></p>
</ul>
<p><strong>Why not abstract further?</strong></p>

<p>You might be tempted to create a generic chart source factory. Resist this urge initially:</p>

<ul><li><strong>Explicit is better than implicit</strong> — Each file is self-contained and understandable</li>
<p><li><strong>Customization is easy</strong> — Modifying one chart doesn't risk breaking others</li> <li><strong>Patterns emerge naturally</strong> — After building several, refactoring opportunities become clear</li></p>
</ul>
<p>The fourth chart source (Top Models) will show a more complex case that would break a simple abstraction.</p></div><div class="page-content"><hr>

<h3>Step 653.4: Understanding Bottom Margin Differences</h3>

<p>Notice the different bottom margins:</p>

<pre class="code-block typescript"><code>// Manufacturer chart
<p>margin: { l: 60, r: 40, t: 40, b: 120 }</p>

<p>// Year chart margin: { l: 60, r: 40, t: 40, b: 60 }</p>

<p>// Body class chart margin: { l: 60, r: 40, t: 40, b: 100 }</p>
</code></pre>

<p><strong>Why the differences?</strong></p>

<ul><li><strong>Manufacturer (120px)</strong> — Long names like "Mercedes-Benz" need more space when angled</li>
<p><li><strong>Year (60px)</strong> — 4-digit years are short; no angling needed</li> <li><strong>Body Class (100px)</strong> — Medium-length names like "Convertible" need moderate space</li></p>
</ul>
<p>These seemingly minor details significantly affect chart readability. When labels overlap or get cut off, users lose information.</p>

<hr>

<h2>Verification</h2>

<h3>1. TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. File Location</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/chart-sources/
</code></pre>

<p>Expected:</p>

<pre class="code-block text"><code>-rw-r--r-- 1 user user  4567 Feb  9 17:00 manufacturer-chart-source.ts
<p>-rw-r--r-- 1 user user  4123 Feb  9 17:05 year-chart-source.ts -rw-r--r-- 1 user user  4234 Feb  9 17:10 body-class-chart-source.ts</p>
</code></pre>

<h3>3. Color Scheme Verification</h3>

<p>Verify the color scheme covers expected body classes:</p>

<pre class="code-block bash"><code>$ grep -c "'" src/app/domain-config/automobile/chart-sources/body-class-chart-source.ts
</code></pre>

<p>Expected: Multiple single quotes indicating the color mapping entries.</p>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Labels cut off at bottom</td> <td>Margin too small</td> <td>Increase <code class="inline">b</code> (bottom) margin value</td></p>
</tr>
<p><tr> <td>"Pickup" and "Truck" have same color</td> <td>Intentional design</td> <td>These are semantically similar categories</td></p>
</tr>
<p><tr> <td>Color scheme not applied</td> <td>Code uses uniform blue</td> <td>The color scheme is for future use; current implementation uses blue</td></p>
</tr>
<p><tr> <td>Multi-selection returns duplicates</td> <td>Missing <code class="inline">Set</code> deduplication</td> <td>Ensure <code class="inline">[...new Set(bodyClasses)]</code> is present</td></p>
</tr>
<p><tr> <td><code class="inline">Cannot find module '../models/automobile.statistics'</code></td> <td>VehicleStatistics not created</td> <td>Complete document 403 first</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Unused code can be intentional</strong> — Color schemes document design decisions for future enhancement</li>
<p><li><strong>Small sets need different treatment</strong> — No "top 20" limit needed for naturally small categories</li> <li><strong>Margins matter for readability</strong> — Adjust bottom margins based on label length and angle</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] File exists at <code class="inline">src/app/domain-config/automobile/chart-sources/body-class-chart-source.ts</code></li>
<p><li>[ ] Class <code class="inline">BodyClassChartDataSource</code> extends <code class="inline">ChartDataSource&lt;VehicleStatistics&gt;</code></li> <li>[ ] Color scheme defined for common body classes (even if not currently used)</li> <li>[ ] Body classes sorted by count descending</li> <li>[ ] <code class="inline">handleClick</code> returns comma-separated body class names</li> <li>[ ] <code class="inline">toUrlParams</code> maps values to <code class="inline">bodyClass</code> or <code class="inline">h_bodyClass</code> parameters</li> <li>[ ] Code compiles without TypeScript errors (after dependencies are created)</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">654-top-models-chart-source.md</code> to create the top models chart source, which demonstrates more complex data transformation.</p></div></div>
    <div class="chapter" id="section-654">
        <div class="chapter-header">
            <div class="chapter-category">Chart Sources</div>
            <h1>654: Top Models Chart Source</h1>
        </div>
<div class="page-content"><h1>654: Top Models Chart Source</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 403-automobile-statistics-model, 653-body-class-chart-source <strong>Blocks:</strong> 801-base-chart-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to transform nested data structures for visualization</li>
<p><li>Know how to implement composite URL parameters from chart clicks</li> <li>Be able to handle data from multiple API response formats</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Create the top models chart data source that transforms vehicle statistics into a Plotly.js bar chart showing the top models by VIN instance count. This chart source handles nested data structures (<code class="inline">modelsByManufacturer</code>) and produces composite URL parameters (<code class="inline">manufacturer:model</code> format).</p>

<hr>

<h2>Why</h2>

<p>The top models chart presents unique challenges that the previous chart sources did not:</p>

<ul><li><strong>Nested data structure</strong> — Models are nested within manufacturers in the API response</li>
<p><li><strong>Composite labels</strong> — Each bar shows "Manufacturer Model" (e.g., "Toyota Camry")</li> <li><strong>Composite URL parameters</strong> — Clicking produces <code class="inline">modelCombos=Toyota:Camry</code>, not separate parameters</li> <li><strong>Two data sources</strong> — Can use either <code class="inline">topModels</code> array or <code class="inline">modelsByManufacturer</code> object</li></p>
</ul>
<p>This complexity demonstrates why we keep chart sources as separate classes rather than abstracting too aggressively. Each chart source handles its unique requirements while maintaining the same interface.</p>

<h3>Design Decision: Combined Manufacturer-Model Format</h3>

<p>When a user clicks on a model bar, we need to filter by both manufacturer AND model. We combine these into a single URL parameter using colon separator:</p>

<pre class="code-block text"><code>?modelCombos=Toyota:Camry
</code></pre>

<p>This approach:</p>
<ul><li><strong>Avoids ambiguity</strong> — "Camry" alone could match multiple manufacturers if the API had duplicates</li>
<p><li><strong>Supports multi-select</strong> — <code class="inline">modelCombos=Toyota:Camry,Honda:Accord</code> selects multiple models</li> <li><strong>Matches API expectations</strong> — The backend parses this format for efficient filtering</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>The top models chart shows how chart sources can produce complex URL structures. The <code class="inline">handleClick</code> method transforms display format ("Toyota Camry") to URL format ("Toyota:Camry"), demonstrating that chart sources aren't just data transformers but also interaction translators.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 654.1: Create the Top Models Chart Source File</h3>

<p>Create the file <code class="inline">src/app/domain-config/automobile/chart-sources/top-models-chart-source.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/domain-config/automobile/chart-sources/top-models-chart-source.ts

<p>/**</p>
 <ul><li>Top Models Chart Data Source</li>
</ul> *
 <ul><li>Transforms vehicle statistics into Plotly.js horizontal bar chart</li>
</ul> <ul><li>showing top models by VIN instance count.</li>
</ul> *
 <ul><li>Domain: Automobile</li>
</ul> */

<p>import { ChartDataSource, ChartData } from '../../../framework/components/base-chart/base-chart.component'; import { VehicleStatistics } from '../models/automobile.statistics';</p>

<p>/**</p>
 <ul><li>Top models chart data source</li>
</ul> *
 <ul><li>Creates a horizontal bar chart of top models by VIN instance count.</li>
</ul> */
<p>export class TopModelsChartDataSource extends ChartDataSource&lt;VehicleStatistics&gt; { /**</p>
   <ul><li>Transform statistics into Plotly chart data</li>
</ul>   */
<p>transform( statistics: VehicleStatistics | null, _highlights: any, _selectedValue: string | null, _containerWidth: number ): ChartData | null { if (!statistics || !statistics.topModels || statistics.topModels.length === 0) { return null; }</p>

<p>// Check if we have segmented statistics from API (with total/highlighted counts) const hasSegmentedStats = statistics.modelsByManufacturer &amp;&amp; Object.values(statistics.modelsByManufacturer).some(models =&gt; typeof models === 'object' &amp;&amp; Object.values(models).some(v =&gt; typeof v === 'object' &amp;&amp; 'total' in v ) );</p>

<p>let traces: any[] = [];</p>

<p>if (hasSegmentedStats &amp;&amp; statistics.modelsByManufacturer) { // Use API's segmented statistics with {total, highlighted} const modelEntries: Array&lt;[string, any]&gt; = [];</p>

<p>Object.entries(statistics.modelsByManufacturer).forEach(([manufacturer, models]) =&gt; { Object.entries(models).forEach(([modelName, stats]) =&gt; { modelEntries.push([<code class="inline">${manufacturer} ${modelName}</code>, stats]); }); });</p>

<p>// Sort by total count descending and take top 20 const sorted = modelEntries .sort((a, b) =&gt; ((b[1] as any).total || 0) - ((a[1] as any).total || 0)) .slice(0, 20);</p>

<p>const modelLabels = sorted.map(([label]) =&gt; label); const highlightedCounts = sorted.map(([, stats]: [string, any]) =&gt; stats.highlighted || 0); const otherCounts = sorted.map(([, stats]: [string, any]) =&gt; (stats.total || 0) - (stats.highlighted || 0) );</p>

<p>// Create stacked bar traces (Highlighted first at bottom, then Other on top) traces = [ { type: 'bar', name: 'Highlighted', x: modelLabels, y: highlightedCounts, marker: { color: '#3B82F6' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Highlighted: %{y}&lt;extra&gt;&lt;/extra&gt;' }, { type: 'bar', name: 'Other', x: modelLabels, y: otherCounts, marker: { color: '#9CA3AF' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Other: %{y}&lt;extra&gt;&lt;/extra&gt;' } ]; } else { // Fallback: simple blue bars using topModels const topModels = statistics.topModels.slice(0, 20); const modelLabels = topModels.map(m =&gt; <code class="inline">${m.manufacturer} ${m.name}</code>); const counts = topModels.map(m =&gt; m.instanceCount);</p>

<p>traces = [{ type: 'bar', x: modelLabels, y: counts, marker: { color: '#3B82F6' }, hovertemplate: '&lt;b&gt;%{x}&lt;/b&gt;&lt;br&gt;Count: %{y}&lt;br&gt;&lt;extra&gt;&lt;/extra&gt;' }]; }</p>

<p>// Create layout const layout: Partial&lt;any&gt; = { barmode: hasSegmentedStats ? 'stack' : undefined, xaxis: { tickangle: -45, automargin: true, color: '#FFFFFF', gridcolor: '#333333' }, yaxis: { title: '', gridcolor: '#333333', automargin: true, color: '#FFFFFF' }, margin: { l: 60, r: 40, t: 40, b: 140 }, plot_bgcolor: '#000000', paper_bgcolor: '#1a1a1a', font: { color: '#FFFFFF' }, showlegend: hasSegmentedStats };</p>

<p>return { traces: traces, layout: layout }; }</p>

<p>/**</p>
   <ul><li>Get chart title</li>
</ul>   */
<p>getTitle(): string { return 'Top Models by VIN Count'; }</p>

<p>/**</p>
   <ul><li>Handle chart click event</li>
</ul>   *
   <ul><li>Supports both single-click and box selection.</li>
</ul>   <ul><li>For box selection, returns comma-separated list of unique models.</li>
</ul>   <ul><li>Converts label format from "Manufacturer Model" to "Manufacturer:Model".</li>
</ul>   */
<p>handleClick(event: any): string | null { if (event.points &amp;&amp; event.points.length &gt; 0) { // Extract all model labels from selected points (format: "Manufacturer Model") const modelLabels: string[] = event.points.map((point: any) =&gt; point.x as string);</p>

<p>// Remove duplicates (box selection may select both stacked bars) const uniqueLabels = [...new Set(modelLabels)];</p>

<p>// Convert from "Manufacturer Model" to "Manufacturer:Model" format const modelCombos = uniqueLabels.map(label =&gt; { // Replace first space with colon (manufacturer doesn't have spaces) return label.replace(' ', ':'); });</p>

<p>// Return comma-separated list (or single value) return modelCombos.join(','); } return null; }</p>

<p>/**</p>
   <ul><li>Convert clicked value to URL parameters</li>
</ul>   */
<p>toUrlParams(value: string, isHighlightMode: boolean): Record&lt;string, any&gt; { const paramName = isHighlightMode ? 'h_modelCombos' : 'modelCombos'; return { [paramName]: value }; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 654.2: Understanding Nested Data Transformation</h3>

<p>The top models chart handles a more complex data structure:</p>

<pre class="code-block typescript"><code>// Statistics structure
<p>{ modelsByManufacturer: { "Toyota": { "Camry": { total: 234, highlighted: 45 }, "Corolla": { total: 189, highlighted: 32 } }, "Honda": { "Accord": { total: 156, highlighted: 28 }, "Civic": { total: 145, highlighted: 21 } } } }</p>
</code></pre>

<p>The transformation flattens this nested structure:</p>

<pre class="code-block typescript"><code>Object.entries(statistics.modelsByManufacturer).forEach(([manufacturer, models]) =&gt; {
<p>Object.entries(models).forEach(([modelName, stats]) =&gt; { modelEntries.push([<code class="inline">${manufacturer} ${modelName}</code>, stats]); }); });</p>
</code></pre>

<p><strong>Result:</strong></p>

<pre class="code-block typescript"><code>modelEntries = [
<p>["Toyota Camry", { total: 234, highlighted: 45 }], ["Toyota Corolla", { total: 189, highlighted: 32 }], ["Honda Accord", { total: 156, highlighted: 28 }], ["Honda Civic", { total: 145, highlighted: 21 }] ]</p>
</code></pre>

<p>This creates a flat array suitable for sorting and slicing to get the top 20.</p>

<hr>

<h3>Step 654.3: Understanding Dual Data Source Fallback</h3>

<p>Notice the two code paths:</p>

<pre class="code-block typescript"><code>if (hasSegmentedStats &amp;&amp; statistics.modelsByManufacturer) {
<p>// Use nested structure with highlight support } else { // Fallback: use topModels array const topModels = statistics.topModels.slice(0, 20); const modelLabels = topModels.map(m =&gt; <code class="inline">${m.manufacturer} ${m.name}</code>); const counts = topModels.map(m =&gt; m.instanceCount); }</p>
</code></pre>

<p><strong>Why two approaches?</strong></p>

<p>The API can return model data in two formats:</p>

<ul><li><strong>Segmented format</strong> (<code class="inline">modelsByManufacturer</code>) — Has highlight counts, needs flattening</li>
<p><li><strong>Array format</strong> (<code class="inline">topModels</code>) — Pre-sorted array, simpler to use but no highlight data</li></p>
</ul>
<p>The segmented format is preferred when available (for highlight support), but the fallback ensures the chart works with simpler API responses.</p>

<hr>

<h3>Step 654.4: Understanding Label Format Conversion</h3>

<p>The click handler converts display format to URL format:</p>

<pre class="code-block typescript"><code>// Convert from "Manufacturer Model" to "Manufacturer:Model" format
<p>const modelCombos = uniqueLabels.map(label =&gt; { // Replace first space with colon (manufacturer doesn't have spaces) return label.replace(' ', ':'); });</p>
</code></pre>

<p><strong>Why this conversion?</strong></p>

<table>
<p><thead><tr> <th>Format</th> <th>Purpose</th> <th>Example</th></p>
</tr></thead>
<p><tbody> <tr> <td>Display</td> <td>Human-readable chart labels</td> <td>"Toyota Camry"</td></p>
</tr>
<p><tr> <td>URL</td> <td>Machine-parseable parameter</td> <td>"Toyota:Camry"</td></p>
</tr>
</tbody>
</table>

<p>The colon separator enables the backend to split the value and query by both manufacturer AND model efficiently.</p>

<p><strong>Edge Case: Multi-Word Models</strong></p>

<p>Consider "Ford Mustang Mach-E":</p>

<pre class="code-block typescript"><code>"Ford Mustang Mach-E".replace(' ', ':')
<p>// Result: "Ford:Mustang Mach-E"</p>
</code></pre>

<p>The first space becomes a colon, preserving "Mustang Mach-E" as the model name. This works because manufacturer names in this dataset don't contain spaces.</p></div><div class="page-content"><hr>

<h3>Step 654.5: Understanding the Larger Bottom Margin</h3>

<p>The top models chart uses the largest bottom margin:</p>

<pre class="code-block typescript"><code>margin: {
<p>l: 60, r: 40, t: 40, b: 140  // Largest of all charts }</p>
</code></pre>

<p><strong>Why 140px?</strong></p>

<p>Model labels are the longest of any chart:</p>
<ul><li>"Toyota Camry" — Short</li>
<p><li>"Mercedes-Benz S-Class" — Medium</li> <li>"Lamborghini Aventador LP700-4" — Long</li></p>
</ul>
<p>When angled at -45 degrees, these long labels need substantial vertical space to remain readable without overlapping or being cut off.</p>

<hr>

<h3>Step 654.6: Understanding the Segmentation Check</h3>

<p>The segmentation check for top models is more complex:</p>

<pre class="code-block typescript"><code>const hasSegmentedStats = statistics.modelsByManufacturer &amp;&amp;
<p>Object.values(statistics.modelsByManufacturer).some(models =&gt; typeof models === 'object' &amp;&amp; Object.values(models).some(v =&gt; typeof v === 'object' &amp;&amp; 'total' in v ) );</p>
</code></pre>

<p><strong>Why so complex?</strong></p>

<p>Unlike <code class="inline">byManufacturer</code> (which is one level deep), <code class="inline">modelsByManufacturer</code> is two levels deep:</p>

<pre class="code-block text"><code>modelsByManufacturer → manufacturer → model → { total, highlighted }
</code></pre>

<p>We need to:</p>
<ul><li>Check that <code class="inline">modelsByManufacturer</code> exists</li>
<p><li>Check that at least one manufacturer has models</li> <li>Check that at least one model has the <code class="inline">{ total, highlighted }</code> structure</li></p>
</ul>
<p>This defensive checking prevents runtime errors when data is missing or in an unexpected format.</p>

<hr>

<h2>Verification</h2>

<h3>1. TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. File Location</h3>

<pre class="code-block bash"><code>$ ls -la src/app/domain-config/automobile/chart-sources/
</code></pre>

<p>Expected:</p>

<pre class="code-block text"><code>-rw-r--r-- 1 user user  4567 Feb  9 17:00 manufacturer-chart-source.ts
<p>-rw-r--r-- 1 user user  4123 Feb  9 17:05 year-chart-source.ts -rw-r--r-- 1 user user  4234 Feb  9 17:10 body-class-chart-source.ts -rw-r--r-- 1 user user  4789 Feb  9 17:15 top-models-chart-source.ts</p>
</code></pre>

<h3>3. Label Conversion Test</h3>

<p>Mentally trace the click handler:</p>

<pre class="code-block typescript"><code>// Input from Plotly click event
<p>event.points = [{ x: "Toyota Camry" }, { x: "Honda Accord" }]</p>

<p>// After processing // uniqueLabels = ["Toyota Camry", "Honda Accord"] // modelCombos = ["Toyota:Camry", "Honda:Accord"] // return value = "Toyota:Camry,Honda:Accord"</p>

<p>// URL parameter // ?modelCombos=Toyota:Camry,Honda:Accord</p>
</code></pre></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Chart shows no data</td> <td><code class="inline">topModels</code> array empty</td> <td>Verify API returns model data</td></p>
</tr>
<p><tr> <td>Labels show "undefined undefined"</td> <td>Missing manufacturer or name</td> <td>Check <code class="inline">topModels</code> array structure</td></p>
</tr>
<p><tr> <td>"Ford:Mustang:Mach-E" (two colons)</td> <td>Multiple <code class="inline">replace()</code> calls</td> <td>Use <code class="inline">replace(' ', ':')</code> not <code class="inline">replaceAll</code></td></p>
</tr>
<p><tr> <td>Segmentation not detected</td> <td>Nested check failing</td> <td>Verify <code class="inline">modelsByManufacturer</code> has expected structure</td></p>
</tr>
<p><tr> <td>Labels overlap</td> <td>Bottom margin too small</td> <td>Increase <code class="inline">b</code> value in margins</td></p>
</tr>
<p><tr> <td><code class="inline">Cannot find module '../models/automobile.statistics'</code></td> <td>VehicleStatistics not created</td> <td>Complete document 403 first</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Nested data requires flattening</strong> — Transform hierarchical API responses into flat arrays for charting</li>
<p><li><strong>Display format differs from URL format</strong> — Convert human-readable labels to machine-parseable parameters</li> <li><strong>Fallback data sources add resilience</strong> — Handle multiple API response formats gracefully</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] File exists at <code class="inline">src/app/domain-config/automobile/chart-sources/top-models-chart-source.ts</code></li>
<p><li>[ ] Class <code class="inline">TopModelsChartDataSource</code> extends <code class="inline">ChartDataSource&lt;VehicleStatistics&gt;</code></li> <li>[ ] Handles both <code class="inline">modelsByManufacturer</code> (segmented) and <code class="inline">topModels</code> (array) formats</li> <li>[ ] Labels show "Manufacturer Model" format (e.g., "Toyota Camry")</li> <li>[ ] <code class="inline">handleClick</code> converts to "Manufacturer:Model" format</li> <li>[ ] <code class="inline">toUrlParams</code> maps values to <code class="inline">modelCombos</code> or <code class="inline">h_modelCombos</code> parameters</li> <li>[ ] Bottom margin (140px) accommodates long model names</li> <li>[ ] Code compiles without TypeScript errors (after dependencies are created)</li></p>
</ul>
<hr>

<h2>Phase 7 Complete</h2>

<p>You have now completed all chart data sources for the automobile domain:</p>

<table>
<p><thead><tr> <th>Document</th> <th>Chart Source</th> <th>Data Property</th> <th>URL Parameter</th></p>
</tr></thead>
<p><tbody> <tr> <td>651</td> <td>ManufacturerChartDataSource</td> <td><code class="inline">byManufacturer</code></td> <td><code class="inline">manufacturer</code></td></p>
</tr>
<p><tr> <td>652</td> <td>YearChartDataSource</td> <td><code class="inline">byYearRange</code></td> <td><code class="inline">year</code>, <code class="inline">yearMin</code>, <code class="inline">yearMax</code></td></p>
</tr>
<p><tr> <td>653</td> <td>BodyClassChartDataSource</td> <td><code class="inline">byBodyClass</code></td> <td><code class="inline">bodyClass</code></td></p>
</tr>
<p><tr> <td>654</td> <td>TopModelsChartDataSource</td> <td><code class="inline">modelsByManufacturer</code>, <code class="inline">topModels</code></td> <td><code class="inline">modelCombos</code></td></p>
</tr>
</tbody>
</table>

<p><strong>Phase 7 Aha Moment:</strong> "Chart sources transform domain data into visualization-ready formats."</p>

<p>Each chart source:</p>
<ul><li>Transforms domain statistics into Plotly traces and layouts</li>
<p><li>Handles both simple and segmented (highlighted) data</li> <li>Converts user interactions into URL parameters</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to Phase 8 (document 801) to build the <code class="inline">BaseChartComponent</code> that uses these data sources to render interactive charts.</p></div></div>
    <div class="chapter" id="section-801">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>801: Base Chart Component</h1>
        </div>
<div class="page-content"><h1>801: Base Chart Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 201-domain-config-interface, 301-url-state-service, 306-resource-management-service, 651-654 (Chart Data Sources) <strong>Blocks:</strong> 804-statistics-panel-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the data source pattern for transforming domain data into chart-ready formats</li>
<p><li>Know how to integrate Plotly.js with Angular's change detection strategy</li> <li>Be able to implement reusable chart containers that work with any domain configuration</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a domain-agnostic chart component that renders Plotly.js visualizations based on pluggable data sources. This component accepts any <code class="inline">ChartDataSource</code> implementation and handles all chart lifecycle concerns: rendering, resizing, event handling, and cleanup.</p>

<hr>

<h2>Why</h2>

<p>Charts are a critical feature for data discovery applications. However, each domain (automobiles, agriculture, etc.) has different data structures and visualization needs. Rather than creating domain-specific chart components, we build one generic container that works with any data.</p>

<p>The <strong>Data Source Pattern</strong> separates concerns:</p>
<ul><li><strong>BaseChartComponent</strong> handles Plotly.js integration, DOM management, and events</li>
<p><li><strong>ChartDataSource</strong> implementations handle domain-specific data transformation</li></p>
</ul>
<p>This pattern is the Phase 8 "aha moment": <strong>Generic components + specific configuration = infinite reusability</strong>.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-01">Style 03-01</a>: Use single responsibility principle</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-15">Style 05-15</a>: Provide a selector prefix</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>When a user clicks on a chart element (e.g., a bar for "Toyota"), the click event flows through the data source's <code class="inline">toUrlParams()</code> method, which converts the click into URL query parameters. This maintains our URL-First principle: all state changes flow through URL updates.</p>

<hr>

<h2>What</h2>

<h3>Step 801.1: Install Plotly.js Dependency</h3>

<p>First, install the Plotly.js minified distribution:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npm install plotly.js-dist-min --save</p>
</code></pre>

<p>Verify installation:</p>

<pre class="code-block bash"><code>$ grep "plotly" package.json
<p>"plotly.js-dist-min": "^2.29.1",</p>
</code></pre></div><div class="page-content"><h3>Step 801.2: Create the Chart Data Interface</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-chart/chart-data.interface.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/base-chart/chart-data.interface.ts
<p>// VERSION 1 (Section 801) - Chart data structures</p>

<p>/**</p>
 <ul><li>Chart data structure for Plotly.js</li>
</ul> *
 <ul><li>Contains the traces (data series), layout configuration, and optional</li>
</ul> <ul><li>interaction state from previous user clicks.</li>
</ul> */
<p>export interface ChartData { /**</p>
   <ul><li>Array of Plotly data traces (each trace represents a data series)</li>
</ul>   */
<p>traces: any[];</p>

<p>/**</p>
   <ul><li>Plotly layout configuration controlling chart appearance, axes, titles</li>
</ul>   */
<p>layout: Partial&lt;any&gt;;</p>

<p>/**</p>
   <ul><li>Optional click event data from the last chart interaction</li>
</ul>   */
<p>clickData?: any; }</p>

<p>/**</p>
 <ul><li>Abstract chart data source</li>
</ul> *
 <ul><li>Transforms domain statistics into Plotly-ready chart data.</li>
</ul> <ul><li>Each domain implements concrete data sources that extend this class.</li>
</ul> *
 <ul><li>@template TStatistics - Domain-specific statistics type</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>typescript</li>
</ul> <ul><li>export class ManufacturerChartSource extends ChartDataSource&lt;VehicleStatistics&gt; {</li>
</ul> <ul><li>  transform(statistics, highlights, selectedValue, width) {</li>
</ul> <ul><li>    // Transform VehicleStatistics into bar chart traces</li>
</ul> <ul><li>  }</li>
</ul> <ul><li>}</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>export abstract class ChartDataSource&lt;TStatistics = any&gt; { /**</p>
   <ul><li>Transform statistics into chart data</li>
</ul>   *
   <ul><li>@param statistics - Domain statistics from ResourceManagementService</li>
</ul>   <ul><li>@param highlights - Highlight filters for visual emphasis</li>
</ul>   <ul><li>@param selectedValue - Currently selected value to highlight</li>
</ul>   <ul><li>@param containerWidth - Container width for responsive sizing</li>
</ul>   <ul><li>@returns Chart data or null if no data available</li>
</ul>   */
<p>abstract transform( statistics: TStatistics | null, highlights: any, selectedValue: string | null, containerWidth: number ): ChartData | null;</p>

<p>/**</p>
   <ul><li>Get chart title for display</li>
</ul>   */
<p>abstract getTitle(): string;</p>

<p>/**</p>
   <ul><li>Handle chart click event</li>
</ul>   *
   <ul><li>Extracts the meaningful value from a Plotly click event.</li>
</ul>   <ul><li>For a bar chart, this might be the category name.</li>
</ul>   <ul><li>For a scatter plot, this might be coordinates.</li>
</ul>   *
   <ul><li>@param event - Plotly click event object</li>
</ul>   <ul><li>@returns Clicked value string or null if click is not actionable</li>
</ul>   */
<p>abstract handleClick(event: any): string | null;</p>

<p>/**</p>
   <ul><li>Convert clicked value to URL parameters</li>
</ul>   *
   <ul><li>Maps the chart's clicked value to URL query parameters.</li>
</ul>   <em> Handles both filter mode (regular params) and highlight mode (h_</em> params).
<p>*</p>
   <ul><li>@param value - The clicked value from handleClick()</li>
</ul>   <ul><li>@param isHighlightMode - Whether highlight mode is active (h key held)</li>
</ul>   <ul><li>@returns URL parameters object to merge into the query string</li>
</ul>   *
   <ul><li>@example</li>
</ul>   <ul><li></code></pre>typescript</li>
</ul>   <ul><li>// ManufacturerChartDataSource</li>
</ul>   <ul><li>toUrlParams('Toyota', false) // { manufacturer: 'Toyota' }</li>
</ul>   <ul><li>toUrlParams('Toyota', true)  // { h_manufacturer: 'Toyota' }</li>
</ul>   <em> <pre class="code-block text"><code>   </em>/
<p>abstract toUrlParams(value: string, isHighlightMode: boolean): Record&lt;string, any&gt;; }</p>
</code></pre></div><div class="page-content"><h3>Step 801.3: Create the Base Chart Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-chart/base-chart.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/base-chart/base-chart.component.ts
<p>// VERSION 1 (Section 801) - Generic Plotly.js chart container</p>

<p>import { Component, Input, Output, EventEmitter, OnInit, OnDestroy, OnChanges, AfterViewInit, SimpleChanges, ChangeDetectionStrategy, ChangeDetectorRef, ElementRef, ViewChild, HostListener } from '@angular/core'; import { CommonModule } from '@angular/common'; import { Subject } from 'rxjs'; import { ButtonModule } from 'primeng/button';</p>

<p>import { ChartData, ChartDataSource } from './chart-data.interface';</p>

<p>// Import Plotly.js minified distribution import * as Plotly from 'plotly.js-dist-min';</p>

<p>/**</p>
 <ul><li>Extended HTMLElement interface for Plotly charts</li>
</ul> *
 <ul><li>Plotly augments the DOM element with chart-specific methods and properties</li>
</ul> <ul><li>after calling Plotly.newPlot().</li>
</ul> */
<p>interface PlotlyHTMLElement extends HTMLElement { on(event: string, callback: (data: any) =&gt; void): void; data?: any[]; layout?: any; }</p>

<p>/**</p>
 <ul><li>Base Chart Component</li>
</ul> *
 <ul><li>Reusable Plotly.js chart container that works with any ChartDataSource.</li>
</ul> <ul><li>Handles chart rendering, resizing, click events, and memory cleanup.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;app-base-chart</li>
</ul> <ul><li>  [dataSource]="manufacturerChartSource"</li>
</ul> <ul><li>  [statistics]="statistics$ | async"</li>
</ul> <ul><li>  [highlights]="highlights$ | async"</li>
</ul> <ul><li>  (chartClick)="onChartClick($event)"&gt;</li>
</ul> <ul><li>&lt;/app-base-chart&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-base-chart', templateUrl: './base-chart.component.html', styleUrls: ['./base-chart.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class BaseChartComponent implements OnInit, AfterViewInit, OnDestroy, OnChanges {</p>

<p>/**</p>
   <ul><li>Reference to the chart container div where Plotly renders</li>
</ul>   */
<p>@ViewChild('chartContainer', { static: false }) chartContainer!: ElementRef&lt;HTMLDivElement&gt;;</p>

<p>/**</p>
   <ul><li>Chart data source implementation (required)</li>
</ul>   */
<p>@Input() dataSource!: ChartDataSource;</p>

<p>/**</p>
   <ul><li>Statistics data to visualize</li>
</ul>   */
<p>@Input() statistics: any | null = null;</p>

<p>/**</p>
   <ul><li>Highlight filters for visual emphasis</li>
</ul>   */
<p>@Input() highlights: any = {};</p>

<p>/**</p>
   <ul><li>Currently selected value to highlight</li>
</ul>   */
<p>@Input() selectedValue: string | null = null;</p>

<p>/**</p>
   <ul><li>Whether to hide the chart title</li>
</ul>   */
<p>@Input() hideTitle = false;</p>

<p>/**</p>
   <ul><li>Whether to show pop-out button in mode bar</li>
</ul>   */
<p>@Input() canPopOut = false;</p>

<p>/**</p>
   <ul><li>Emits when user clicks on a chart element</li>
</ul>   */
<p>@Output() chartClick = new EventEmitter&lt;{ value: string; isHighlightMode: boolean; }&gt;();</p>

<p>/**</p>
   <ul><li>Emits when user clicks the pop-out button</li>
</ul>   */
<p>@Output() popOutClick = new EventEmitter&lt;void&gt;();</p>

<p>/**</p>
   <ul><li>Whether highlight mode is active (h key held)</li>
</ul>   */
<p>isHighlightModeActive = false;</p>

<p>/**</p>
   <ul><li>Chart title from data source</li>
</ul>   */
<p>chartTitle = '';</p>

<p>/**</p>
   <ul><li>Error state flag</li>
</ul>   */
<p>hasError = false;</p>

<p>/**</p>
   <ul><li>Error message for display</li>
</ul>   */
<p>errorMessage = '';</p>

<p>private destroy$ = new Subject&lt;void&gt;(); private plotlyElement: PlotlyHTMLElement | null = null;</p>

<p>constructor(private cdr: ChangeDetectorRef) {}</p>

<p>// ============================================================================ // Lifecycle Hooks // ============================================================================</p>

<p>ngOnInit(): void { if (!this.dataSource) { console.error('BaseChartComponent: dataSource is required'); } this.chartTitle = this.dataSource?.getTitle() || 'Chart'; }</p>

<p>ngAfterViewInit(): void { // Render chart after view is ready this.renderChart(); }</p>

<p>ngOnChanges(changes: SimpleChanges): void { // Re-render when inputs change (after initial render) if (this.chartContainer) { this.renderChart(); } }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete();</p>

<p>// Clean up Plotly chart to prevent memory leaks if (this.plotlyElement) { Plotly.purge(this.plotlyElement); } }</p>

<p>// ============================================================================ // Event Handlers // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle window resize events</li>
</ul>   */
<p>@HostListener('window:resize') onWindowResize(): void { if (this.plotlyElement) { Plotly.Plots.resize(this.plotlyElement); } }</p>

<p>/**</p>
   <ul><li>Enable highlight mode when h key is pressed</li>
</ul>   */
<p>@HostListener('document:keydown.h') onHighlightKeyDown(): void { this.isHighlightModeActive = true; this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Disable highlight mode when h key is released</li>
</ul>   */
<p>@HostListener('document:keyup.h') onHighlightKeyUp(): void { this.isHighlightModeActive = false; this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Retry rendering after an error</li>
</ul>   */
<p>retryRender(): void { this.hasError = false; this.errorMessage = ''; this.cdr.markForCheck(); setTimeout(() =&gt; this.renderChart(), 0); }</p>

<p>// ============================================================================ // Private Methods // ============================================================================</p>

<p>/**</p>
   <ul><li>Render the Plotly chart with error boundary</li>
</ul>   */
<p>private renderChart(): void { if (!this.chartContainer || !this.dataSource) { return; }</p>

<p>try { this.hasError = false; this.errorMessage = '';</p>

<p>const element = this.chartContainer.nativeElement; const containerWidth = element.clientWidth;</p>

<p>// Transform data using the data source const chartData = this.dataSource.transform( this.statistics, this.highlights, this.selectedValue, containerWidth );</p>

<p>if (!chartData) { // No data - clear chart if (this.plotlyElement) { Plotly.purge(this.plotlyElement); this.plotlyElement = null; } return; }</p>

<p>// Configure layout with title const layout: Record&lt;string, any&gt; = { ...chartData.layout }; if (!this.hideTitle &amp;&amp; this.chartTitle) { layout['title'] = { text: this.chartTitle, font: { size: 14, color: '#ffffff' }, x: 0.01, xanchor: 'left', y: 0.97, yanchor: 'top' }; layout['margin'] = { ...layout['margin'], t: (layout['margin']?.t || 30) + 20 }; }</p>

<p>// Plotly configuration const config: Partial&lt;any&gt; = { responsive: true, displayModeBar: true, displaylogo: false, scrollZoom: false, modeBarButtonsToRemove: ['sendDataToCloud', 'lasso2d'] };</p>

<p>// Render or update chart if (this.plotlyElement) { Plotly.react(this.plotlyElement, chartData.traces, layout, config); } else { Plotly.newPlot(element, chartData.traces, layout, config) .then((gd: PlotlyHTMLElement) =&gt; { this.plotlyElement = gd; this.attachEventHandlers(gd); }) .catch((err: Error) =&gt; { this.handleRenderError(err, 'Failed to create chart'); }); } } catch (err) { this.handleRenderError(err as Error, 'Chart rendering failed'); } }</p>

<p>/**</p>
   <ul><li>Attach Plotly event handlers</li>
</ul>   */
<p>private attachEventHandlers(gd: PlotlyHTMLElement): void { gd.on('plotly_click', (data: any) =&gt; { try { const clickedValue = this.dataSource.handleClick(data); if (clickedValue) { this.chartClick.emit({ value: clickedValue, isHighlightMode: this.isHighlightModeActive }); } } catch (err) { console.error('[BaseChart] Click handler error:', err); } });</p>

<p>gd.on('plotly_selected', (data: any) =&gt; { try { const selectedValue = this.dataSource.handleClick(data); if (selectedValue) { this.chartClick.emit({ value: selectedValue, isHighlightMode: this.isHighlightModeActive }); } } catch (err) { console.error('[BaseChart] Selection handler error:', err); } }); }</p>

<p>/**</p>
   <ul><li>Handle render errors with user-friendly fallback</li>
</ul>   */
<p>private handleRenderError(err: Error, context: string): void { console.error(<code class="inline">[BaseChart] ${context}:</code>, err); this.hasError = true; this.errorMessage = <code class="inline">${context}: ${err.message || 'Unknown error'}</code>; this.cdr.markForCheck();</p>

<p>if (this.plotlyElement) { try { Plotly.purge(this.plotlyElement); } catch { // Ignore purge errors } this.plotlyElement = null; } } }</p>
</code></pre></div><div class="page-content"><h3>Step 801.4: Create the Base Chart Component Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-chart/base-chart.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/framework/components/base-chart/base-chart.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 801) - Chart container template --&gt;</p>

<p>&lt;div class="chart-wrapper"&gt; &lt;!-- Error boundary fallback --&gt; &lt;div *ngIf="hasError" class="chart-error"&gt; &lt;div class="error-content"&gt; &lt;i class="pi pi-exclamation-triangle"&gt;&lt;/i&gt; &lt;p class="error-title"&gt;Chart failed to render&lt;/p&gt; &lt;p class="error-message"&gt;{{ errorMessage }}&lt;/p&gt; &lt;button pButton type="button" label="Retry" icon="pi pi-refresh" class="p-button-outlined p-button-sm" (click)="retryRender()"&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;</p>

<p>&lt;!-- Plotly chart container (hidden when error) --&gt; &lt;div #chartContainer class="chart-container" [hidden]="hasError"&gt;&lt;/div&gt;</p>

<p>&lt;!-- No data message --&gt; &lt;div *ngIf="!statistics &amp;&amp; !hasError" class="no-data-message"&gt; &lt;p&gt;No data available&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre>

<h3>Step 801.5: Create the Base Chart Component Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-chart/base-chart.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/framework/components/base-chart/base-chart.component.scss
<p>// VERSION 1 (Section 801) - Chart container styles</p>

<p>.chart-wrapper { width: 100%; height: 100%; display: flex; flex-direction: column; }</p>

<p>.chart-container { flex: 1; min-height: 300px; width: 100%; overflow: hidden; }</p>

<p>.no-data-message { display: flex; justify-content: center; align-items: center; height: 300px; color: var(--text-color-secondary); font-style: italic; }</p>

<p>.chart-error { display: flex; justify-content: center; align-items: center; min-height: 300px; background-color: var(--surface-ground, #f8f9fa); border: 1px dashed var(--red-400, #f87171); border-radius: 6px; padding: 2rem;</p>

<p>.error-content { text-align: center; max-width: 400px;</p>

<p>.pi-exclamation-triangle { font-size: 2.5rem; color: var(--red-500, #ef4444); margin-bottom: 1rem; }</p>

<p>.error-title { font-size: 1.1rem; font-weight: 600; color: var(--text-color); margin: 0 0 0.5rem 0; }</p>

<p>.error-message { font-size: 0.875rem; color: var(--text-color-secondary); margin: 0 0 1rem 0; word-break: break-word; }</p>

<p>button { margin-top: 0.5rem; } } }</p>
</code></pre></div><div class="page-content"><h3>Step 801.6: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-chart/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/base-chart/index.ts
<p>// VERSION 1 (Section 801) - Barrel export</p>

<p>export { BaseChartComponent } from './base-chart.component'; export { ChartData, ChartDataSource } from './chart-data.interface';</p>
</code></pre>

<h3>Step 801.7: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p>

<pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 2 (Section 801) - Add BaseChartComponent // Replaces VERSION 1 from Section 315</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { ButtonModule } from 'primeng/button';</p>

<p>import { BaseChartComponent } from './components/base-chart/base-chart.component';</p>

<p>@NgModule({ declarations: [ BaseChartComponent ], imports: [ CommonModule, ButtonModule ], exports: [ BaseChartComponent ] }) export class FrameworkModule {}</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors related to BaseChartComponent.</p>

<h3>2. Check TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit
</code></pre>

<p>Expected: No type errors.</p>

<h3>3. Verify Module Registration</h3>

<pre class="code-block bash"><code>$ grep -r "BaseChartComponent" src/app/framework/
</code></pre>

<p>Expected output shows the component in the module's declarations and exports.</p>

<h3>4. Manual Inspection</h3>

<p>Open <code class="inline">src/app/framework/components/base-chart/base-chart.component.ts</code> and verify:</p>
<ul><li>The <code class="inline">ChartDataSource</code> abstract class is imported</li>
<p><li>All lifecycle hooks are implemented</li> <li>The <code class="inline">@HostListener</code> decorators are present for resize and keyboard events</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Cannot find module 'plotly.js-dist-min'</code></td> <td>Package not installed</td> <td>Run <code class="inline">npm install plotly.js-dist-min --save</code></td></p>
</tr>
<p><tr> <td><code class="inline">Property 'Plots' does not exist on type 'typeof Plotly'</code></td> <td>TypeScript type issue</td> <td>The <code class="inline">any</code> type on Plotly import handles this; verify import syntax</td></p>
</tr>
<p><tr> <td>Chart doesn't resize on window resize</td> <td><code class="inline">@HostListener</code> not triggering</td> <td>Ensure component is in change detection tree</td></p>
</tr>
<p><tr> <td>Memory leak warnings in console</td> <td>Plotly not cleaned up</td> <td>Verify <code class="inline">Plotly.purge()</code> is called in <code class="inline">ngOnDestroy</code></td></p>
</tr>
<p><tr> <td>Chart not rendering</td> <td>Container has zero dimensions</td> <td>Add <code class="inline">min-height: 300px</code> to the chart container</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>The Data Source Pattern separates concerns</strong> - The component handles rendering; data sources handle transformation</li>
<p><li><strong>Plotly requires explicit cleanup</strong> - Always call <code class="inline">Plotly.purge()</code> in <code class="inline">ngOnDestroy</code> to prevent memory leaks</li> <li><strong>Abstract classes define contracts</strong> - <code class="inline">ChartDataSource</code> ensures all chart types implement required methods</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">plotly.js-dist-min</code> package is installed and listed in <code class="inline">package.json</code></li>
<p><li>[ ] <code class="inline">ChartDataSource</code> abstract class defines all required methods</li> <li>[ ] <code class="inline">BaseChartComponent</code> renders a container div for Plotly</li> <li>[ ] Window resize triggers chart resize via <code class="inline">@HostListener</code></li> <li>[ ] <code class="inline">h</code> key toggles highlight mode</li> <li>[ ] Error boundary displays user-friendly message on render failure</li> <li>[ ] <code class="inline">ngOnDestroy</code> calls <code class="inline">Plotly.purge()</code> for cleanup</li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">802-base-picker-component.md</code> to build the configuration-driven multi-select picker component.</p></div></div>
    <div class="chapter" id="section-802">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>802: Base Picker Component</h1>
        </div>
<div class="page-content"><h1>802: Base Picker Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 205-picker-config-interface, 301-url-state-service, 306-resource-management-service, 311-picker-config-registry <strong>Blocks:</strong> 806-query-panel-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand the configuration-driven approach to building reusable UI components</li>
<p><li>Know how to synchronize component state with URL parameters bidirectionally</li> <li>Be able to implement server-side pagination with selection persistence across pages</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a configuration-driven multi-select table component that wraps PrimeNG Table with selection management and URL synchronization. The picker loads data from an API, displays it in a paginated table, allows multi-row selection, and emits selected items for URL parameter updates.</p>

<hr>

<h2>Why</h2>

<p>Many data discovery applications need "picker" interfaces: tables where users select one or more items to filter results. For example, selecting specific vehicle models, manufacturers, or years.</p>

<p>Without a reusable picker component, each domain would require a custom implementation. The <strong>Base Picker Component</strong> eliminates this duplication by accepting configuration that describes:</p>
<ul><li>Which API endpoint to call</li>
<p><li>Which columns to display</li> <li>How to serialize/deserialize selections to URL parameters</li></p>
</ul>
<p>This is the Phase 8 pattern in action: <strong>Generic components + specific configuration = infinite reusability</strong>.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-01">Style 03-01</a>: Use single responsibility principle</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-04">Style 05-04</a>: Put logic in the component class</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>The picker maintains bidirectional sync with URL parameters:</p>
<ul><li><strong>URL to Picker</strong>: When URL contains selection parameters, the picker hydrates those selections</li>
<p><li><strong>Picker to URL</strong>: When user clicks "Apply", the component emits a selection event that the parent uses to update the URL</li></p>
</ul>
<p>This ensures selections survive page refreshes and are shareable via URL.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 802.1: Create the Picker State Interface</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-picker/picker-state.interface.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/base-picker/picker-state.interface.ts
<p>// VERSION 1 (Section 802) - Picker component state</p>

<p>/**</p>
 <ul><li>Internal state for BasePickerComponent</li>
</ul> *
 <ul><li>Tracks loaded data, pagination, selection, and loading/error states.</li>
</ul> */
<p>export interface PickerState&lt;T&gt; { /**</p>
   <ul><li>Currently loaded data rows (current page only)</li>
</ul>   */
<p>data: T[];</p>

<p>/**</p>
   <ul><li>Total count of records (for pagination)</li>
</ul>   */
<p>totalCount: number;</p>

<p>/**</p>
   <ul><li>Current page index (0-based)</li>
</ul>   */
<p>currentPage: number;</p>

<p>/**</p>
   <ul><li>Number of rows per page</li>
</ul>   */
<p>pageSize: number;</p>

<p>/**</p>
   <ul><li>Current sort field (if any)</li>
</ul>   */
<p>sortField?: string;</p>

<p>/**</p>
   <ul><li>Sort order: 1 = ascending, -1 = descending</li>
</ul>   */
<p>sortOrder: number;</p>

<p>/**</p>
   <ul><li>Current search/filter term</li>
</ul>   */
<p>searchTerm: string;</p>

<p>/**</p>
   <ul><li>Loading state flag</li>
</ul>   */
<p>loading: boolean;</p>

<p>/**</p>
   <ul><li>Error object (if any)</li>
</ul>   */
<p>error: Error | null;</p>

<p>/**</p>
   <ul><li>Whether initial data has been loaded</li>
</ul>   */
<p>dataLoaded: boolean;</p>

<p>/**</p>
   <ul><li>Set of selected row keys (for O(1) lookup)</li>
</ul>   */
<p>selectedKeys: Set&lt;string&gt;;</p>

<p>/**</p>
   <ul><li>Array of selected row objects</li>
</ul>   */
<p>selectedItems: T[];</p>

<p>/**</p>
   <ul><li>Keys pending hydration from URL (before data loads)</li>
</ul>   */
<p>pendingHydration: string[]; }</p>

<p>/**</p>
 <ul><li>Get default picker state</li>
</ul> */
<p>export function getDefaultPickerState&lt;T&gt;(pageSize = 20): PickerState&lt;T&gt; { return { data: [], totalCount: 0, currentPage: 0, pageSize, sortField: undefined, sortOrder: 1, searchTerm: '', loading: false, error: null, dataLoaded: false, selectedKeys: new Set&lt;string&gt;(), selectedItems: [], pendingHydration: [] }; }</p>
</code></pre>

<h3>Step 802.2: Create the Base Picker Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-picker/base-picker.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/base-picker/base-picker.component.ts
<p>// VERSION 1 (Section 802) - Configuration-driven multi-select table</p>

<p>import { AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { Subject } from 'rxjs'; import { distinctUntilChanged, map, takeUntil } from 'rxjs/operators';</p>

<p>import { TableModule } from 'primeng/table'; import { ButtonModule } from 'primeng/button'; import { CheckboxModule } from 'primeng/checkbox'; import { InputTextModule } from 'primeng/inputtext'; import { SkeletonModule } from 'primeng/skeleton'; import { MessageModule } from 'primeng/message';</p>

<p>import { PickerConfig, PickerSelectionEvent, PickerApiParams } from '../../models/picker-config.interface'; import { PickerConfigRegistry } from '../../services/picker-config-registry.service'; import { UrlStateService } from '../../services/url-state.service'; import { ResourceManagementService } from '../../services/resource-management.service'; import { PickerState, getDefaultPickerState } from './picker-state.interface';</p>

<p>/**</p>
 <ul><li>Base Picker Component</li>
</ul> *
 <ul><li>Configuration-driven multi-select table with:</li>
</ul> <ul><li>- Server-side pagination and sorting</li>
</ul> <ul><li>- Search filtering</li>
</ul> <ul><li>- Selection persistence across pages</li>
</ul> <ul><li>- URL parameter synchronization</li>
</ul> *
 <ul><li>@template T - The data model type for table rows</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;!-- Using config from registry --&gt;</li>
</ul> <ul><li>&lt;app-base-picker</li>
</ul> <ul><li>  [configId]="'vehicle-picker'"</li>
</ul> <ul><li>  (selectionChange)="onSelectionChange($event)"&gt;</li>
</ul> <ul><li>&lt;/app-base-picker&gt;</li>
</ul> *
 <ul><li>&lt;!-- Using direct config object --&gt;</li>
</ul> <ul><li>&lt;app-base-picker</li>
</ul> <ul><li>  [config]="vehiclePickerConfig"</li>
</ul> <ul><li>  (selectionChange)="onSelectionChange($event)"&gt;</li>
</ul> <ul><li>&lt;/app-base-picker&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-base-picker', templateUrl: './base-picker.component.html', styleUrls: ['./base-picker.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class BasePickerComponent&lt;T&gt; implements OnInit, OnDestroy, AfterViewInit {</p>

<p>/**</p>
   <ul><li>Picker configuration ID (loads from registry)</li>
</ul>   <ul><li>Either configId or config must be provided.</li>
</ul>   */
<p>@Input() configId?: string;</p>

<p>/**</p>
   <ul><li>Direct picker configuration object</li>
</ul>   <ul><li>Either configId or config must be provided.</li>
</ul>   */
<p>@Input() config?: PickerConfig&lt;T&gt;;</p>

<p>/**</p>
   <ul><li>Emits when user clicks "Apply" with selected items</li>
</ul>   */
<p>@Output() selectionChange = new EventEmitter&lt;PickerSelectionEvent&lt;T&gt;&gt;();</p>

<p>/**</p>
   <ul><li>Current picker state</li>
</ul>   */
<p>state: PickerState&lt;T&gt; = getDefaultPickerState();</p>

<p>/**</p>
   <ul><li>Active configuration (resolved from configId or config)</li>
</ul>   */
<p>activeConfig?: PickerConfig&lt;T&gt;;</p>

<p>private destroy$ = new Subject&lt;void&gt;();</p>

<p>constructor( private registry: PickerConfigRegistry, private urlState: UrlStateService, private cdr: ChangeDetectorRef, private elementRef: ElementRef, private resourceService: ResourceManagementService&lt;any, any, any&gt; ) {}</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnInit(): void { this.loadConfiguration();</p>

<p>if (!this.activeConfig) { throw new Error('BasePickerComponent requires either configId or config input'); }</p>

<p>this.initializeState(); this.subscribeToUrlChanges(); this.loadData(); }</p>

<p>ngAfterViewInit(): void { this.syncPaginatorWidth(); }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); }</p>

<p>// ============================================================================ // Configuration // ============================================================================</p>

<p>private loadConfiguration(): void { if (this.config) { this.activeConfig = this.config; } else if (this.configId) { this.activeConfig = this.registry.get&lt;T&gt;(this.configId); } }</p>

<p>private initializeState(): void { const pageSize = this.activeConfig!.pagination.defaultPageSize || 20; this.state = getDefaultPickerState&lt;T&gt;(pageSize); }</p>

<p>// ============================================================================ // URL Synchronization // ============================================================================</p>

<p>private subscribeToUrlChanges(): void { const urlParam = this.activeConfig!.selection.urlParam;</p>

<p>this.resourceService.filters$ .pipe( map(filters =&gt; (filters as any)[urlParam] || null), distinctUntilChanged(), takeUntil(this.destroy$) ) .subscribe(filterValue =&gt; { if (filterValue) { this.hydrateFromUrl(String(filterValue)); } else { // Clear selections this.state.selectedKeys = new Set&lt;string&gt;(); this.state.selectedItems = []; this.state.pendingHydration = []; this.state.data = [...this.state.data]; this.cdr.detectChanges(); } }); }</p>

<p>private hydrateFromUrl(urlValue: string): void { const config = this.activeConfig!; const partialItems = config.selection.deserializer(urlValue); const keyGenerator = config.selection.keyGenerator || config.row.keyGenerator; const keys = partialItems.map(item =&gt; keyGenerator(item as T));</p>

<p>if (this.state.dataLoaded) { this.hydrateSelections(keys); } else { this.state.pendingHydration = keys; }</p>

<p>this.cdr.markForCheck(); }</p>

<p>private hydrateSelections(keys: string[]): void { const config = this.activeConfig!; this.state.selectedKeys = new Set&lt;string&gt;(keys);</p>

<p>// Preserve items from other pages const existingItemsByKey = new Map&lt;string, T&gt;(); this.state.selectedItems.forEach(item =&gt; { const key = config.row.keyGenerator(item); existingItemsByKey.set(key, item); });</p>

<p>// Build new selectedItems array const newSelectedItems: T[] = []; keys.forEach(key =&gt; { const itemInCurrentPage = this.state.data.find( row =&gt; config.row.keyGenerator(row) === key );</p>

<p>if (itemInCurrentPage) { newSelectedItems.push(itemInCurrentPage); } else if (existingItemsByKey.has(key)) { newSelectedItems.push(existingItemsByKey.get(key)!); } });</p>

<p>this.state.selectedItems = newSelectedItems; this.cdr.markForCheck(); }</p>

<p>// ============================================================================ // Data Loading // ============================================================================</p>

<p>private loadData(): void { const config = this.activeConfig!; this.state.loading = true; this.state.error = null; this.cdr.markForCheck();</p>

<p>const params: PickerApiParams = { page: this.state.currentPage, size: this.state.pageSize, search: this.state.searchTerm || undefined, sortField: this.state.sortField, sortOrder: this.state.sortOrder };</p>

<p>const apiParams = config.api.paramMapper ? config.api.paramMapper(params) : params;</p>

<p>config.api.fetchData(apiParams) .pipe(takeUntil(this.destroy$)) .subscribe({ next: response =&gt; { const transformed = config.api.responseTransformer(response); this.state.data = transformed.results; this.state.totalCount = transformed.total; this.state.loading = false; this.state.dataLoaded = true;</p>

<p>// Hydrate pending selections if (this.state.pendingHydration.length &gt; 0) { this.hydrateSelections(this.state.pendingHydration); this.state.pendingHydration = []; }</p>

<p>this.cdr.markForCheck(); }, error: error =&gt; { this.state.loading = false; this.state.error = error; this.cdr.markForCheck(); } }); }</p>

<p>// ============================================================================ // Selection Handlers // ============================================================================</p>

<p>onRowSelectionChange(row: T, checked: boolean): void { const key = this.activeConfig!.row.keyGenerator(row);</p>

<p>if (checked) { this.state.selectedKeys.add(key); this.state.selectedItems.push(row); } else { this.state.selectedKeys.delete(key); this.state.selectedItems = this.state.selectedItems.filter( item =&gt; this.activeConfig!.row.keyGenerator(item) !== key ); }</p>

<p>this.cdr.markForCheck(); }</p>

<p>onSelectAll(checked: boolean): void { if (checked) { this.state.data.forEach(row =&gt; { const key = this.activeConfig!.row.keyGenerator(row); if (!this.state.selectedKeys.has(key)) { this.state.selectedKeys.add(key); this.state.selectedItems.push(row); } }); } else { this.state.data.forEach(row =&gt; { const key = this.activeConfig!.row.keyGenerator(row); this.state.selectedKeys.delete(key); }); this.state.selectedItems = this.state.selectedItems.filter(item =&gt; { const key = this.activeConfig!.row.keyGenerator(item); return this.state.selectedKeys.has(key); }); }</p>

<p>this.cdr.markForCheck(); }</p>

<p>isRowSelected(row: T): boolean { const key = this.activeConfig!.row.keyGenerator(row); return this.state.selectedKeys.has(key); }</p>

<p>get allVisibleSelected(): boolean { if (this.state.data.length === 0) { return false; } return this.state.data.every(row =&gt; this.isRowSelected(row)); }</p>

<p>// ============================================================================ // Pagination &amp; Sorting // ============================================================================</p>

<p>onLazyLoad(event: any): void { if (this.state.loading) { return; }</p>

<p>this.state.currentPage = event.first / event.rows; this.state.pageSize = event.rows; this.state.sortField = event.sortField || undefined; this.state.sortOrder = event.sortOrder || 1;</p>

<p>this.loadData(); }</p>

<p>onSearch(term: string): void { this.state.searchTerm = term; this.state.currentPage = 0; this.loadData(); }</p>

<p>// ============================================================================ // Actions // ============================================================================</p>

<p>applySelections(): void { const config = this.activeConfig!; const urlValue = config.selection.serializer(this.state.selectedItems);</p>

<p>const event: PickerSelectionEvent&lt;T&gt; = { pickerId: config.id, selections: this.state.selectedItems, selectedKeys: Array.from(this.state.selectedKeys), urlValue };</p>

<p>this.selectionChange.emit(event); }</p>

<p>clearSelections(): void { this.state.selectedKeys = new Set&lt;string&gt;(); this.state.selectedItems = []; this.state.data = [...this.state.data]; this.cdr.markForCheck();</p>

<p>// Emit empty selection const event: PickerSelectionEvent&lt;T&gt; = { pickerId: this.activeConfig!.id, selections: [], selectedKeys: [], urlValue: '' }; this.selectionChange.emit(event); }</p>

<p>// ============================================================================ // Helpers // ============================================================================</p>

<p>fieldToString(field: keyof T): string { return String(field); }</p>

<p>private syncPaginatorWidth(): void { const nativeEl = this.elementRef.nativeElement; const table = nativeEl.querySelector('.p-datatable-table') as HTMLElement; const paginator = nativeEl.querySelector('.p-paginator') as HTMLElement;</p>

<p>if (table &amp;&amp; paginator) { paginator.style.width = <code class="inline">${table.offsetWidth}px</code>; } } }</p>
</code></pre></div><div class="page-content"><h3>Step 802.3: Create the Base Picker Component Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-picker/base-picker.component.html</code>:</p></div><div class="page-content"><pre class="code-block html"><code>&lt;!-- src/app/framework/components/base-picker/base-picker.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 802) - Picker table template --&gt;</p>

<p>&lt;div *ngIf="activeConfig" class="picker-container"&gt; &lt;p-table [value]="state.data" [loading]="state.loading" [lazy]="activeConfig.pagination.mode === 'server'" [paginator]="true" [rows]="state.pageSize" [totalRecords]="state.totalCount" [rowsPerPageOptions]="activeConfig.pagination.pageSizeOptions || [10, 20, 50, 100]" [showCurrentPageReport]="true" currentPageReportTemplate="Showing {first} to {last} of {totalRecords} entries" (onLazyLoad)="onLazyLoad($event)" styleClass="p-datatable-gridlines" responsiveLayout="scroll"&gt;</p>

<p>&lt;!-- Caption with search and actions --&gt; &lt;ng-template pTemplate="caption"&gt; &lt;div class="table-caption"&gt; &lt;!-- Search --&gt; &lt;div *ngIf="activeConfig.showSearch !== false" class="picker-search"&gt; &lt;input type="text" pInputText [placeholder]="activeConfig.searchPlaceholder || 'Search...'" [value]="state.searchTerm" (input)="onSearch($any($event.target).value)" class="search-input"&gt; &lt;/div&gt; &lt;div class="table-actions"&gt; &lt;button pButton type="button" label="Clear" icon="pi pi-times" class="p-button-outlined p-button-secondary" (click)="clearSelections()" [disabled]="state.selectedItems.length === 0"&gt; &lt;/button&gt; &lt;button pButton type="button" label="Apply" icon="pi pi-check" class="p-button-primary" (click)="applySelections()" [disabled]="state.selectedItems.length === 0"&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Header --&gt; &lt;ng-template pTemplate="header"&gt; &lt;tr&gt; &lt;!-- Select All Checkbox --&gt; &lt;th style="width: 3rem"&gt; &lt;p-checkbox [ngModel]="allVisibleSelected" (onChange)="onSelectAll($any($event).checked)" [binary]="true" [disabled]="state.data.length === 0"&gt; &lt;/p-checkbox&gt; &lt;/th&gt; &lt;!-- Column Headers --&gt; &lt;th *ngFor="let col of activeConfig.columns" [pSortableColumn]="col.sortable ? fieldToString(col.field) : ''" [ngStyle]="{ width: col.width, textAlign: col.align || 'left' }"&gt; {{ col.header }} &lt;p-sortIcon *ngIf="col.sortable" [field]="fieldToString(col.field)"&gt; &lt;/p-sortIcon&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Body --&gt; &lt;ng-template pTemplate="body" let-row&gt; &lt;tr&gt; &lt;!-- Row Checkbox --&gt; &lt;td&gt; &lt;p-checkbox [ngModel]="isRowSelected(row)" (onChange)="onRowSelectionChange(row, $any($event).checked)" [binary]="true"&gt; &lt;/p-checkbox&gt; &lt;/td&gt; &lt;!-- Column Data --&gt; &lt;td *ngFor="let col of activeConfig.columns" [ngStyle]="{ textAlign: col.align || 'left' }"&gt; {{ row[col.field] }} &lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Empty Message --&gt; &lt;ng-template pTemplate="emptymessage"&gt; &lt;tr&gt; &lt;td [attr.colspan]="activeConfig.columns.length + 1"&gt; &lt;div class="empty-message"&gt; &lt;i class="pi pi-inbox empty-icon"&gt;&lt;/i&gt; &lt;p&gt;No data available&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Loading Body --&gt; &lt;ng-template pTemplate="loadingbody"&gt; &lt;tr *ngFor="let i of [1, 2, 3, 4, 5]"&gt; &lt;td [attr.colspan]="activeConfig.columns.length + 1"&gt; &lt;div class="loading-row"&gt; &lt;p-skeleton width="100%" height="2rem"&gt;&lt;/p-skeleton&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt; &lt;/p-table&gt;</p>

<p>&lt;!-- Error Display --&gt; &lt;div *ngIf="state.error" class="picker-error"&gt; &lt;p-message severity="error" [text]="state.error.message || 'An error occurred'"&gt; &lt;/p-message&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre></div><div class="page-content"><h3>Step 802.4: Create the Base Picker Component Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-picker/base-picker.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/framework/components/base-picker/base-picker.component.scss
<p>// VERSION 1 (Section 802) - Picker table styles</p>

<p>.picker-container { display: flex; flex-direction: column; gap: 0; padding: 0; background: var(--surface-card); border-radius: var(--border-radius); border: 1px solid var(--surface-border); }</p>

<p>.picker-search { display: flex; align-items: center; gap: 0.5rem; flex: 1;</p>

<p>.search-input { flex: 1; width: 100%; } }</p>

<p>.table-caption { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 1rem; gap: 1rem; background-color: var(--surface-50);</p>

<p>@media (max-width: 768px) { flex-direction: column; align-items: flex-start; } }</p>

<p>.table-actions { display: flex; gap: 0.5rem; white-space: nowrap; }</p>

<p>.empty-message { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem 1rem; color: var(--text-color-secondary);</p>

<p>.empty-icon { font-size: 3rem; margin-bottom: 1rem; opacity: 0.5; }</p>

<p>p { margin: 0; font-size: 1rem; } }</p>

<p>.loading-row { padding: 0.5rem; }</p>

<p>.picker-error { margin-top: 1rem; }</p>

<p>// PrimeNG table overrides ::ng-deep { .p-datatable { .p-datatable-thead &gt; tr &gt; th { background: var(--surface-section); color: var(--text-color); font-weight: 600; padding: 0.75rem 1rem; }</p>

<p>.p-datatable-tbody &gt; tr { background: var(--surface-card); color: var(--text-color);</p>

<p>&amp;:hover { background: var(--surface-hover); }</p>

<p>&gt; td { padding: 0.75rem 1rem; } }</p>

<p>.p-paginator { background: var(--surface-section); color: var(--text-color); border: none; padding: 0.5rem 1rem; } } }</p>
</code></pre>

<h3>Step 802.5: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/base-picker/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/base-picker/index.ts
<p>// VERSION 1 (Section 802) - Barrel export</p>

<p>export { BasePickerComponent } from './base-picker.component'; export { PickerState, getDefaultPickerState } from './picker-state.interface';</p>
</code></pre></div><div class="page-content"><h3>Step 802.6: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p>

<pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 3 (Section 802) - Add BasePickerComponent // Replaces VERSION 2 from Section 801</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { ButtonModule } from 'primeng/button'; import { TableModule } from 'primeng/table'; import { CheckboxModule } from 'primeng/checkbox'; import { InputTextModule } from 'primeng/inputtext'; import { SkeletonModule } from 'primeng/skeleton'; import { MessageModule } from 'primeng/message';</p>

<p>import { BaseChartComponent } from './components/base-chart/base-chart.component'; import { BasePickerComponent } from './components/base-picker/base-picker.component';</p>

<p>@NgModule({ declarations: [ BaseChartComponent, BasePickerComponent ], imports: [ CommonModule, FormsModule, ButtonModule, TableModule, CheckboxModule, InputTextModule, SkeletonModule, MessageModule ], exports: [ BaseChartComponent, BasePickerComponent ] }) export class FrameworkModule {}</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Check TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit
</code></pre>

<p>Expected: No type errors.</p>

<h3>3. Verify Dependencies</h3>

<pre class="code-block bash"><code>$ grep -E "TableModule|CheckboxModule" src/app/framework/framework.module.ts
</code></pre>

<p>Expected: Both modules are in the imports array.</p>

<h3>4. Manual Inspection</h3>

<p>Check <code class="inline">src/app/framework/components/base-picker/base-picker.component.ts</code>:</p>
<ul><li><code class="inline">PickerConfig</code> is used for configuration</li>
<p><li>Selection is tracked with both <code class="inline">Set&lt;string&gt;</code> and <code class="inline">T[]</code></li> <li>Lazy loading is implemented for server-side pagination</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">No provider for PickerConfigRegistry</code></td> <td>Service not provided</td> <td>Ensure <code class="inline">PickerConfigRegistry</code> is provided in root</td></p>
</tr>
<p><tr> <td>Selections lost on page change</td> <td>Hydration not preserving off-page items</td> <td>Verify <code class="inline">hydrateSelections</code> merges with existing items</td></p>
</tr>
<p><tr> <td>Checkbox state not updating</td> <td>Change detection not triggered</td> <td>Use <code class="inline">cdr.detectChanges()</code> instead of <code class="inline">markForCheck()</code></td></p>
</tr>
<p><tr> <td>Paginator width doesn't match table</td> <td><code class="inline">syncPaginatorWidth</code> not called</td> <td>Verify it runs in <code class="inline">ngAfterViewInit</code></td></p>
</tr>
<p><tr> <td><code class="inline">ExpressionChangedAfterItHasBeenCheckedError</code></td> <td>Mutating state during render</td> <td>Move mutations to lifecycle hooks or use <code class="inline">setTimeout</code></td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Configuration drives behavior</strong> - The same component renders different data based on <code class="inline">PickerConfig</code></li>
<p><li><strong>Selections persist across pages</strong> - Use a <code class="inline">Set</code> for O(1) lookup and an array for full item data</li> <li><strong>URL hydration requires two-phase approach</strong> - Store pending keys until data loads, then match</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">BasePickerComponent</code> accepts <code class="inline">configId</code> or <code class="inline">config</code> input</li>
<p><li>[ ] Table displays columns from configuration</li> <li>[ ] Server-side pagination triggers <code class="inline">loadData()</code> on page change</li> <li>[ ] Search input filters results (if enabled in config)</li> <li>[ ] Checkbox selection tracks items across pages</li> <li>[ ] "Apply" button emits <code class="inline">selectionChange</code> with serialized URL value</li> <li>[ ] "Clear" button resets all selections</li> <li>[ ] URL parameter changes hydrate selections</li> <li>[ ] Loading skeleton displays during data fetch</li> <li>[ ] Error message displays on API failure</li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">803-basic-results-table.md</code> to build the domain-agnostic data table for displaying search results.</p></div></div>
    <div class="chapter" id="section-803">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>803: Basic Results Table</h1>
        </div>
<div class="page-content"><h1>803: Basic Results Table</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 204-table-config-interface, 301-url-state-service, 306-resource-management-service <strong>Blocks:</strong> 904-automobile-discover</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to bind a data table to reactive streams from a service</li>
<p><li>Know how to implement server-side pagination and sorting via URL state</li> <li>Be able to create expandable row details using PrimeNG Table templates</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a configuration-driven results table component that displays data from <code class="inline">ResourceManagementService</code>, supports server-side pagination and sorting, and shows expandable row details. This component is the primary way users view search results in the discover interface.</p>

<hr>

<h2>Why</h2>

<p>The results table is the heart of any data discovery application. Users search, filter, and browse results in this table. However, different domains have different columns and data structures. The <strong>Basic Results Table</strong> solves this by:</p>

<ul><li>Reading column definitions from <code class="inline">DomainConfig.tableConfig</code></li>
<p><li>Binding to reactive streams (<code class="inline">results$</code>, <code class="inline">loading$</code>, <code class="inline">totalResults$</code>) from <code class="inline">ResourceManagementService</code></li> <li>Emitting pagination and sort changes that update URL state</li></p>
</ul>
<p>This keeps the component domain-agnostic while still providing rich functionality.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-05-02">Style 05-02</a>: Use input properties for data binding</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-15">Style 05-15</a>: Provide a selector prefix</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>When users click pagination controls or column headers to sort, the table emits events that ultimately update URL parameters. The <code class="inline">ResourceManagementService</code> watches these URL changes and triggers new API requests. This maintains our URL-First principle: the URL is the single source of truth.</p>

<hr>

<h2>What</h2>

<h3>Step 803.1: Create the Basic Results Table Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/basic-results-table/basic-results-table.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/basic-results-table/basic-results-table.component.ts
<p>// VERSION 1 (Section 803) - Configuration-driven results display</p>

<p>import { AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'; import { CommonModule } from '@angular/common'; import { Observable, Subject } from 'rxjs'; import { filter, takeUntil } from 'rxjs/operators';</p>

<p>import { TableModule } from 'primeng/table'; import { ButtonModule } from 'primeng/button'; import { RippleModule } from 'primeng/ripple'; import { SkeletonModule } from 'primeng/skeleton';</p>

<p>import { DomainConfig } from '../../models/domain-config.interface'; import { ResourceManagementService } from '../../services/resource-management.service'; import { PopOutContextService } from '../../services/popout-context.service'; import { PopOutMessageType } from '../../models/popout.interface';</p>

<p>/**</p>
 <ul><li>Basic Results Table Component</li>
</ul> *
 <ul><li>Displays search results in a paginated, sortable table with expandable rows.</li>
</ul> <ul><li>Reads configuration from DomainConfig and data from ResourceManagementService.</li>
</ul> *
 <ul><li>@template TFilters - Domain-specific filter model type</li>
</ul> <ul><li>@template TData - Domain-specific data model type</li>
</ul> <ul><li>@template TStatistics - Domain-specific statistics model type</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;app-basic-results-table</li>
</ul> <ul><li>  [domainConfig]="automobileDomainConfig"&gt;</li>
</ul> <ul><li>&lt;/app-basic-results-table&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-basic-results-table', templateUrl: './basic-results-table.component.html', styleUrls: ['./basic-results-table.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class BasicResultsTableComponent&lt;TFilters = any, TData = any, TStatistics = any&gt; implements OnInit, AfterViewInit, OnDestroy {</p>

<p>private readonly destroy$ = new Subject&lt;void&gt;();</p>

<p>/**</p>
   <ul><li>Domain configuration with table columns and settings</li>
</ul>   */
<p>@Input() domainConfig!: DomainConfig&lt;TFilters, TData, TStatistics&gt;;</p>

<p>/**</p>
   <ul><li>Emits when URL parameters should be updated (for pop-out sync)</li>
</ul>   */
<p>@Output() urlParamsChange = new EventEmitter&lt;{ [key: string]: any }&gt;();</p>

<p>/**</p>
   <ul><li>Track expanded rows by data key</li>
</ul>   */
<p>expandedRows: { [key: string]: boolean } = {};</p>

<p>/**</p>
   <ul><li>Reference to Object for template use</li>
</ul>   */
<p>Object = Object;</p>

<p>constructor( private readonly resourceService: ResourceManagementService&lt;TFilters, TData, TStatistics&gt;, private readonly cdr: ChangeDetectorRef, private readonly popOutContext: PopOutContextService, private readonly elementRef: ElementRef ) {}</p>

<p>// ============================================================================ // Observable Streams // ============================================================================</p>

<p>get filters$(): Observable&lt;TFilters&gt; { return this.resourceService.filters$; }</p>

<p>get results$(): Observable&lt;TData[]&gt; { return this.resourceService.results$; }</p>

<p>get totalResults$(): Observable&lt;number&gt; { return this.resourceService.totalResults$; }</p>

<p>get loading$(): Observable&lt;boolean&gt; { return this.resourceService.loading$; }</p>

<p>// ============================================================================ // Computed Properties // ============================================================================</p>

<p>/**</p>
   <ul><li>Calculate paginator first index from current filters</li>
</ul>   */
<p>get paginatorFirst(): number { const filters = this.resourceService.getCurrentFilters() as Record&lt;string, any&gt;; const page = filters['page'] || 1; const size = filters['size'] || 20; return (page - 1) * size; }</p>

<p>/**</p>
   <ul><li>Get current filters for template bindings</li>
</ul>   */
<p>get currentFilters(): Record&lt;string, any&gt; { return this.resourceService.getCurrentFilters() as Record&lt;string, any&gt;; }</p>

<p>// ============================================================================ // Template Helpers // ============================================================================</p>

<p>/**</p>
   <ul><li>Get object keys for row expansion display</li>
</ul>   */
<p>getObjectKeys(obj: any): string[] { return Object.keys(obj); }</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnInit(): void { if (!this.domainConfig) { throw new Error('BasicResultsTableComponent requires domainConfig input'); }</p>

<p>// Pop-out window support: sync state from parent window if (this.popOutContext.isInPopOut()) { this.popOutContext .getMessages$() .pipe( filter(msg =&gt; msg.type === PopOutMessageType.STATE_UPDATE), takeUntil(this.destroy$) ) .subscribe(message =&gt; { if (message.payload &amp;&amp; message.payload.state) { this.resourceService.syncStateFromExternal(message.payload.state); this.cdr.markForCheck(); } }); } }</p>

<p>ngAfterViewInit(): void { this.syncPaginatorWidth(); }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); }</p>

<p>// ============================================================================ // Event Handlers // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle pagination change</li>
</ul>   */
<p>onPageChange(event: any): void { const page = event.first / event.rows + 1; const size = event.rows;</p>

<p>if (this.popOutContext.isInPopOut()) { // In pop-out: emit for parent to handle this.urlParamsChange.emit({ page, size }); } else { // In main window: update filters directly const currentFilters = this.resourceService.getCurrentFilters() as Record&lt;string, any&gt;; const newFilters = { ...currentFilters, page, size } as unknown as TFilters; this.resourceService.updateFilters(newFilters); } }</p>

<p>/**</p>
   <ul><li>Handle sort change</li>
</ul>   */
<p>onSort(event: any): void { const sort = event.field; const sortDirection = event.order === 1 ? 'asc' : 'desc';</p>

<p>if (this.popOutContext.isInPopOut()) { this.urlParamsChange.emit({ sort, sortDirection }); } else { const currentFilters = this.resourceService.getCurrentFilters() as Record&lt;string, any&gt;; const newFilters = { ...currentFilters, sort, sortDirection } as unknown as TFilters; this.resourceService.updateFilters(newFilters); } }</p>

<p>/**</p>
   <ul><li>Refresh current results</li>
</ul>   */
<p>refresh(): void { this.resourceService.refresh(); }</p>

<p>// ============================================================================ // Private Methods // ============================================================================</p>

<p>/**</p>
   <ul><li>Sync paginator width to match table width</li>
</ul>   */
<p>private syncPaginatorWidth(): void { const nativeEl = this.elementRef.nativeElement; const table = nativeEl.querySelector('.p-datatable-table') as HTMLElement; const paginator = nativeEl.querySelector('.p-paginator') as HTMLElement;</p>

<p>if (table &amp;&amp; paginator) { paginator.style.width = <code class="inline">${table.offsetWidth}px</code>; } } }</p>
</code></pre></div><div class="page-content"><h3>Step 803.2: Create the Basic Results Table Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/basic-results-table/basic-results-table.component.html</code>:</p></div><div class="page-content"><pre class="code-block html"><code>&lt;!-- src/app/framework/components/basic-results-table/basic-results-table.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 803) - Results table template --&gt;</p>

<p>&lt;div class="basic-results-table-container"&gt; &lt;div class="table-container"&gt; &lt;p-table [value]="(results$ | async) || []" [columns]="domainConfig.tableConfig.columns" [dataKey]="$any(domainConfig.tableConfig.dataKey)" [loading]="(loading$ | async) || false" [lazy]="true" [paginator]="true" [rows]="currentFilters['size'] || 20" [first]="paginatorFirst" [totalRecords]="(totalResults$ | async) || 0" [rowsPerPageOptions]="domainConfig.tableConfig.rowsPerPageOptions || [10, 20, 50]" [styleClass]="domainConfig.tableConfig.styleClass || ''" [responsiveLayout]="domainConfig.tableConfig.responsiveLayout || 'scroll'" [expandedRowKeys]="expandedRows" (onPage)="onPageChange($event)" (onSort)="onSort($event)" [showCurrentPageReport]="true" [currentPageReportTemplate]="'Showing {first} to {last} of {totalRecords} results'"&gt;</p>

<p>&lt;!-- Caption with result count --&gt; &lt;ng-template pTemplate="caption"&gt; &lt;div class="table-caption"&gt; &lt;span class="caption-count"&gt; {{ (totalResults$ | async) || 0 }} result(s) &lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Header --&gt; &lt;ng-template pTemplate="header" let-columns&gt; &lt;tr&gt; &lt;th *ngIf="domainConfig.tableConfig.expandable" style="width: 3rem"&gt;&lt;/th&gt; &lt;th *ngFor="let col of columns" [pSortableColumn]="col.sortable ? col.field : undefined" [ngStyle]="{ 'width': col.width }"&gt; {{ col.header }} &lt;p-sortIcon *ngIf="col.sortable" [field]="col.field"&gt;&lt;/p-sortIcon&gt; &lt;/th&gt; &lt;/tr&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Body --&gt; &lt;ng-template pTemplate="body" let-row let-columns="columns" let-expanded="expanded"&gt; &lt;tr&gt; &lt;!-- Expand toggle --&gt; &lt;td *ngIf="domainConfig.tableConfig.expandable"&gt; &lt;button type="button" pButton pRipple [pRowToggler]="row" class="p-button-text p-button-rounded p-button-plain" [icon]="expanded ? 'pi pi-chevron-down' : 'pi pi-chevron-right'"&gt; &lt;/button&gt; &lt;/td&gt;</p>

<p>&lt;!-- Data columns --&gt; &lt;td *ngFor="let col of columns"&gt; {{ row[col.field] }} &lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Row Expansion --&gt; &lt;ng-template pTemplate="rowexpansion" let-row&gt; &lt;tr&gt; &lt;td [attr.colspan]="domainConfig.tableConfig.columns.length + 1"&gt; &lt;div class="row-expansion"&gt; &lt;h3&gt;Details&lt;/h3&gt; &lt;div class="expansion-grid"&gt; &lt;div *ngFor="let key of getObjectKeys(row)" class="expansion-field"&gt; &lt;strong&gt;{{ key }}:&lt;/strong&gt; {{ row[key] }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Empty message --&gt; &lt;ng-template pTemplate="emptymessage"&gt; &lt;tr&gt; &lt;td [attr.colspan]="domainConfig.tableConfig.columns.length + (domainConfig.tableConfig.expandable ? 1 : 0)"&gt; &lt;div class="empty-message"&gt; &lt;i class="pi pi-inbox" style="font-size: 3rem"&gt;&lt;/i&gt; &lt;p&gt;No results found&lt;/p&gt; &lt;p class="empty-hint"&gt;Try adjusting your filters&lt;/p&gt; &lt;/div&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt;</p>

<p>&lt;!-- Loading skeleton --&gt; &lt;ng-template pTemplate="loadingbody"&gt; &lt;tr *ngFor="let i of [1, 2, 3, 4, 5]"&gt; &lt;td [attr.colspan]="domainConfig.tableConfig.columns.length + (domainConfig.tableConfig.expandable ? 1 : 0)"&gt; &lt;p-skeleton width="100%" height="2rem"&gt;&lt;/p-skeleton&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/ng-template&gt; &lt;/p-table&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre></div><div class="page-content"><h3>Step 803.3: Create the Basic Results Table Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/basic-results-table/basic-results-table.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/framework/components/basic-results-table/basic-results-table.component.scss
<p>// VERSION 1 (Section 803) - Results table styles</p>

<p>.basic-results-table-container { display: flex; flex-direction: column; gap: 1rem; padding: 1rem;</p>

<p>.table-container { background: var(--surface-card); border-radius: 6px; padding: 1rem;</p>

<p>::ng-deep .p-datatable { .p-datatable-thead &gt; tr &gt; th, .p-datatable-tbody &gt; tr &gt; td { padding: 0.5rem 0.75rem; border: 1px solid var(--surface-border); }</p>

<p>.p-datatable-thead &gt; tr &gt; th { border-bottom-width: 2px; background: var(--surface-section); font-weight: 600; }</p>

<p>.p-datatable-table { border: 1px solid var(--surface-border); }</p>

<p>.p-paginator { border: none; background: var(--surface-section); }</p>

<p>.p-datatable-table-container { overflow-x: auto; } }</p>

<p>.table-caption { display: flex; justify-content: flex-end; align-items: center; padding: 0.5rem 1rem; background-color: var(--surface-50); border-bottom: 1px solid var(--surface-border);</p>

<p>.caption-count { font-size: 0.875rem; color: var(--text-color-secondary); } }</p>

<p>.empty-message { text-align: center; padding: 3rem 1rem; color: var(--text-color-secondary);</p>

<p>i { color: var(--text-color-secondary); opacity: 0.5; }</p>

<p>p { margin: 1rem 0 0.5rem; font-size: 1.125rem; }</p>

<p>.empty-hint { font-size: 0.875rem; margin: 0.5rem 0 0; } }</p>

<p>.row-expansion { padding: 1.5rem; background: var(--surface-ground); border-left: 3px solid var(--primary-color);</p>

<p>h3 { margin: 0 0 1rem; font-size: 1.125rem; color: var(--text-color); }</p>

<p>.expansion-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 0;</p>

<p>.expansion-field { display: flex; flex-direction: column; gap: 0.25rem; padding: 0.75rem; border: 1px solid var(--surface-border);</p>

<p>strong { color: var(--text-color-secondary); font-size: 0.75rem; text-transform: uppercase; } } } } } }</p>
</code></pre></div><div class="page-content"><h3>Step 803.4: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/basic-results-table/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/basic-results-table/index.ts
<p>// VERSION 1 (Section 803) - Barrel export</p>

<p>export { BasicResultsTableComponent } from './basic-results-table.component';</p>
</code></pre>

<h3>Step 803.5: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p>

<pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 4 (Section 803) - Add BasicResultsTableComponent // Replaces VERSION 3 from Section 802</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { ButtonModule } from 'primeng/button'; import { TableModule } from 'primeng/table'; import { CheckboxModule } from 'primeng/checkbox'; import { InputTextModule } from 'primeng/inputtext'; import { SkeletonModule } from 'primeng/skeleton'; import { MessageModule } from 'primeng/message'; import { RippleModule } from 'primeng/ripple';</p>

<p>import { BaseChartComponent } from './components/base-chart/base-chart.component'; import { BasePickerComponent } from './components/base-picker/base-picker.component'; import { BasicResultsTableComponent } from './components/basic-results-table/basic-results-table.component';</p>

<p>@NgModule({ declarations: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent ], imports: [ CommonModule, FormsModule, ButtonModule, TableModule, CheckboxModule, InputTextModule, SkeletonModule, MessageModule, RippleModule ], exports: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent ] }) export class FrameworkModule {}</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Check TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit
</code></pre>

<p>Expected: No type errors.</p></div><div class="page-content"><h3>3. Verify Observable Bindings</h3>

<p>Check <code class="inline">src/app/framework/components/basic-results-table/basic-results-table.component.ts</code>:</p>
<ul><li><code class="inline">results$</code>, <code class="inline">loading$</code>, <code class="inline">totalResults$</code> are getter properties</li>
<p><li>They delegate to <code class="inline">ResourceManagementService</code></li></p>
</ul>
<h3>4. Verify Template Bindings</h3>

<p>Check <code class="inline">src/app/framework/components/basic-results-table/basic-results-table.component.html</code>:</p>
<ul><li><code class="inline">async</code> pipe is used with all observables</li>
<p><li>Null coalescing (<code class="inline">|| []</code>, <code class="inline">|| 0</code>, <code class="inline">|| false</code>) handles initial null values</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Table shows no data</td> <td><code class="inline">results$</code> returning empty array</td> <td>Verify <code class="inline">ResourceManagementService</code> has data loaded</td></p>
</tr>
<p><tr> <td>Pagination not working</td> <td><code class="inline">[lazy]="true"</code> without <code class="inline">onLazyLoad</code> handler</td> <td>This component uses <code class="inline">onPageChange</code> instead; ensure it updates filters</td></p>
</tr>
<p><tr> <td>Sort not persisting on refresh</td> <td>Sort params not in URL</td> <td>Verify <code class="inline">onSort</code> updates URL state</td></p>
</tr>
<p><tr> <td>Expandable rows not working</td> <td><code class="inline">dataKey</code> not set</td> <td>Ensure <code class="inline">tableConfig.dataKey</code> is set in domain config</td></p>
</tr>
<p><tr> <td><code class="inline">ExpressionChangedAfterItHasBeenCheckedError</code></td> <td>Calling <code class="inline">getCurrentFilters()</code> in template</td> <td>Use computed property instead</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Reactive binding with async pipe</strong> - The template subscribes to observables; no manual subscription management needed</li>
<p><li><strong>Lazy loading enables server-side operations</strong> - The table delegates pagination/sorting to the service</li> <li><strong>Pop-out support is built-in</strong> - The same component works in both main window and pop-out windows</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">BasicResultsTableComponent</code> accepts <code class="inline">domainConfig</code> input</li>
<p><li>[ ] Table columns render from <code class="inline">tableConfig.columns</code></li> <li>[ ] Pagination controls trigger <code class="inline">onPageChange</code> which updates filters</li> <li>[ ] Column headers trigger <code class="inline">onSort</code> which updates filters</li> <li>[ ] Loading skeleton displays while <code class="inline">loading$</code> is true</li> <li>[ ] Empty message displays when <code class="inline">results$</code> is empty</li> <li>[ ] Expandable rows show all object properties (if <code class="inline">tableConfig.expandable</code> is true)</li> <li>[ ] Result count displays in caption</li> <li>[ ] Pop-out window receives state updates via <code class="inline">PopOutContextService</code></li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">804-statistics-panel-component.md</code> to build the chart grid container component.</p></div></div>
    <div class="chapter" id="section-804">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>804: Statistics Panel Component</h1>
        </div>
<div class="page-content"><h1>804: Statistics Panel Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 801-base-chart-component, 306-resource-management-service, 651-654 (Chart Data Sources) <strong>Blocks:</strong> 904-automobile-discover</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to compose multiple chart components into a single panel</li>
<p><li>Know how to implement drag-and-drop reordering with Angular CDK</li> <li>Be able to coordinate chart clicks with URL state updates</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a statistics panel component that renders multiple charts in a draggable grid layout. This component composes <code class="inline">BaseChartComponent</code> instances and handles chart ordering, pop-out functionality, and click event coordination.</p>

<hr>

<h2>Why</h2>

<p>Data discovery applications often display multiple charts showing different statistical views: distributions by manufacturer, year, body type, etc. Rather than hard-coding chart layouts, we build a <strong>Statistics Panel</strong> that:</p>

<ul><li>Accepts an array of chart IDs or reads from <code class="inline">DomainConfig.chartDataSources</code></li>
<p><li>Renders each chart using <code class="inline">BaseChartComponent</code></li> <li>Allows users to reorder charts via drag-and-drop</li> <li>Coordinates click events with URL state</li></p>
</ul>
<p>The Angular CDK (Component Dev Kit) provides drag-and-drop functionality without requiring a full component library.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-02">Style 03-02</a>: Use delegation over inheritance</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-02">Style 05-02</a>: Use input properties for data binding</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>When a user clicks on a chart element (e.g., a bar representing "Toyota"), the click flows:</p>
<ul><li><code class="inline">BaseChartComponent</code> emits <code class="inline">chartClick</code> event</li>
<p><li><code class="inline">StatisticsPanelComponent</code> receives the event and gets the data source</li> <li>Data source's <code class="inline">toUrlParams()</code> converts the click to URL parameters</li> <li>URL state is updated, triggering new API requests</li></p>
</ul>
<p>This maintains our URL-First principle while keeping chart interaction logic in data sources.</p>

<hr>

<h2>What</h2>

<h3>Step 804.1: Install Angular CDK</h3>

<p>The Angular CDK provides drag-and-drop functionality:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npm install @angular/cdk --save</p>
</code></pre>

<p>Verify installation:</p>

<pre class="code-block bash"><code>$ grep "@angular/cdk" package.json
<p>"@angular/cdk": "^13.3.0",</p>
</code></pre></div><div class="page-content"><h3>Step 804.2: Create the Statistics Panel Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/statistics-panel/statistics-panel.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/statistics-panel/statistics-panel.component.ts
<p>// VERSION 1 (Section 804) - Chart grid with drag-drop reordering</p>

<p>import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'; import { CommonModule } from '@angular/common'; import { Observable, Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators';</p>

<p>import { DragDropModule, CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';</p>

<p>import { DomainConfig } from '../../models/domain-config.interface'; import { ChartDataSource } from '../base-chart/chart-data.interface'; import { ResourceManagementService } from '../../services/resource-management.service'; import { UrlStateService } from '../../services/url-state.service'; import { PopOutContextService } from '../../services/popout-context.service'; import { PopOutMessageType } from '../../models/popout.interface'; import { DomainConfigRegistry } from '../../services/domain-config-registry.service';</p>

<p>/**</p>
 <ul><li>Statistics Panel Component</li>
</ul> *
 <ul><li>Renders multiple charts in a CDK drag-drop grid.</li>
</ul> <ul><li>Charts can be reordered by dragging.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;app-statistics-panel</li>
</ul> <ul><li>  [domainConfig]="domainConfig"</li>
</ul> <ul><li>  [chartIds]="['manufacturer', 'year']"</li>
</ul> <ul><li>  (chartPopOut)="onChartPopOut($event)"</li>
</ul> <ul><li>  (chartClicked)="onChartClick($event)"&gt;</li>
</ul> <ul><li>&lt;/app-statistics-panel&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-statistics-panel', templateUrl: './statistics-panel.component.html', styleUrls: ['./statistics-panel.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class StatisticsPanelComponent implements OnInit, OnDestroy {</p>

<p>private readonly destroy$ = new Subject&lt;void&gt;();</p>

<p>/**</p>
   <ul><li>Domain configuration with chart data sources</li>
</ul>   */
<p>@Input() domainConfig!: DomainConfig&lt;any, any, any&gt;;</p>

<p>/**</p>
   <ul><li>Optional subset of chart IDs to display</li>
</ul>   <ul><li>If not provided, all charts from domainConfig.chartDataSources are shown</li>
</ul>   */
<p>@Input() chartIds?: string[];</p>

<p>/**</p>
   <ul><li>Function to check if a chart is popped out</li>
</ul>   <ul><li>Provided by parent component</li>
</ul>   */
<p>@Input() isPanelPoppedOut: (panelId: string) =&gt; boolean = () =&gt; false;</p>

<p>/**</p>
   <ul><li>Emits when user clicks the pop-out button on a chart</li>
</ul>   */
<p>@Output() chartPopOut = new EventEmitter&lt;string&gt;();</p>

<p>/**</p>
   <ul><li>Emits when user clicks on a chart element</li>
</ul>   */
<p>@Output() chartClicked = new EventEmitter&lt;{ event: { value: string; isHighlightMode: boolean }; dataSource: ChartDataSource; }&gt;();</p>

<p>/**</p>
   <ul><li>Ordered list of chart IDs for the grid</li>
</ul>   */
<p>chartOrder: string[] = [];</p>

<p>constructor( private readonly resourceService: ResourceManagementService&lt;any, any, any&gt;, private readonly urlState: UrlStateService, private readonly popOutContext: PopOutContextService, private readonly cdr: ChangeDetectorRef, private readonly domainRegistry: DomainConfigRegistry ) {}</p>

<p>// ============================================================================ // Observable Streams // ============================================================================</p>

<p>get statistics$(): Observable&lt;any | undefined&gt; { return this.resourceService.statistics$; }</p>

<p>get highlights$(): Observable&lt;any&gt; { return this.resourceService.highlights$; }</p>

<p>/**</p>
   <ul><li>Check if running in a pop-out window</li>
</ul>   */
<p>get isInPopOut(): boolean { return this.popOutContext.isInPopOut(); }</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnInit(): void { // If domainConfig not provided (e.g., in pop-out), get from registry if (!this.domainConfig) { this.domainConfig = this.domainRegistry.getActive(); }</p>

<p>// Initialize chart order if (this.chartIds &amp;&amp; this.chartIds.length &gt; 0) { this.chartOrder = this.chartIds; } else if (this.domainConfig.chartDataSources) { this.chartOrder = Object.keys(this.domainConfig.chartDataSources); } }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); }</p>

<p>// ============================================================================ // Event Handlers // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle chart drag-drop to reorder</li>
</ul>   */
<p>onChartDrop(event: CdkDragDrop&lt;string[]&gt;): void { moveItemInArray(this.chartOrder, event.previousIndex, event.currentIndex); this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Handle chart pop-out request</li>
</ul>   */
<p>onChartPopOut(chartId: string): void { this.chartPopOut.emit(chartId); }</p>

<p>/**</p>
   <ul><li>Handle chart click</li>
</ul>   *
   <ul><li>Gets URL params from the data source and updates URL state.</li>
</ul>   */
<p>onChartClick(event: { value: string; isHighlightMode: boolean }, chartId: string): void { const dataSource = this.domainConfig.chartDataSources?.[chartId]; if (!dataSource) return;</p>

<p>// Get URL params from data source const newParams = dataSource.toUrlParams(event.value, event.isHighlightMode);</p>

<p>// Update URL (either directly or via pop-out message) if (this.popOutContext.isInPopOut()) { this.popOutContext.sendMessage({ type: PopOutMessageType.URL_PARAMS_CHANGED, payload: { params: newParams }, timestamp: Date.now() }); } else { this.urlState.setParams(newParams); } }</p>

<p>/**</p>
   <ul><li>Get data source for a chart ID</li>
</ul>   */
<p>getDataSource(chartId: string): ChartDataSource | undefined { return this.domainConfig.chartDataSources?.[chartId]; } }</p>
</code></pre></div><div class="page-content"><h3>Step 804.3: Create the Statistics Panel Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/statistics-panel/statistics-panel.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/framework/components/statistics-panel/statistics-panel.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 804) - Chart grid with drag-drop --&gt;</p>

<p>&lt;div class="statistics-content"&gt; &lt;!-- No data message --&gt; &lt;div *ngIf="!(statistics$ | async)" class="no-data-message"&gt; &lt;i class="pi pi-info-circle"&gt;&lt;/i&gt; &lt;p&gt;No statistics available. Add filters or select data to view distributions.&lt;/p&gt; &lt;/div&gt;</p>

<p>&lt;!-- Chart Grid with CDK Drag-Drop --&gt; &lt;div *ngIf="statistics$ | async" cdkDropList cdkDropListOrientation="horizontal" (cdkDropListDropped)="onChartDrop($event)" class="chart-grid"&gt;</p>

<p>&lt;ng-container *ngFor="let chartId of chartOrder"&gt; &lt;div *ngIf="getDataSource(chartId) as dataSource" class="chart-box" cdkDrag&gt; &lt;!-- Drag Handle --&gt; &lt;div class="chart-drag-handle" cdkDragHandle&gt; &lt;i class="pi pi-bars"&gt;&lt;/i&gt; &lt;/div&gt;</p>

<p>&lt;!-- Chart or Placeholder --&gt; &lt;ng-container *ngIf="isInPopOut || !isPanelPoppedOut('chart-' + chartId); else chartPoppedOut"&gt; &lt;app-base-chart [dataSource]="dataSource" [statistics]="statistics$ | async" [highlights]="highlights$ | async" [selectedValue]="null" [canPopOut]="!isInPopOut" (popOutClick)="onChartPopOut(chartId)" (chartClick)="onChartClick($event, chartId)"&gt; &lt;/app-base-chart&gt; &lt;/ng-container&gt;</p>

<p>&lt;ng-template #chartPoppedOut&gt; &lt;div class="popout-placeholder"&gt; &lt;i class="pi pi-external-link"&gt;&lt;/i&gt; &lt;span&gt;Chart is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/div&gt; &lt;/ng-container&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre>

<h3>Step 804.4: Create the Statistics Panel Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/statistics-panel/statistics-panel.component.scss</code>:</p></div><div class="page-content"><pre class="code-block scss"><code>// src/app/framework/components/statistics-panel/statistics-panel.component.scss
<p>// VERSION 1 (Section 804) - Chart grid styles</p>

<p>.statistics-content { padding: 0.5rem; }</p>

<p>.no-data-message { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem 1rem; text-align: center; color: var(--text-color-secondary);</p>

<p>i.pi { font-size: 3rem; margin-bottom: 1rem; opacity: 0.5; }</p>

<p>p { margin: 0; font-size: 1rem; } }</p>

<p>.chart-grid { display: flex; flex-wrap: wrap; gap: 1rem; padding: 0.5rem; background: var(--surface-ground); border-radius: 6px; border: 1px solid var(--surface-border); min-height: 200px;</p>

<p>.chart-box { // Two charts per row flex: 0 0 calc(50% - 0.5rem); background: var(--surface-card); border-radius: 4px; padding: 1rem; position: relative; box-sizing: border-box;</p>

<p>// Drag handle .chart-drag-handle { position: absolute; top: 0.5rem; left: 0.5rem; cursor: move; padding: 0.25rem 0.5rem; color: var(--text-color-secondary); opacity: 0.6; transition: opacity 0.2s, color 0.2s; z-index: 10;</p>

<p>&amp;:hover { opacity: 1; color: var(--text-color); }</p>

<p>i { font-size: 1rem; } }</p>

<p>app-base-chart { display: block; height: 300px; }</p>

<p>.popout-placeholder { display: flex; align-items: center; justify-content: center; gap: 0.75rem; height: 300px; background-color: var(--surface-ground); border: 2px dashed var(--surface-border); border-radius: 4px; color: var(--text-color-secondary); font-style: italic;</p>

<p>i { font-size: 1.5rem; color: var(--primary-color); } }</p>

<p>// CDK Drag states &amp;.cdk-drag-preview { box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); opacity: 0.95; border: 2px solid var(--primary-color); }</p>

<p>&amp;.cdk-drag-placeholder { opacity: 0.3; background: var(--surface-hover); border: 2px dashed var(--surface-border); } } }</p>

<p>// Responsive adjustments @media (max-width: 1200px) { .chart-grid { .chart-box { flex: 0 0 100%; } } }</p>
</code></pre></div><div class="page-content"><h3>Step 804.5: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/statistics-panel/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/statistics-panel/index.ts
<p>// VERSION 1 (Section 804) - Barrel export</p>

<p>export { StatisticsPanelComponent } from './statistics-panel.component';</p>
</code></pre>

<h3>Step 804.6: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p>

<pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 5 (Section 804) - Add StatisticsPanelComponent // Replaces VERSION 4 from Section 803</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { DragDropModule } from '@angular/cdk/drag-drop'; import { ButtonModule } from 'primeng/button'; import { TableModule } from 'primeng/table'; import { CheckboxModule } from 'primeng/checkbox'; import { InputTextModule } from 'primeng/inputtext'; import { SkeletonModule } from 'primeng/skeleton'; import { MessageModule } from 'primeng/message'; import { RippleModule } from 'primeng/ripple';</p>

<p>import { BaseChartComponent } from './components/base-chart/base-chart.component'; import { BasePickerComponent } from './components/base-picker/base-picker.component'; import { BasicResultsTableComponent } from './components/basic-results-table/basic-results-table.component'; import { StatisticsPanelComponent } from './components/statistics-panel/statistics-panel.component';</p>

<p>@NgModule({ declarations: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent, StatisticsPanelComponent ], imports: [ CommonModule, FormsModule, DragDropModule, ButtonModule, TableModule, CheckboxModule, InputTextModule, SkeletonModule, MessageModule, RippleModule ], exports: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent, StatisticsPanelComponent ] }) export class FrameworkModule {}</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Check CDK Installation</h3>

<pre class="code-block bash"><code>$ npm list @angular/cdk
</code></pre>

<p>Expected: Shows CDK version installed.</p>

<h3>3. Verify Drag-Drop Import</h3>

<pre class="code-block bash"><code>$ grep "DragDropModule" src/app/framework/framework.module.ts
</code></pre>

<p>Expected: <code class="inline">DragDropModule</code> is in imports array.</p>

<h3>4. Manual Inspection</h3>

<p>Check <code class="inline">src/app/framework/components/statistics-panel/statistics-panel.component.html</code>:</p>
<ul><li><code class="inline">cdkDropList</code> is on the grid container</li>
<p><li><code class="inline">cdkDrag</code> is on each chart box</li> <li><code class="inline">cdkDragHandle</code> is on the drag handle element</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">No provider for DragDropModule</code></td> <td>Module not imported</td> <td>Add <code class="inline">DragDropModule</code> to imports in <code class="inline">FrameworkModule</code></td></p>
</tr>
<p><tr> <td>Charts don't reorder</td> <td><code class="inline">cdkDrag</code> not on correct element</td> <td>Ensure <code class="inline">cdkDrag</code> is on <code class="inline">.chart-box</code> div</td></p>
</tr>
<p><tr> <td>Drag preview looks wrong</td> <td>Missing CDK styles</td> <td>Ensure <code class="inline">.cdk-drag-preview</code> and <code class="inline">.cdk-drag-placeholder</code> styles are defined</td></p>
</tr>
<p><tr> <td>Charts overlap during drag</td> <td>Missing <code class="inline">position: relative</code></td> <td>Add <code class="inline">position: relative</code> to <code class="inline">.chart-box</code></td></p>
</tr>
<p><tr> <td>Click events fire during drag</td> <td>CDK captures events</td> <td>This is expected; CDK handles the separation</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>CDK provides powerful primitives</strong> - Drag-drop without a full UI library</li>
<p><li><strong>Composition over inheritance</strong> - StatisticsPanel composes BaseChartComponents</li> <li><strong>URL updates flow through data sources</strong> - The panel doesn't know how to update URLs; it delegates to data sources</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">@angular/cdk</code> is installed and listed in <code class="inline">package.json</code></li>
<p><li>[ ] <code class="inline">StatisticsPanelComponent</code> accepts <code class="inline">domainConfig</code> and optional <code class="inline">chartIds</code> inputs</li> <li>[ ] Charts render in a grid layout (2 per row on desktop, 1 per row on mobile)</li> <li>[ ] Charts can be reordered via drag-and-drop</li> <li>[ ] Drag handle appears on hover</li> <li>[ ] Chart clicks update URL state via data source's <code class="inline">toUrlParams()</code></li> <li>[ ] Pop-out placeholder shows when a chart is in a separate window</li> <li>[ ] "No data" message shows when <code class="inline">statistics$</code> is null</li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">805-inline-filters-component.md</code> to build the compact filter chip display component.</p></div></div>
    <div class="chapter" id="section-805">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>805: Inline Filters Component</h1>
        </div>
<div class="page-content"><h1>805: Inline Filters Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 203-filter-definition-interface, 301-url-state-service, 306-resource-management-service <strong>Blocks:</strong> 904-automobile-discover</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to display active filters as interactive chips</li>
<p><li>Know how to synchronize chip state with URL parameters</li> <li>Be able to implement click-to-edit and click-to-remove functionality</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a compact inline filters component that displays active filters as chips. Each chip shows the filter label and value(s), can be clicked to edit, and has a remove button. This component provides a non-intrusive way to show what filters are currently active.</p>

<hr>

<h2>Why</h2>

<p>Users need to see what filters are active without opening a panel. The <strong>Inline Filters Component</strong> provides:</p>

<ul><li><strong>Visibility</strong>: Users immediately see which filters are applied</li>
<p><li><strong>Quick removal</strong>: One-click removal of any filter</li> <li><strong>Edit access</strong>: Click a chip to open the filter editor</li> <li><strong>Compact display</strong>: Uses minimal vertical space</li></p>
</ul>
<p>This component complements the Query Panel (806) by showing the "output" of filter selections in a condensed format.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-01">Style 03-01</a>: Use single responsibility principle</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-02">Style 05-02</a>: Use input properties for data binding</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>The inline filters component reads active filters from URL state (via <code class="inline">UrlStateService</code>) and displays them as chips. When a chip is removed, the component emits an event that clears the corresponding URL parameter. The component never stores filter state internally - it only reflects URL state.</p>

<hr>

<h2>What</h2>

<h3>Step 805.1: Create the Inline Filters Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/inline-filters/inline-filters.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/inline-filters/inline-filters.component.ts
<p>// VERSION 1 (Section 805) - Active filter chip display</p>

<p>import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'; import { CommonModule } from '@angular/common'; import { Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators';</p>

<p>import { ChipModule } from 'primeng/chip'; import { TooltipModule } from 'primeng/tooltip'; import { ButtonModule } from 'primeng/button';</p>

<p>import { FilterDefinition } from '../../models/filter-definition.interface'; import { UrlStateService } from '../../services/url-state.service';</p>

<p>/**</p>
 <ul><li>Active filter representation for display</li>
</ul> */
<p>export interface ActiveFilterChip { /**</p>
   <ul><li>Filter definition from domain config</li>
</ul>   */
<p>definition: FilterDefinition;</p>

<p>/**</p>
   <ul><li>Display values (may be truncated)</li>
</ul>   */
<p>values: (string | number)[];</p>

<p>/**</p>
   <ul><li>URL parameter value for this filter</li>
</ul>   */
<p>urlValue: string; }</p>

<p>/**</p>
 <ul><li>Inline Filters Component</li>
</ul> *
 <ul><li>Displays active filters as removable chips.</li>
</ul> <ul><li>Reads filter state from URL and emits events for removal/editing.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;app-inline-filters</li>
</ul> <ul><li>  [filterDefinitions]="domainConfig.queryControlFilters"</li>
</ul> <ul><li>  (filterRemove)="onFilterRemove($event)"</li>
</ul> <ul><li>  (filterEdit)="onFilterEdit($event)"&gt;</li>
</ul> <ul><li>&lt;/app-inline-filters&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-inline-filters', templateUrl: './inline-filters.component.html', styleUrls: ['./inline-filters.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class InlineFiltersComponent implements OnInit, OnDestroy {</p>

<p>private readonly destroy$ = new Subject&lt;void&gt;();</p>

<p>/**</p>
   <ul><li>Filter definitions from domain config</li>
</ul>   */
<p>@Input() filterDefinitions: FilterDefinition[] = [];</p>

<p>/**</p>
   <ul><li>Highlight filter definitions (optional)</li>
</ul>   */
<p>@Input() highlightDefinitions: FilterDefinition[] = [];</p>

<p>/**</p>
   <ul><li>Whether to show a "Clear All" button</li>
</ul>   */
<p>@Input() showClearAll = true;</p>

<p>/**</p>
   <ul><li>Emits when a filter chip is removed</li>
</ul>   */
<p>@Output() filterRemove = new EventEmitter&lt;ActiveFilterChip&gt;();</p>

<p>/**</p>
   <ul><li>Emits when a filter chip is clicked for editing</li>
</ul>   */
<p>@Output() filterEdit = new EventEmitter&lt;ActiveFilterChip&gt;();</p>

<p>/**</p>
   <ul><li>Emits when "Clear All" is clicked</li>
</ul>   */
<p>@Output() clearAll = new EventEmitter&lt;void&gt;();</p>

<p>/**</p>
   <ul><li>Active filters derived from URL state</li>
</ul>   */
<p>activeFilters: ActiveFilterChip[] = [];</p>

<p>/**</p>
   <ul><li>Active highlights derived from URL state</li>
</ul>   */
<p>activeHighlights: ActiveFilterChip[] = [];</p>

<p>constructor( private readonly urlState: UrlStateService, private readonly cdr: ChangeDetectorRef ) {}</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnInit(): void { // Subscribe to URL changes to rebuild active filter chips this.urlState.params$ .pipe(takeUntil(this.destroy$)) .subscribe(params =&gt; { this.buildActiveFilters(params); this.buildActiveHighlights(params); this.cdr.markForCheck(); }); }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); }</p>

<p>// ============================================================================ // Active Filter Management // ============================================================================</p>

<p>/**</p>
   <ul><li>Build active filter chips from URL params</li>
</ul>   */
<p>private buildActiveFilters(params: Record&lt;string, any&gt;): void { this.activeFilters = [];</p>

<p>for (const filterDef of this.filterDefinitions) { const chip = this.buildChipFromParams(params, filterDef); if (chip) { this.activeFilters.push(chip); } } }</p>

<p>/**</p>
   <ul><li>Build active highlight chips from URL params</li>
</ul>   */
<p>private buildActiveHighlights(params: Record&lt;string, any&gt;): void { this.activeHighlights = [];</p>

<p>for (const filterDef of this.highlightDefinitions) { const chip = this.buildChipFromParams(params, filterDef); if (chip) { this.activeHighlights.push(chip); } } }</p>

<p>/**</p>
   <ul><li>Build a chip from URL params for a given filter definition</li>
</ul>   */
<p>private buildChipFromParams( params: Record&lt;string, any&gt;, filterDef: FilterDefinition ): ActiveFilterChip | null { if (filterDef.type === 'range') { // Range filters have min/max params const urlParamsConfig = filterDef.urlParams as { min: string; max: string }; const minValue = params[urlParamsConfig.min]; const maxValue = params[urlParamsConfig.max];</p>

<p>if (minValue || maxValue) { const values: (string | number)[] = []; if (minValue) values.push(minValue); if (maxValue) values.push(maxValue);</p>

<p>return { definition: filterDef, values, urlValue: <code class="inline">${minValue || ''}-${maxValue || ''}</code> }; } } else { // Other filters have a single param const paramName = filterDef.urlParams as string; const paramValue = params[paramName];</p>

<p>if (paramValue) { const values = Array.isArray(paramValue) ? paramValue : String(paramValue).split(',');</p>

<p>return { definition: filterDef, values, urlValue: Array.isArray(paramValue) ? paramValue.join(',') : paramValue }; } }</p>

<p>return null; }</p>

<p>// ============================================================================ // Event Handlers // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle chip remove click</li>
</ul>   */
<p>onChipRemove(chip: ActiveFilterChip, event: Event): void { event.stopPropagation(); // Prevent chip click (edit) from firing this.filterRemove.emit(chip); }</p>

<p>/**</p>
   <ul><li>Handle chip click (edit)</li>
</ul>   */
<p>onChipClick(chip: ActiveFilterChip): void { this.filterEdit.emit(chip); }</p>

<p>/**</p>
   <ul><li>Handle clear all click</li>
</ul>   */
<p>onClearAll(): void { this.clearAll.emit(); }</p>

<p>// ============================================================================ // Display Helpers // ============================================================================</p>

<p>/**</p>
   <ul><li>Get display label for a chip</li>
</ul>   */
<p>getChipLabel(chip: ActiveFilterChip): string { if (chip.definition.type === 'range') { const values = chip.values; if (values.length === 2) { return <code class="inline">${chip.definition.label}: ${values[0]} - ${values[1]}</code>; } else if (values.length === 1) { return <code class="inline">${chip.definition.label}: ${values[0]}+</code>; } return chip.definition.label; }</p>

<p>// For multiselect, truncate if too many values const displayValues = chip.values.slice(0, 3).join(', '); const remaining = chip.values.length - 3; return remaining &gt; 0 ? <code class="inline">${chip.definition.label}: ${displayValues}... +${remaining}</code> : <code class="inline">${chip.definition.label}: ${displayValues}</code>; }</p>

<p>/**</p>
   <ul><li>Get tooltip for a chip</li>
</ul>   */
<p>getChipTooltip(chip: ActiveFilterChip): string { return <code class="inline">${chip.definition.label}: ${chip.values.join(', ')} (Click to edit)</code>; }</p>

<p>/**</p>
   <ul><li>Check if there are any active filters or highlights</li>
</ul>   */
<p>get hasActiveFilters(): boolean { return this.activeFilters.length &gt; 0 || this.activeHighlights.length &gt; 0; } }</p>
</code></pre></div><div class="page-content"><h3>Step 805.2: Create the Inline Filters Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/inline-filters/inline-filters.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/framework/components/inline-filters/inline-filters.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 805) - Active filter chips --&gt;</p>

<p>&lt;div class="inline-filters-container" *ngIf="hasActiveFilters"&gt; &lt;!-- Filter Chips --&gt; &lt;div class="filter-chips" *ngIf="activeFilters.length &gt; 0"&gt; &lt;span class="chips-label"&gt;Filters:&lt;/span&gt; &lt;p-chip *ngFor="let chip of activeFilters" [label]="getChipLabel(chip)" [pTooltip]="getChipTooltip(chip)" tooltipPosition="top" [removable]="true" (onRemove)="onChipRemove(chip, $event)" (click)="onChipClick(chip)" styleClass="filter-chip clickable"&gt; &lt;/p-chip&gt; &lt;/div&gt;</p>

<p>&lt;!-- Highlight Chips --&gt; &lt;div class="highlight-chips" *ngIf="activeHighlights.length &gt; 0"&gt; &lt;span class="chips-label"&gt;Highlights:&lt;/span&gt; &lt;p-chip *ngFor="let chip of activeHighlights" [label]="getChipLabel(chip)" [pTooltip]="getChipTooltip(chip)" tooltipPosition="top" [removable]="true" (onRemove)="onChipRemove(chip, $event)" (click)="onChipClick(chip)" styleClass="highlight-chip clickable"&gt; &lt;/p-chip&gt; &lt;/div&gt;</p>

<p>&lt;!-- Clear All Button --&gt; &lt;button *ngIf="showClearAll &amp;&amp; hasActiveFilters" pButton type="button" label="Clear All" icon="pi pi-times" class="p-button-text p-button-sm clear-all-button" (click)="onClearAll()"&gt; &lt;/button&gt; &lt;/div&gt;</p>
</code></pre>

<h3>Step 805.3: Create the Inline Filters Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/inline-filters/inline-filters.component.scss</code>:</p></div><div class="page-content"><pre class="code-block scss"><code>// src/app/framework/components/inline-filters/inline-filters.component.scss
<p>// VERSION 1 (Section 805) - Filter chip styles</p>

<p>.inline-filters-container { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; padding: 0.5rem; background: var(--surface-ground); border-radius: 6px; border: 1px solid var(--surface-border); }</p>

<p>.filter-chips, .highlight-chips { display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem; }</p>

<p>.chips-label { font-size: 0.875rem; font-weight: 600; color: var(--text-color-secondary); margin-right: 0.25rem; }</p>

<p>// Filter chip styling ::ng-deep { .filter-chip { background: var(--primary-color); color: var(--primary-color-text, #ffffff); border-radius: 16px; font-size: 0.875rem;</p>

<p>&amp;.clickable { cursor: pointer; transition: background-color 0.2s, transform 0.1s;</p>

<p>&amp;:hover { background: var(--primary-600, #4338ca); transform: translateY(-1px); } }</p>

<p>.p-chip-remove-icon { color: var(--primary-color-text, #ffffff); margin-left: 0.5rem;</p>

<p>&amp;:hover { color: var(--red-400, #f87171); } } }</p>

<p>.highlight-chip { background: var(--yellow-500, #eab308); color: var(--gray-900, #111827); border-radius: 16px; font-size: 0.875rem;</p>

<p>&amp;.clickable { cursor: pointer; transition: background-color 0.2s, transform 0.1s;</p>

<p>&amp;:hover { background: var(--yellow-600, #ca8a04); transform: translateY(-1px); } }</p>

<p>.p-chip-remove-icon { color: var(--gray-900, #111827); margin-left: 0.5rem;</p>

<p>&amp;:hover { color: var(--red-600, #dc2626); } } } }</p>

<p>.clear-all-button { margin-left: auto; color: var(--text-color-secondary);</p>

<p>&amp;:hover { color: var(--red-500, #ef4444); background: var(--red-50, #fef2f2); } }</p>

<p>// Responsive @media (max-width: 768px) { .inline-filters-container { flex-direction: column; align-items: flex-start; }</p>

<p>.clear-all-button { margin-left: 0; margin-top: 0.5rem; } }</p>
</code></pre></div><div class="page-content"><h3>Step 805.4: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/inline-filters/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/inline-filters/index.ts
<p>// VERSION 1 (Section 805) - Barrel export</p>

<p>export { InlineFiltersComponent, ActiveFilterChip } from './inline-filters.component';</p>
</code></pre>

<h3>Step 805.5: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p>

<pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 6 (Section 805) - Add InlineFiltersComponent // Replaces VERSION 5 from Section 804</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { DragDropModule } from '@angular/cdk/drag-drop'; import { ButtonModule } from 'primeng/button'; import { TableModule } from 'primeng/table'; import { CheckboxModule } from 'primeng/checkbox'; import { InputTextModule } from 'primeng/inputtext'; import { SkeletonModule } from 'primeng/skeleton'; import { MessageModule } from 'primeng/message'; import { RippleModule } from 'primeng/ripple'; import { ChipModule } from 'primeng/chip'; import { TooltipModule } from 'primeng/tooltip';</p>

<p>import { BaseChartComponent } from './components/base-chart/base-chart.component'; import { BasePickerComponent } from './components/base-picker/base-picker.component'; import { BasicResultsTableComponent } from './components/basic-results-table/basic-results-table.component'; import { StatisticsPanelComponent } from './components/statistics-panel/statistics-panel.component'; import { InlineFiltersComponent } from './components/inline-filters/inline-filters.component';</p>

<p>@NgModule({ declarations: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent, StatisticsPanelComponent, InlineFiltersComponent ], imports: [ CommonModule, FormsModule, DragDropModule, ButtonModule, TableModule, CheckboxModule, InputTextModule, SkeletonModule, MessageModule, RippleModule, ChipModule, TooltipModule ], exports: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent, StatisticsPanelComponent, InlineFiltersComponent ] }) export class FrameworkModule {}</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Check TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit
</code></pre>

<p>Expected: No type errors.</p>

<h3>3. Verify PrimeNG Chip Import</h3>

<pre class="code-block bash"><code>$ grep "ChipModule" src/app/framework/framework.module.ts
</code></pre>

<p>Expected: <code class="inline">ChipModule</code> is in imports array.</p>

<h3>4. Manual Inspection</h3>

<p>Check <code class="inline">src/app/framework/components/inline-filters/inline-filters.component.ts</code>:</p>
<ul><li>Subscribes to <code class="inline">urlState.params$</code></li>
<p><li>Builds chips from URL parameters</li> <li>Emits events for remove/edit/clear all</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Chips not showing</td> <td>URL params not matching filter definitions</td> <td>Verify <code class="inline">urlParams</code> in filter definitions match actual URL param names</td></p>
</tr>
<p><tr> <td>Remove button doesn't work</td> <td>Event propagation</td> <td>Verify <code class="inline">event.stopPropagation()</code> is called in <code class="inline">onChipRemove</code></td></p>
</tr>
<p><tr> <td>Chip click and remove both fire</td> <td>Missing stop propagation</td> <td>Add <code class="inline">event.stopPropagation()</code> to remove handler</td></p>
</tr>
<p><tr> <td>Highlights not distinguishable</td> <td>Same styling as filters</td> <td>Verify <code class="inline">.highlight-chip</code> has different background color</td></p>
</tr>
<p><tr> <td>Chips wrap incorrectly</td> <td>Missing <code class="inline">flex-wrap</code></td> <td>Ensure container has <code class="inline">flex-wrap: wrap</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Chips provide compact filter visibility</strong> - Users see active filters at a glance</li>
<p><li><strong>Events enable parent coordination</strong> - The component doesn't modify URL directly; it emits events</li> <li><strong>Separate filter and highlight sections</strong> - Different visual treatment for different purposes</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">InlineFiltersComponent</code> accepts filter and highlight definitions</li>
<p><li>[ ] Active filters from URL display as chips</li> <li>[ ] Filter chips have primary color styling</li> <li>[ ] Highlight chips have yellow/warning color styling</li> <li>[ ] Clicking a chip emits <code class="inline">filterEdit</code> event</li> <li>[ ] Clicking remove icon emits <code class="inline">filterRemove</code> event</li> <li>[ ] "Clear All" button emits <code class="inline">clearAll</code> event</li> <li>[ ] Chips show truncated values with "+N more" for long lists</li> <li>[ ] Tooltips show full filter details</li> <li>[ ] Component hides when no active filters</li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">806-query-panel-component.md</code> to build the full filter management panel.</p></div></div>
    <div class="chapter" id="section-806">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>806: Query Panel Component</h1>
        </div>
<div class="page-content"><h1>806: Query Panel Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 203-filter-definition-interface, 301-url-state-service, 306-resource-management-service, 802-base-picker-component <strong>Blocks:</strong> 904-automobile-discover</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to render form controls dynamically from configuration</li>
<p><li>Know how to implement debounced input handling for performance</li> <li>Be able to coordinate multiple filter types in a single panel</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a configuration-driven filter panel that renders filter controls dynamically based on <code class="inline">DomainConfig.filters</code>. This component supports multiple filter types (text, number, select, multiselect, autocomplete, range, boolean, date) and integrates with the ResourceManagementService for state updates.</p>

<hr>

<h2>Why</h2>

<p>Every data discovery application needs a way for users to filter results. The challenge is that different domains have different filter requirements: automobiles need year ranges and manufacturer dropdowns; products need category hierarchies and price ranges.</p>

<p>The <strong>Query Panel Component</strong> solves this by:</p>

<ul><li>Reading filter definitions from <code class="inline">DomainConfig.filters</code></li>
<p><li>Rendering appropriate PrimeNG controls for each filter type</li> <li>Handling value changes with debouncing for performance</li> <li>Syncing all filter state with URL parameters</li></p>
</ul>
<p>This is the Phase 8 pattern: <strong>Generic components + specific configuration = infinite reusability</strong>.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-01">Style 03-01</a>: Use single responsibility principle</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-04">Style 05-04</a>: Put logic in the component class</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>When a user changes a filter value:</p>
<ul><li>The component updates its local model immediately (for UI responsiveness)</li>
<p><li>After debounce delay (for text inputs), it calls <code class="inline">ResourceManagementService.updateFilters()</code></li> <li>ResourceManagementService updates URL state</li> <li>URL change triggers new API request</li></p>
</ul>
<p>This flow ensures filters are shareable via URL and survive page refreshes.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 806.1: Create the Query Panel Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/query-panel/query-panel.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/query-panel/query-panel.component.ts
<p>// VERSION 1 (Section 806) - Configuration-driven filter panel</p>

<p>import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { HttpClient } from '@angular/common/http'; import { Observable, Subject } from 'rxjs'; import { takeUntil, filter, debounceTime } from 'rxjs/operators';</p>

<p>import { InputTextModule } from 'primeng/inputtext'; import { InputNumberModule } from 'primeng/inputnumber'; import { ButtonModule } from 'primeng/button'; import { DropdownModule } from 'primeng/dropdown'; import { MultiSelectModule } from 'primeng/multiselect'; import { AutoCompleteModule } from 'primeng/autocomplete'; import { CheckboxModule } from 'primeng/checkbox'; import { CalendarModule } from 'primeng/calendar';</p>

<p>import { DomainConfig, FilterDefinition, FilterOption } from '../../models/domain-config.interface'; import { ResourceManagementService } from '../../services/resource-management.service'; import { PopOutContextService } from '../../services/popout-context.service'; import { PopOutMessageType } from '../../models/popout.interface';</p>

<p>/**</p>
 <ul><li>Query Panel Component</li>
</ul> *
 <ul><li>Domain-agnostic filter panel that renders controls based on configuration.</li>
</ul> *
 <ul><li>Supported filter types:</li>
</ul> <ul><li>- text: Text input with clear button</li>
</ul> <ul><li>- number: Numeric input with spinner</li>
</ul> <ul><li>- range: Dual inputs for min/max values</li>
</ul> <ul><li>- select: Single-select dropdown</li>
</ul> <ul><li>- multiselect: Multi-select dropdown</li>
</ul> <ul><li>- autocomplete: Text input with suggestions from API</li>
</ul> <ul><li>- date: Date picker</li>
</ul> <ul><li>- boolean: Checkbox</li>
</ul> *
 <ul><li>@template TFilters - Domain-specific filter model type</li>
</ul> <ul><li>@template TData - Domain-specific data model type</li>
</ul> <ul><li>@template TStatistics - Domain-specific statistics model type</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;app-query-panel</li>
</ul> <ul><li>  [domainConfig]="automobileDomainConfig"&gt;</li>
</ul> <ul><li>&lt;/app-query-panel&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-query-panel', templateUrl: './query-panel.component.html', styleUrls: ['./query-panel.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class QueryPanelComponent&lt;TFilters = any, TData = any, TStatistics = any&gt; implements OnInit, OnDestroy {</p>

<p>/**</p>
   <ul><li>Domain configuration with filter definitions</li>
</ul>   */
<p>@Input() domainConfig!: DomainConfig&lt;TFilters, TData, TStatistics&gt;;</p>

<p>/**</p>
   <ul><li>Emits when URL parameters should be updated (for pop-out sync)</li>
</ul>   */
<p>@Output() urlParamsChange = new EventEmitter&lt;{ [key: string]: any }&gt;();</p>

<p>/**</p>
   <ul><li>Emits when all filters should be cleared</li>
</ul>   */
<p>@Output() clearAllFilters = new EventEmitter&lt;void&gt;();</p>

<p>/**</p>
   <ul><li>Observable of current filter state</li>
</ul>   */
<p>filters$!: Observable&lt;TFilters&gt;;</p>

<p>/**</p>
   <ul><li>Local filter values (for form binding)</li>
</ul>   */
<p>currentFilters: Record&lt;string, any&gt; = {};</p>

<p>/**</p>
   <ul><li>Dynamic options loaded from API</li>
</ul>   */
<p>dynamicOptions: Record&lt;string, FilterOption[]&gt; = {};</p>

<p>/**</p>
   <ul><li>Autocomplete suggestions by filter ID</li>
</ul>   */
<p>autocompleteSuggestions: Record&lt;string, string[]&gt; = {};</p>

<p>private destroy$ = new Subject&lt;void&gt;(); private searchSubject = new Subject&lt;{ field: string; value: any }&gt;();</p>

<p>constructor( private resourceService: ResourceManagementService&lt;TFilters, TData, TStatistics&gt;, private cdr: ChangeDetectorRef, private http: HttpClient, private popOutContext: PopOutContextService ) { // Setup debounced search for text inputs this.searchSubject.pipe( debounceTime(300), takeUntil(this.destroy$) ).subscribe(({ field, value }) =&gt; { this.applyFilterChange(field, value); }); }</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnInit(): void { if (!this.domainConfig) { throw new Error('QueryPanelComponent requires domainConfig input'); }</p>

<p>// Load dynamic options for filters with endpoints this.loadDynamicFilterOptions();</p>

<p>// Subscribe to filter state this.filters$ = this.resourceService.filters$;</p>

<p>this.filters$ .pipe(takeUntil(this.destroy$)) .subscribe(filters =&gt; { this.currentFilters = { ...filters as any }; this.cdr.markForCheck(); });</p>

<p>// Pop-out window support if (this.popOutContext.isInPopOut()) { this.popOutContext .getMessages$() .pipe( filter(msg =&gt; msg.type === PopOutMessageType.STATE_UPDATE), takeUntil(this.destroy$) ) .subscribe(message =&gt; { if (message.payload &amp;&amp; message.payload.state) { this.resourceService.syncStateFromExternal(message.payload.state); this.cdr.markForCheck(); } }); } }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); }</p>

<p>// ============================================================================ // Filter Change Handling // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle filter input change</li>
</ul>   *
   <ul><li>@param field - Filter field ID</li>
</ul>   <ul><li>@param value - New value</li>
</ul>   <ul><li>@param debounce - Whether to debounce this change</li>
</ul>   */
<p>onFilterChange(field: string, value: any, debounce = false): void { // Update local model immediately this.currentFilters[field] = value;</p>

<p>if (debounce) { this.searchSubject.next({ field, value }); } else { this.applyFilterChange(field, value); } }</p>

<p>/**</p>
   <ul><li>Apply filter change to state management</li>
</ul>   */
<p>private applyFilterChange(field: string, value: any): void { const isEmpty = value === null || value === undefined || value === '' || (Array.isArray(value) &amp;&amp; value.length === 0);</p>

<p>const paramValue = isEmpty ? null : value;</p>

<p>if (this.popOutContext.isInPopOut()) { // In pop-out: emit event for parent this.urlParamsChange.emit({ [field]: paramValue, page: 1 }); } else { // In main window: update ResourceManagementService const newFilters: Record&lt;string, any&gt; = { ...this.currentFilters, page: 1 };</p>

<p>if (isEmpty) { newFilters[field] = undefined; } else { newFilters[field] = value; }</p>

<p>this.resourceService.updateFilters(newFilters as unknown as TFilters); } }</p>

<p>/**</p>
   <ul><li>Clear all filters</li>
</ul>   */
<p>clearFilters(): void { if (this.popOutContext.isInPopOut()) { this.clearAllFilters.emit(); } else { this.resourceService.updateFilters({ page: 1, size: this.currentFilters['size'] || 20 } as unknown as TFilters); } }</p>

<p>// ============================================================================ // Options Management // ============================================================================</p>

<p>/**</p>
   <ul><li>Get options for a filter</li>
</ul>   */
<p>getFilterOptions(filterId: string): FilterOption[] { if (this.dynamicOptions[filterId]) { return this.dynamicOptions[filterId]; } const filterDef = this.domainConfig.filters.find(f =&gt; f.id === filterId); return filterDef?.options || []; }</p>

<p>/**</p>
   <ul><li>Load dynamic options from API</li>
</ul>   */
<p>private loadDynamicFilterOptions(): void { const filtersWithEndpoint = this.domainConfig.filters.filter(f =&gt; f.optionsEndpoint);</p>

<p>filtersWithEndpoint.forEach(filterDef =&gt; { const endpoint = <code class="inline">${this.domainConfig.apiBaseUrl}/agg/${filterDef.optionsEndpoint}</code>;</p>

<p>this.http.get&lt;{ field: string; values: Array&lt;{ value: string; count: number }&gt; }&gt;(endpoint) .pipe(takeUntil(this.destroy$)) .subscribe({ next: (response) =&gt; { this.dynamicOptions[filterDef.id] = response.values.map(item =&gt; ({ value: item.value, label: item.value })); this.cdr.markForCheck(); }, error: (err) =&gt; { console.error(<code class="inline">Failed to load options for ${filterDef.id}:</code>, err); } }); }); }</p>

<p>// ============================================================================ // Autocomplete // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle autocomplete search</li>
</ul>   */
<p>onAutocompleteSearch(event: { query: string }, filterDef: FilterDefinition): void { if (!filterDef.autocompleteEndpoint) { return; }</p>

<p>const query = event.query; const limit = 10; const endpoint = <code class="inline">${this.domainConfig.apiBaseUrl}/${filterDef.autocompleteEndpoint}?search=${encodeURIComponent(query)}&amp;limit=${limit}</code>;</p>

<p>this.http.get&lt;Record&lt;string, string[]&gt;&gt;(endpoint) .pipe(takeUntil(this.destroy$)) .subscribe({ next: (response) =&gt; { const values = Object.values(response)[0] || []; this.autocompleteSuggestions[filterDef.id] = values; this.cdr.detectChanges(); }, error: () =&gt; { this.autocompleteSuggestions[filterDef.id] = []; this.cdr.detectChanges(); } }); }</p>

<p>/**</p>
   <ul><li>Handle autocomplete focus - load initial suggestions</li>
</ul>   */
<p>onAutocompleteFocus(filterDef: FilterDefinition): void { if (this.autocompleteSuggestions[filterDef.id]?.length &gt; 0) { return; } this.onAutocompleteSearch({ query: '' }, filterDef); } }</p>
</code></pre></div><div class="page-content"><h3>Step 806.2: Create the Query Panel Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/query-panel/query-panel.component.html</code>:</p></div><div class="page-content"><pre class="code-block html"><code>&lt;!-- src/app/framework/components/query-panel/query-panel.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 806) - Dynamic filter controls --&gt;</p>

<p>&lt;div class="query-panel-container"&gt; &lt;div class="filter-panel-container"&gt; &lt;div class="filter-grid"&gt; &lt;!-- Dynamic Filter Rendering --&gt; &lt;ng-container *ngFor="let filterDef of domainConfig.filters"&gt; &lt;!-- Skip search filter (handled separately) --&gt; &lt;ng-container *ngIf="filterDef.id !== 'search'"&gt; &lt;div class="filter-field"&gt; &lt;label [for]="filterDef.id"&gt;{{ filterDef.label }}&lt;/label&gt;</p>

<p>&lt;!-- Text Input --&gt; &lt;ng-container *ngIf="filterDef.type === 'text'"&gt; &lt;span class="p-input-icon-right" style="display: block;"&gt; &lt;i *ngIf="currentFilters[filterDef.id]" class="pi pi-times" (click)="onFilterChange(filterDef.id, null)" style="cursor: pointer;"&gt;&lt;/i&gt; &lt;input pInputText [id]="filterDef.id" [(ngModel)]="currentFilters[filterDef.id]" (ngModelChange)="onFilterChange(filterDef.id, $event, true)" [placeholder]="filterDef.placeholder || ''" style="width: 100%;"&gt; &lt;/span&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Number Input --&gt; &lt;ng-container *ngIf="filterDef.type === 'number'"&gt; &lt;div class="p-inputgroup"&gt; &lt;p-inputNumber [id]="filterDef.id" [(ngModel)]="currentFilters[filterDef.id]" (ngModelChange)="onFilterChange(filterDef.id, $event)" [showButtons]="true" [min]="+(filterDef.min ?? 0)" [max]="+(filterDef.max ?? 999999)" [step]="filterDef.step ?? 1" [placeholder]="filterDef.placeholder || ''"&gt; &lt;/p-inputNumber&gt; &lt;button *ngIf="currentFilters[filterDef.id] != null" pButton type="button" icon="pi pi-times" class="p-button-outlined p-button-secondary" (click)="onFilterChange(filterDef.id, null)"&gt; &lt;/button&gt; &lt;/div&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Range Input (Min) --&gt; &lt;ng-container *ngIf="filterDef.type === 'range'"&gt; &lt;div class="p-inputgroup"&gt; &lt;p-inputNumber [id]="filterDef.id + 'Min'" [(ngModel)]="currentFilters[filterDef.id + 'Min']" (ngModelChange)="onFilterChange(filterDef.id + 'Min', $event)" [showButtons]="true" [min]="+(filterDef.min ?? 0)" [max]="+(filterDef.max ?? 999999)" placeholder="Min"&gt; &lt;/p-inputNumber&gt; &lt;button *ngIf="currentFilters[filterDef.id + 'Min'] != null" pButton type="button" icon="pi pi-times" class="p-button-outlined p-button-secondary" (click)="onFilterChange(filterDef.id + 'Min', null)"&gt; &lt;/button&gt; &lt;/div&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Select Dropdown --&gt; &lt;ng-container *ngIf="filterDef.type === 'select'"&gt; &lt;p-dropdown [id]="filterDef.id" [(ngModel)]="currentFilters[filterDef.id]" (ngModelChange)="onFilterChange(filterDef.id, $event)" [options]="getFilterOptions(filterDef.id)" optionLabel="label" optionValue="value" [showClear]="true" [filter]="true" filterBy="label" [placeholder]="filterDef.placeholder || 'Select...'"&gt; &lt;/p-dropdown&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Multi-Select --&gt; &lt;ng-container *ngIf="filterDef.type === 'multiselect'"&gt; &lt;p-multiSelect [id]="filterDef.id" [(ngModel)]="currentFilters[filterDef.id]" (ngModelChange)="onFilterChange(filterDef.id, $event)" [options]="getFilterOptions(filterDef.id)" optionLabel="label" optionValue="value" [filter]="true" [showClear]="true" [placeholder]="filterDef.placeholder || 'Select...'"&gt; &lt;/p-multiSelect&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Autocomplete --&gt; &lt;ng-container *ngIf="filterDef.type === 'autocomplete'"&gt; &lt;p-autoComplete [id]="filterDef.id" [(ngModel)]="currentFilters[filterDef.id]" (onSelect)="onFilterChange(filterDef.id, $event)" (onClear)="onFilterChange(filterDef.id, null)" [suggestions]="autocompleteSuggestions[filterDef.id] || []" (completeMethod)="onAutocompleteSearch($event, filterDef)" (onFocus)="onAutocompleteFocus(filterDef)" [minLength]="1" [forceSelection]="false" [placeholder]="filterDef.placeholder || 'Type to search...'" [showClear]="true" [delay]="300" appendTo="body" styleClass="w-full"&gt; &lt;/p-autoComplete&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Date Picker --&gt; &lt;ng-container *ngIf="filterDef.type === 'date'"&gt; &lt;div class="p-inputgroup"&gt; &lt;p-calendar [id]="filterDef.id" [(ngModel)]="currentFilters[filterDef.id]" (ngModelChange)="onFilterChange(filterDef.id, $event)" dateFormat="yy-mm-dd"&gt; &lt;/p-calendar&gt; &lt;button *ngIf="currentFilters[filterDef.id]" pButton type="button" icon="pi pi-times" class="p-button-outlined p-button-secondary" (click)="onFilterChange(filterDef.id, null)"&gt; &lt;/button&gt; &lt;/div&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Boolean Checkbox --&gt; &lt;ng-container *ngIf="filterDef.type === 'boolean'"&gt; &lt;p-checkbox [id]="filterDef.id" [(ngModel)]="currentFilters[filterDef.id]" (ngModelChange)="onFilterChange(filterDef.id, $event)" [binary]="true"&gt; &lt;/p-checkbox&gt; &lt;/ng-container&gt; &lt;/div&gt;</p>

<p>&lt;!-- Range Max (second input) --&gt; &lt;div *ngIf="filterDef.type === 'range'" class="filter-field"&gt; &lt;label [for]="filterDef.id + 'Max'"&gt;{{ filterDef.label }} Max&lt;/label&gt; &lt;div class="p-inputgroup"&gt; &lt;p-inputNumber [id]="filterDef.id + 'Max'" [(ngModel)]="currentFilters[filterDef.id + 'Max']" (ngModelChange)="onFilterChange(filterDef.id + 'Max', $event)" [showButtons]="true" [min]="+(filterDef.min ?? 0)" [max]="+(filterDef.max ?? 999999)" placeholder="Max"&gt; &lt;/p-inputNumber&gt; &lt;button *ngIf="currentFilters[filterDef.id + 'Max'] != null" pButton type="button" icon="pi pi-times" class="p-button-outlined p-button-secondary" (click)="onFilterChange(filterDef.id + 'Max', null)"&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/ng-container&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Clear Filters Button --&gt; &lt;div class="filter-field"&gt; &lt;label&gt;&amp;nbsp;&lt;/label&gt; &lt;button pButton type="button" label="Clear Filters" icon="pi pi-filter-slash" class="p-button-outlined" (click)="clearFilters()"&gt; &lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre></div><div class="page-content"><h3>Step 806.3: Create the Query Panel Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/query-panel/query-panel.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/framework/components/query-panel/query-panel.component.scss
<p>// VERSION 1 (Section 806) - Filter panel styles</p>

<p>.query-panel-container { display: flex; flex-direction: column; gap: 1rem; padding: 1rem;</p>

<p>.filter-panel-container { border: 1px solid var(--surface-border); border-radius: 6px; overflow: hidden; background: var(--surface-card); }</p>

<p>.filter-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1rem; align-items: end; padding: 1rem;</p>

<p>.filter-field { display: flex; flex-direction: column; gap: 0.5rem;</p>

<p>label { font-weight: 600; font-size: 0.875rem; color: var(--text-color); }</p>

<p>input, p-inputNumber, p-dropdown, p-multiSelect, p-calendar, p-autoComplete, p-checkbox { width: 100%; }</p>

<p>// Make PrimeNG components full width ::ng-deep { .p-dropdown, .p-multiselect, .p-calendar, .p-autocomplete { width: 100%; }</p>

<p>.p-autocomplete-input { width: 100%; } } } } }</p>
</code></pre>

<h3>Step 806.4: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/query-panel/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/query-panel/index.ts
<p>// VERSION 1 (Section 806) - Barrel export</p>

<p>export { QueryPanelComponent } from './query-panel.component';</p>
</code></pre>

<h3>Step 806.5: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 7 (Section 806) - Add QueryPanelComponent // Replaces VERSION 6 from Section 805</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { DragDropModule } from '@angular/cdk/drag-drop'; import { ButtonModule } from 'primeng/button'; import { TableModule } from 'primeng/table'; import { CheckboxModule } from 'primeng/checkbox'; import { InputTextModule } from 'primeng/inputtext'; import { InputNumberModule } from 'primeng/inputnumber'; import { SkeletonModule } from 'primeng/skeleton'; import { MessageModule } from 'primeng/message'; import { RippleModule } from 'primeng/ripple'; import { ChipModule } from 'primeng/chip'; import { TooltipModule } from 'primeng/tooltip'; import { DropdownModule } from 'primeng/dropdown'; import { MultiSelectModule } from 'primeng/multiselect'; import { AutoCompleteModule } from 'primeng/autocomplete'; import { CalendarModule } from 'primeng/calendar';</p>

<p>import { BaseChartComponent } from './components/base-chart/base-chart.component'; import { BasePickerComponent } from './components/base-picker/base-picker.component'; import { BasicResultsTableComponent } from './components/basic-results-table/basic-results-table.component'; import { StatisticsPanelComponent } from './components/statistics-panel/statistics-panel.component'; import { InlineFiltersComponent } from './components/inline-filters/inline-filters.component'; import { QueryPanelComponent } from './components/query-panel/query-panel.component';</p>

<p>@NgModule({ declarations: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent, StatisticsPanelComponent, InlineFiltersComponent, QueryPanelComponent ], imports: [ CommonModule, FormsModule, HttpClientModule, DragDropModule, ButtonModule, TableModule, CheckboxModule, InputTextModule, InputNumberModule, SkeletonModule, MessageModule, RippleModule, ChipModule, TooltipModule, DropdownModule, MultiSelectModule, AutoCompleteModule, CalendarModule ], exports: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent, StatisticsPanelComponent, InlineFiltersComponent, QueryPanelComponent ] }) export class FrameworkModule {}</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Check TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit
</code></pre>

<p>Expected: No type errors.</p>

<h3>3. Verify All PrimeNG Imports</h3>

<pre class="code-block bash"><code>$ grep -E "DropdownModule|MultiSelectModule|AutoCompleteModule|CalendarModule" src/app/framework/framework.module.ts
</code></pre>

<p>Expected: All modules are in imports array.</p>

<h3>4. Manual Inspection</h3>

<p>Check <code class="inline">src/app/framework/components/query-panel/query-panel.component.html</code>:</p>
<ul><li>Each filter type has its own <code class="inline">*ngIf</code> block</li>
<p><li>All inputs use <code class="inline">[(ngModel)]</code> for two-way binding</li> <li>Text inputs use <code class="inline">debounce: true</code> in <code class="inline">onFilterChange</code></li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Filter controls not rendering</td> <td><code class="inline">filterDef.type</code> not matching template conditions</td> <td>Verify filter type strings match exactly</td></p>
</tr>
<p><tr> <td>Dropdown options empty</td> <td>Dynamic options not loaded</td> <td>Check <code class="inline">optionsEndpoint</code> in filter definition</td></p>
</tr>
<p><tr> <td>Autocomplete not showing suggestions</td> <td>API endpoint incorrect</td> <td>Verify <code class="inline">autocompleteEndpoint</code> and API response format</td></p>
</tr>
<p><tr> <td>Debounce not working</td> <td><code class="inline">searchSubject</code> not subscribed</td> <td>Ensure constructor sets up debounce subscription</td></p>
</tr>
<p><tr> <td>Clear button doesn't reset page</td> <td><code class="inline">page: 1</code> not included in update</td> <td>Verify <code class="inline">applyFilterChange</code> includes page reset</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Dynamic rendering from configuration</strong> - One component handles all filter types</li>
<p><li><strong>Debounce improves performance</strong> - Text inputs wait before triggering API calls</li> <li><strong>Two-way binding with manual updates</strong> - <code class="inline">ngModel</code> updates local state; <code class="inline">ngModelChange</code> triggers state management</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">QueryPanelComponent</code> accepts <code class="inline">domainConfig</code> input</li>
<p><li>[ ] Text filters render with clear button</li> <li>[ ] Number filters render with spinner buttons</li> <li>[ ] Range filters render as two inputs (Min/Max)</li> <li>[ ] Select filters render as dropdowns</li> <li>[ ] Multiselect filters render as multi-select dropdowns</li> <li>[ ] Autocomplete filters load suggestions from API</li> <li>[ ] Date filters render as date pickers</li> <li>[ ] Boolean filters render as checkboxes</li> <li>[ ] Text inputs debounce for 300ms before applying</li> <li>[ ] "Clear Filters" button resets all filters</li> <li>[ ] Filter changes update URL state</li> <li>[ ] Pop-out window receives state updates</li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">807-column-manager-component.md</code> to build the table column visibility manager.</p></div></div>
    <div class="chapter" id="section-807">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>807: Column Manager Component</h1>
        </div>
<div class="page-content"><h1>807: Column Manager Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 204-table-config-interface, 803-basic-results-table <strong>Blocks:</strong> 904-automobile-discover</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to manage table column visibility with user preferences</li>
<p><li>Know how to persist column settings to localStorage</li> <li>Be able to implement drag-and-drop column reordering</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a column manager component that allows users to show/hide and reorder table columns. The component displays a list of available columns with checkboxes and drag handles, persists preferences to localStorage, and emits column configuration changes to parent components.</p>

<hr>

<h2>Why</h2>

<p>Data tables often have many columns, but users typically only need a subset for their current task. The <strong>Column Manager Component</strong> provides:</p>

<ul><li><strong>Column visibility toggle</strong>: Show/hide columns without losing data</li>
<p><li><strong>Column reordering</strong>: Drag columns to customize display order</li> <li><strong>Persistence</strong>: Settings survive browser refresh</li> <li><strong>Domain-agnostic</strong>: Works with any table configuration</li></p>
</ul>
<p>This enhances user experience by letting each user customize their view.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-01">Style 03-01</a>: Use single responsibility principle</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-02">Style 05-02</a>: Use input properties for data binding</li></p>
</ul>
<h3>LocalStorage Persistence</h3>

<p>Column preferences are stored in localStorage using a domain-specific key:</p>
<pre class="code-block text"><code>vvroom_columns_{domainId}
</code></pre>

<p>This ensures settings persist across sessions and don't conflict between domains.</p>

<hr>

<h2>What</h2>

<h3>Step 807.1: Create the Column Manager Interface</h3>

<p>Create the file <code class="inline">src/app/framework/components/column-manager/column-manager.interface.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/column-manager/column-manager.interface.ts
<p>// VERSION 1 (Section 807) - Column manager types</p>

<p>import { TableColumn } from '../../models/table-config.interface';</p>

<p>/**</p>
 <ul><li>Column visibility state</li>
</ul> */
<p>export interface ColumnState { /**</p>
   <ul><li>Column field name (unique identifier)</li>
</ul>   */
<p>field: string;</p>

<p>/**</p>
   <ul><li>Whether column is visible</li>
</ul>   */
<p>visible: boolean;</p>

<p>/**</p>
   <ul><li>Display order (lower = earlier)</li>
</ul>   */
<p>order: number; }</p>

<p>/**</p>
 <ul><li>Column manager output event</li>
</ul> */
<p>export interface ColumnConfigEvent { /**</p>
   <ul><li>Visible columns in display order</li>
</ul>   */
<p>visibleColumns: TableColumn[];</p>

<p>/**</p>
   <ul><li>All column states (for persistence)</li>
</ul>   */
<p>allColumnStates: ColumnState[]; }</p>
</code></pre></div><div class="page-content"><h3>Step 807.2: Create the Column Manager Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/column-manager/column-manager.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/column-manager/column-manager.component.ts
<p>// VERSION 1 (Section 807) - Table column visibility manager</p>

<p>import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Input, OnDestroy, OnInit, Output } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms';</p>

<p>import { DragDropModule, CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop'; import { CheckboxModule } from 'primeng/checkbox'; import { ButtonModule } from 'primeng/button'; import { DialogModule } from 'primeng/dialog'; import { TooltipModule } from 'primeng/tooltip';</p>

<p>import { TableColumn } from '../../models/table-config.interface'; import { ColumnState, ColumnConfigEvent } from './column-manager.interface';</p>

<p>/**</p>
 <ul><li>Column Manager Component</li>
</ul> *
 <ul><li>Provides UI for managing table column visibility and order.</li>
</ul> <ul><li>Persists settings to localStorage.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;app-column-manager</li>
</ul> <ul><li>  [columns]="tableConfig.columns"</li>
</ul> <ul><li>  [domainId]="'automobile'"</li>
</ul> <ul><li>  (columnConfigChange)="onColumnConfigChange($event)"&gt;</li>
</ul> <ul><li>&lt;/app-column-manager&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-column-manager', templateUrl: './column-manager.component.html', styleUrls: ['./column-manager.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class ColumnManagerComponent implements OnInit, OnDestroy {</p>

<p>/**</p>
   <ul><li>Available columns from table config</li>
</ul>   */
<p>@Input() columns: TableColumn[] = [];</p>

<p>/**</p>
   <ul><li>Domain ID for localStorage key</li>
</ul>   */
<p>@Input() domainId = 'default';</p>

<p>/**</p>
   <ul><li>Minimum number of visible columns required</li>
</ul>   */
<p>@Input() minVisibleColumns = 1;</p>

<p>/**</p>
   <ul><li>Emits when column configuration changes</li>
</ul>   */
<p>@Output() columnConfigChange = new EventEmitter&lt;ColumnConfigEvent&gt;();</p>

<p>/**</p>
   <ul><li>Whether the column manager dialog is visible</li>
</ul>   */
<p>dialogVisible = false;</p>

<p>/**</p>
   <ul><li>Column states for the manager UI</li>
</ul>   */
<p>columnStates: ColumnState[] = [];</p>

<p>private readonly STORAGE_KEY_PREFIX = 'vvroom_columns_';</p>

<p>constructor(private readonly cdr: ChangeDetectorRef) {}</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnInit(): void { this.loadColumnStates(); this.emitCurrentConfig(); }</p>

<p>ngOnDestroy(): void { // Save on destroy in case of unsaved changes this.saveColumnStates(); }</p>

<p>// ============================================================================ // Dialog Management // ============================================================================</p>

<p>/**</p>
   <ul><li>Open the column manager dialog</li>
</ul>   */
<p>openDialog(): void { this.dialogVisible = true; this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Close the dialog and save changes</li>
</ul>   */
<p>closeDialog(): void { this.saveColumnStates(); this.emitCurrentConfig(); this.dialogVisible = false; this.cdr.markForCheck(); }</p>

<p>// ============================================================================ // Column State Management // ============================================================================</p>

<p>/**</p>
   <ul><li>Load column states from localStorage or initialize from input columns</li>
</ul>   */
<p>private loadColumnStates(): void { const storageKey = this.STORAGE_KEY_PREFIX + this.domainId; const savedStates = localStorage.getItem(storageKey);</p>

<p>if (savedStates) { try { const parsed: ColumnState[] = JSON.parse(savedStates);</p>

<p>// Merge saved states with current columns // (handles new columns added since last save) this.columnStates = this.mergeColumnStates(parsed); } catch { // Invalid JSON, initialize fresh this.initializeColumnStates(); } } else { this.initializeColumnStates(); } }</p>

<p>/**</p>
   <ul><li>Initialize column states from input columns</li>
</ul>   */
<p>private initializeColumnStates(): void { this.columnStates = this.columns.map((col, index) =&gt; ({ field: col.field, visible: col.hidden !== true, order: index })); }</p>

<p>/**</p>
   <ul><li>Merge saved states with current columns</li>
</ul>   */
<p>private mergeColumnStates(savedStates: ColumnState[]): ColumnState[] { const savedByField = new Map(savedStates.map(s =&gt; [s.field, s])); const merged: ColumnState[] = [];</p>

<p>// Add states for all current columns this.columns.forEach((col, index) =&gt; { const saved = savedByField.get(col.field); if (saved) { merged.push({ ...saved }); savedByField.delete(col.field); } else { // New column not in saved states merged.push({ field: col.field, visible: col.hidden !== true, order: index + 1000 // Put new columns at end }); } });</p>

<p>// Sort by order merged.sort((a, b) =&gt; a.order - b.order);</p>

<p>// Normalize order values merged.forEach((state, index) =&gt; { state.order = index; });</p>

<p>return merged; }</p>

<p>/**</p>
   <ul><li>Save column states to localStorage</li>
</ul>   */
<p>private saveColumnStates(): void { const storageKey = this.STORAGE_KEY_PREFIX + this.domainId; localStorage.setItem(storageKey, JSON.stringify(this.columnStates)); }</p>

<p>// ============================================================================ // Event Handlers // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle visibility checkbox change</li>
</ul>   */
<p>onVisibilityChange(state: ColumnState): void { // Enforce minimum visible columns const visibleCount = this.columnStates.filter(s =&gt; s.visible).length; if (!state.visible &amp;&amp; visibleCount &lt;= this.minVisibleColumns) { // Can't hide, restore visible state state.visible = true; this.cdr.markForCheck(); return; }</p>

<p>this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Handle drag-drop reordering</li>
</ul>   */
<p>onColumnDrop(event: CdkDragDrop&lt;ColumnState[]&gt;): void { moveItemInArray(this.columnStates, event.previousIndex, event.currentIndex);</p>

<p>// Update order values this.columnStates.forEach((state, index) =&gt; { state.order = index; });</p>

<p>this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Show all columns</li>
</ul>   */
<p>showAll(): void { this.columnStates.forEach(state =&gt; { state.visible = true; }); this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Reset to default column configuration</li>
</ul>   */
<p>resetToDefault(): void { this.initializeColumnStates(); this.cdr.markForCheck(); }</p>

<p>// ============================================================================ // Output // ============================================================================</p>

<p>/**</p>
   <ul><li>Emit current column configuration</li>
</ul>   */
<p>private emitCurrentConfig(): void { // Build visible columns in order const visibleColumns: TableColumn[] = []; const columnsByField = new Map(this.columns.map(c =&gt; [c.field, c]));</p>

<p>this.columnStates .filter(state =&gt; state.visible) .forEach(state =&gt; { const column = columnsByField.get(state.field); if (column) { visibleColumns.push(column); } });</p>

<p>const event: ColumnConfigEvent = { visibleColumns, allColumnStates: [...this.columnStates] };</p>

<p>this.columnConfigChange.emit(event); }</p>

<p>// ============================================================================ // Template Helpers // ============================================================================</p>

<p>/**</p>
   <ul><li>Get column definition for a state</li>
</ul>   */
<p>getColumn(state: ColumnState): TableColumn | undefined { return this.columns.find(c =&gt; c.field === state.field); }</p>

<p>/**</p>
   <ul><li>Check if a column can be hidden</li>
</ul>   */
<p>canHide(state: ColumnState): boolean { const visibleCount = this.columnStates.filter(s =&gt; s.visible).length; return state.visible &amp;&amp; visibleCount &gt; this.minVisibleColumns; } }</p>
</code></pre></div><div class="page-content"><h3>Step 807.3: Create the Column Manager Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/column-manager/column-manager.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/framework/components/column-manager/column-manager.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 807) - Column visibility manager UI --&gt;</p>

<p>&lt;!-- Trigger Button --&gt; &lt;button pButton type="button" icon="pi pi-sliders-h" class="p-button-text p-button-secondary" pTooltip="Manage Columns" tooltipPosition="top" (click)="openDialog()"&gt; &lt;/button&gt;</p>

<p>&lt;!-- Column Manager Dialog --&gt; &lt;p-dialog header="Manage Columns" [(visible)]="dialogVisible" [modal]="true" [style]="{ width: '400px' }" [closable]="true" [closeOnEscape]="true" [dismissableMask]="true" (onHide)="closeDialog()"&gt;</p>

<p>&lt;!-- Dialog Content --&gt; &lt;div class="column-manager-content"&gt; &lt;p class="instructions"&gt; Drag to reorder. Check/uncheck to show/hide columns. &lt;/p&gt;</p>

<p>&lt;!-- Column List with Drag-Drop --&gt; &lt;div cdkDropList (cdkDropListDropped)="onColumnDrop($event)" class="column-list"&gt;</p>

<p>&lt;div *ngFor="let state of columnStates" cdkDrag class="column-item"&gt;</p>

<p>&lt;!-- Drag Handle --&gt; &lt;div class="drag-handle" cdkDragHandle&gt; &lt;i class="pi pi-bars"&gt;&lt;/i&gt; &lt;/div&gt;</p>

<p>&lt;!-- Visibility Checkbox --&gt; &lt;p-checkbox [(ngModel)]="state.visible" [binary]="true" (onChange)="onVisibilityChange(state)" [pTooltip]="!canHide(state) ? 'At least one column must be visible' : ''" tooltipPosition="right"&gt; &lt;/p-checkbox&gt;</p>

<p>&lt;!-- Column Name --&gt; &lt;span class="column-name"&gt; {{ getColumn(state)?.header || state.field }} &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</p>

<p>&lt;!-- Dialog Footer --&gt; &lt;ng-template pTemplate="footer"&gt; &lt;div class="dialog-actions"&gt; &lt;button pButton type="button" label="Show All" icon="pi pi-eye" class="p-button-text" (click)="showAll()"&gt; &lt;/button&gt; &lt;button pButton type="button" label="Reset" icon="pi pi-refresh" class="p-button-text" (click)="resetToDefault()"&gt; &lt;/button&gt; &lt;button pButton type="button" label="Done" icon="pi pi-check" class="p-button-primary" (click)="closeDialog()"&gt; &lt;/button&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/p-dialog&gt;</p>
</code></pre></div><div class="page-content"><h3>Step 807.4: Create the Column Manager Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/column-manager/column-manager.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/framework/components/column-manager/column-manager.component.scss
<p>// VERSION 1 (Section 807) - Column manager styles</p>

<p>.column-manager-content { .instructions { margin: 0 0 1rem 0; font-size: 0.875rem; color: var(--text-color-secondary); } }</p>

<p>.column-list { border: 1px solid var(--surface-border); border-radius: 6px; overflow: hidden; }</p>

<p>.column-item { display: flex; align-items: center; gap: 0.75rem; padding: 0.75rem 1rem; background: var(--surface-card); border-bottom: 1px solid var(--surface-border); cursor: default;</p>

<p>&amp;:last-child { border-bottom: none; }</p>

<p>.drag-handle { cursor: move; color: var(--text-color-secondary); padding: 0.25rem; transition: color 0.2s;</p>

<p>&amp;:hover { color: var(--text-color); }</p>

<p>i { font-size: 1rem; } }</p>

<p>.column-name { flex: 1; font-size: 0.875rem; color: var(--text-color); }</p>

<p>// CDK Drag states &amp;.cdk-drag-preview { box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); background: var(--surface-card); border: 1px solid var(--primary-color); border-radius: 4px; }</p>

<p>&amp;.cdk-drag-placeholder { opacity: 0.4; background: var(--surface-hover); } }</p>

<p>.dialog-actions { display: flex; justify-content: flex-end; gap: 0.5rem; }</p>
</code></pre>

<h3>Step 807.5: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/column-manager/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/column-manager/index.ts
<p>// VERSION 1 (Section 807) - Barrel export</p>

<p>export { ColumnManagerComponent } from './column-manager.component'; export { ColumnState, ColumnConfigEvent } from './column-manager.interface';</p>
</code></pre>

<h3>Step 807.6: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 8 (Section 807) - Add ColumnManagerComponent // Replaces VERSION 7 from Section 806</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { DragDropModule } from '@angular/cdk/drag-drop'; import { ButtonModule } from 'primeng/button'; import { TableModule } from 'primeng/table'; import { CheckboxModule } from 'primeng/checkbox'; import { InputTextModule } from 'primeng/inputtext'; import { InputNumberModule } from 'primeng/inputnumber'; import { SkeletonModule } from 'primeng/skeleton'; import { MessageModule } from 'primeng/message'; import { RippleModule } from 'primeng/ripple'; import { ChipModule } from 'primeng/chip'; import { TooltipModule } from 'primeng/tooltip'; import { DropdownModule } from 'primeng/dropdown'; import { MultiSelectModule } from 'primeng/multiselect'; import { AutoCompleteModule } from 'primeng/autocomplete'; import { CalendarModule } from 'primeng/calendar'; import { DialogModule } from 'primeng/dialog';</p>

<p>import { BaseChartComponent } from './components/base-chart/base-chart.component'; import { BasePickerComponent } from './components/base-picker/base-picker.component'; import { BasicResultsTableComponent } from './components/basic-results-table/basic-results-table.component'; import { StatisticsPanelComponent } from './components/statistics-panel/statistics-panel.component'; import { InlineFiltersComponent } from './components/inline-filters/inline-filters.component'; import { QueryPanelComponent } from './components/query-panel/query-panel.component'; import { ColumnManagerComponent } from './components/column-manager/column-manager.component';</p>

<p>@NgModule({ declarations: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent, StatisticsPanelComponent, InlineFiltersComponent, QueryPanelComponent, ColumnManagerComponent ], imports: [ CommonModule, FormsModule, HttpClientModule, DragDropModule, ButtonModule, TableModule, CheckboxModule, InputTextModule, InputNumberModule, SkeletonModule, MessageModule, RippleModule, ChipModule, TooltipModule, DropdownModule, MultiSelectModule, AutoCompleteModule, CalendarModule, DialogModule ], exports: [ BaseChartComponent, BasePickerComponent, BasicResultsTableComponent, StatisticsPanelComponent, InlineFiltersComponent, QueryPanelComponent, ColumnManagerComponent ] }) export class FrameworkModule {}</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Check TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit
</code></pre>

<p>Expected: No type errors.</p>

<h3>3. Verify LocalStorage Key</h3>

<p>Check <code class="inline">src/app/framework/components/column-manager/column-manager.component.ts</code>:</p>
<ul><li><code class="inline">STORAGE_KEY_PREFIX</code> is defined</li>
<p><li><code class="inline">loadColumnStates</code> reads from localStorage</li> <li><code class="inline">saveColumnStates</code> writes to localStorage</li></p>
</ul>
<h3>4. Verify Drag-Drop Integration</h3>

<p>Check the template:</p>
<ul><li><code class="inline">cdkDropList</code> on the column list</li>
<p><li><code class="inline">cdkDrag</code> on each column item</li> <li><code class="inline">cdkDragHandle</code> on the drag handle</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Column order not persisting</td> <td>localStorage not saving</td> <td>Verify <code class="inline">saveColumnStates</code> is called in <code class="inline">closeDialog</code></td></p>
</tr>
<p><tr> <td>New columns not appearing</td> <td>Merge logic not handling new columns</td> <td>Check <code class="inline">mergeColumnStates</code> adds missing columns</td></p>
</tr>
<p><tr> <td>Can't hide last column</td> <td>Minimum columns check working</td> <td>This is expected behavior; verify <code class="inline">minVisibleColumns</code> input</td></p>
</tr>
<p><tr> <td>Drag preview looks wrong</td> <td>Missing CDK styles</td> <td>Ensure <code class="inline">.cdk-drag-preview</code> styles are defined</td></p>
</tr>
<p><tr> <td>Dialog doesn't close</td> <td><code class="inline">dialogVisible</code> not updating</td> <td>Verify <code class="inline">closeDialog</code> sets <code class="inline">dialogVisible = false</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>LocalStorage provides simple persistence</strong> - No backend required for user preferences</li>
<p><li><strong>Merge handles schema evolution</strong> - New columns appear even if user has saved preferences</li> <li><strong>CDK Drag-Drop is reusable</strong> - Same pattern as StatisticsPanel (Section 804)</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">ColumnManagerComponent</code> accepts <code class="inline">columns</code> and <code class="inline">domainId</code> inputs</li>
<p><li>[ ] Clicking the button opens a dialog</li> <li>[ ] Columns display with checkboxes and drag handles</li> <li>[ ] Checking/unchecking toggles column visibility</li> <li>[ ] Dragging reorders columns</li> <li>[ ] At least one column must remain visible</li> <li>[ ] "Show All" button shows all columns</li> <li>[ ] "Reset" button restores default order and visibility</li> <li>[ ] "Done" button closes dialog and saves settings</li> <li>[ ] Settings persist to localStorage</li> <li>[ ] Settings survive page refresh</li> <li>[ ] <code class="inline">columnConfigChange</code> emits visible columns in correct order</li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">808-statistics-panel-2.md</code> to build the refined CDK horizontal chart grid.</p></div></div>
    <div class="chapter" id="section-808">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>808: Statistics Panel 2</h1>
        </div>
<div class="page-content"><h1>808: Statistics Panel 2 Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 801-base-chart-component, 606-chart-configs, 651-654 (Chart Data Sources) <strong>Blocks:</strong> 809-dockview-statistics-panel, 903-discover-page-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to build a CDK drag-drop chart grid with horizontal orientation</li>
<p><li>Know how to coordinate chart clicks with URL state updates</li> <li>Be able to implement pop-out placeholder patterns for multi-window applications</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a statistics panel component that renders multiple charts in a draggable grid layout using Angular CDK. This component composes <code class="inline">BaseChartComponent</code> instances and handles chart ordering, pop-out functionality, and click event coordination with URL state.</p>

<hr>

<h2>Why</h2>

<p>The original <code class="inline">StatisticsPanelComponent</code> (document 804) introduced the concept of a chart grid. <code class="inline">StatisticsPanel2Component</code> refines this pattern with:</p>

<ul><li><strong>CDK horizontal orientation</strong> — Charts drag horizontally, wrapping to rows</li>
<p><li><strong>Pop-out awareness</strong> — Shows placeholder when a chart is in a separate window</li> <li><strong>Pop-out window support</strong> — Works correctly when rendered inside a pop-out window</li> <li><strong>URL state coordination</strong> — Chart clicks update URL via data sources</li></p>
</ul>
<h3>Why a Second Statistics Panel?</h3>

<p>The application needs different chart layouts in different contexts:</p>
<ul><li><strong>Discover page</strong>: Full statistics panel with all charts</li>
<p><li><strong>Pop-out windows</strong>: Subset of charts (e.g., just manufacturer and models)</li></p>
</ul>
<p><code class="inline">StatisticsPanel2Component</code> supports both via the optional <code class="inline">chartIds</code> input.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-02">Style 03-02</a>: Use delegation over inheritance</li>
<p><li><a href="https://angular.io/guide/styleguide#style-05-02">Style 05-02</a>: Use input properties for data binding</li></p>
</ul>
<h3>URL-First Architecture Reference</h3>

<p>When a user clicks on a chart element:</p>
<ul><li><code class="inline">BaseChartComponent</code> emits <code class="inline">chartClick</code> event with value and highlight mode</li>
<p><li><code class="inline">StatisticsPanel2Component</code> receives the event</li> <li>Data source's <code class="inline">toUrlParams()</code> converts the click to URL parameters</li> <li>URL state is updated (directly or via pop-out message)</li></p>
</ul>
<p>This maintains the URL-First principle: all state flows through the URL.</p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 808.1: Create the Statistics Panel 2 Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/statistics-panel-2/statistics-panel-2.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/statistics-panel-2/statistics-panel-2.component.ts
<p>// VERSION 1 (Section 808) - CDK horizontal chart grid</p>

<p>import { ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter, Inject, Input, OnDestroy, OnInit, Optional, Output } from '@angular/core'; import { ActivatedRoute } from '@angular/router'; import { Observable, Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators'; import { CdkDragDrop, moveItemInArray } from '@angular/cdk/drag-drop';</p>

<p>import { DomainConfig } from '../../models/domain-config.interface'; import { PopOutMessageType } from '../../models/popout.interface'; import { PopOutContextService } from '../../services/popout-context.service'; import { ResourceManagementService } from '../../services/resource-management.service'; import { UrlStateService } from '../../services/url-state.service'; import { DomainConfigRegistry } from '../../services/domain-config-registry.service'; import { ChartDataSource } from '../base-chart/chart-data.interface'; import { IS_POPOUT_TOKEN } from '../../tokens/popout.token';</p>

<p>/**</p>
 <ul><li>Statistics Panel 2 Component</li>
</ul> *
 <ul><li>Renders statistical charts in a CDK horizontal drag-drop grid.</li>
</ul> <ul><li>Charts can be reordered by dragging.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;app-statistics-panel-2</li>
</ul> <ul><li>  [domainConfig]="domainConfig"</li>
</ul> <ul><li>  [chartIds]="['manufacturer', 'top-models']"</li>
</ul> <ul><li>  (chartPopOut)="onChartPopOut($event)"</li>
</ul> <ul><li>  (chartClicked)="onChartClick($event)"&gt;</li>
</ul> <ul><li>&lt;/app-statistics-panel-2&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-statistics-panel-2', templateUrl: './statistics-panel-2.component.html', styleUrls: ['./statistics-panel-2.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush }) export class StatisticsPanel2Component implements OnInit, OnDestroy {</p>

<p>private readonly destroy$ = new Subject&lt;void&gt;();</p>

<p>// ============================================================================ // Inputs // ============================================================================</p>

<p>/**</p>
   <ul><li>Domain configuration with chart data sources</li>
</ul>   */
<p>@Input() domainConfig!: DomainConfig&lt;any, any, any&gt;;</p>

<p>/**</p>
   <ul><li>Optional subset of chart IDs to display</li>
</ul>   <ul><li>If not provided, all charts from domainConfig.chartDataSources are shown</li>
</ul>   */
<p>@Input() chartIds?: string[];</p>

<p>/**</p>
   <ul><li>Function to check if a chart is popped out</li>
</ul>   <ul><li>Provided by parent component (DiscoverComponent)</li>
</ul>   */
<p>@Input() isPanelPoppedOut: (panelId: string) =&gt; boolean = () =&gt; false;</p>

<p>// ============================================================================ // Outputs // ============================================================================</p>

<p>/**</p>
   <ul><li>Emits when user clicks the pop-out button on a chart</li>
</ul>   */
<p>@Output() chartPopOut = new EventEmitter&lt;string&gt;();</p>

<p>/**</p>
   <ul><li>Emits when user clicks on a chart element</li>
</ul>   */
<p>@Output() chartClicked = new EventEmitter&lt;{ event: { value: string; isHighlightMode: boolean }; dataSource: ChartDataSource; }&gt;();</p>

<p>// ============================================================================ // State // ============================================================================</p>

<p>/**</p>
   <ul><li>Ordered list of chart IDs for the grid</li>
</ul>   */
<p>chartOrder: string[] = [];</p>

<p>constructor( private readonly resourceService: ResourceManagementService&lt;any, any, any&gt;, private readonly urlState: UrlStateService, private readonly popOutContext: PopOutContextService, private readonly cdr: ChangeDetectorRef, private readonly domainRegistry: DomainConfigRegistry, @Optional() private readonly route: ActivatedRoute, @Optional() @Inject(IS_POPOUT_TOKEN) private readonly isPopout: boolean ) {}</p>

<p>// ============================================================================ // Observable Streams // ============================================================================</p>

<p>get statistics$(): Observable&lt;any | undefined&gt; { return this.resourceService.statistics$; }</p>

<p>get highlights$(): Observable&lt;any&gt; { return this.resourceService.highlights$; }</p>

<p>/**</p>
   <ul><li>Check if running in a pop-out window</li>
</ul>   */
<p>get isInPopOut(): boolean { return this.popOutContext.isInPopOut(); }</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnInit(): void { // If domainConfig not provided via @Input (e.g., in popout), get from registry if (!this.domainConfig) { this.domainConfig = this.domainRegistry.getActive(); }</p>

<p>// Initialize chart order from chartIds input or domain config if (this.chartIds &amp;&amp; this.chartIds.length &gt; 0) { this.chartOrder = this.chartIds; } else if (this.isPopout &amp;&amp; this.route) { // In popout: extract componentId from URL and map to chart IDs const componentId = this.route.parent?.snapshot.paramMap.get('componentId') ?? null; this.chartOrder = this.getChartIdsForStatisticsPanel(componentId); } else if (this.domainConfig.chartDataSources) { this.chartOrder = Object.keys(this.domainConfig.chartDataSources); } }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); }</p>

<p>// ============================================================================ // Private Methods // ============================================================================</p>

<p>/**</p>
   <ul><li>Map statistics panel ID to chart IDs</li>
</ul>   *
   <ul><li>This mapping determines which charts appear in which pop-out panel.</li>
</ul>   <ul><li>The default configuration splits charts into two panels.</li>
</ul>   */
<p>private getChartIdsForStatisticsPanel(panelId: string | null): string[] { const chartIdMap: { [key: string]: string[] } = { 'statistics-1': ['manufacturer', 'top-models'], 'statistics-2': ['body-class', 'year'] };</p>

<p>if (panelId &amp;&amp; chartIdMap[panelId]) { return chartIdMap[panelId]; }</p>

<p>// Fallback to all charts if panel ID not recognized if (this.domainConfig.chartDataSources) { return Object.keys(this.domainConfig.chartDataSources); } return []; }</p>

<p>// ============================================================================ // Event Handlers // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle chart drag-drop to reorder</li>
</ul>   */
<p>onChartDrop(event: CdkDragDrop&lt;string[]&gt;): void { moveItemInArray(this.chartOrder, event.previousIndex, event.currentIndex); this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Handle chart pop-out request</li>
</ul>   */
<p>onChartPopOut(chartId: string): void { this.chartPopOut.emit(chartId); }</p>

<p>/**</p>
   <ul><li>Handle chart click</li>
</ul>   *
   <ul><li>Gets URL params from the data source and updates URL state.</li>
</ul>   <ul><li>When in a pop-out window, sends the update via message to parent.</li>
</ul>   */
<p>onChartClick(event: { value: string; isHighlightMode: boolean }, chartId: string): void { const dataSource = this.domainConfig.chartDataSources?.[chartId]; if (!dataSource) return;</p>

<p>// Delegate URL param generation to the data source const newParams = dataSource.toUrlParams(event.value, event.isHighlightMode);</p>

<p>// Update URL (either directly or via pop-out message) if (this.popOutContext.isInPopOut()) { this.popOutContext.sendMessage({ type: PopOutMessageType.URL_PARAMS_CHANGED, payload: { params: newParams }, timestamp: Date.now() }); } else { this.urlState.setParams(newParams); } }</p>

<p>/**</p>
   <ul><li>Get data source for a chart ID</li>
</ul>   */
<p>getDataSource(chartId: string): ChartDataSource | undefined { return this.domainConfig.chartDataSources?.[chartId]; } }</p>
</code></pre></div><div class="page-content"><h3>Step 808.2: Create the Statistics Panel 2 Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/statistics-panel-2/statistics-panel-2.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/framework/components/statistics-panel-2/statistics-panel-2.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 808) - CDK horizontal chart grid --&gt;</p>

<p>&lt;div class="statistics-content"&gt; &lt;!-- No data message --&gt; &lt;div *ngIf="!(statistics$ | async)" class="no-data-message"&gt; &lt;i class="pi pi-info-circle"&gt;&lt;/i&gt; &lt;p&gt;No statistics available. Add filters or select data to view distributions.&lt;/p&gt; &lt;/div&gt;</p>

<p>&lt;!-- Chart Grid with CDK Drag-Drop --&gt; &lt;div *ngIf="statistics$ | async" cdkDropList cdkDropListOrientation="horizontal" (cdkDropListDropped)="onChartDrop($event)" class="chart-grid"&gt;</p>

<p>&lt;ng-container *ngFor="let chartId of chartOrder"&gt; &lt;div *ngIf="getDataSource(chartId) as dataSource" class="chart-box" cdkDrag&gt; &lt;!-- Drag Handle --&gt; &lt;div class="chart-drag-handle" cdkDragHandle&gt; &lt;i class="pi pi-bars"&gt;&lt;/i&gt; &lt;/div&gt;</p>

<p>&lt;!-- Chart or Placeholder --&gt; &lt;ng-container *ngIf="isInPopOut || !isPanelPoppedOut('chart-' + chartId); else chartPoppedOut"&gt; &lt;app-base-chart [dataSource]="dataSource" [statistics]="statistics$ | async" [highlights]="highlights$ | async" [selectedValue]="null" [canPopOut]="!isInPopOut" (popOutClick)="onChartPopOut(chartId)" (chartClick)="onChartClick($event, chartId)"&gt; &lt;/app-base-chart&gt; &lt;/ng-container&gt;</p>

<p>&lt;ng-template #chartPoppedOut&gt; &lt;div class="popout-placeholder"&gt; &lt;i class="pi pi-external-link"&gt;&lt;/i&gt; &lt;span&gt;Chart is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/div&gt; &lt;/ng-container&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre>

<h3>Step 808.3: Create the Statistics Panel 2 Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/statistics-panel-2/statistics-panel-2.component.scss</code>:</p></div><div class="page-content"><pre class="code-block scss"><code>// src/app/framework/components/statistics-panel-2/statistics-panel-2.component.scss
<p>// VERSION 1 (Section 808) - CDK horizontal chart grid styles</p>

<p>// When in popout context, hide overflow to prevent scrollbars :host-context(.statistics-2-popout) { display: block; overflow: hidden; height: 100%;</p>

<p>.statistics-content { overflow: hidden; height: 100%; }</p>

<p>.chart-grid { overflow: hidden; max-height: 100%; } }</p>

<p>.statistics-content { padding: 0.5rem; }</p>

<p>.no-data-message { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 3rem 1rem; text-align: center; color: var(--text-color-secondary);</p>

<p>i.pi { font-size: 3rem; margin-bottom: 1rem; opacity: 0.5; }</p>

<p>p { margin: 0; font-size: 1rem; } }</p>

<p>// Chart Grid with CDK Horizontal Drag-Drop .chart-grid { display: flex; flex-wrap: wrap; gap: 1rem; padding: 0.5rem; background: var(--surface-ground); border-radius: 6px; border: 1px solid var(--surface-border); min-height: 200px;</p>

<p>.chart-box { // Each chart takes ~50% width minus gap (2 per row) flex: 0 0 calc(50% - 0.5rem); background: var(--surface-card); border-radius: 4px; padding: 1rem; position: relative; box-sizing: border-box;</p>

<p>// Drag handle positioned in top-left .chart-drag-handle { position: absolute; top: 0.5rem; left: 0.5rem; cursor: move; padding: 0.25rem 0.5rem; color: var(--text-color-secondary); opacity: 0.6; transition: opacity 0.2s, color 0.2s; z-index: 10;</p>

<p>&amp;:hover { opacity: 1; color: var(--text-color); }</p>

<p>i { font-size: 1rem; } }</p>

<p>app-base-chart { display: block; height: 300px; }</p>

<p>.popout-placeholder { display: flex; align-items: center; justify-content: center; gap: 0.75rem; height: 300px; background-color: var(--surface-ground); border: 2px dashed var(--surface-border); border-radius: 4px; color: var(--text-color-secondary); font-style: italic;</p>

<p>i { font-size: 1.5rem; color: var(--primary-color); } }</p>

<p>// CDK Drag states for chart boxes &amp;.cdk-drag-preview { box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3); opacity: 0.95; border: 2px solid var(--primary-color); }</p>

<p>&amp;.cdk-drag-placeholder { opacity: 0.3; background: var(--surface-hover); border: 2px dashed var(--surface-border); } } }</p>

<p>// Responsive adjustments @media (max-width: 1200px) { .chart-grid { .chart-box { flex: 0 0 100%; } } }</p>
</code></pre></div><div class="page-content"><h3>Step 808.4: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/statistics-panel-2/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/statistics-panel-2/index.ts
<p>// VERSION 1 (Section 808) - Barrel export</p>

<p>export { StatisticsPanel2Component } from './statistics-panel-2.component';</p>
</code></pre>

<h3>Step 808.5: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p>

<pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 9 (Section 808) - Add StatisticsPanel2Component // Replaces VERSION 8 from Section 807</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { FormsModule } from '@angular/forms'; import { HttpClientModule } from '@angular/common/http'; import { DragDropModule } from '@angular/cdk/drag-drop'; // ... other imports</p>

<p>import { StatisticsPanel2Component } from './components/statistics-panel-2/statistics-panel-2.component';</p>

<p>@NgModule({ declarations: [ // ... existing components StatisticsPanel2Component ], imports: [ CommonModule, FormsModule, HttpClientModule, DragDropModule, // ... other imports ], exports: [ // ... existing exports StatisticsPanel2Component ] }) export class FrameworkModule {}</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Check TypeScript Compilation</h3>

<pre class="code-block bash"><code>$ npx tsc --noEmit
</code></pre>

<p>Expected: No type errors.</p>

<h3>3. Verify CDK Integration</h3>

<p>Check the template for proper CDK attributes:</p>
<ul><li><code class="inline">cdkDropList</code> on the grid container</li>
<p><li><code class="inline">cdkDropListOrientation="horizontal"</code> for row-based dragging</li> <li><code class="inline">cdkDrag</code> on each chart box</li> <li><code class="inline">cdkDragHandle</code> on the drag handle</li></p>
</ul>
<h3>4. Verify Pop-out Integration</h3>

<p>Check the component:</p>
<ul><li><code class="inline">isInPopOut</code> getter uses <code class="inline">PopOutContextService</code></li>
<p><li><code class="inline">onChartClick</code> sends messages via <code class="inline">PopOutContextService</code> when in pop-out</li> <li><code class="inline">isPanelPoppedOut</code> input allows parent to track pop-out state</li></ul></p></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Charts don't render</td> <td><code class="inline">domainConfig</code> not provided</td> <td>Verify @Input or registry fallback</td></p>
</tr>
<p><tr> <td>Drag not working</td> <td>CDK module not imported</td> <td>Add <code class="inline">DragDropModule</code> to imports</td></p>
</tr>
<p><tr> <td>Pop-out placeholder not showing</td> <td><code class="inline">isPanelPoppedOut</code> not bound</td> <td>Verify parent passes the function</td></p>
</tr>
<p><tr> <td>Click not updating URL</td> <td>Data source not found</td> <td>Verify chartId matches key in <code class="inline">chartDataSources</code></td></p>
</tr>
<p><tr> <td>Charts overlap during drag</td> <td>Missing CSS position</td> <td>Ensure <code class="inline">.chart-box</code> has <code class="inline">position: relative</code></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Horizontal CDK orientation with wrap</strong> — Flexbox handles row wrapping automatically</li>
<p><li><strong>Pop-out awareness is bidirectional</strong> — Component knows when it's in a pop-out AND when its charts are popped out</li> <li><strong>URL updates delegate to data sources</strong> — The panel doesn't know URL structure; data sources handle that</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">StatisticsPanel2Component</code> accepts <code class="inline">domainConfig</code>, <code class="inline">chartIds</code>, and <code class="inline">isPanelPoppedOut</code> inputs</li>
<p><li>[ ] Charts render in a 2-column grid (1 column on mobile)</li> <li>[ ] Charts can be reordered via horizontal drag-and-drop</li> <li>[ ] Drag handle appears in top-left corner of each chart</li> <li>[ ] Chart clicks update URL state via data source's <code class="inline">toUrlParams()</code></li> <li>[ ] When in pop-out window, clicks send messages to parent</li> <li>[ ] Pop-out placeholder shows when a chart is in a separate window</li> <li>[ ] "No data" message shows when <code class="inline">statistics$</code> is null</li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></p>
</ul>
<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">809-dockview-statistics-panel.md</code> to build the tabbed/dockable statistics panel using Dockview.</p></div></div>
    <div class="chapter" id="section-809">
        <div class="chapter-header">
            <div class="chapter-category">Components</div>
            <h1>809: Dockview Statistics Panel</h1>
        </div>
<div class="page-content"><h1>809: Dockview Statistics Panel Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 808-statistics-panel-2, 801-base-chart-component <strong>Blocks:</strong> 903-discover-page-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to integrate Dockview with Angular components</li>
<p><li>Know how to move Angular-rendered elements into Dockview panels via DOM manipulation</li> <li>Be able to create tabbed, resizable panel layouts for data visualization</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build a statistics panel component that renders charts inside Dockview containers with tabbed, resizable, and draggable panels. This provides an alternative layout to the CDK grid, allowing users to arrange charts in a more flexible workspace.</p>

<hr>

<h2>Why</h2>

<p>Different users prefer different layouts for data exploration:</p>

<ul><li><strong>Fixed grid</strong> (StatisticsPanel2) — Simple, predictable, two columns</li>
<p><li><strong>Dockable panels</strong> (DockviewStatisticsPanel) — Flexible, tabbed, resizable</li></p>
</ul>
<p>Dockview provides:</p>
<ul><li><strong>Tabbed panels</strong> — Multiple charts in the same space, switch via tabs</li>
<p><li><strong>Resizable splits</strong> — Drag borders to adjust chart sizes</li> <li><strong>Drag to rearrange</strong> — Drag tabs to reorder or split panels</li> <li><strong>Consistent dark theme</strong> — Matches the application's visual style</li></p>
</ul>
<h3>Why Dockview Instead of Building Custom Panels?</h3>

<p>Building a full-featured docking system is complex:</p>
<ul><li>Tab management with close/reorder</li>
<p><li>Resizable split panes</li> <li>Drop zones for drag operations</li> <li>Serialization/restoration of layouts</li></p>
</ul>
<p>Dockview provides all of this out of the box. We integrate it with Angular via a DOM manipulation pattern.</p>

<h3>The DOM Manipulation Pattern</h3>

<p>Dockview is framework-agnostic and expects to manage its own DOM. Angular components, however, are rendered by Angular's change detection. The pattern:</p>

<ul><li>Render Angular chart components in a hidden container</li>
<p><li>When Dockview creates a panel, move the chart element into the panel</li> <li>When Dockview disposes a panel, move the chart back to the hidden container</li></p>
</ul>
<p>This keeps Angular happy while letting Dockview manage the layout.</p></div><div class="page-content"><h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-03-01">Style 03-01</a>: Use single responsibility principle</li>
<p><li><a href="https://angular.io/guide/styleguide#style-09-01">Style 09-01</a>: Use lifecycle hooks for setup/teardown</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 809.1: Install Dockview</h3>

<p>Install the Dockview core library:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ npm install dockview-core --save</p>
</code></pre>

<p>Verify installation:</p>

<pre class="code-block bash"><code>$ grep "dockview-core" package.json
<p>"dockview-core": "^1.8.0",</p>
</code></pre>

<h3>Step 809.2: Add Dockview Styles to Angular.json</h3>

<p>Dockview requires its CSS to be loaded globally. Open <code class="inline">angular.json</code> and add to the styles array:</p>

<pre class="code-block json"><code>{
<p>"projects": { "vvroom": { "architect": { "build": { "options": { "styles": [ "node_modules/dockview-core/dist/styles/dockview.css", "src/styles.scss" ] } } } } } }</p>
</code></pre>

<h3>Step 809.3: Create the Dockview Statistics Panel Component TypeScript</h3>

<p>Create the file <code class="inline">src/app/framework/components/dockview-statistics-panel/dockview-statistics-panel.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/framework/components/dockview-statistics-panel/dockview-statistics-panel.component.ts
<p>// VERSION 1 (Section 809) - Dockview tabbed chart panels</p>

<p>import { AfterViewInit, ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, EventEmitter, Input, NgZone, OnDestroy, OnInit, Output, QueryList, ViewChild, ViewChildren, ViewEncapsulation } from '@angular/core'; import { Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators'; import { createDockview, DockviewApi, IContentRenderer, themeDark } from 'dockview-core';</p>

<p>import { DomainConfig } from '../../models/domain-config.interface'; import { PopOutMessageType } from '../../models/popout.interface'; import { PopOutContextService } from '../../services/popout-context.service'; import { ResourceManagementService } from '../../services/resource-management.service'; import { UrlStateService } from '../../services/url-state.service'; import { DomainConfigRegistry } from '../../services/domain-config-registry.service'; import { ChartDataSource } from '../base-chart/chart-data.interface';</p>

<p>/**</p>
 <ul><li>Dockview Statistics Panel Component</li>
</ul> *
 <ul><li>Renders charts in a dockview container with tabbed/split panel support.</li>
</ul> <ul><li>Charts are rendered by Angular then moved into Dockview panels via DOM.</li>
</ul> *
 <ul><li>@example</li>
</ul> <ul><li></code></pre>html</li>
</ul> <ul><li>&lt;app-dockview-statistics-panel</li>
</ul> <ul><li>  [domainConfig]="domainConfig"</li>
</ul> <ul><li>  [chartIds]="['manufacturer', 'top-models']"&gt;</li>
</ul> <ul><li>&lt;/app-dockview-statistics-panel&gt;</li>
</ul> <em> <pre class="code-block text"><code> </em>/
<p>@Component({ selector: 'app-dockview-statistics-panel', templateUrl: './dockview-statistics-panel.component.html', styleUrls: ['./dockview-statistics-panel.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush, encapsulation: ViewEncapsulation.None // Required for Dockview CSS overrides }) export class DockviewStatisticsPanelComponent implements OnInit, AfterViewInit, OnDestroy {</p>

<p>private readonly destroy$ = new Subject&lt;void&gt;(); private dockviewApi: DockviewApi | null = null;</p>

<p>@ViewChild('dockviewContainer', { static: true }) dockviewContainer!: ElementRef&lt;HTMLDivElement&gt;;</p>

<p>@ViewChildren('chartElement') chartElements!: QueryList&lt;ElementRef&lt;HTMLDivElement&gt;&gt;;</p>

<p>// ============================================================================ // Inputs // ============================================================================</p>

<p>/**</p>
   <ul><li>Domain configuration with chart data sources</li>
</ul>   */
<p>@Input() domainConfig!: DomainConfig&lt;any, any, any&gt;;</p>

<p>/**</p>
   <ul><li>Chart IDs to display in dockview panels</li>
</ul>   */
<p>@Input() chartIds: string[] = [];</p>

<p>/**</p>
   <ul><li>Function to check if a panel is popped out</li>
</ul>   <ul><li>Uses dockview-chart- prefix for chart panel IDs</li>
</ul>   */
<p>@Input() isPanelPoppedOut: (panelId: string) =&gt; boolean = () =&gt; false;</p>

<p>// ============================================================================ // Outputs // ============================================================================</p>

<p>/**</p>
   <ul><li>Emits when user clicks on a chart element</li>
</ul>   */
<p>@Output() chartClicked = new EventEmitter&lt;{ event: { value: string; isHighlightMode: boolean }; dataSource: ChartDataSource; }&gt;();</p>

<p>/**</p>
   <ul><li>Emits when user clicks the pop-out button on a chart</li>
</ul>   */
<p>@Output() chartPopOut = new EventEmitter&lt;string&gt;();</p>

<p>// ============================================================================ // State // ============================================================================</p>

<p>/**</p>
   <ul><li>Current statistics from resource service</li>
</ul>   */
<p>statistics: any = null;</p>

<p>/**</p>
   <ul><li>Current highlights from resource service</li>
</ul>   */
<p>highlights: any = {};</p>

<p>/**</p>
   <ul><li>Map of chartId to title (from data source)</li>
</ul>   */
<p>chartTitles: Map&lt;string, string&gt; = new Map();</p>

<p>constructor( private readonly resourceService: ResourceManagementService&lt;any, any, any&gt;, private readonly urlState: UrlStateService, private readonly popOutContext: PopOutContextService, private readonly cdr: ChangeDetectorRef, private readonly ngZone: NgZone, private readonly domainRegistry: DomainConfigRegistry ) {}</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnInit(): void { // If domainConfig not provided via @Input, get from registry if (!this.domainConfig) { this.domainConfig = this.domainRegistry.getActive(); }</p>

<p>// Initialize chart titles from data sources this.chartIds.forEach(chartId =&gt; { const dataSource = this.domainConfig.chartDataSources?.[chartId]; if (dataSource) { this.chartTitles.set(chartId, dataSource.getTitle()); } });</p>

<p>// Subscribe to statistics updates this.resourceService.statistics$ .pipe(takeUntil(this.destroy$)) .subscribe(stats =&gt; { this.statistics = stats; this.cdr.markForCheck(); });</p>

<p>// Subscribe to highlights updates this.resourceService.highlights$ .pipe(takeUntil(this.destroy$)) .subscribe(highlights =&gt; { this.highlights = highlights; this.cdr.markForCheck(); }); }</p>

<p>ngAfterViewInit(): void { // Give Angular time to render chart components before initializing Dockview setTimeout(() =&gt; { this.initializeDockview(); }, 100); }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete();</p>

<p>// Dispose dockview to prevent memory leaks if (this.dockviewApi) { this.dockviewApi.dispose(); } }</p>

<p>// ============================================================================ // Dockview Setup // ============================================================================</p>

<p>/**</p>
   <ul><li>Initialize the Dockview instance and populate panels</li>
</ul>   *
   <ul><li>This method:</li>
</ul>   <ul><li>1. Creates a map of chart elements by their data-chart-id attribute</li>
</ul>   <ul><li>2. Creates a Dockview instance with a custom component factory</li>
</ul>   <ul><li>3. Adds panels for each chart, arranged side-by-side</li>
</ul>   */
<p>private initializeDockview(): void { const container = this.dockviewContainer.nativeElement;</p>

<p>// Map to store chart elements by their ID const chartElementsMap = new Map&lt;string, HTMLElement&gt;();</p>

<p>// Find all chart wrapper elements this.chartElements.forEach(el =&gt; { const chartId = el.nativeElement.getAttribute('data-chart-id'); if (chartId) { chartElementsMap.set(chartId, el.nativeElement); } });</p>

<p>// Create dockview instance // Note: disableFloatingGroups prevents conflicts with PopOutManagerService this.dockviewApi = createDockview(container, { disableFloatingGroups: true, theme: themeDark, createComponent: (options): IContentRenderer =&gt; { const chartId = options.id; const chartElement = chartElementsMap.get(chartId);</p>

<p>// Create a wrapper element for the panel content const wrapper = document.createElement('div'); wrapper.className = 'dockview-chart-content'; wrapper.style.width = '100%'; wrapper.style.height = '100%'; wrapper.style.overflow = 'hidden';</p>

<p>// Move the chart element into the wrapper if (chartElement) { chartElement.style.display = 'block'; wrapper.appendChild(chartElement); }</p>

<p>return { element: wrapper, init: () =&gt; {}, dispose: () =&gt; { // Move chart element back to hidden container on dispose if (chartElement) { const hiddenContainer = document.querySelector('.charts-hidden-container'); if (hiddenContainer) { hiddenContainer.appendChild(chartElement); chartElement.style.display = 'none'; } } } }; } });</p>

<p>// Add panels for each chart - side by side layout this.chartIds.forEach((chartId, index) =&gt; { const title = this.chartTitles.get(chartId) || chartId;</p>

<p>if (index === 0) { // First panel - add normally this.dockviewApi!.addPanel({ id: chartId, title: title, component: 'chart' }); } else { // Subsequent panels - add to the right of the first panel this.dockviewApi!.addPanel({ id: chartId, title: title, component: 'chart', position: { referencePanel: this.chartIds[0], direction: 'right' } }); } });</p>

<p>// Force layout calculation after panels are added const rect = container.getBoundingClientRect(); if (rect.width &gt; 0 &amp;&amp; rect.height &gt; 0) { this.dockviewApi!.layout(rect.width, rect.height); }</p>

<p>this.cdr.markForCheck(); }</p>

<p>// ============================================================================ // Event Handlers // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle chart click</li>
</ul>   *
   <ul><li>Gets URL params from the data source and updates URL state.</li>
</ul>   */
<p>onChartClick(event: { value: string; isHighlightMode: boolean }, chartId: string): void { const dataSource = this.domainConfig.chartDataSources?.[chartId]; if (!dataSource) return;</p>

<p>// Delegate URL param generation to the data source const newParams = dataSource.toUrlParams(event.value, event.isHighlightMode);</p>

<p>// Update URL (either directly or via pop-out message) if (this.popOutContext.isInPopOut()) { this.popOutContext.sendMessage({ type: PopOutMessageType.URL_PARAMS_CHANGED, payload: { params: newParams }, timestamp: Date.now() }); } else { this.urlState.setParams(newParams); } }</p>

<p>/**</p>
   <ul><li>Handle chart pop-out request</li>
</ul>   */
<p>onChartPopOut(chartId: string): void { this.chartPopOut.emit(chartId); }</p>

<p>/**</p>
   <ul><li>Get data source for a chart ID</li>
</ul>   */
<p>getDataSource(chartId: string): ChartDataSource | undefined { return this.domainConfig.chartDataSources?.[chartId]; }</p>

<p>/**</p>
   <ul><li>Check if a chart is popped out</li>
</ul>   <ul><li>Uses dockview-chart- prefix for panel IDs</li>
</ul>   */
<p>isChartPoppedOut(chartId: string): boolean { return this.isPanelPoppedOut(<code class="inline">dockview-chart-${chartId}</code>); } }</p>
</code></pre></div><div class="page-content"><h3>Step 809.4: Create the Dockview Statistics Panel Template</h3>

<p>Create the file <code class="inline">src/app/framework/components/dockview-statistics-panel/dockview-statistics-panel.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/framework/components/dockview-statistics-panel/dockview-statistics-panel.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 809) - Dockview tabbed chart panels --&gt;</p>

<p>&lt;div class="dockview-statistics-container"&gt; &lt;!-- Dockview container --&gt; &lt;div #dockviewContainer class="dockview-wrapper"&gt;&lt;/div&gt;</p>

<p>&lt;!-- Chart components rendered in hidden container, moved into dockview panels via DOM --&gt; &lt;div class="charts-hidden-container"&gt; &lt;ng-container *ngFor="let chartId of chartIds"&gt; &lt;div #chartElement [attr.data-chart-id]="chartId" class="chart-wrapper" style="display: none;"&gt; &lt;!-- Show chart or placeholder based on pop-out state --&gt; &lt;ng-container *ngIf="!isChartPoppedOut(chartId); else chartPoppedOutPlaceholder"&gt; &lt;app-base-chart *ngIf="getDataSource(chartId) as dataSource" [dataSource]="dataSource" [statistics]="statistics" [highlights]="highlights" [selectedValue]="null" [hideTitle]="true" [canPopOut]="true" (chartClick)="onChartClick($event, chartId)" (popOutClick)="onChartPopOut(chartId)"&gt; &lt;/app-base-chart&gt; &lt;/ng-container&gt; &lt;ng-template #chartPoppedOutPlaceholder&gt; &lt;div class="popout-placeholder"&gt; &lt;i class="pi pi-external-link"&gt;&lt;/i&gt; &lt;span&gt;Chart is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/div&gt; &lt;/ng-container&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre>

<h3>Step 809.5: Create the Dockview Statistics Panel Styles</h3>

<p>Create the file <code class="inline">src/app/framework/components/dockview-statistics-panel/dockview-statistics-panel.component.scss</code>:</p></div><div class="page-content"><pre class="code-block scss"><code>// src/app/framework/components/dockview-statistics-panel/dockview-statistics-panel.component.scss
<p>// VERSION 1 (Section 809) - Dockview styles with dark theme</p>

<p>// Dockview CSS is imported globally in angular.json</p>

<p>.dockview-statistics-container { width: 100%; height: 400px; position: relative; }</p>

<p>.dockview-wrapper { width: 100%; height: 100%; min-height: 400px;</p>

<p>// Ensure dockview takes full space &gt; div { width: 100%; height: 100%; } }</p>

<p>// Hidden container keeps Angular components alive while Dockview manages layout .charts-hidden-container { position: absolute; left: -9999px; top: -9999px; visibility: hidden; pointer-events: none; }</p>

<p>.chart-wrapper { width: 100%; height: 100%; }</p>

<p>// Dockview dark theme overrides :host ::ng-deep { .dockview-theme-dark { --dv-background-color: var(--surface-ground, #1a1a1a); --dv-paneview-header-border-color: var(--surface-border, #333333); --dv-tabs-and-actions-container-background-color: var(--surface-card, #252525); --dv-activegroup-visiblepanel-tab-background-color: var(--surface-ground, #1a1a1a); --dv-activegroup-hiddenpanel-tab-background-color: var(--surface-hover, #2d2d2d); --dv-inactivegroup-visiblepanel-tab-background-color: var(--surface-hover, #2d2d2d); --dv-inactivegroup-hiddenpanel-tab-background-color: var(--surface-card, #252525); --dv-tab-divider-color: var(--surface-border, #404040); --dv-activegroup-visiblepanel-tab-color: var(--text-color, #ffffff); --dv-activegroup-hiddenpanel-tab-color: var(--text-color-secondary, #999999); --dv-inactivegroup-visiblepanel-tab-color: var(--text-color, #cccccc); --dv-inactivegroup-hiddenpanel-tab-color: var(--text-color-secondary, #999999); --dv-separator-border: var(--surface-border, #404040); --dv-paneview-header-background-color: var(--surface-card, #252525); }</p>

<p>.dockview-vue, .dockview-react, .dockview { background-color: var(--surface-ground, #1a1a1a); }</p>

<p>.groupview { background-color: var(--surface-ground, #1a1a1a); }</p>

<p>.tab { font-size: 12px; padding: 4px 12px; }</p>

<p>.dv-resize-container { background-color: var(--surface-ground, #1a1a1a); }</p>

<p>.content-container { background-color: var(--surface-ground, #1a1a1a); } }</p>

<p>.dockview-chart-content { width: 100%; height: 100%; background: var(--surface-ground, #1a1a1a); overflow: hidden;</p>

<p>app-base-chart { display: block; width: 100%; height: 100%; } }</p>

<p>.popout-placeholder { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; min-height: 200px; background: var(--surface-ground, #1a1a1a); color: var(--text-color-secondary, #999999); gap: 12px;</p>

<p>i { font-size: 2rem; color: var(--text-color-secondary, #666666); }</p>

<p>span { font-size: 14px; } }</p>
</code></pre></div><div class="page-content"><h3>Step 809.6: Create the Module Export</h3>

<p>Create the file <code class="inline">src/app/framework/components/dockview-statistics-panel/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/framework/components/dockview-statistics-panel/index.ts
<p>// VERSION 1 (Section 809) - Barrel export</p>

<p>export { DockviewStatisticsPanelComponent } from './dockview-statistics-panel.component';</p>
</code></pre>

<h3>Step 809.7: Register in Framework Module</h3>

<p>Open <code class="inline">src/app/framework/framework.module.ts</code> and add the component:</p>

<pre class="code-block typescript"><code>// src/app/framework/framework.module.ts
<p>// VERSION 10 (Section 809) - Add DockviewStatisticsPanelComponent // Replaces VERSION 9 from Section 808</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; // ... other imports</p>

<p>import { DockviewStatisticsPanelComponent } from './components/dockview-statistics-panel/dockview-statistics-panel.component';</p>

<p>@NgModule({ declarations: [ // ... existing components DockviewStatisticsPanelComponent ], imports: [ CommonModule, // ... other imports ], exports: [ // ... existing exports DockviewStatisticsPanelComponent ] }) export class FrameworkModule {}</p>
</code></pre>

<hr>

<h2>Understanding the DOM Manipulation Pattern</h2>

<p>The hidden container pattern deserves special attention:</p>

<pre class="code-block html"><code>&lt;!-- Charts render here (hidden from view) --&gt;
<p>&lt;div class="charts-hidden-container"&gt; &lt;div #chartElement data-chart-id="manufacturer"&gt; &lt;app-base-chart [dataSource]="..." ...&gt;&lt;/app-base-chart&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre>

<p>When Dockview's <code class="inline">createComponent</code> is called:</p>

<pre class="code-block typescript"><code>createComponent: (options): IContentRenderer =&gt; {
<p>const chartId = options.id; const chartElement = chartElementsMap.get(chartId);</p>

<p>// Move Angular component into Dockview panel wrapper.appendChild(chartElement);</p>

<p>return { element: wrapper, dispose: () =&gt; { // Move back to hidden container hiddenContainer.appendChild(chartElement); } }; }</p>
</code></pre>

<p><strong>Why this works:</strong></p>
<ul><li>Angular renders the chart components normally</li>
<p><li>We physically move the DOM elements into Dockview panels</li> <li>Angular's change detection continues to work because the component instance is unchanged</li> <li>When Dockview disposes a panel, we move the element back to keep it alive</li></ul></p></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ ng build</p>
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Check Dockview Installation</h3>

<pre class="code-block bash"><code>$ npm list dockview-core
</code></pre>

<p>Expected: Shows dockview-core version installed.</p>

<h3>3. Verify Global Styles</h3>

<pre class="code-block bash"><code>$ grep "dockview" angular.json
</code></pre>

<p>Expected: Shows <code class="inline">node_modules/dockview-core/dist/styles/dockview.css</code> in styles array.</p>

<h3>4. Manual Inspection</h3>

<p>Check the component template:</p>
<ul><li><code class="inline">#dockviewContainer</code> is present</li>
<p><li><code class="inline">#chartElement</code> template references are correct</li> <li><code class="inline">data-chart-id</code> attributes are bound</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Dockview not rendering</td> <td>Container has zero height</td> <td>Add <code class="inline">min-height: 400px</code> to <code class="inline">.dockview-wrapper</code></td></p>
</tr>
<p><tr> <td>Charts not visible in panels</td> <td>DOM elements not moved</td> <td>Check <code class="inline">chartElementsMap</code> population in console</td></p>
</tr>
<p><tr> <td>Tabs not styled</td> <td>Global CSS not loaded</td> <td>Verify <code class="inline">angular.json</code> styles array</td></p>
</tr>
<p><tr> <td>TypeError on dispose</td> <td>Element already removed</td> <td>Check for null in dispose callback</td></p>
</tr>
<p><tr> <td>Floating panels appearing</td> <td><code class="inline">disableFloatingGroups</code> not set</td> <td>Verify Dockview options</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Dockview is framework-agnostic</strong> — It manages DOM; we bridge to Angular via element moves</li>
<p><li><strong>Hidden container pattern</strong> — Keeps Angular components alive while Dockview manages layout</li> <li><strong>Disable floating groups</strong> — Prevents conflicts with our custom PopOutManagerService</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">dockview-core</code> package is installed and listed in <code class="inline">package.json</code></li>
<p><li>[ ] Dockview CSS is loaded globally via <code class="inline">angular.json</code></li> <li>[ ] <code class="inline">DockviewStatisticsPanelComponent</code> accepts <code class="inline">domainConfig</code> and <code class="inline">chartIds</code> inputs</li> <li>[ ] Charts render inside Dockview panels with tabs</li> <li>[ ] Panels can be resized by dragging borders</li> <li>[ ] Tabs can be dragged to reorder</li> <li>[ ] Chart clicks update URL state</li> <li>[ ] Pop-out placeholder shows when a chart is in a separate window</li> <li>[ ] Dark theme matches application styling</li> <li>[ ] Component is registered in <code class="inline">FrameworkModule</code></li> <li>[ ] <code class="inline">ng build</code> completes with no errors</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Phase 8 (Framework Components) is now complete. Proceed to Phase 9 to build the feature components that wire everything together.</p></div></div>
    <div class="chapter" id="section-901">
        <div class="chapter-header">
            <div class="chapter-category">Pages</div>
            <h1>901: Home Component</h1>
        </div>
<div class="page-content"><h1>901: Home Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 102-app-shell, 103-routing <strong>Blocks:</strong> 907-final-integration</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to create a landing page component that serves as a domain hub</li>
<p><li>Know how to use Angular's <code class="inline">RouterModule</code> for in-app navigation links</li> <li>Be able to apply CSS Grid to create responsive card layouts</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build the Home component — the application's main entry point that welcomes users and provides navigation to the automobile discovery features. This component establishes the visual identity of vvroom and guides users to explore automobile data.</p>

<hr>

<h2>Why</h2>

<p>Every application needs a home base. The Home component serves several critical purposes:</p>

<ul><li><strong>First Impression</strong> — Users land here first; it sets expectations for the entire application</li>
<p><li><strong>Navigation Hub</strong> — Provides clear pathways to key features without overwhelming users</li> <li><strong>Domain Introduction</strong> — Explains what the application does before diving into specifics</li></p>
</ul>
<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-02-01">Style 02-01</a>: Use consistent naming conventions (<code class="inline">home.component.ts</code>)</li>
<p><li><a href="https://angular.io/guide/styleguide#style-04-07">Style 04-07</a>: Create a folder for each feature component</li></p>
</ul>
<h3>Design Principles</h3>

<p>The Home component is intentionally simple. It contains no business logic, no API calls, and no complex state management. It's pure presentation:</p>

<ul><li>Static content</li>
<p><li>Navigation links</li> <li>Visual styling</li></p>
</ul>
<p>This simplicity is deliberate. The Home component should load instantly and never fail. It's the fallback when something goes wrong elsewhere.</p>

<hr>

<h2>What</h2>

<h3>Step 901.1: Create the Home Component Directory</h3>

<p>First, ensure the home feature directory exists:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ mkdir -p src/app/features/home</p>
</code></pre>

<hr>

<h3>Step 901.2: Create the Home Component</h3>

<p>Create <code class="inline">src/app/features/home/home.component.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/home/home.component.ts
<p>// VERSION 1 (Section 901) - Complete home component with navigation</p>

<p>import { Component } from '@angular/core'; import { RouterModule } from '@angular/router'; import { CommonModule } from '@angular/common';</p>

<p>/**</p>
 <ul><li>Home Component - Landing Page</li>
</ul> *
 <ul><li>Serves as the main entry point for the vvroom application.</li>
</ul> <ul><li>Provides navigation to the automobile discovery features.</li>
</ul> *
 <ul><li>This component is intentionally simple - pure presentation</li>
</ul> <ul><li>with no business logic or state management.</li>
</ul> */
<p>@Component({ selector: 'app-home', templateUrl: './home.component.html', styleUrls: ['./home.component.scss'] }) export class HomeComponent {}</p>
</code></pre>

<p><strong>What this code does:</strong></p>

<table>
<p><thead><tr> <th>Element</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">selector: 'app-home'</code></td> <td>The HTML tag used to render this component</td></p>
</tr>
<p><tr> <td><code class="inline">templateUrl</code></td> <td>External HTML file for better separation of concerns</td></p>
</tr>
<p><tr> <td><code class="inline">styleUrls</code></td> <td>External SCSS file for component-specific styles</td></p>
</tr>
<p><tr> <td>Empty class body</td> <td>No logic needed — this is pure presentation</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h3>Step 901.3: Create the Home Component Template</h3>

<p>Create <code class="inline">src/app/features/home/home.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/features/home/home.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 901) - Home page with domain navigation --&gt;</p>

<p>&lt;div class="home-container"&gt; &lt;!-- Header Section --&gt; &lt;div class="header"&gt; &lt;h1&gt;Vvroom&lt;/h1&gt; &lt;p class="subtitle"&gt;Automobile Discovery Platform&lt;/p&gt; &lt;/div&gt;</p>

<p>&lt;!-- Domain Cards Section --&gt; &lt;div class="domains-section"&gt; &lt;h2&gt;Explore Data&lt;/h2&gt; &lt;div class="domain-grid"&gt; &lt;a routerLink="/automobiles" class="domain-card"&gt; &lt;div class="card-icon"&gt;🚗&lt;/div&gt; &lt;h3&gt;Automobiles&lt;/h3&gt; &lt;p&gt;Browse and analyze vehicle data from thousands of manufacturers&lt;/p&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;</p>

<p>&lt;!-- Quick Start Section --&gt; &lt;div class="quickstart-section"&gt; &lt;h2&gt;Quick Start&lt;/h2&gt; &lt;div class="quickstart-grid"&gt; &lt;div class="quickstart-card"&gt; &lt;div class="step-number"&gt;1&lt;/div&gt; &lt;h4&gt;Select a Domain&lt;/h4&gt; &lt;p&gt;Click on Automobiles above to begin exploring vehicle data&lt;/p&gt; &lt;/div&gt; &lt;div class="quickstart-card"&gt; &lt;div class="step-number"&gt;2&lt;/div&gt; &lt;h4&gt;Apply Filters&lt;/h4&gt; &lt;p&gt;Use the query panel to narrow down results by manufacturer, year, and more&lt;/p&gt; &lt;/div&gt; &lt;div class="quickstart-card"&gt; &lt;div class="step-number"&gt;3&lt;/div&gt; &lt;h4&gt;Analyze Results&lt;/h4&gt; &lt;p&gt;View charts, statistics, and detailed data tables&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre>

<p><strong>Template structure explained:</strong></p>

<table>
<p><thead><tr> <th>Section</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">.header</code></td> <td>Application branding and tagline</td></p>
</tr>
<p><tr> <td><code class="inline">.domains-section</code></td> <td>Navigation cards to feature areas</td></p>
</tr>
<p><tr> <td><code class="inline">.quickstart-section</code></td> <td>User guidance for first-time visitors</td></p>
</tr>
</tbody>
</table>

<p><strong>Note on <code class="inline">routerLink</code>:</strong> The <code class="inline">routerLink</code> directive from <code class="inline">RouterModule</code> creates navigation links that work with Angular's router. Unlike regular <code class="inline">href</code> attributes, <code class="inline">routerLink</code> doesn't cause a full page reload — it performs client-side navigation.</p></div><div class="page-content"><hr>

<h3>Step 901.4: Create the Home Component Styles</h3>

<p>Create <code class="inline">src/app/features/home/home.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/features/home/home.component.scss
<p>// VERSION 1 (Section 901) - Home page styles</p>

<p>.home-container { max-width: 1200px; margin: 0 auto; padding: 2rem; }</p>

<p>// Header styles .header { text-align: center; margin-bottom: 3rem; padding: 2rem 0;</p>

<p>h1 { font-size: 3rem; font-weight: 700; color: #1976d2; margin-bottom: 0.5rem; }</p>

<p>.subtitle { font-size: 1.25rem; color: #666; margin: 0; } }</p>

<p>// Domain cards section .domains-section { margin-bottom: 3rem;</p>

<p>h2 { font-size: 1.5rem; color: #333; margin-bottom: 1.5rem; text-align: center; } }</p>

<p>.domain-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; justify-items: center; }</p>

<p>.domain-card { display: block; background: white; border-radius: 12px; padding: 2rem; text-decoration: none; color: inherit; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); transition: transform 0.2s, box-shadow 0.2s; max-width: 320px; width: 100%; text-align: center;</p>

<p>&amp;:hover { transform: translateY(-4px); box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15); text-decoration: none; }</p>

<p>.card-icon { font-size: 3rem; margin-bottom: 1rem; }</p>

<p>h3 { font-size: 1.25rem; color: #1976d2; margin-bottom: 0.5rem; }</p>

<p>p { font-size: 0.9rem; color: #666; margin: 0; line-height: 1.5; } }</p>

<p>// Quick start section .quickstart-section { background: #f8f9fa; border-radius: 12px; padding: 2rem;</p>

<p>h2 { font-size: 1.5rem; color: #333; margin-bottom: 1.5rem; text-align: center; } }</p>

<p>.quickstart-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 1.5rem; }</p>

<p>.quickstart-card { background: white; border-radius: 8px; padding: 1.5rem; text-align: center;</p>

<p>.step-number { width: 40px; height: 40px; background: #1976d2; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.25rem; font-weight: 600; margin: 0 auto 1rem; }</p>

<p>h4 { font-size: 1rem; color: #333; margin-bottom: 0.5rem; }</p>

<p>p { font-size: 0.875rem; color: #666; margin: 0; line-height: 1.4; } }</p>
</code></pre>

<p><strong>CSS techniques used:</strong></p>

<table>
<p><thead><tr> <th>Technique</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">max-width</code> + <code class="inline">margin: auto</code></td> <td>Centers content with a maximum width</td></p>
</tr>
<p><tr> <td>CSS Grid with <code class="inline">auto-fit</code></td> <td>Creates responsive columns that adapt to screen size</td></p>
</tr>
<p><tr> <td><code class="inline">translateY</code> on hover</td> <td>Provides visual lift effect for interactive cards</td></p>
</tr>
<p><tr> <td><code class="inline">box-shadow</code> transitions</td> <td>Smooth shadow changes on interaction</td></p>
</tr>
<p><tr> <td>SCSS nesting</td> <td>Keeps related styles organized and readable</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h3>Step 901.5: Register the Home Component in a Feature Module</h3>

<p>For Angular 13 with NgModules, create a module for the home feature.</p>

<p>Create <code class="inline">src/app/features/home/home.module.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/home/home.module.ts
<p>// VERSION 1 (Section 901) - Home feature module</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule } from '@angular/router';</p>

<p>import { HomeComponent } from './home.component';</p>

<p>@NgModule({ declarations: [ HomeComponent ], imports: [ CommonModule, RouterModule ], exports: [ HomeComponent ] }) export class HomeModule {}</p>
</code></pre>

<p><strong>Module structure explained:</strong></p>

<table>
<p><thead><tr> <th>Property</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">declarations</code></td> <td>Components that belong to this module</td></p>
</tr>
<p><tr> <td><code class="inline">imports</code></td> <td>Other modules this module depends on</td></p>
</tr>
<p><tr> <td><code class="inline">exports</code></td> <td>Components available to other modules that import HomeModule</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 901.6: Create the Index Barrel Export</h3>

<p>Create <code class="inline">src/app/features/home/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/home/index.ts
<p>// VERSION 1 (Section 901) - Barrel export for home feature</p>

<p>export * from './home.component'; export * from './home.module';</p>
</code></pre>

<p>This barrel export allows clean imports elsewhere in the application:</p>

<pre class="code-block typescript"><code>import { HomeComponent, HomeModule } from './features/home';
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Structure</h3>

<pre class="code-block bash"><code>$ find src/app/features/home -type f | sort
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>src/app/features/home/home.component.html
<p>src/app/features/home/home.component.scss src/app/features/home/home.component.ts src/app/features/home/home.module.ts src/app/features/home/index.ts</p>
</code></pre>

<h3>2. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors. If you see errors about missing routes, that's expected — we'll configure routing in document 905.</p>

<h3>3. Visual Verification (After Routing)</h3>

<p>Once routing is configured (document 905), navigate to <code class="inline">http://localhost:4200/home</code>:</p>

<ul><li>Large "Vvroom" heading with blue color</li>
<p><li>"Automobile Discovery Platform" subtitle</li> <li>Single domain card for Automobiles</li> <li>Three quick-start steps at the bottom</li> <li>Card lifts on hover with shadow effect</li></ul></p></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Component not found error</td> <td>Module not imported in AppModule</td> <td>Add <code class="inline">HomeModule</code> to AppModule imports (done in document 906)</td></p>
</tr>
<p><tr> <td><code class="inline">routerLink</code> not working</td> <td>RouterModule not imported</td> <td>Ensure <code class="inline">RouterModule</code> is in the HomeModule imports</td></p>
</tr>
<p><tr> <td>Styles not applying</td> <td>Wrong file path in <code class="inline">styleUrls</code></td> <td>Verify the path matches the actual file location</td></p>
</tr>
<p><tr> <td>Emoji not displaying</td> <td>System font issue</td> <td>Use an SVG icon instead, or accept platform variation</td></p>
</tr>
<p><tr> <td>Grid layout broken</td> <td>Browser doesn't support CSS Grid</td> <td>Add fallback styles or use flexbox for older browsers</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Feature components live in feature folders</strong> — <code class="inline">src/app/features/home/</code> keeps all home-related files together</li>
<p><li><strong>Simple components are powerful</strong> — The Home component has no logic but serves a critical role</li> <li><strong>CSS Grid enables responsive layouts</strong> — <code class="inline">auto-fit</code> and <code class="inline">minmax</code> create layouts that adapt to any screen size</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/features/home/home.component.ts</code> exists with proper decorator configuration</li>
<p><li>[ ] <code class="inline">src/app/features/home/home.component.html</code> contains header, domain card, and quickstart sections</li> <li>[ ] <code class="inline">src/app/features/home/home.component.scss</code> contains responsive grid layout styles</li> <li>[ ] <code class="inline">src/app/features/home/home.module.ts</code> declares and exports HomeComponent</li> <li>[ ] <code class="inline">src/app/features/home/index.ts</code> provides barrel exports</li> <li>[ ] Component uses <code class="inline">routerLink</code> for navigation (not <code class="inline">href</code>)</li> <li>[ ] <code class="inline">ng build</code> completes without errors</li></p>
</ul>
<hr>

<h2>Architecture Note</h2>

<p>The Home component exemplifies the separation between <strong>feature components</strong> and <strong>framework components</strong>:</p>

<ul><li><strong>Feature components</strong> (like Home) are page-level, application-specific</li>
<p><li><strong>Framework components</strong> (from Phase 8) are reusable across any domain</li></p>
</ul>
<p>The Home component contains no domain logic — it's pure navigation and branding. This means:</p>

<ul><li>It loads instantly (no API calls)</li>
<p><li>It never fails (no dependencies)</li> <li>It can be tested in isolation</li></p>
</ul>
<p>This pattern will repeat for other feature components: they orchestrate framework components and provide page-level structure.</p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">902-automobile-landing-component.md</code> to build the automobile domain's landing page.</p></div></div>
    <div class="chapter" id="section-902">
        <div class="chapter-header">
            <div class="chapter-category">Pages</div>
            <h1>902: Automobile Landing Component</h1>
        </div>
<div class="page-content"><h1>902: Automobile Landing Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 901-home-component, 607-domain-config-assembly <strong>Blocks:</strong> 903-discover-page-component</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to create a domain-specific landing page within a feature module</li>
<p><li>Know how to provide context and navigation for a domain's features</li> <li>Be able to structure informational content that guides users to key functionality</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build the Automobile Landing component — the entry point to the automobile domain that introduces users to available features and guides them toward the discovery interface. This component bridges the gap between the general Home page and the feature-rich Discover page.</p>

<hr>

<h2>Why</h2>

<p>When users click "Automobiles" from the Home page, they need orientation before diving into complex data exploration. The Automobile Landing component serves as this orientation layer:</p>

<ul><li><strong>Domain Context</strong> — Tells users what kind of data they'll explore</li>
<p><li><strong>Feature Preview</strong> — Shows available capabilities before committing</li> <li><strong>Clear Call-to-Action</strong> — Guides users to the primary feature (Discover)</li> <li><strong>Supporting Information</strong> — Provides dataset stats and usage tips</li></p>
</ul>
<h3>The Landing Page Pattern</h3>

<p>Many successful applications use a two-level navigation pattern:</p>

<pre class="code-block text"><code>Home (all domains) → Domain Landing (one domain) → Feature Page (specific task)
</code></pre>

<p>This progressive disclosure prevents cognitive overload. Users make one decision at a time:</p>
<ul><li>"I want to explore automobiles" (Home → Automobile Landing)</li>
<p><li>"I want to search and analyze data" (Landing → Discover)</li></p>
</ul>
<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-04-07">Style 04-07</a>: Feature areas should have their own folder</li>
<p><li><a href="https://angular.io/guide/styleguide#style-02-01">Style 02-01</a>: Name files with their feature name (<code class="inline">automobile</code>)</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 902.1: Create the Automobile Feature Directory</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ mkdir -p src/app/features/automobile</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 902.2: Create the Automobile Landing Component</h3>

<p>Create <code class="inline">src/app/features/automobile/automobile.component.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/automobile/automobile.component.ts
<p>// VERSION 1 (Section 902) - Automobile domain landing page</p>

<p>import { Component } from '@angular/core'; import { RouterModule } from '@angular/router';</p>

<p>/**</p>
 <ul><li>Automobile Component - Domain Landing Page</li>
</ul> *
 <ul><li>Feature component serving as the entry point for the Automobile domain.</li>
</ul> <ul><li>Provides navigation and context for automobile-related data exploration.</li>
</ul> *
 <ul><li>This component:</li>
</ul> <ul><li>- Introduces the automobile domain to users</li>
</ul> <ul><li>- Previews available features (search, analytics, specs)</li>
</ul> <ul><li>- Guides users to the Discover page for data exploration</li>
</ul> <ul><li>- Displays dataset information and usage tips</li>
</ul> *
 <ul><li>This is a pure presentation component with no business logic.</li>
</ul> <ul><li>All data exploration happens in the Discover component.</li>
</ul> */
<p>@Component({ selector: 'app-automobile', templateUrl: './automobile.component.html', styleUrls: ['./automobile.component.scss'] }) export class AutomobileComponent {}</p>
</code></pre>

<hr>

<h3>Step 902.3: Create the Automobile Landing Template</h3>

<p>Create <code class="inline">src/app/features/automobile/automobile.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/features/automobile/automobile.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 902) - Automobile landing page with feature preview --&gt;</p>

<p>&lt;div class="automobile-container"&gt; &lt;!-- Features Grid --&gt; &lt;div class="features-section"&gt; &lt;h2&gt;&lt;span class="section-icon"&gt;🚗&lt;/span&gt; Explore Automobile Data&lt;/h2&gt; &lt;div class="features-grid"&gt; &lt;!-- Primary Feature Card (Linked) --&gt; &lt;a routerLink="/automobiles/discover" class="feature-card feature-card-primary"&gt; &lt;div class="feature-icon"&gt;🔍&lt;/div&gt; &lt;h3&gt;Advanced Search&lt;/h3&gt; &lt;p&gt;Filter and search across thousands of vehicles using advanced criteria&lt;/p&gt; &lt;span class="card-action"&gt;Start Exploring →&lt;/span&gt; &lt;/a&gt;</p>

<p>&lt;!-- Preview Feature Cards (Not Yet Linked) --&gt; &lt;div class="feature-card"&gt; &lt;div class="feature-icon"&gt;📊&lt;/div&gt; &lt;h3&gt;Analytics&lt;/h3&gt; &lt;p&gt;View comprehensive statistics and visualizations of vehicle data&lt;/p&gt; &lt;/div&gt; &lt;div class="feature-card"&gt; &lt;div class="feature-icon"&gt;🛠️&lt;/div&gt; &lt;h3&gt;Detailed Specs&lt;/h3&gt; &lt;p&gt;Access detailed specifications for every vehicle in the database&lt;/p&gt; &lt;/div&gt; &lt;div class="feature-card"&gt; &lt;div class="feature-icon"&gt;⚡&lt;/div&gt; &lt;h3&gt;Performance&lt;/h3&gt; &lt;p&gt;Compare performance metrics and find the perfect vehicle match&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</p>

<p>&lt;!-- Info Section --&gt; &lt;div class="info-section"&gt; &lt;div class="info-card info-card-highlight"&gt; &lt;h3&gt;Ready to Explore?&lt;/h3&gt; &lt;p&gt;Click "Advanced Search" above to dive into the full discovery experience with filters, charts, and data tables.&lt;/p&gt; &lt;/div&gt; &lt;div class="info-card"&gt; &lt;h3&gt;Dataset Information&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;&lt;strong&gt;Vehicle Count:&lt;/strong&gt; 55,000+ vehicles&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Data Fields:&lt;/strong&gt; Manufacturer, model, year, body class, and more&lt;/li&gt; &lt;li&gt;&lt;strong&gt;Coverage:&lt;/strong&gt; Comprehensive automobile market data&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="info-card"&gt; &lt;h3&gt;Quick Tips&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;Use filters to narrow down search results&lt;/li&gt; &lt;li&gt;Hover over charts for detailed information&lt;/li&gt; &lt;li&gt;Pop-out panels for multi-monitor workflows&lt;/li&gt; &lt;li&gt;URL state persists across page reloads&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre></div><div class="page-content"><p><strong>Template structure explained:</strong></p>

<table>
<p><thead><tr> <th>Section</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">.features-section</code></td> <td>Grid of feature cards previewing capabilities</td></p>
</tr>
<p><tr> <td><code class="inline">.feature-card-primary</code></td> <td>The main call-to-action linking to Discover</td></p>
</tr>
<p><tr> <td>Other <code class="inline">.feature-card</code> elements</td> <td>Preview features (some may not be implemented yet)</td></p>
</tr>
<p><tr> <td><code class="inline">.info-section</code></td> <td>Supporting information cards</td></p>
</tr>
</tbody>
</table>

<p><strong>Design decision:</strong> Only the "Advanced Search" card links to a page. Other feature cards show what's possible but don't have links yet. This is intentional — it shows users the application's scope while guiding them to the implemented feature.</p>

<hr>

<h3>Step 902.4: Create the Automobile Landing Styles</h3>

<p>Create <code class="inline">src/app/features/automobile/automobile.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/features/automobile/automobile.component.scss
<p>// VERSION 1 (Section 902) - Automobile landing page styles</p>

<p>.automobile-container { max-width: 1200px; margin: 0 auto; padding: 2rem; }</p>

<p>// Features section .features-section { margin-bottom: 3rem;</p>

<p>h2 { font-size: 1.75rem; color: #333; margin-bottom: 1.5rem; display: flex; align-items: center; gap: 0.5rem;</p>

<p>.section-icon { font-size: 1.5rem; } } }</p>

<p>.features-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 1.5rem; }</p>

<p>.feature-card { background: white; border-radius: 12px; padding: 1.5rem; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08); transition: transform 0.2s, box-shadow 0.2s;</p>

<p>.feature-icon { font-size: 2.5rem; margin-bottom: 1rem; }</p>

<p>h3 { font-size: 1.125rem; color: #333; margin-bottom: 0.5rem; }</p>

<p>p { font-size: 0.9rem; color: #666; margin: 0; line-height: 1.5; } }</p>

<p>// Primary feature card (linked) .feature-card-primary { display: block; text-decoration: none; color: inherit; border: 2px solid #1976d2; position: relative;</p>

<p>&amp;:hover { transform: translateY(-4px); box-shadow: 0 8px 24px rgba(25, 118, 210, 0.2); text-decoration: none; }</p>

<p>.card-action { display: block; margin-top: 1rem; color: #1976d2; font-weight: 600; font-size: 0.9rem; } }</p>

<p>// Info section .info-section { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.5rem; }</p>

<p>.info-card { background: white; border-radius: 12px; padding: 1.5rem; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);</p>

<p>h3 { font-size: 1rem; color: #333; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid #eee; }</p>

<p>p { font-size: 0.9rem; color: #666; margin: 0; line-height: 1.6; }</p>

<p>ul { margin: 0; padding-left: 1.25rem;</p>

<p>li { font-size: 0.9rem; color: #666; margin-bottom: 0.5rem; line-height: 1.4;</p>

<p>strong { color: #333; }</p>

<p>&amp;:last-child { margin-bottom: 0; } } } }</p>

<p>.info-card-highlight { background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%); color: white;</p>

<p>h3 { color: white; border-bottom-color: rgba(255, 255, 255, 0.2); }</p>

<p>p { color: rgba(255, 255, 255, 0.9); } }</p>
</code></pre>

<p><strong>Key styling patterns:</strong></p></div><div class="page-content"><table>
<p><thead><tr> <th>Pattern</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">.feature-card-primary</code> with border</td> <td>Visual distinction for actionable card</td></p>
</tr>
<p><tr> <td><code class="inline">.info-card-highlight</code> with gradient</td> <td>Draws attention to the call-to-action</td></p>
</tr>
<p><tr> <td>Consistent <code class="inline">border-radius: 12px</code></td> <td>Establishes visual consistency across cards</td></p>
</tr>
<p><tr> <td><code class="inline">translateY</code> hover effect</td> <td>Indicates clickability on interactive elements</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 902.5: Create the Automobile Feature Module</h3>

<p>Create <code class="inline">src/app/features/automobile/automobile.module.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/automobile/automobile.module.ts
<p>// VERSION 1 (Section 902) - Automobile feature module</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule } from '@angular/router';</p>

<p>import { AutomobileComponent } from './automobile.component';</p>

<p>@NgModule({ declarations: [ AutomobileComponent ], imports: [ CommonModule, RouterModule ], exports: [ AutomobileComponent ] }) export class AutomobileModule {}</p>
</code></pre>

<p><strong>Note:</strong> This module will grow in document 903 when we add the Discover component. For now, it only contains the landing component.</p>

<hr>

<h3>Step 902.6: Create the Index Barrel Export</h3>

<p>Create <code class="inline">src/app/features/automobile/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/automobile/index.ts
<p>// VERSION 1 (Section 902) - Barrel export for automobile feature</p>

<p>export * from './automobile.component'; export * from './automobile.module';</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Structure</h3>

<pre class="code-block bash"><code>$ find src/app/features/automobile -type f | sort
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>src/app/features/automobile/automobile.component.html
<p>src/app/features/automobile/automobile.component.scss src/app/features/automobile/automobile.component.ts src/app/features/automobile/automobile.module.ts src/app/features/automobile/index.ts</p>
</code></pre>

<h3>2. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>3. Visual Verification (After Routing)</h3>

<p>Once routing is configured (document 905), navigate to <code class="inline">http://localhost:4200/automobiles</code>:</p>

<ul><li>Section header with car emoji: "Explore Automobile Data"</li>
<p><li>Four feature cards in a responsive grid</li> <li>"Advanced Search" card has blue border and "Start Exploring →" link</li> <li>Three info cards at the bottom</li> <li>Blue highlighted card inviting users to explore</li></ul></p></div><div class="page-content"><h3>4. Navigation Test</h3>

<p>Click "Start Exploring →" on the Advanced Search card:</p>
<ul><li>URL should change to <code class="inline">/automobiles/discover</code></li>
<p><li>(The Discover component will be created in document 903)</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Grid layout shows one column</td> <td>Container too narrow</td> <td>Check <code class="inline">max-width</code> on <code class="inline">.automobile-container</code></td></p>
</tr>
<p><tr> <td>Primary card not visually distinct</td> <td>Missing <code class="inline">.feature-card-primary</code> class</td> <td>Verify HTML has both <code class="inline">feature-card</code> and <code class="inline">feature-card-primary</code> classes</td></p>
</tr>
<p><tr> <td>Hover effect not working</td> <td>CSS transition not applied</td> <td>Check that <code class="inline">.feature-card-primary</code> has <code class="inline">transition</code> property</td></p>
</tr>
<p><tr> <td>Link not navigating</td> <td>Route not configured</td> <td>Routes will be set up in document 905</td></p>
</tr>
<p><tr> <td>Styles bleeding to other components</td> <td>Missing component encapsulation</td> <td>Ensure styles are in component-specific SCSS file</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Landing pages provide context</strong> — They orient users before complex features</li>
<p><li><strong>Progressive disclosure reduces overwhelm</strong> — Show features one level at a time</li> <li><strong>Visual hierarchy guides attention</strong> — Use borders, colors, and hover effects to indicate primary actions</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">src/app/features/automobile/automobile.component.ts</code> exists with proper decorator</li>
<p><li>[ ] <code class="inline">src/app/features/automobile/automobile.component.html</code> contains feature cards and info sections</li> <li>[ ] <code class="inline">src/app/features/automobile/automobile.component.scss</code> provides responsive grid styles</li> <li>[ ] <code class="inline">src/app/features/automobile/automobile.module.ts</code> declares and exports the component</li> <li>[ ] Primary feature card (Advanced Search) has visual distinction and links to <code class="inline">/automobiles/discover</code></li> <li>[ ] Info cards display dataset information and quick tips</li> <li>[ ] <code class="inline">ng build</code> completes without errors</li></p>
</ul>
<hr>

<h2>Architecture Note</h2>

<p>The Automobile Landing component is the first <strong>domain-specific feature component</strong> we've built. Notice the pattern:</p>

<pre class="code-block text"><code>features/
<p>├── home/                    # Application-level (no domain) │   └── home.component.ts └── automobile/              # Domain-specific └── automobile.component.ts</p>
</code></pre>

<p>The <code class="inline">home</code> feature is domain-agnostic — it navigates to domains but contains no domain logic. The <code class="inline">automobile</code> feature is domain-specific — it lives entirely within the automobile context.</p>

<p>This separation matters because:</p>
<ul><li>Home component never changes when automobile features change</li>
<p><li>Automobile module can be lazy-loaded independently</li> <li>Future domains (if any) follow the same pattern</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">903-discover-page-component.md</code> to build the main discovery interface where users explore automobile data with filters, charts, and tables.</p></div></div>
    <div class="chapter" id="section-903">
        <div class="chapter-header">
            <div class="chapter-category">Pages</div>
            <h1>903: Discover Page Component</h1>
        </div>
<div class="page-content"><h1>903: Discover Page Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 902-automobile-landing-component, 306-resource-management-service, 801-809 (Framework Components) <strong>Blocks:</strong> 907-final-integration</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to orchestrate multiple framework components in a feature page</li>
<p><li>Know how to use <code class="inline">ResourceManagementService</code> for URL-first state management</li> <li>Be able to implement drag-and-drop panel reordering with Angular CDK</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build the Automobile Discover component — the main data exploration interface that combines all framework components (query control, charts, tables, pickers) into a cohesive discovery experience. This is where users spend most of their time: filtering data, viewing statistics, and exploring results.</p>

<hr>

<h2>Why</h2>

<p>The Discover component is the heart of vvroom. It demonstrates the power of the URL-First architecture by:</p>

<ul><li><strong>Orchestrating Components</strong> — Combines query panel, charts, tables, and pickers</li>
<p><li><strong>Managing State</strong> — Uses <code class="inline">ResourceManagementService</code> with URL as single source of truth</li> <li><strong>Enabling Workflows</strong> — Supports pop-out windows for multi-monitor setups</li> <li><strong>Providing Flexibility</strong> — Allows users to reorder and collapse panels</li></p>
</ul>
<h3>The Orchestrator Pattern</h3>

<p>Feature components like Discover don't contain UI logic themselves. Instead, they:</p>

<pre class="code-block text"><code>Feature Component (Orchestrator)
<p>├── Injects services (ResourceManagementService, DomainConfig) ├── Coordinates framework components ├── Handles cross-component communication └── Manages page-level concerns (panel order, collapse state)</p>
</code></pre>

<p>Each framework component (QueryControl, BaseChart, DynamicResultsTable) is self-contained. The Discover component wires them together and handles their outputs.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-05-04">Style 05-04</a>: Delegate complex component logic to services</li>
<p><li><a href="https://angular.io/guide/styleguide#style-07-04">Style 07-04</a>: Use input/output properties for component communication</li></ul></p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 903.1: Create the Discover Component Directory</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ mkdir -p src/app/features/automobile/automobile-discover</p>
</code></pre>

<hr>

<h3>Step 903.2: Create the Discover Component</h3>

<p>Create <code class="inline">src/app/features/automobile/automobile-discover/automobile-discover.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/features/automobile/automobile-discover/automobile-discover.component.ts
<p>// VERSION 1 (Section 903) - Main discovery page with framework component orchestration</p>

<p>import { ChangeDetectionStrategy, ChangeDetectorRef, Component, Inject, Injector, OnDestroy, OnInit } from '@angular/core'; import { Params } from '@angular/router'; import { Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators';</p>

<p>import { DomainConfig } from '../../../../framework/models/domain-config.interface'; import { PopOutMessageType } from '../../../../framework/models/popout.interface'; import { DOMAIN_CONFIG } from '../../../../framework/services/domain-config-registry.service'; import { FilterOptionsService } from '../../../../framework/services/filter-options.service'; import { PickerConfigRegistry } from '../../../../framework/services/picker-config-registry.service'; import { PopOutManagerService } from '../../../../framework/services/popout-manager.service'; import { ResourceManagementService } from '../../../../framework/services/resource-management.service'; import { UrlStateService } from '../../../../framework/services/url-state.service'; import { UserPreferencesService } from '../../../../framework/services/user-preferences.service'; import { ChartDataSource } from '../../../../framework/components/base-chart/base-chart.component'; import { createAutomobilePickerConfigs } from '../../../../domain-config/automobile/configs/automobile.picker-configs';</p>

<p>/**</p>
 <ul><li>Automobile Discover Component</li>
</ul> *
 <ul><li>Main discovery page for the Automobile domain. This component orchestrates</li>
</ul> <ul><li>all framework components to provide a comprehensive data exploration experience.</li>
</ul> *
 <ul><li>Responsibilities:</li>
</ul> <ul><li>- Provides ResourceManagementService instance for URL-first state management</li>
</ul> <ul><li>- Registers automobile-specific picker configurations</li>
</ul> <ul><li>- Manages pop-out window communication</li>
</ul> <ul><li>- Handles panel ordering and collapse state</li>
</ul> <ul><li>- Coordinates events between child components</li>
</ul> *
 <ul><li>Child Components:</li>
</ul> <ul><li>- QueryControlComponent: Filter management UI</li>
</ul> <ul><li>- BasePickerComponent: Manufacturer-model hierarchical picker</li>
</ul> <ul><li>- StatisticsPanel2Component: Multi-chart statistics display</li>
</ul> <ul><li>- DynamicResultsTableComponent: Paginated data table</li>
</ul> <ul><li>- BaseChartComponent: Individual chart visualizations</li>
</ul> */
<p>@Component({ selector: 'app-automobile-discover', templateUrl: './automobile-discover.component.html', styleUrls: ['./automobile-discover.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush, providers: [ResourceManagementService, PopOutManagerService] }) export class AutomobileDiscoverComponent implements OnInit, OnDestroy {</p>

<p>/<em>* Domain configuration injected from registry </em>/ domainConfig: DomainConfig&lt;any, any, any&gt;;</p>

<p>/<em>* Track which panels are collapsed </em>/ collapsedPanels = new Map&lt;string, boolean&gt;([ ['manufacturer-model-picker', true]  // Start picker collapsed ]);</p>

<p>/<em>* Order of panels in the UI (user can reorder via drag-drop) </em>/ panelOrder: string[] = [ 'query-control', 'statistics-1', 'chart-body-class', 'chart-year', 'manufacturer-model-picker', 'results-table' ];</p>

<p>/<em>* Unique picker configuration ID for this page instance </em>/ readonly pickerConfigId = 'automobile-discover-manufacturer-model-picker';</p>

<p>private destroy$ = new Subject&lt;void&gt;(); private readonly gridId = 'automobile-discover';</p>

<p>constructor( @Inject(DOMAIN_CONFIG) domainConfig: DomainConfig&lt;any, any, any&gt;, public resourceService: ResourceManagementService&lt;any, any, any&gt;, private pickerRegistry: PickerConfigRegistry, private injector: Injector, private popOutManager: PopOutManagerService, private cdr: ChangeDetectorRef, private urlStateService: UrlStateService, private userPreferences: UserPreferencesService, private filterOptionsService: FilterOptionsService ) { this.domainConfig = domainConfig; }</p>

<p>ngOnInit(): void { // Register picker configurations for this page const pickerConfigs = createAutomobilePickerConfigs(this.injector, 'automobile-discover'); this.pickerRegistry.registerMultiple(pickerConfigs);</p>

<p>// Initialize pop-out manager for this grid this.popOutManager.initialize(this.gridId);</p>

<p>// Handle messages from pop-out windows this.popOutManager.messages$ .pipe(takeUntil(this.destroy$)) .subscribe(({ panelId, message }) =&gt; { this.handlePopOutMessage(panelId, message); });</p>

<p>// Update UI when pop-out windows close this.popOutManager.closed$ .pipe(takeUntil(this.destroy$)) .subscribe(() =&gt; { this.cdr.markForCheck(); });</p>

<p>// Broadcast state changes to pop-out windows this.resourceService.state$ .pipe(takeUntil(this.destroy$)) .subscribe(state =&gt; { const filterOptionsCache = this.filterOptionsService.getCache(); this.popOutManager.broadcastState(state, filterOptionsCache); });</p>

<p>// Sync filter options cache to pop-outs when it changes this.filterOptionsService.getCache$() .pipe(takeUntil(this.destroy$)) .subscribe(cache =&gt; { if (this.popOutManager.getPoppedOutPanels().length &gt; 0) { const state = this.resourceService.getCurrentState(); this.popOutManager.broadcastState(state, cache); } }); }</p>

<p>// ============================================================================ // Panel State Management // ============================================================================</p>

<p>/**</p>
   <ul><li>Check if a panel is currently popped out to a separate window</li>
</ul>   */
<p>isPanelPoppedOut(panelId: string): boolean { return this.popOutManager.isPoppedOut(panelId); }</p>

<p>/**</p>
   <ul><li>Check if a panel is collapsed</li>
</ul>   */
<p>isPanelCollapsed(panelId: string): boolean { return this.collapsedPanels.get(panelId) ?? false; }</p>

<p>/**</p>
   <ul><li>Toggle panel collapse state</li>
</ul>   */
<p>togglePanelCollapse(panelId: string): void { const currentState = this.collapsedPanels.get(panelId) ?? false; this.collapsedPanels.set(panelId, !currentState);</p>

<p>// Persist collapsed state const collapsedPanels = Array.from(this.collapsedPanels.entries()) .filter(([_, isCollapsed]) =&gt; isCollapsed) .map(([id]) =&gt; id); this.userPreferences.saveCollapsedPanels(collapsedPanels);</p>

<p>this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Handle panel drag-drop reordering</li>
</ul>   */
<p>onPanelDrop(event: { previousIndex: number; currentIndex: number }): void { const item = this.panelOrder.splice(event.previousIndex, 1)[0]; this.panelOrder.splice(event.currentIndex, 0, item); this.userPreferences.savePanelOrder(this.panelOrder); this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>TrackBy function for panel ngFor</li>
</ul>   */
<p>trackByPanelId(index: number, panelId: string): string { return panelId; }</p>

<p>// ============================================================================ // Panel Configuration // ============================================================================</p>

<p>/**</p>
   <ul><li>Get human-readable title for a panel</li>
</ul>   */
<p>getPanelTitle(panelId: string): string { const titleMap: { [key: string]: string } = { 'query-control': 'Query Control', 'manufacturer-model-picker': 'Manufacturer-Model Picker', 'statistics-1': 'Statistics', 'chart-body-class': 'Vehicles by Body Class', 'chart-year': 'Vehicles by Year', 'results-table': 'Results Table' }; return titleMap[panelId] || panelId; }</p>

<p>/**</p>
   <ul><li>Get component type for a panel (used for pop-out routing)</li>
</ul>   */
<p>getPanelType(panelId: string): string { const typeMap: { [key: string]: string } = { 'query-control': 'query-control', 'manufacturer-model-picker': 'picker', 'statistics-1': 'statistics-2', 'chart-body-class': 'chart', 'chart-year': 'chart', 'results-table': 'basic-results' }; return typeMap[panelId] || panelId; }</p>

<p>/**</p>
   <ul><li>Get chart IDs for a statistics panel</li>
</ul>   */
<p>getChartIdsForPanel(panelId: string): string[] { const chartIdMap: { [key: string]: string[] } = { 'statistics-1': ['manufacturer', 'top-models'] }; return chartIdMap[panelId] || []; }</p>

<p>/**</p>
   <ul><li>Get chart data source by ID</li>
</ul>   */
<p>getChartDataSource(chartId: string): ChartDataSource | undefined { return this.domainConfig.chartDataSources?.[chartId]; }</p>

<p>// ============================================================================ // Pop-Out Management // ============================================================================</p>

<p>/**</p>
   <ul><li>Open a panel in a pop-out window</li>
</ul>   */
<p>popOutPanel(panelId: string, panelType: string): void { this.popOutManager.openPopOut(panelId, panelType); this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Handle chart pop-out request</li>
</ul>   */
<p>onChartPopOut(chartId: string): void { const panelId = <code class="inline">chart-${chartId}</code>; this.popOutManager.openPopOut(panelId, 'chart'); this.cdr.markForCheck(); }</p>

<p>/**</p>
   <ul><li>Handle messages from pop-out windows</li>
</ul>   */
<p>private async handlePopOutMessage(_panelId: string, message: any): Promise&lt;void&gt; { switch (message.type) { case PopOutMessageType.PANEL_READY: // Pop-out is ready, send current state const currentState = this.resourceService.getCurrentState(); const currentCache = this.filterOptionsService.getCache(); this.popOutManager.broadcastState(currentState, currentCache); break;</p>

<p>case PopOutMessageType.URL_PARAMS_CHANGED: // Pop-out changed filters, update URL if (message.payload?.params) { await this.urlStateService.setParams(message.payload.params); } break;</p>

<p>case PopOutMessageType.CLEAR_ALL_FILTERS: await this.urlStateService.clearParams(); break;</p>

<p>case PopOutMessageType.PICKER_SELECTION_CHANGE: if (message.payload) { await this.onPickerSelectionChangeAndUpdateUrl(message.payload); } break;</p>

<p>case PopOutMessageType.FILTER_ADD: if (message.payload?.params) { await this.urlStateService.setParams({ ...message.payload.params, page: 1 }); } break;</p>

<p>case PopOutMessageType.FILTER_REMOVE: if (message.payload?.field) { await this.urlStateService.setParams({ [message.payload.field]: null, page: 1 }); } break;</p>

<p>case PopOutMessageType.CHART_CLICK: if (message.payload) { const dataSource = this.domainConfig.chartDataSources?.[message.payload.chartId]; await this.onStandaloneChartClick( { value: message.payload.value, isHighlightMode: message.payload.isHighlightMode }, dataSource ); } break; } }</p>

<p>// ============================================================================ // Event Handlers // ============================================================================</p>

<p>/**</p>
   <ul><li>Handle URL parameter changes from child components</li>
</ul>   */
<p>async onUrlParamsChange(params: Params): Promise&lt;void&gt; { await this.urlStateService.setParams(params); }</p>

<p>/**</p>
   <ul><li>Handle clear all filters request</li>
</ul>   */
<p>async onClearAllFilters(): Promise&lt;void&gt; { await this.urlStateService.clearParams(); }</p>

<p>/**</p>
   <ul><li>Handle chart click events</li>
</ul>   */
<p>async onStandaloneChartClick( event: { value: string; isHighlightMode: boolean }, dataSource: ChartDataSource | undefined ): Promise&lt;void&gt; { if (!dataSource) return;</p>

<p>const newParams = dataSource.toUrlParams(event.value, event.isHighlightMode); if (!event.isHighlightMode) { newParams['page'] = 1; }</p>

<p>if (Object.keys(newParams).length &gt; 0) { await this.urlStateService.setParams(newParams); } }</p>

<p>/**</p>
   <ul><li>Handle picker selection changes</li>
</ul>   */
<p>async onPickerSelectionChangeAndUpdateUrl(event: any): Promise&lt;void&gt; { const paramName = 'modelCombos'; await this.urlStateService.setParams({ [paramName]: event.urlValue || null, page: 1 }); }</p>

<p>// ============================================================================ // Lifecycle // ============================================================================</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); } }</p>
</code></pre></div><div class="page-content"><p><strong>Key architectural points:</strong></p>

<table>
<p><thead><tr> <th>Aspect</th> <th>Implementation</th></p>
</tr></thead>
<p><tbody> <tr> <td>State Management</td> <td><code class="inline">ResourceManagementService</code> provided at component level</td></p>
</tr>
<p><tr> <td>Pop-Out Support</td> <td><code class="inline">PopOutManagerService</code> coordinates window communication</td></p>
</tr>
<p><tr> <td>Change Detection</td> <td><code class="inline">OnPush</code> strategy for optimal performance</td></p>
</tr>
<p><tr> <td>Panel Ordering</td> <td>Array-based order with drag-drop support</td></p>
</tr>
<p><tr> <td>Event Handling</td> <td>Async URL state updates for all user interactions</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 903.3: Create the Discover Component Template</h3>

<p>Create <code class="inline">src/app/features/automobile/automobile-discover/automobile-discover.component.html</code>:</p></div><div class="page-content"><pre class="code-block html"><code>&lt;!-- src/app/features/automobile/automobile-discover/automobile-discover.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 903) - Discovery page with draggable panels --&gt;</p>

<p>&lt;div class="discover-container"&gt; &lt;!-- Header with Results Count --&gt; &lt;div class="discover-header"&gt; &lt;h1&gt;Automobile Discovery&lt;/h1&gt; &lt;span class="results-count"&gt; {{ resourceService.totalResults$ | async }} {{ (resourceService.totalResults$ | async) === 1 ? 'result' : 'results' }} &lt;/span&gt; &lt;/div&gt;</p>

<p>&lt;!-- Panels Container --&gt; &lt;div class="panels-container"&gt; &lt;div *ngFor="let panelId of panelOrder; trackBy: trackByPanelId" class="panel-wrapper" [attr.id]="'panel-' + panelId"&gt;</p>

<p>&lt;!-- Panel Header --&gt; &lt;div class="panel-header"&gt; &lt;div class="panel-title-group"&gt; &lt;span class="drag-handle"&gt;☰&lt;/span&gt; &lt;h3 class="panel-title"&gt;{{ getPanelTitle(panelId) }}&lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-actions"&gt; &lt;button type="button" class="btn-icon" (click)="togglePanelCollapse(panelId)" [attr.aria-label]="isPanelCollapsed(panelId) ? 'Expand' : 'Collapse'" [title]="isPanelCollapsed(panelId) ? 'Expand' : 'Collapse'"&gt; {{ isPanelCollapsed(panelId) ? '▶' : '▼' }} &lt;/button&gt; &lt;button *ngIf="!isPanelPoppedOut(panelId)" type="button" class="btn-icon" (click)="popOutPanel(panelId, getPanelType(panelId))" aria-label="Pop out to separate window" title="Pop out to separate window"&gt; ↗ &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;</p>

<p>&lt;!-- Panel Content (shown when not collapsed) --&gt; &lt;div class="panel-content" *ngIf="!isPanelCollapsed(panelId)"&gt;</p>

<p>&lt;!-- Query Control Panel --&gt; &lt;ng-container *ngIf="panelId === 'query-control'"&gt; &lt;div *ngIf="!isPanelPoppedOut('query-control'); else queryControlPoppedOut"&gt; &lt;app-query-control [domainConfig]="domainConfig" (urlParamsChange)="onUrlParamsChange($event)" (clearAllFilters)="onClearAllFilters()"&gt; &lt;/app-query-control&gt; &lt;/div&gt; &lt;ng-template #queryControlPoppedOut&gt; &lt;div class="popout-placeholder"&gt; &lt;span class="popout-icon"&gt;↗&lt;/span&gt; &lt;span&gt;Query Control is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Manufacturer-Model Picker Panel --&gt; &lt;ng-container *ngIf="panelId === 'manufacturer-model-picker'"&gt; &lt;div *ngIf="!isPanelPoppedOut('manufacturer-model-picker'); else pickerPoppedOut"&gt; &lt;app-base-picker [configId]="pickerConfigId" (selectionChange)="onPickerSelectionChangeAndUpdateUrl($event)"&gt; &lt;/app-base-picker&gt; &lt;/div&gt; &lt;ng-template #pickerPoppedOut&gt; &lt;div class="popout-placeholder"&gt; &lt;span class="popout-icon"&gt;↗&lt;/span&gt; &lt;span&gt;Manufacturer-Model Picker is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Statistics Panel --&gt; &lt;ng-container *ngIf="panelId === 'statistics-1'"&gt; &lt;div *ngIf="!isPanelPoppedOut('statistics-1'); else statsPoppedOut"&gt; &lt;app-statistics-panel-2 [domainConfig]="domainConfig" [chartIds]="getChartIdsForPanel('statistics-1')" [isPanelPoppedOut]="isPanelPoppedOut.bind(this)" (chartPopOut)="onChartPopOut($event)"&gt; &lt;/app-statistics-panel-2&gt; &lt;/div&gt; &lt;ng-template #statsPoppedOut&gt; &lt;div class="popout-placeholder"&gt; &lt;span class="popout-icon"&gt;↗&lt;/span&gt; &lt;span&gt;Statistics is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Body Class Chart (Standalone) --&gt; &lt;ng-container *ngIf="panelId === 'chart-body-class'"&gt; &lt;div *ngIf="!isPanelPoppedOut('chart-body-class') &amp;&amp; getChartDataSource('body-class') as bodyClassDataSource; else bodyClassPoppedOut"&gt; &lt;app-base-chart [dataSource]="bodyClassDataSource" [statistics]="resourceService.statistics$ | async" [highlights]="resourceService.highlights$ | async" [selectedValue]="null" (chartClick)="onStandaloneChartClick($event, bodyClassDataSource)"&gt; &lt;/app-base-chart&gt; &lt;/div&gt; &lt;ng-template #bodyClassPoppedOut&gt; &lt;div class="popout-placeholder"&gt; &lt;span class="popout-icon"&gt;↗&lt;/span&gt; &lt;span&gt;Vehicles by Body Class is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Year Chart (Standalone) --&gt; &lt;ng-container *ngIf="panelId === 'chart-year'"&gt; &lt;div *ngIf="!isPanelPoppedOut('chart-year') &amp;&amp; getChartDataSource('year') as yearDataSource; else yearPoppedOut"&gt; &lt;app-base-chart [dataSource]="yearDataSource" [statistics]="resourceService.statistics$ | async" [highlights]="resourceService.highlights$ | async" [selectedValue]="null" (chartClick)="onStandaloneChartClick($event, yearDataSource)"&gt; &lt;/app-base-chart&gt; &lt;/div&gt; &lt;ng-template #yearPoppedOut&gt; &lt;div class="popout-placeholder"&gt; &lt;span class="popout-icon"&gt;↗&lt;/span&gt; &lt;span&gt;Vehicles by Year is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/ng-container&gt;</p>

<p>&lt;!-- Results Table Panel --&gt; &lt;ng-container *ngIf="panelId === 'results-table'"&gt; &lt;div *ngIf="!isPanelPoppedOut('results-table'); else resultsTablePoppedOut"&gt; &lt;app-dynamic-results-table [domainConfig]="domainConfig"&gt; &lt;/app-dynamic-results-table&gt; &lt;/div&gt; &lt;ng-template #resultsTablePoppedOut&gt; &lt;div class="popout-placeholder"&gt; &lt;span class="popout-icon"&gt;↗&lt;/span&gt; &lt;span&gt;Results Table is open in a separate window&lt;/span&gt; &lt;/div&gt; &lt;/ng-template&gt; &lt;/ng-container&gt;</p>

<p>&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;</p>
</code></pre></div><div class="page-content"><p><strong>Template patterns explained:</strong></p>

<table>
<p><thead><tr> <th>Pattern</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">async</code> pipe</td> <td>Subscribes to observables and handles cleanup automatically</td></p>
</tr>
<p><tr> <td><code class="inline">ng-template</code> with <code class="inline">#reference</code></td> <td>Defines placeholder content for popped-out panels</td></p>
</tr>
<p><tr> <td><code class="inline">*ngIf...else</code></td> <td>Conditionally shows component or placeholder</td></p>
</tr>
<p><tr> <td><code class="inline">trackBy</code> function</td> <td>Optimizes <code class="inline">*ngFor</code> rendering performance</td></p>
</tr>
<p><tr> <td><code class="inline">bind(this)</code> on callback</td> <td>Preserves <code class="inline">this</code> context when passing method as input</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 903.4: Create the Discover Component Styles</h3>

<p>Create <code class="inline">src/app/features/automobile/automobile-discover/automobile-discover.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/features/automobile/automobile-discover/automobile-discover.component.scss
<p>// VERSION 1 (Section 903) - Discovery page layout and panel styles</p>

<p>.discover-container { max-width: 1400px; margin: 0 auto; padding: 1rem; }</p>

<p>// Header .discover-header { display: flex; align-items: baseline; gap: 1rem; margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid #e0e0e0;</p>

<p>h1 { font-size: 1.5rem; font-weight: 600; color: #333; margin: 0; }</p>

<p>.results-count { font-size: 0.9rem; color: #666; } }</p>

<p>// Panels container .panels-container { display: flex; flex-direction: column; gap: 1rem; }</p>

<p>// Individual panel .panel-wrapper { background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1); overflow: hidden; }</p>

<p>.panel-header { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 1rem; background: #f5f5f5; border-bottom: 1px solid #e0e0e0; }</p>

<p>.panel-title-group { display: flex; align-items: center; gap: 0.75rem;</p>

<p>.drag-handle { cursor: grab; color: #999; font-size: 1rem; user-select: none;</p>

<p>&amp;:hover { color: #666; } }</p>

<p>.panel-title { font-size: 0.95rem; font-weight: 600; color: #333; margin: 0; } }</p>

<p>.panel-actions { display: flex; gap: 0.25rem; }</p>

<p>.btn-icon { display: flex; align-items: center; justify-content: center; width: 28px; height: 28px; border: none; background: transparent; border-radius: 4px; cursor: pointer; font-size: 0.8rem; color: #666; transition: background-color 0.15s, color 0.15s;</p>

<p>&amp;:hover { background: rgba(0, 0, 0, 0.08); color: #333; }</p>

<p>&amp;:focus { outline: 2px solid #1976d2; outline-offset: 1px; } }</p>

<p>.panel-content { padding: 1rem; }</p>

<p>// Pop-out placeholder .popout-placeholder { display: flex; align-items: center; justify-content: center; gap: 0.75rem; padding: 3rem 1rem; background: #f9f9f9; border: 2px dashed #ddd; border-radius: 4px; color: #666; font-size: 0.9rem;</p>

<p>.popout-icon { font-size: 1.25rem; opacity: 0.6; } }</p>

<p>// Loading state :host ::ng-deep .loading-overlay { display: flex; align-items: center; justify-content: center; padding: 2rem; color: #666; }</p>

<p>// Responsive adjustments @media (max-width: 768px) { .discover-container { padding: 0.5rem; }</p>

<p>.discover-header { flex-direction: column; gap: 0.25rem;</p>

<p>h1 { font-size: 1.25rem; } }</p>

<p>.panel-content { padding: 0.75rem; } }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 903.5: Update the Automobile Module</h3>

<p>Update <code class="inline">src/app/features/automobile/automobile.module.ts</code> to include the Discover component:</p>

<pre class="code-block typescript"><code>// src/app/features/automobile/automobile.module.ts
<p>// VERSION 2 (Section 903) - Add AutomobileDiscoverComponent // Replaces VERSION 1 from Section 902</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule } from '@angular/router';</p>

<p>import { AutomobileComponent } from './automobile.component'; import { AutomobileDiscoverComponent } from './automobile-discover/automobile-discover.component';</p>

<p>// Framework component imports import { QueryControlComponent } from '../../../framework/components/query-control/query-control.component'; import { BasePickerComponent } from '../../../framework/components/base-picker/base-picker.component'; import { StatisticsPanel2Component } from '../../../framework/components/statistics-panel-2/statistics-panel-2.component'; import { BaseChartComponent } from '../../../framework/components/base-chart/base-chart.component'; import { DynamicResultsTableComponent } from '../../../framework/components/dynamic-results-table/dynamic-results-table.component';</p>

<p>@NgModule({ declarations: [ AutomobileComponent, AutomobileDiscoverComponent ], imports: [ CommonModule, RouterModule, // Framework components QueryControlComponent, BasePickerComponent, StatisticsPanel2Component, BaseChartComponent, DynamicResultsTableComponent ], exports: [ AutomobileComponent, AutomobileDiscoverComponent ] }) export class AutomobileModule {}</p>
</code></pre>

<p><strong>Note:</strong> Framework components from Phase 8 are imported here. They should already be created as standalone components or have their own modules.</p>

<hr>

<h3>Step 903.6: Update Barrel Export</h3>

<p>Update <code class="inline">src/app/features/automobile/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/automobile/index.ts
<p>// VERSION 2 (Section 903) - Add discover component export</p>

<p>export * from './automobile.component'; export * from './automobile-discover/automobile-discover.component'; export * from './automobile.module';</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Check File Structure</h3>

<pre class="code-block bash"><code>$ find src/app/features/automobile -type f | sort
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>src/app/features/automobile/automobile-discover/automobile-discover.component.html
<p>src/app/features/automobile/automobile-discover/automobile-discover.component.scss src/app/features/automobile/automobile-discover/automobile-discover.component.ts src/app/features/automobile/automobile.component.html src/app/features/automobile/automobile.component.scss src/app/features/automobile/automobile.component.ts src/app/features/automobile/automobile.module.ts src/app/features/automobile/index.ts</p>
</code></pre>

<h3>2. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds. If there are import errors for framework components, ensure Phase 8 is complete.</p>

<h3>3. Visual Verification (After Routing)</h3>

<p>Navigate to <code class="inline">http://localhost:4200/automobiles/discover</code>:</p>

<ul><li>Page header shows "Automobile Discovery" with results count</li>
<p><li>Multiple panels visible (Query Control, Statistics, Charts, Table)</li> <li>Each panel has header with collapse/expand and pop-out buttons</li> <li>Clicking collapse button hides panel content</li> <li>Clicking pop-out button opens new window (requires pop-out routes)</li></p>
</ul>
<h3>4. URL State Test</h3>

<ul><li>Apply a filter (e.g., select a manufacturer)</li>
<p><li>Observe URL changes (e.g., <code class="inline">?manufacturer=Toyota</code>)</li> <li>Refresh the page</li> <li>Filter should persist (URL-first architecture in action)</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"No provider for ResourceManagementService"</td> <td>Service not in providers array</td> <td>Add to component's <code class="inline">providers</code> array</td></p>
</tr>
<p><tr> <td>"No provider for DOMAIN_CONFIG"</td> <td>Domain config not registered</td> <td>Ensure domain providers are set up in AppModule</td></p>
</tr>
<p><tr> <td>Framework components not found</td> <td>Phase 8 components missing</td> <td>Complete Phase 8 before this section</td></p>
</tr>
<p><tr> <td>Pop-out not working</td> <td>Pop-out routes not configured</td> <td>Configure pop-out routes in document 904-905</td></p>
</tr>
<p><tr> <td>Charts not rendering</td> <td>Chart data sources not configured</td> <td>Verify domain config has <code class="inline">chartDataSources</code> property</td></p>
</tr>
<p><tr> <td>Filters not persisting</td> <td>URL state service not working</td> <td>Check UrlStateService initialization</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Feature components orchestrate, not implement</strong> — They wire together framework components</li>
<p><li><strong>Component-level providers create isolated instances</strong> — <code class="inline">ResourceManagementService</code> is fresh for each Discover instance</li> <li><strong>The async pipe is your friend</strong> — It handles subscription management automatically</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">AutomobileDiscoverComponent</code> is created with proper providers</li>
<p><li>[ ] Component template renders all panel types (query control, charts, table, picker)</li> <li>[ ] Panels can be collapsed and expanded</li> <li>[ ] Pop-out placeholder is shown when a panel is popped out</li> <li>[ ] Results count updates reactively from <code class="inline">ResourceManagementService</code></li> <li>[ ] All child component inputs are properly bound</li> <li>[ ] Event handlers update URL state through <code class="inline">UrlStateService</code></li> <li>[ ] <code class="inline">ng build</code> completes without errors</li></p>
</ul>
<hr>

<h2>Architecture Note: The Flow of Data</h2>

<p>The Discover component demonstrates the complete URL-First data flow:</p>

<pre class="code-block text"><code>User Action (click filter)
<p>↓ Event Handler (onUrlParamsChange) ↓ UrlStateService.setParams() ↓ URL Updates (browser address bar) ↓ ResourceManagementService watches URL ↓ Filters extracted → API call made ↓ Response updates BehaviorSubject ↓ Components receive new data via async pipe ↓ UI updates automatically</p>
</code></pre>

<p>Every piece of state flows through the URL. This is the "Aha moment" of Phase 9: you've built an application where the URL is the single source of truth, and every component reacts to URL changes.</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">904-popout-component.md</code> to build the pop-out window component that enables multi-monitor workflows.</p></div></div>
    <div class="chapter" id="section-904">
        <div class="chapter-header">
            <div class="chapter-category">Pages</div>
            <h1>904: Popout Component</h1>
        </div>
<div class="page-content"><h1>904: Popout Component</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 307-popout-context-service, 308-popout-manager-service, 315-popout-token <strong>Blocks:</strong> 905-app-routing-module</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to create a layout component for pop-out windows</li>
<p><li>Know how to use injection tokens to identify pop-out context</li> <li>Be able to synchronize state between main window and pop-out windows using BroadcastChannel</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Build the Popout component — a minimal layout shell that hosts framework components in separate browser windows. This enables multi-monitor workflows where users can pop out charts, tables, or query panels to secondary displays while the main window remains focused on other tasks.</p>

<hr>

<h2>Why</h2>

<p>Professional data analysis workflows often span multiple monitors. A user might want:</p>

<ul><li><strong>Primary monitor:</strong> Main discovery interface with filters</li>
<p><li><strong>Secondary monitor:</strong> Large chart for detailed visualization</li> <li><strong>Third monitor:</strong> Results table for data review</li></p>
</ul>
<p>The Popout component makes this possible by:</p>

<ul><li><strong>Providing a Shell</strong> — A minimal container for the popped-out component</li>
<p><li><strong>Managing Context</strong> — Setting up domain configuration for child components</li> <li><strong>Synchronizing State</strong> — Receiving state updates from the main window</li> <li><strong>Forwarding Actions</strong> — Sending user interactions back to the main window</li></p>
</ul>
<h3>The Pop-Out Architecture</h3>

<p>Pop-out windows don't fetch data independently. Instead:</p>

<pre class="code-block text"><code>Main Window (source of truth)
<p>├── Makes API calls ├── Manages URL state ├── Broadcasts state updates │ └─── [BroadcastChannel] ───→ Pop-Out Window ├── Receives state ├── Renders UI └── Sends actions back</p>
</code></pre>

<p>This design ensures consistency: all data flows from one source, and pop-outs are essentially "remote views" of the main window's state.</p>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-05-02">Style 05-02</a>: Use services for shared functionality</li>
<p><li><a href="https://angular.io/guide/styleguide#style-07-01">Style 07-01</a>: Define small, focused components</li></ul></p></div><div class="page-content"><hr>

<h2>What</h2>

<h3>Step 904.1: Create the Popout Feature Directory</h3>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ mkdir -p src/app/features/popout</p>
</code></pre>

<hr>

<h3>Step 904.2: Create the Popout Component</h3>

<p>Create <code class="inline">src/app/features/popout/popout.component.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/features/popout/popout.component.ts
<p>// VERSION 1 (Section 904) - Pop-out window layout component</p>

<p>import { ChangeDetectionStrategy, ChangeDetectorRef, Component, OnDestroy, OnInit } from '@angular/core'; import { ActivatedRoute } from '@angular/router'; import { Subject } from 'rxjs'; import { takeUntil } from 'rxjs/operators';</p>

<p>import { PopOutMessage, PopOutMessageType } from '../../../framework/models/popout.interface'; import { DomainConfigRegistry } from '../../../framework/services/domain-config-registry.service'; import { PopOutContextService } from '../../../framework/services/popout-context.service'; import { ResourceManagementService } from '../../../framework/services/resource-management.service'; import { IS_POPOUT_TOKEN } from '../../../framework/tokens/popout.token';</p>

<p>/**</p>
 <ul><li>Popout Component - Pop-out Window Layout Shell</li>
</ul> *
 <ul><li>A minimal layout component for pop-out windows. This component:</li>
</ul> <ul><li>1. Provides ResourceManagementService and IS_POPOUT_TOKEN to children</li>
</ul> <ul><li>2. Sets the active domain so child components can inject domain config</li>
</ul> <ul><li>3. Syncs state from main window via BroadcastChannel</li>
</ul> <ul><li>4. Renders child components via router-outlet</li>
</ul> *
 <ul><li>The popout has NO knowledge of specific component types. Child routes</li>
</ul> <ul><li>determine which component is rendered. Each child component is responsible</li>
</ul> <ul><li>for its own behavior based on injected services.</li>
</ul> *
 <ul><li>URL structure: /popout/:gridId/:componentId/:type</li>
</ul> <ul><li>- gridId: Identifies the source grid (e.g., 'automobile-discover')</li>
</ul> <ul><li>- componentId: Unique ID of the panel being popped out</li>
</ul> <ul><li>- type: Component type for routing (e.g., 'chart', 'picker', 'query-control')</li>
</ul> */
<p>@Component({ selector: 'app-popout', templateUrl: './popout.component.html', styleUrls: ['./popout.component.scss'], changeDetection: ChangeDetectionStrategy.OnPush, providers: [ ResourceManagementService, { provide: IS_POPOUT_TOKEN, useValue: true } ] }) export class PopoutComponent implements OnInit, OnDestroy { private destroy$ = new Subject&lt;void&gt;();</p>

<p>constructor( private route: ActivatedRoute, private popOutContext: PopOutContextService, private cdr: ChangeDetectorRef, private resourceService: ResourceManagementService&lt;any, any, any&gt;, private domainRegistry: DomainConfigRegistry ) {}</p>

<p>ngOnInit(): void { // Extract route parameters and initialize this.route.params .pipe(takeUntil(this.destroy$)) .subscribe(params =&gt; { const gridId = params['gridId']; const componentId = params['componentId'];</p>

<p>// Extract domain name from gridId (e.g., 'automobile-discover' -&gt; 'automobile') const domainName = gridId.split('-')[0] || 'automobile';</p>

<p>// Set active domain for child components this.domainRegistry.setActive(domainName);</p>

<p>// Initialize BroadcastChannel communication this.popOutContext.initializeAsPopOut(componentId);</p>

<p>// Add pop-out styling classes to document document.documentElement.classList.add('popout-html'); document.body.classList.add('popout-body'); });</p>

<p>// Handle messages from the main window this.popOutContext .getMessages$() .pipe(takeUntil(this.destroy$)) .subscribe(message =&gt; { this.handleMessage(message); }); }</p>

<p>/**</p>
   <ul><li>Handle incoming messages from the main window</li>
</ul>   */
<p>private handleMessage(message: PopOutMessage): void { switch (message.type) { case PopOutMessageType.CLOSE_POPOUT: // Main window requested this pop-out to close window.close(); break;</p>

<p>case PopOutMessageType.STATE_UPDATE: // Main window sent updated state if (message.payload?.state) { this.resourceService.syncStateFromExternal(message.payload.state); this.cdr.detectChanges(); } break; } }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); } }</p>
</code></pre></div><div class="page-content"><p><strong>Key design decisions:</strong></p>

<table>
<p><thead><tr> <th>Decision</th> <th>Rationale</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">IS_POPOUT_TOKEN</code> provided as <code class="inline">true</code></td> <td>Child components can check if they're in a pop-out</td></p>
</tr>
<p><tr> <td><code class="inline">ResourceManagementService</code> provided here</td> <td>Creates isolated instance that receives state from main</td></p>
</tr>
<p><tr> <td>Domain extracted from <code class="inline">gridId</code></td> <td>Enables domain-agnostic pop-out support</td></p>
</tr>
<p><tr> <td><code class="inline">OnPush</code> change detection</td> <td>Requires explicit <code class="inline">detectChanges()</code> after state sync</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 904.3: Create the Popout Component Template</h3>

<p>Create <code class="inline">src/app/features/popout/popout.component.html</code>:</p>

<pre class="code-block html"><code>&lt;!-- src/app/features/popout/popout.component.html --&gt;
<p>&lt;!-- VERSION 1 (Section 904) - Minimal pop-out layout --&gt;</p>

<p>&lt;div class="popout-container"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;/div&gt;</p>
</code></pre>

<p>The template is intentionally minimal. The <code class="inline">router-outlet</code> renders whatever child component is specified by the route (chart, table, picker, etc.).</p>

<hr>

<h3>Step 904.4: Create the Popout Component Styles</h3>

<p>Create <code class="inline">src/app/features/popout/popout.component.scss</code>:</p>

<pre class="code-block scss"><code>// src/app/features/popout/popout.component.scss
<p>// VERSION 1 (Section 904) - Pop-out window styles</p>

<p>// Full-height container .popout-container { display: flex; flex-direction: column; min-height: 100vh; padding: 1rem; background: #f5f5f5; }</p>

<p>// Global styles applied via class on html/body :host-context(.popout-html) { // Remove default margins margin: 0; padding: 0; }</p>

<p>:host-context(.popout-body) { margin: 0; padding: 0; overflow: auto; }</p>

<p>// Ensure child components take full space ::ng-deep { .popout-container &gt; * { flex: 1; display: flex; flex-direction: column; }</p>

<p>// Charts should fill available space app-base-chart { flex: 1; min-height: 400px; }</p>

<p>// Tables should scroll internally app-dynamic-results-table, app-basic-results-table { flex: 1; overflow: auto; }</p>

<p>// Query control takes its natural height app-query-control { flex: none; } }</p>
</code></pre>

<hr>

<h3>Step 904.5: Create the Popout Routes</h3>

<p>Create <code class="inline">src/app/features/popout/popout.routes.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/features/popout/popout.routes.ts
<p>// VERSION 1 (Section 904) - Child routes for pop-out window</p>

<p>import { Routes } from '@angular/router';</p>

<p>/**</p>
 <ul><li>Popout Child Routes</li>
</ul> *
 <ul><li>Defines the child routes for the pop-out layout. Each route maps a component</li>
</ul> <ul><li>type (from the URL) to the actual component that should be rendered.</li>
</ul> *
 <ul><li>URL structure: /popout/:gridId/:componentId/:type</li>
</ul> <ul><li>Where :type is one of these child route paths.</li>
</ul> *
 <ul><li>Note: For Angular 13 with NgModules, components are referenced directly</li>
</ul> <ul><li>rather than using dynamic imports (loadComponent).</li>
</ul> */
<p>export const POPOUT_ROUTES: Routes = [ { path: 'query-control', loadChildren: () =&gt; import('../../../framework/components/query-control/query-control.module') .then(m =&gt; m.QueryControlModule) }, { path: 'picker', loadChildren: () =&gt; import('../../../framework/components/base-picker/base-picker.module') .then(m =&gt; m.BasePickerModule) }, { path: 'chart', loadChildren: () =&gt; import('../../../framework/components/base-chart/base-chart.module') .then(m =&gt; m.BaseChartModule) }, { path: 'basic-results', loadChildren: () =&gt; import('../../../framework/components/dynamic-results-table/dynamic-results-table.module') .then(m =&gt; m.DynamicResultsTableModule) }, { path: 'statistics-2', loadChildren: () =&gt; import('../../../framework/components/statistics-panel-2/statistics-panel-2.module') .then(m =&gt; m.StatisticsPanel2Module) } ];</p>
</code></pre>

<p><strong>Note on Angular 13 patterns:</strong> This uses <code class="inline">loadChildren</code> with module imports, which is the NgModule pattern. The exact implementation depends on how framework components are structured in Phase 8. If components are standalone, use <code class="inline">loadComponent</code> instead.</p>

<hr>

<h3>Step 904.6: Create the Popout Module</h3>

<p>Create <code class="inline">src/app/features/popout/popout.module.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/popout/popout.module.ts
<p>// VERSION 1 (Section 904) - Pop-out feature module</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule } from '@angular/router';</p>

<p>import { PopoutComponent } from './popout.component'; import { POPOUT_ROUTES } from './popout.routes';</p>

<p>@NgModule({ declarations: [ PopoutComponent ], imports: [ CommonModule, RouterModule.forChild([ { path: '', component: PopoutComponent, children: POPOUT_ROUTES } ]) ] }) export class PopoutModule {}</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 904.7: Create the Barrel Export</h3>

<p>Create <code class="inline">src/app/features/popout/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/popout/index.ts
<p>// VERSION 1 (Section 904) - Barrel export for popout feature</p>

<p>export * from './popout.component'; export * from './popout.routes'; export * from './popout.module';</p>
</code></pre>

<hr>

<h3>Step 904.8: Add Global Pop-out Styles (Optional)</h3>

<p>For consistent pop-out appearance, add these global styles to <code class="inline">src/styles.scss</code>:</p>

<pre class="code-block scss"><code>// src/styles.scss
<p>// ADD these styles for pop-out window support</p>

<p>// Pop-out window specific styles .popout-html { height: 100%; margin: 0; padding: 0; }</p>

<p>.popout-body { height: 100%; margin: 0; padding: 0; background: #f5f5f5; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif; }</p>
</code></pre>

<hr>

<h2>Verification</h2>

<h3>1. Check File Structure</h3>

<pre class="code-block bash"><code>$ find src/app/features/popout -type f | sort
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>src/app/features/popout/index.ts
<p>src/app/features/popout/popout.component.html src/app/features/popout/popout.component.scss src/app/features/popout/popout.component.ts src/app/features/popout/popout.module.ts src/app/features/popout/popout.routes.ts</p>
</code></pre>

<h3>2. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds.</p>

<h3>3. Manual Pop-out Test (After Full Integration)</h3>

<ul><li>Navigate to <code class="inline">/automobiles/discover</code></li>
<p><li>Click the pop-out button on any panel</li> <li>A new browser window should open with URL like:</li></p>
</ul>   <code class="inline">/popout/automobile-discover/chart-year/chart</code>
<ul><li>The component should render in the new window</li>
<p><li>State changes in main window should reflect in pop-out</li></p>
</ul>
<h3>4. Message Flow Test</h3>

<p>In browser console of main window:</p>
<pre class="code-block javascript"><code>// After pop-out is open, check BroadcastChannel
<p>console.log('Pop-out should receive state updates');</p>
</code></pre>

<p>In pop-out window console:</p>
<pre class="code-block javascript"><code>// State should sync from main
<p>console.log('Check that data appears');</p>
</code></pre>

<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>Pop-out window is blank</td> <td>Router-outlet not finding child route</td> <td>Verify route path matches child routes</td></p>
</tr>
<p><tr> <td>"No provider for DOMAIN_CONFIG"</td> <td>Domain not set before component loads</td> <td>Ensure <code class="inline">domainRegistry.setActive()</code> called in ngOnInit</td></p>
</tr>
<p><tr> <td>State not syncing</td> <td>BroadcastChannel not initialized</td> <td>Check <code class="inline">popOutContext.initializeAsPopOut()</code> called</td></p>
</tr>
<p><tr> <td>Change detection not updating</td> <td>OnPush strategy blocking updates</td> <td>Call <code class="inline">cdr.detectChanges()</code> after state sync</td></p>
</tr>
<p><tr> <td>Window.close() not working</td> <td>Browser security restrictions</td> <td>User must have opened the window (not blocked)</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Pop-outs are state receivers, not sources</strong> — They display data but don't fetch it</li>
<p><li><strong>BroadcastChannel enables cross-window communication</strong> — Built into modern browsers</li> <li><strong>Injection tokens differentiate contexts</strong> — <code class="inline">IS_POPOUT_TOKEN</code> tells components where they're running</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">PopoutComponent</code> is created with <code class="inline">IS_POPOUT_TOKEN</code> provider</li>
<p><li>[ ] Component extracts <code class="inline">gridId</code> and <code class="inline">componentId</code> from route params</li> <li>[ ] Domain is set via <code class="inline">DomainConfigRegistry.setActive()</code></li> <li>[ ] BroadcastChannel communication initialized via <code class="inline">PopOutContextService</code></li> <li>[ ] State updates from main window sync to <code class="inline">ResourceManagementService</code></li> <li>[ ] Child routes defined for all pop-out-able component types</li> <li>[ ] <code class="inline">ng build</code> completes without errors</li></p>
</ul>
<hr>

<h2>Architecture Note: Cross-Window Communication</h2>

<p>The pop-out system uses the browser's <code class="inline">BroadcastChannel</code> API for communication:</p>

<pre class="code-block text"><code>Main Window                    Pop-Out Window
<p>│                               │ │  ┌─────────────────────────┐  │ │  │   BroadcastChannel      │  │ │  │   'vvroom-popout'        │  │ │  └─────────────────────────┘  │ │                               │ ├──── STATE_UPDATE ────────────→│ │                               │ │←───── PANEL_READY ───────────┤ │                               │ │←── URL_PARAMS_CHANGED ───────┤ │                               │</p>
</code></pre>

<p><strong>Message types:</strong></p>

<table>
<p><thead><tr> <th>Type</th> <th>Direction</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">STATE_UPDATE</code></td> <td>Main → Pop-out</td> <td>Send current state (filters, results, statistics)</td></p>
</tr>
<p><tr> <td><code class="inline">PANEL_READY</code></td> <td>Pop-out → Main</td> <td>Pop-out initialized, ready for state</td></p>
</tr>
<p><tr> <td><code class="inline">URL_PARAMS_CHANGED</code></td> <td>Pop-out → Main</td> <td>User changed filter in pop-out</td></p>
</tr>
<p><tr> <td><code class="inline">CLOSE_POPOUT</code></td> <td>Main → Pop-out</td> <td>Request pop-out to close</td></p>
</tr>
</tbody>
</table>

<p>This architecture ensures the main window remains the source of truth while pop-outs provide additional viewport space.</p>

<hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">905-app-routing-module.md</code> to configure the application's routing, connecting all feature components into a navigable application.</p></div></div>
    <div class="chapter" id="section-905">
        <div class="chapter-header">
            <div class="chapter-category">Pages</div>
            <h1>905: App Routing Module</h1>
        </div>
<div class="page-content"><h1>905: App Routing Module</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 901-home-component, 902-automobile-landing-component, 903-discover-page-component, 904-popout-component <strong>Blocks:</strong> 906-app-module</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to configure Angular Router with lazy loading for feature modules</li>
<p><li>Know how to structure routes with nested children for complex navigation</li> <li>Be able to implement route guards and redirects for improved UX</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Configure the application's routing module to connect all feature components into a cohesive, navigable application. This is where the individual pieces we've built come together as a unified experience.</p>

<hr>

<h2>Why</h2>

<p>The routing module is the skeleton of your application. It defines:</p>

<ul><li><strong>Navigation Paths</strong> — What URLs map to which components</li>
<p><li><strong>Loading Strategy</strong> — Which features load immediately vs. on demand</li> <li><strong>User Experience</strong> — Default routes, redirects, and error handling</li></p>
</ul>
<h3>Angular Router Key Concepts</h3>

<table>
<p><thead><tr> <th>Concept</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Routes</code></td> <td>Array of route configurations</td></p>
</tr>
<p><tr> <td><code class="inline">RouterModule.forRoot()</code></td> <td>Configures router at application level</td></p>
</tr>
<p><tr> <td><code class="inline">loadChildren</code></td> <td>Lazy-loads a feature module on navigation</td></p>
</tr>
<p><tr> <td><code class="inline">redirectTo</code></td> <td>Redirects one path to another</td></p>
</tr>
<p><tr> <td><code class="inline">pathMatch</code></td> <td>Determines how path is matched ('full' or 'prefix')</td></p>
</tr>
</tbody>
</table>

<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-04-10">Style 04-10</a>: Use redirects for default routes</li>
<p><li><a href="https://angular.io/guide/styleguide#style-04-11">Style 04-11</a>: Consider lazy loading for large features</li></p>
</ul>
<h3>URL-First Architecture</h3>

<p>The router is central to URL-First architecture. Every view in the application corresponds to a URL, and the URL is the source of truth for application state. The routing module defines what those URLs are.</p>

<hr>

<h2>What</h2>

<h3>Step 905.1: Create the App Routing Module</h3>

<p>Create <code class="inline">src/app/app-routing.module.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/app-routing.module.ts
<p>// VERSION 1 (Section 905) - Complete application routing configuration</p>

<p>import { NgModule } from '@angular/core'; import { RouterModule, Routes } from '@angular/router';</p>

<p>/**</p>
 <ul><li>Application Routes Configuration</li>
</ul> *
 <ul><li>Defines all navigation paths for the vvroom application.</li>
</ul> <ul><li>Uses lazy loading for feature modules to improve initial load time.</li>
</ul> *
 <ul><li>Route Structure:</li>
</ul> <ul><li>- / (root): Redirects to /home</li>
</ul> <ul><li>- /home: Home landing page</li>
</ul> <ul><li>- /automobiles: Automobile domain landing</li>
</ul> <ul><li>- /automobiles/discover: Main discovery interface</li>
</ul> <ul><li>- /popout/:gridId/:componentId/:type: Pop-out window routes</li>
</ul> */
<p>const routes: Routes = [ // Default route - redirect to home { path: '', redirectTo: 'home', pathMatch: 'full' },</p>

<p>// Home page (eager loaded for instant landing) { path: 'home', loadChildren: () =&gt; import('./features/home/home.module') .then(m =&gt; m.HomeModule) },</p>

<p>// Automobile domain routes (lazy loaded) { path: 'automobiles', loadChildren: () =&gt; import('./features/automobile/automobile.module') .then(m =&gt; m.AutomobileModule) },</p>

<p>// Pop-out window routes (lazy loaded) { path: 'popout/:gridId/:componentId', loadChildren: () =&gt; import('./features/popout/popout.module') .then(m =&gt; m.PopoutModule) },</p>

<p>// Wildcard route - redirect unknown paths to home { path: '**', redirectTo: 'home' } ];</p>

<p>@NgModule({ imports: [ RouterModule.forRoot(routes, { // Enable URL fragment scrolling anchorScrolling: 'enabled', // Scroll to top on navigation scrollPositionRestoration: 'enabled', // Preserve query params on redirect (important for URL-First) paramsInheritanceStrategy: 'always' }) ], exports: [RouterModule] }) export class AppRoutingModule {}</p>
</code></pre>

<p><strong>Route configuration explained:</strong></p>

<table>
<p><thead><tr> <th>Route</th> <th>Purpose</th> <th>Loading Strategy</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">''</code></td> <td>Root path, redirects to home</td> <td>Immediate redirect</td></p>
</tr>
<p><tr> <td><code class="inline">'home'</code></td> <td>Home landing page</td> <td>Lazy loaded</td></p>
</tr>
<p><tr> <td><code class="inline">'automobiles'</code></td> <td>Automobile feature area</td> <td>Lazy loaded</td></p>
</tr>
<p><tr> <td><code class="inline">'popout/:gridId/:componentId'</code></td> <td>Pop-out windows</td> <td>Lazy loaded</td></p>
</tr>
<p><tr> <td><code class="inline">'**'</code></td> <td>Catch-all for unknown routes</td> <td>Redirect to home</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h3>Step 905.2: Update Feature Modules for Routing</h3>

<p>Each feature module needs internal routes. Update the modules created earlier.</p>

<h4>Update Home Module</h4>

<p>Update <code class="inline">src/app/features/home/home.module.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/home/home.module.ts
<p>// VERSION 2 (Section 905) - Add routing configuration // Replaces VERSION 1 from Section 901</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule, Routes } from '@angular/router';</p>

<p>import { HomeComponent } from './home.component';</p>

<p>const routes: Routes = [ { path: '', component: HomeComponent } ];</p>

<p>@NgModule({ declarations: [ HomeComponent ], imports: [ CommonModule, RouterModule.forChild(routes) ] }) export class HomeModule {}</p>
</code></pre>

<h4>Update Automobile Module</h4>

<p>Update <code class="inline">src/app/features/automobile/automobile.module.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/features/automobile/automobile.module.ts
<p>// VERSION 3 (Section 905) - Add routing configuration // Replaces VERSION 2 from Section 903</p>

<p>import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule, Routes } from '@angular/router';</p>

<p>import { AutomobileComponent } from './automobile.component'; import { AutomobileDiscoverComponent } from './automobile-discover/automobile-discover.component';</p>

<p>// Framework component imports (from Phase 8) import { QueryControlModule } from '../../framework/components/query-control/query-control.module'; import { BasePickerModule } from '../../framework/components/base-picker/base-picker.module'; import { StatisticsPanel2Module } from '../../framework/components/statistics-panel-2/statistics-panel-2.module'; import { BaseChartModule } from '../../framework/components/base-chart/base-chart.module'; import { DynamicResultsTableModule } from '../../framework/components/dynamic-results-table/dynamic-results-table.module';</p>

<p>const routes: Routes = [ { path: '', component: AutomobileComponent }, { path: 'discover', component: AutomobileDiscoverComponent } ];</p>

<p>@NgModule({ declarations: [ AutomobileComponent, AutomobileDiscoverComponent ], imports: [ CommonModule, RouterModule.forChild(routes), // Framework component modules QueryControlModule, BasePickerModule, StatisticsPanel2Module, BaseChartModule, DynamicResultsTableModule ] }) export class AutomobileModule {}</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 905.3: Understanding Route Parameters</h3>

<p>The pop-out route uses parameters to identify what component to show:</p>

<pre class="code-block text"><code>/popout/:gridId/:componentId/:type
<p>│       │            │ │       │            └── Component type (chart, picker, etc.) │       └── Unique panel identifier └── Source grid identifier (e.g., automobile-discover)</p>
</code></pre>

<p><strong>Example URLs:</strong></p>

<table>
<p><thead><tr> <th>URL</th> <th>Meaning</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">/popout/automobile-discover/chart-year/chart</code></td> <td>Year chart from automobile discover</td></p>
</tr>
<p><tr> <td><code class="inline">/popout/automobile-discover/query-control/query-control</code></td> <td>Query control panel</td></p>
</tr>
<p><tr> <td><code class="inline">/popout/automobile-discover/results-table/basic-results</code></td> <td>Results table</td></p>
</tr>
</tbody>
</table>

<p>The PopoutComponent extracts these parameters to:</p>
<ul><li>Set the correct domain (<code class="inline">automobile</code>)</li>
<p><li>Initialize BroadcastChannel with the right ID (<code class="inline">chart-year</code>)</li> <li>Load the appropriate child component via router</li></p>
</ul>
<hr>

<h3>Step 905.4: Update AppComponent for Router Outlet</h3>

<p>Ensure <code class="inline">src/app/app.component.ts</code> includes the router outlet:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/app.component.ts
<p>// VERSION 3 (Section 905) - Router outlet support // Replaces VERSION 2 from Section 102</p>

<p>import { Component, OnInit, OnDestroy } from '@angular/core'; import { Router, NavigationEnd } from '@angular/router'; import { Subject } from 'rxjs'; import { filter, takeUntil } from 'rxjs/operators';</p>

<p>/**</p>
 <ul><li>Root Application Component</li>
</ul> *
 <ul><li>Main container for the vvroom application. Provides:</li>
</ul> <ul><li>- Application shell with header navigation</li>
</ul> <ul><li>- Router outlet for feature components</li>
</ul> <ul><li>- Pop-out detection to hide header in pop-out windows</li>
</ul> */
<p>@Component({ selector: 'app-root', template: <code class="inline"> &lt;!-- Navigation Header (hidden in pop-outs) --&gt; &lt;header class="app-header" *ngIf="!isPopOut"&gt; &lt;div class="app-header-brand"&gt; &lt;a routerLink="/home" class="brand-link"&gt; &lt;span class="app-header-logo"&gt;🚗&lt;/span&gt; &lt;span class="app-header-title"&gt;vvroom&lt;/span&gt; &lt;/a&gt; &lt;/div&gt; &lt;nav class="app-header-nav"&gt; &lt;a routerLink="/home" routerLinkActive="active" class="nav-link"&gt;Home&lt;/a&gt; &lt;a routerLink="/automobiles" routerLinkActive="active" class="nav-link"&gt;Automobiles&lt;/a&gt; &lt;/nav&gt; &lt;/header&gt;</p>

<p>&lt;!-- Main Content Area --&gt; &lt;main class="app-content" [class.popout-content]="isPopOut"&gt; &lt;router-outlet&gt;&lt;/router-outlet&gt; &lt;/main&gt;</p>
  </code>,
<p>styles: [<code class="inline"> :host { display: flex; flex-direction: column; min-height: 100vh; }</p>

<p>.app-header { display: flex; align-items: center; justify-content: space-between; padding: 0 1.5rem; height: 56px; background-color: #1976d2; color: white; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }</p>

<p>.app-header-brand { display: flex; align-items: center; }</p>

<p>.brand-link { display: flex; align-items: center; gap: 0.5rem; color: white; text-decoration: none; }</p>

<p>.app-header-logo { font-size: 1.5rem; }</p>

<p>.app-header-title { font-size: 1.25rem; font-weight: 600; letter-spacing: -0.5px; }</p>

<p>.app-header-nav { display: flex; gap: 0.5rem; }</p>

<p>.nav-link { padding: 0.5rem 1rem; color: rgba(255, 255, 255, 0.9); text-decoration: none; border-radius: 4px; transition: background-color 0.2s; }</p>

<p>.nav-link:hover { background-color: rgba(255, 255, 255, 0.1); }</p>

<p>.nav-link.active { background-color: rgba(255, 255, 255, 0.2); }</p>

<p>.app-content { flex: 1; background: #f5f5f5; }</p>

<p>.popout-content { padding: 0; }</p>
  </code>]
<p>}) export class AppComponent implements OnInit, OnDestroy { isPopOut = false; private destroy$ = new Subject&lt;void&gt;();</p>

<p>constructor(private router: Router) {}</p>

<p>ngOnInit(): void { // Check if current route is a pop-out this.isPopOut = this.router.url.startsWith('/popout');</p>

<p>// Watch for route changes this.router.events.pipe( filter((event): event is NavigationEnd =&gt; event instanceof NavigationEnd), takeUntil(this.destroy$) ).subscribe(event =&gt; { this.isPopOut = event.urlAfterRedirects.startsWith('/popout'); }); }</p>

<p>ngOnDestroy(): void { this.destroy$.next(); this.destroy$.complete(); } }</p>
</code></pre>

<p><strong>Key features:</strong></p></div><div class="page-content"><table>
<p><thead><tr> <th>Feature</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">*ngIf="!isPopOut"</code></td> <td>Hides header in pop-out windows</td></p>
</tr>
<p><tr> <td><code class="inline">routerLinkActive="active"</code></td> <td>Highlights current route in navigation</td></p>
</tr>
<p><tr> <td><code class="inline">[class.popout-content]</code></td> <td>Removes padding for pop-out content</td></p>
</tr>
<p><tr> <td>Route change detection</td> <td>Updates <code class="inline">isPopOut</code> on navigation</td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Step 905.5: Router Configuration Options</h3>

<p>The <code class="inline">RouterModule.forRoot()</code> options we used:</p>

<pre class="code-block typescript"><code>RouterModule.forRoot(routes, {
<p>anchorScrolling: 'enabled', scrollPositionRestoration: 'enabled', paramsInheritanceStrategy: 'always' })</p>
</code></pre>

<table>
<p><thead><tr> <th>Option</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">anchorScrolling</code></td> <td>Enables scrolling to <code class="inline">#fragment</code> anchors</td></p>
</tr>
<p><tr> <td><code class="inline">scrollPositionRestoration</code></td> <td>Scrolls to top when navigating between routes</td></p>
</tr>
<p><tr> <td><code class="inline">paramsInheritanceStrategy: 'always'</code></td> <td>Query params available in all child routes</td></p>
</tr>
</tbody>
</table>

<p>The <code class="inline">paramsInheritanceStrategy</code> is particularly important for URL-First architecture — it ensures query parameters are accessible throughout the component tree.</p>

<hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Serve and Navigate</h3>

<pre class="code-block bash"><code>$ ng serve --open
</code></pre>

<p>Test these navigation paths:</p>

<table>
<p><thead><tr> <th>Action</th> <th>Expected Result</th></p>
</tr></thead>
<p><tbody> <tr> <td>Open <code class="inline">http://localhost:4200</code></td> <td>Redirects to <code class="inline">/home</code></td></p>
</tr>
<p><tr> <td>Click "Automobiles" in header</td> <td>Navigates to <code class="inline">/automobiles</code></td></p>
</tr>
<p><tr> <td>Click "Advanced Search" card</td> <td>Navigates to <code class="inline">/automobiles/discover</code></td></p>
</tr>
<p><tr> <td>Click "Home" in header</td> <td>Returns to <code class="inline">/home</code></td></p>
</tr>
<p><tr> <td>Enter unknown URL like <code class="inline">/foo</code></td> <td>Redirects to <code class="inline">/home</code></td></p>
</tr>
</tbody>
</table>

<h3>3. Verify Lazy Loading</h3>

<p>Open browser DevTools (Network tab) and observe:</p>

<ul><li>Initial load: Only main bundle and home module</li>
<p><li>Navigate to <code class="inline">/automobiles</code>: Automobile module loads</li> <li>Navigate to <code class="inline">/automobiles/discover</code>: No additional load (same module)</li></p>
</ul>
<h3>4. Check Router Link Active</h3>

<p>The navigation link for the current route should have the <code class="inline">active</code> class applied, showing a slightly different background color.</p>

<h3>5. Verify Query Param Persistence</h3>

<ul><li>Navigate to <code class="inline">/automobiles/discover?manufacturer=Toyota</code></li>
<p><li>Note the query parameter in URL</li> <li>Refresh the page</li> <li>Query parameter should persist</li></ul></p></div><div class="page-content"><hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"Cannot find module" error</td> <td>Import path wrong</td> <td>Verify feature module paths are correct</td></p>
</tr>
<p><tr> <td>Blank page on navigation</td> <td>Component not declared in module</td> <td>Add component to module's declarations</td></p>
</tr>
<p><tr> <td>Query params lost on navigation</td> <td>Wrong <code class="inline">paramsInheritanceStrategy</code></td> <td>Set to <code class="inline">'always'</code> in RouterModule.forRoot</td></p>
</tr>
<p><tr> <td>Pop-out routes not loading</td> <td>Missing route parameters</td> <td>Verify URL includes gridId and componentId</td></p>
</tr>
<p><tr> <td>"No provider" errors</td> <td>Services not provided</td> <td>Add providers to feature module or app module</td></p>
</tr>
<p><tr> <td>Redirect loops</td> <td>Conflicting route definitions</td> <td>Check for multiple matching paths</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Lazy loading improves performance</strong> — Feature modules load only when needed</li>
<p><li><strong>Route parameters enable dynamic content</strong> — The pop-out route uses params to determine what to show</li> <li><strong>RouterModule.forRoot() vs forChild()</strong> — <code class="inline">forRoot()</code> at app level, <code class="inline">forChild()</code> in feature modules</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">AppRoutingModule</code> configures all application routes</li>
<p><li>[ ] Root path (<code class="inline">/</code>) redirects to <code class="inline">/home</code></li> <li>[ ] Home, Automobile, and Popout routes are lazy loaded</li> <li>[ ] Unknown routes (<code class="inline">**</code>) redirect to home</li> <li>[ ] Feature modules define their internal routes with <code class="inline">RouterModule.forChild()</code></li> <li>[ ] <code class="inline">AppComponent</code> hides header for pop-out routes</li> <li>[ ] <code class="inline">routerLinkActive</code> highlights current navigation item</li> <li>[ ] Query parameters persist across navigation</li> <li>[ ] <code class="inline">ng build</code> completes without errors</li> <li>[ ] Navigation between all routes works correctly</li></p>
</ul>
<hr>

<h2>Architecture Note: Route Hierarchy</h2>

<p>The complete route structure:</p>

<pre class="code-block text"><code>/
<p>├── home                          → HomeComponent ├── automobiles                   → AutomobileComponent │   └── discover                  → AutomobileDiscoverComponent └── popout/:gridId/:componentId ├── query-control             → QueryControlComponent ├── picker                    → BasePickerComponent ├── chart                     → BaseChartComponent ├── basic-results             → DynamicResultsTableComponent └── statistics-2              → StatisticsPanel2Component</p>
</code></pre>

<p>This hierarchy reflects the application's information architecture:</p>
<ul><li>Top level: Application areas (home, automobiles, popout)</li>
<p><li>Second level: Features within areas (landing, discover)</li> <li>Pop-out level: Individual components in isolation</li></ul></p></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">906-app-module.md</code> to configure the root AppModule with all necessary imports, providers, and bootstrap configuration.</p></div></div>
    <div class="chapter" id="section-906">
        <div class="chapter-header">
            <div class="chapter-category">Pages</div>
            <h1>906: App Module</h1>
        </div>
<div class="page-content"><h1>906: App Module</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 905-app-routing-module, 312-error-notification-service, 313-http-error-interceptor, 314-global-error-handler, 608-domain-providers <strong>Blocks:</strong> 907-final-integration</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how to configure the root Angular module with all necessary providers</li>
<p><li>Know how to set up HTTP interceptors for global error handling</li> <li>Be able to register domain configuration providers at the application level</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Configure the root <code class="inline">AppModule</code> — the central hub that bootstraps the application and registers all global services, providers, and configurations. This module ties together everything we've built across all phases.</p>

<hr>

<h2>Why</h2>

<p>The <code class="inline">AppModule</code> is the entry point for your Angular application. It:</p>

<ul><li><strong>Bootstraps the Application</strong> — Tells Angular which component to load first</li>
<p><li><strong>Registers Global Providers</strong> — Services available throughout the app</li> <li><strong>Configures HTTP Layer</strong> — Sets up interceptors for error handling</li> <li><strong>Imports Core Modules</strong> — BrowserModule, HttpClient, etc.</li> <li><strong>Registers Domain Configuration</strong> — Makes domain config available via DI</li></p>
</ul>
<h3>Angular Module Types</h3>

<table>
<p><thead><tr> <th>Type</th> <th>Purpose</th> <th>Example</th></p>
</tr></thead>
<p><tbody> <tr> <td>Root Module</td> <td>Bootstraps app, global config</td> <td><code class="inline">AppModule</code></td></p>
</tr>
<p><tr> <td>Feature Module</td> <td>Encapsulates a feature</td> <td><code class="inline">AutomobileModule</code></td></p>
</tr>
<p><tr> <td>Shared Module</td> <td>Commonly used components/pipes</td> <td><code class="inline">SharedModule</code></td></p>
</tr>
<p><tr> <td>Core Module</td> <td>Singleton services</td> <td><code class="inline">CoreModule</code></td></p>
</tr>
</tbody>
</table>

<p>For vvroom, we use a simplified structure:</p>
<ul><li><code class="inline">AppModule</code> handles root and core concerns</li>
<p><li>Feature modules are lazy-loaded</li> <li>Framework services are provided at root level via <code class="inline">@Injectable({ providedIn: 'root' })</code></li></p>
</ul>
<h3>Angular Style Guide References</h3>

<ul><li><a href="https://angular.io/guide/styleguide#style-04-12">Style 04-12</a>: Do not export the root module</li>
<p><li><a href="https://angular.io/guide/styleguide#style-04-13">Style 04-13</a>: Use the root module for configuration</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 906.1: Create the Complete AppModule</h3>

<p>Replace the contents of <code class="inline">src/app/app.module.ts</code>:</p></div><div class="page-content"><pre class="code-block typescript"><code>// src/app/app.module.ts
<p>// VERSION 1 (Section 906) - Complete application module configuration</p>

<p>import { ErrorHandler, Injector, NgModule } from '@angular/core'; import { BrowserModule } from '@angular/platform-browser'; import { BrowserAnimationsModule } from '@angular/platform-browser/animations'; import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';</p>

<p>import { AppComponent } from './app.component'; import { AppRoutingModule } from './app-routing.module';</p>

<p>// Framework services for global configuration import { HttpErrorInterceptor } from './framework/services/http-error.interceptor'; import { GlobalErrorHandler } from './framework/services/global-error.handler'; import { DOMAIN_CONFIG } from './framework/services/domain-config-registry.service';</p>

<p>// Domain configuration import { createAutomobileDomainConfig } from './domain-config/automobile';</p>

<p>/**</p>
 <ul><li>Root Application Module</li>
</ul> *
 <ul><li>Central configuration hub for the vvroom application.</li>
</ul> *
 <ul><li>Responsibilities:</li>
</ul> <ul><li>- Bootstrap the AppComponent</li>
</ul> <ul><li>- Configure HTTP client with error interceptor</li>
</ul> <ul><li>- Set up global error handling</li>
</ul> <ul><li>- Provide domain configuration for dependency injection</li>
</ul> *
 <ul><li>Module Import Order:</li>
</ul> <ul><li>1. BrowserModule (must be first for browser apps)</li>
</ul> <ul><li>2. BrowserAnimationsModule (enables Angular animations)</li>
</ul> <ul><li>3. HttpClientModule (enables HTTP requests)</li>
</ul> <ul><li>4. AppRoutingModule (application routes)</li>
</ul> *
 <ul><li>Note: Feature modules (Home, Automobile, Popout) are lazy-loaded</li>
</ul> <ul><li>via the router, not imported here.</li>
</ul> */
<p>@NgModule({ declarations: [ AppComponent ], imports: [ // Angular core modules BrowserModule, BrowserAnimationsModule, HttpClientModule,</p>

<p>// Application routing AppRoutingModule ], providers: [ // HTTP Error Interceptor - catches all HTTP errors { provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: true },</p>

<p>// Global Error Handler - catches all unhandled errors { provide: ErrorHandler, useClass: GlobalErrorHandler },</p>

<p>// Domain Configuration - provides automobile config to all components { provide: DOMAIN_CONFIG, useFactory: createAutomobileDomainConfig, deps: [Injector] } ], bootstrap: [AppComponent] }) export class AppModule {}</p>
</code></pre>

<p><strong>Module configuration explained:</strong></p>

<table>
<p><thead><tr> <th>Section</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">declarations</code></td> <td>Components owned by this module (only AppComponent)</td></p>
</tr>
<p><tr> <td><code class="inline">imports</code></td> <td>Other modules this module depends on</td></p>
</tr>
<p><tr> <td><code class="inline">providers</code></td> <td>Services and tokens available globally</td></p>
</tr>
<p><tr> <td><code class="inline">bootstrap</code></td> <td>The root component to start the application</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h3>Step 906.2: Understanding the Provider Configuration</h3>

<p>Let's examine each provider in detail:</p>

<h4>HTTP Interceptor</h4>

<pre class="code-block typescript"><code>{
<p>provide: HTTP_INTERCEPTORS, useClass: HttpErrorInterceptor, multi: true }</p>
</code></pre>

<ul><li><code class="inline">HTTP_INTERCEPTORS</code> is an Angular token for HTTP middleware</li>
<p><li><code class="inline">useClass</code> instantiates <code class="inline">HttpErrorInterceptor</code></li> <li><code class="inline">multi: true</code> allows multiple interceptors (they chain together)</li></p>
</ul>
<p>The interceptor catches HTTP errors before they reach components, enabling centralized error handling.</p>

<h4>Global Error Handler</h4>

<pre class="code-block typescript"><code>{
<p>provide: ErrorHandler, useClass: GlobalErrorHandler }</p>
</code></pre>

<ul><li><code class="inline">ErrorHandler</code> is Angular's built-in error handling token</li>
<p><li>Replacing it with <code class="inline">GlobalErrorHandler</code> catches all unhandled errors</li> <li>Useful for logging, error reporting, and user notification</li></p>
</ul>
<h4>Domain Configuration</h4>

<pre class="code-block typescript"><code>{
<p>provide: DOMAIN_CONFIG, useFactory: createAutomobileDomainConfig, deps: [Injector] }</p>
</code></pre>

<ul><li><code class="inline">DOMAIN_CONFIG</code> is our custom injection token (from Phase 3)</li>
<p><li><code class="inline">useFactory</code> calls a function to create the config</li> <li><code class="inline">deps: [Injector]</code> provides the Injector to the factory</li> <li>Components can inject <code class="inline">DOMAIN_CONFIG</code> to access domain configuration</li></p>
</ul>
<hr>

<h3>Step 906.3: Domain Configuration Factory</h3>

<p>The factory function creates the automobile domain configuration. This should be defined in <code class="inline">src/app/domain-config/automobile/index.ts</code>:</p>

<pre class="code-block typescript"><code>// src/app/domain-config/automobile/index.ts
<p>// VERSION 1 (Section 906) - Domain config factory</p>

<p>import { Injector } from '@angular/core'; import { DomainConfig } from '../../framework/models/domain-config.interface'; import { automobileDomainConfig } from './automobile.domain-config';</p>

<p>/**</p>
 <ul><li>Factory function for creating automobile domain configuration</li>
</ul> *
 <ul><li>This factory is called by Angular's dependency injection system</li>
</ul> <ul><li>when DOMAIN_CONFIG is first requested.</li>
</ul> *
 <ul><li>@param injector - Angular's Injector for creating service instances</li>
</ul> <ul><li>@returns Complete domain configuration for automobiles</li>
</ul> */
<p>export function createAutomobileDomainConfig(injector: Injector): DomainConfig&lt;any, any, any&gt; { // The base config is defined in automobile.domain-config.ts // The factory allows us to inject dependencies if needed return automobileDomainConfig; }</p>

<p>// Re-export everything from the domain config export * from './automobile.domain-config'; export * from './models'; export * from './adapters'; export * from './configs'; export * from './chart-sources';</p>
</code></pre></div><div class="page-content"><hr>

<h3>Step 906.4: Main Entry Point</h3>

<p>Verify the <code class="inline">main.ts</code> file bootstraps the AppModule:</p>

<pre class="code-block typescript"><code>// src/main.ts
<p>// VERSION 1 (Section 906) - Application bootstrap</p>

<p>import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module';</p>

<p>platformBrowserDynamic() .bootstrapModule(AppModule) .catch(err =&gt; console.error('Bootstrap error:', err));</p>
</code></pre>

<p>This is the entry point that Angular CLI uses to start the application.</p>

<hr>

<h3>Step 906.5: Module Import Order</h3>

<p>The order of imports in <code class="inline">AppModule</code> matters:</p>

<pre class="code-block typescript"><code>imports: [
<p>BrowserModule,           // 1. Browser platform (must be first) BrowserAnimationsModule, // 2. Animation support HttpClientModule,        // 3. HTTP client AppRoutingModule         // 4. Routes (last, so it can use all imported modules) ]</p>
</code></pre>

<p><strong>Why this order?</strong></p>

<ul><li><code class="inline">BrowserModule</code> provides browser-specific services and must be imported first in the root module</li>
<p><li><code class="inline">BrowserAnimationsModule</code> must come after <code class="inline">BrowserModule</code></li> <li><code class="inline">HttpClientModule</code> sets up the HTTP client that services will use</li> <li><code class="inline">AppRoutingModule</code> should be last so routes can reference any components from other imports</li></p>
</ul>
<hr>

<h3>Step 906.6: Production Considerations</h3>

<p>For production, you may want additional configuration. Create/update <code class="inline">src/environments/environment.prod.ts</code>:</p>

<pre class="code-block typescript"><code>// src/environments/environment.prod.ts
<p>// VERSION 1 (Section 906) - Production environment</p>

<p>export const environment = { production: true, apiBaseUrl: 'http://generic-prime.minilab/api/specs/v1' };</p>
</code></pre>

<p>And in <code class="inline">main.ts</code>, you can enable production mode:</p>

<pre class="code-block typescript"><code>// src/main.ts
<p>// VERSION 2 (Section 906) - Production mode support</p>

<p>import { enableProdMode } from '@angular/core'; import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; import { environment } from './environments/environment';</p>

<p>if (environment.production) { enableProdMode(); }</p>

<p>platformBrowserDynamic() .bootstrapModule(AppModule) .catch(err =&gt; console.error('Bootstrap error:', err));</p>
</code></pre></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>1. Build the Application</h3>

<pre class="code-block bash"><code>$ ng build
</code></pre>

<p>Expected: Build succeeds with no errors.</p>

<h3>2. Serve the Application</h3>

<pre class="code-block bash"><code>$ ng serve
</code></pre>

<p>Expected: Application starts without errors. Console should show:</p>

<pre class="code-block text"><code>✔ Compiled successfully.
</code></pre>

<h3>3. Check Provider Registration</h3>

<p>Open browser DevTools and verify:</p>

<ul><li><strong>HTTP Interceptor:</strong> Make a request and check Network tab. Errors should be handled gracefully.</li>
</ul>
<ul><li><strong>Global Error Handler:</strong> In console, run:</li>
</ul>   <pre class="code-block javascript"><code>   throw new Error('Test error');
   </code></pre>
<p>The error should be caught by <code class="inline">GlobalErrorHandler</code>.</p>

<ul><li><strong>Domain Config:</strong> Components should receive domain configuration. If the discover page loads and shows data, the config is working.</li>
</ul>
<h3>4. Verify Lazy Loading</h3>

<p>In the Network tab, observe chunk files loading:</p>
<ul><li>Initial load: <code class="inline">main.js</code>, <code class="inline">vendor.js</code>, <code class="inline">polyfills.js</code></li>
<p><li>Navigate to <code class="inline">/automobiles</code>: <code class="inline">automobile-module.js</code> loads</li> <li>Navigate to <code class="inline">/automobiles/discover</code>: No new chunk (same module)</li></p>
</ul>
<h3>5. Full Application Test</h3>

<p>Complete this workflow:</p>
<ul><li>Open <code class="inline">http://localhost:4200</code> → Redirects to <code class="inline">/home</code></li>
<p><li>Click "Automobiles" → Navigates to automobile landing</li> <li>Click "Advanced Search" → Navigates to discover page</li> <li>Apply filters → Data loads, URL updates</li> <li>Refresh page → Filters persist</li> <li>Pop out a panel → New window opens with synced state</li></p>
</ul>
<hr>

<h2>Common Problems</h2>

<table>
<p><thead><tr> <th>Symptom</th> <th>Cause</th> <th>Solution</th></p>
</tr></thead>
<p><tbody> <tr> <td>"No provider for HttpClient"</td> <td>HttpClientModule not imported</td> <td>Add <code class="inline">HttpClientModule</code> to imports</td></p>
</tr>
<p><tr> <td>"NullInjectorError: No provider for DOMAIN_CONFIG"</td> <td>Factory not registered</td> <td>Add DOMAIN_CONFIG provider with factory</td></p>
</tr>
<p><tr> <td>Animations not working</td> <td>BrowserAnimationsModule missing</td> <td>Add <code class="inline">BrowserAnimationsModule</code> to imports</td></p>
</tr>
<p><tr> <td>Multiple instances of services</td> <td>Wrong providedIn setting</td> <td>Use <code class="inline">providedIn: 'root'</code> for singletons</td></p>
</tr>
<p><tr> <td>HTTP interceptor not firing</td> <td>Not registered properly</td> <td>Use <code class="inline">multi: true</code> with HTTP_INTERCEPTORS</td></p>
</tr>
<p><tr> <td>"AppComponent is not known element"</td> <td>Not in declarations</td> <td>Add AppComponent to declarations array</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>AppModule is the configuration hub</strong> — It wires together all parts of the application</li>
<p><li><strong>Provider order doesn't matter, import order does</strong> — Especially for BrowserModule</li> <li><strong>Use factories for complex configuration</strong> — The DOMAIN_CONFIG factory pattern is powerful</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] <code class="inline">AppModule</code> imports BrowserModule, BrowserAnimationsModule, HttpClientModule, and AppRoutingModule</li>
<p><li>[ ] <code class="inline">AppComponent</code> is declared and bootstrapped</li> <li>[ ] <code class="inline">HTTP_INTERCEPTORS</code> provider registers <code class="inline">HttpErrorInterceptor</code></li> <li>[ ] <code class="inline">ErrorHandler</code> provider registers <code class="inline">GlobalErrorHandler</code></li> <li>[ ] <code class="inline">DOMAIN_CONFIG</code> provider uses factory function with Injector</li> <li>[ ] <code class="inline">main.ts</code> bootstraps <code class="inline">AppModule</code></li> <li>[ ] Application builds without errors</li> <li>[ ] Application runs and all routes are accessible</li> <li>[ ] HTTP errors are caught by the interceptor</li> <li>[ ] Domain configuration is available throughout the app</li></p>
</ul>
<hr>

<h2>Architecture Note: Provider Scopes</h2>

<p>Angular's dependency injection has different scopes:</p>

<table>
<p><thead><tr> <th>Scope</th> <th>How to Achieve</th> <th>Lifetime</th></p>
</tr></thead>
<p><tbody> <tr> <td>Application (singleton)</td> <td><code class="inline">@Injectable({ providedIn: 'root' })</code></td> <td>Entire app lifetime</td></p>
</tr>
<p><tr> <td>Module</td> <td><code class="inline">providers: []</code> in module</td> <td>Module lifetime</td></p>
</tr>
<p><tr> <td>Component</td> <td><code class="inline">providers: []</code> in component</td> <td>Component lifetime</td></p>
</tr>
</tbody>
</table>

<p>In vvroom:</p>
<ul><li><strong>Root-level singletons:</strong> <code class="inline">UrlStateService</code>, <code class="inline">DomainConfigRegistry</code>, <code class="inline">ErrorNotificationService</code></li>
<p><li><strong>Module-provided:</strong> None (all framework services are root)</li> <li><strong>Component-provided:</strong> <code class="inline">ResourceManagementService</code>, <code class="inline">PopOutManagerService</code> (new instance per component)</li></p>
</ul>
<p>This design ensures:</p>
<ul><li>Shared services (URL state) are consistent across the app</li>
<p><li>Per-page services (resource management) are isolated to their component</li></p>
</ul>
<hr>

<h2>Module Relationship Diagram</h2>

<pre class="code-block text"><code>AppModule (root)
<p>│ ├── BrowserModule ├── BrowserAnimationsModule ├── HttpClientModule ├── AppRoutingModule ─────────────────┐ │                                      │ │   Lazy-loaded via routes:           │ │   ┌────────────────────────────────┘ │   │ │   ├── HomeModule │   │   └── HomeComponent │   │ │   ├── AutomobileModule │   │   ├── AutomobileComponent │   │   ├── AutomobileDiscoverComponent │   │   └── Framework Component Modules │   │ │   └── PopoutModule │       └── PopoutComponent │ └── Providers: ├── HTTP_INTERCEPTORS → HttpErrorInterceptor ├── ErrorHandler → GlobalErrorHandler └── DOMAIN_CONFIG → createAutomobileDomainConfig()</p>
</code></pre></div><div class="page-content"><hr>

<h2>Next Step</h2>

<p>Proceed to <code class="inline">907-final-integration.md</code> to complete the integration, perform final testing, and celebrate completing the vvroom application!</p></div></div>
    <div class="chapter" id="section-907">
        <div class="chapter-header">
            <div class="chapter-category">Pages</div>
            <h1>907: Final Integration</h1>
        </div>
<div class="page-content"><h1>907: Final Integration</h1>

<p><strong>Status:</strong> Planning <strong>Depends On:</strong> 901-906 (All Phase 9 components) <strong>Blocks:</strong> None (Final document)</p>

<hr>

<h2>Learning Objectives</h2>

<p>After completing this section, you will:</p>
<ul><li>Understand how all the pieces of the vvroom application fit together</li>
<p><li>Be able to perform comprehensive integration testing</li> <li>Have a fully functional production-ready Angular application</li></p>
</ul>
<hr>

<h2>Objective</h2>

<p>Complete the final integration of the vvroom application by verifying all components work together, performing comprehensive testing, and ensuring the application is ready for production use. This is the culmination of everything you've built throughout this book.</p>

<hr>

<h2>Congratulations!</h2>

<p>You've made it. From an empty Angular project to a fully-featured data exploration application, you've typed every line of code and understood every decision. Let's take a moment to appreciate what you've built.</p>

<h3>What You've Accomplished</h3>

<p>Over the course of this book, you have:</p>

<p><strong>Phase 0: API Contract &amp; Naming</strong></p>
<ul><li>Defined the API contract that drives the entire application</li>
<p><li>Established naming conventions separating framework from domain code</li></p>
</ul>
<p><strong>Phase 1: Foundation</strong></p>
<ul><li>Created the project structure from scratch</li>
<p><li>Configured routing and environment settings</li> <li>Built the application shell</li></p>
</ul>
<p><strong>Phase 2: Framework Models</strong></p>
<ul><li>Defined TypeScript interfaces for type safety</li>
<p><li>Created generic models that work with any domain</li> <li>Learned how interfaces serve as executable documentation</li></p>
</ul>
<p><strong>Phase 3: Framework Services</strong></p>
<ul><li>Built the URL-First state management system</li>
<p><li>Created services for API communication, error handling, and pop-out windows</li> <li>Implemented the service layer that powers the entire application</li></p>
</ul>
<p><strong>Phase 4-6: Automobile Domain</strong></p>
<ul><li>Defined automobile-specific models, adapters, and configurations</li>
<p><li>Created the bridge between framework and domain</li> <li>Configured filters, tables, and charts for automobile data</li></p>
</ul>
<p><strong>Phase 7: Chart Data Sources</strong></p>
<ul><li>Implemented visualization data transformations</li>
<p><li>Created reusable chart source patterns</li></p>
</ul>
<p><strong>Phase 8: Framework Components</strong></p>
<ul><li>Built reusable UI components for queries, charts, tables, and pickers</li>
<p><li>Created components that work with any domain configuration</li> <li>Implemented the visual layer of the application</li></p>
</ul>
<p><strong>Phase 9: Feature Components</strong></p>
<ul><li>Orchestrated framework components into complete pages</li>
<p><li>Built the Home, Automobile Landing, and Discover pages</li> <li>Implemented pop-out window support for multi-monitor workflows</li> <li>Configured routing and the root module</li></ul></p></div><div class="page-content"><h3>The Aha Moment</h3>

<p><strong>"I just built a production application. I understand every line."</strong></p>

<p>This is what sets you apart. You didn't just follow a tutorial — you understand:</p>

<ul><li>Why the URL is the single source of truth</li>
<p><li>How dependency injection wires everything together</li> <li>What makes a component reusable vs. domain-specific</li> <li>When to use BehaviorSubject vs. ReplaySubject</li> <li>How to debug RxJS streams</li> <li>Why TypeScript generics enable type-safe reuse</li></p>
</ul>
<hr>

<h2>What</h2>

<h3>Step 907.1: Complete File Structure Verification</h3>

<p>Let's verify the complete file structure of the application:</p>

<pre class="code-block bash"><code>$ cd ~/projects/vvroom
<p>$ find src/app -type f -name "*.ts" | wc -l</p>
</code></pre>

<p>You should have approximately 60-70 TypeScript files across:</p>

<pre class="code-block text"><code>src/app/
<p>├── app.component.ts ├── app.module.ts ├── app-routing.module.ts ├── domain-config/ │   └── automobile/ │       ├── adapters/          (3 files) │       ├── chart-sources/     (4 files) │       ├── configs/           (6 files) │       ├── models/            (3 files) │       └── automobile.domain-config.ts ├── features/ │   ├── home/                  (3 files) │   ├── automobile/ │   │   ├── automobile-discover/  (4 files) │   │   └── (4 files) │   └── popout/                (4 files) └── framework/ ├── components/            (~27 files across 9 components) ├── models/                (8 files) ├── services/              (12 files) └── tokens/                (1 file)</p>
</code></pre>

<h3>Step 907.2: Build Verification</h3>

<p>Perform a production build to verify everything compiles correctly:</p>

<pre class="code-block bash"><code>$ ng build --configuration production
</code></pre>

<p>Expected output:</p>

<pre class="code-block text"><code>✔ Browser application bundle generation complete.
<p>✔ Copying assets complete. ✔ Index html generation complete.</p>

<p>Initial Chunk Files           | Names         |  Raw Size | Estimated Transfer Size main.js                       | main          | 250.00 kB |              65.00 kB polyfills.js                  | polyfills     | 180.00 kB |              57.00 kB styles.css                    | styles        |  15.00 kB |               4.00 kB runtime.js                    | runtime       |   2.00 kB |               1.00 kB</p>

<p>Lazy Chunk Files              | Names         |  Raw Size | Estimated Transfer Size automobile-module.js          | automobile    |  80.00 kB |              20.00 kB home-module.js                | home          |   5.00 kB |               2.00 kB popout-module.js              | popout        |  10.00 kB |               3.00 kB</p>

<p>Build at: 2026-02-09T17:00:00.000Z - Hash: abc123def456 - Time: 15000ms</p>
</code></pre>

<p><strong>Key points:</strong></p>
<ul><li>No errors or warnings</li>
<p><li>Lazy chunks are generated for feature modules</li> <li>Bundle sizes are reasonable</li></ul></p></div><div class="page-content"><h3>Step 907.3: Integration Test Checklist</h3>

<p>Run through this comprehensive test checklist:</p>

<h4>Navigation Tests</h4>

<table>
<p><thead><tr> <th>Test</th> <th>Expected Result</th> <th>Pass?</th></p>
</tr></thead>
<p><tbody> <tr> <td>Open <code class="inline">/</code></td> <td>Redirects to <code class="inline">/home</code></td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Click "Automobiles"</td> <td>Navigates to <code class="inline">/automobiles</code></td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Click "Advanced Search"</td> <td>Navigates to <code class="inline">/automobiles/discover</code></td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Click "Home" in header</td> <td>Returns to <code class="inline">/home</code></td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Enter invalid URL <code class="inline">/xyz</code></td> <td>Redirects to <code class="inline">/home</code></td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Back button</td> <td>Previous page loads</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Forward button</td> <td>Next page loads</td> <td>[ ]</td></p>
</tr>
</tbody>
</table>

<h4>URL State Tests</h4>

<table>
<p><thead><tr> <th>Test</th> <th>Expected Result</th> <th>Pass?</th></p>
</tr></thead>
<p><tbody> <tr> <td>Apply filter on Discover</td> <td>URL updates with query param</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Refresh page with filter</td> <td>Filter persists</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Copy URL to new tab</td> <td>Same state loads</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Clear all filters</td> <td>URL resets to clean state</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Apply multiple filters</td> <td>All params in URL</td> <td>[ ]</td></p>
</tr>
</tbody>
</table>

<h4>Data Loading Tests</h4>

<table>
<p><thead><tr> <th>Test</th> <th>Expected Result</th> <th>Pass?</th></p>
</tr></thead>
<p><tbody> <tr> <td>Load Discover page</td> <td>Results count appears</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Apply manufacturer filter</td> <td>Filtered results load</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Change pagination</td> <td>Page param updates, new data loads</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Sort table column</td> <td>Sort param updates, data re-orders</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Loading indicator</td> <td>Shows during API calls</td> <td>[ ]</td></p>
</tr>
</tbody>
</table>

<h4>Chart Interaction Tests</h4>

<table>
<p><thead><tr> <th>Test</th> <th>Expected Result</th> <th>Pass?</th></p>
</tr></thead>
<p><tbody> <tr> <td>Charts display data</td> <td>Bars/segments visible</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Hover on chart element</td> <td>Tooltip appears</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Click chart bar (filter mode)</td> <td>Filter applied, data updates</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Click chart bar (highlight mode)</td> <td>Highlight added, visual change</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Multiple chart sources</td> <td>All charts update with filters</td> <td>[ ]</td></p>
</tr>
</tbody>
</table>

<h4>Pop-out Tests</h4>

<table>
<p><thead><tr> <th>Test</th> <th>Expected Result</th> <th>Pass?</th></p>
</tr></thead>
<p><tbody> <tr> <td>Click pop-out button</td> <td>New window opens</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Pop-out shows data</td> <td>State synced from main</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Change filter in main</td> <td>Pop-out updates</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Close pop-out</td> <td>Panel reappears in main</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Pop-out header hidden</td> <td>No navigation in pop-out</td> <td>[ ]</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><h4>Query Control Tests</h4>

<table>
<p><thead><tr> <th>Test</th> <th>Expected Result</th> <th>Pass?</th></p>
</tr></thead>
<p><tbody> <tr> <td>Dropdown filter works</td> <td>Options load, selection applies</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Text search works</td> <td>Search executes on enter</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Clear individual filter</td> <td>Only that filter removed</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Clear all filters</td> <td>All filters removed</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Filter chips display</td> <td>Active filters shown</td> <td>[ ]</td></p>
</tr>
</tbody>
</table>

<h4>Error Handling Tests</h4>

<table>
<p><thead><tr> <th>Test</th> <th>Expected Result</th> <th>Pass?</th></p>
</tr></thead>
<p><tbody> <tr> <td>API error occurs</td> <td>Error notification shown</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Network timeout</td> <td>Graceful error message</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>Invalid filter value</td> <td>Validation feedback</td> <td>[ ]</td></p>
</tr>
<p><tr> <td>404 route</td> <td>Redirects to home</td> <td>[ ]</td></p>
</tr>
</tbody>
</table>

<h3>Step 907.4: Performance Verification</h3>

<p>Check application performance:</p>

<pre class="code-block bash"><code># Development server
<p>$ ng serve</p>

<h1>In another terminal, run Lighthouse or similar tool</h1>
<h1>Or manually check DevTools Performance tab</h1>
</code></pre>

<p>Performance targets:</p>
<ul><li>First Contentful Paint: &lt; 1.5s</li>
<p><li>Time to Interactive: &lt; 3s</li> <li>Largest Contentful Paint: &lt; 2.5s</li> <li>No layout shifts during load</li></p>
</ul>
<h3>Step 907.5: Code Quality Check</h3>

<p>Run linting and formatting:</p>

<pre class="code-block bash"><code>$ ng lint
</code></pre>

<p>Expected: No errors. (Warnings acceptable for rough draft.)</p>

<h3>Step 907.6: Final Review of Key Patterns</h3>

<p>Let's summarize the key architectural patterns used throughout the application:</p>

<h4>URL-First State Management</h4>

<pre class="code-block text"><code>URL (source of truth)
<p>↓ UrlStateService (URL → Params) ↓ ResourceManagementService (Params → Filters → API) ↓ Components (via async pipe)</p>
</code></pre>

<p>Every piece of state is derived from the URL. This enables:</p>
<ul><li>Deep linking</li>
<p><li>Browser history support</li> <li>State sharing via URL</li> <li>Debuggability</li></p>
</ul>
<h4>Dependency Injection Hierarchy</h4>

<pre class="code-block text"><code>AppModule (global providers)
<p>↓ Feature Module (lazy-loaded) ↓ Component (component-level providers) ↓ Template (via async pipe)</p>
</code></pre>

<p>Services are provided at the appropriate level:</p>
<ul><li>Singletons at root</li>
<p><li>Per-page instances at component level</li></p>
</ul>
<h4>Component Composition</h4>

<pre class="code-block text"><code>Feature Component (orchestrator)
<p>├── Framework Component (reusable) │   └── Domain Config (configuration) └── Framework Component (reusable) └── Domain Config (configuration)</p>
</code></pre>

<p>Framework components are reusable shells. Domain configuration provides the specifics.</p></div><div class="page-content"><hr>

<h2>Verification</h2>

<h3>Final Build and Serve</h3>

<pre class="code-block bash"><code>$ ng build --configuration production
<p>$ npx http-server dist/vvroom -p 8080</p>
</code></pre>

<p>Open <code class="inline">http://localhost:8080</code> and verify:</p>

<ul><li>Application loads without errors</li>
<p><li>All pages are accessible</li> <li>Data loads correctly</li> <li>Pop-outs work</li> <li>URL state persists</li></p>
</ul>
<h3>Commit the Final State</h3>

<pre class="code-block bash"><code>$ git add .
<p>$ git commit -m "Section 907: Complete vvroom application" $ git tag phase-9-complete</p>
</code></pre>

<hr>

<h2>What You've Built</h2>

<h3>Application Statistics</h3>

<table>
<p><thead><tr> <th>Metric</th> <th>Value</th></p>
</tr></thead>
<p><tbody> <tr> <td>TypeScript Files</td> <td>~70</td></p>
</tr>
<p><tr> <td>Lines of Code</td> <td>~11,000</td></p>
</tr>
<p><tr> <td>Components</td> <td>~15</td></p>
</tr>
<p><tr> <td>Services</td> <td>~12</td></p>
</tr>
<p><tr> <td>Interfaces</td> <td>~10</td></p>
</tr>
<p><tr> <td>Feature Modules</td> <td>3</td></p>
</tr>
</tbody>
</table>

<h3>Capabilities</h3>

<ul><li><strong>Data Exploration:</strong> Filter, sort, and paginate through automobile data</li>
<p><li><strong>Visualization:</strong> Charts for manufacturers, years, body classes</li> <li><strong>Multi-Monitor:</strong> Pop-out any panel to a separate window</li> <li><strong>URL Persistence:</strong> Every view has a shareable URL</li> <li><strong>Error Handling:</strong> Graceful error messages and recovery</li> <li><strong>Performance:</strong> Lazy loading, OnPush change detection</li></p>
</ul>
<h3>Technologies Used</h3>

<table>
<p><thead><tr> <th>Technology</th> <th>Purpose</th></p>
</tr></thead>
<p><tbody> <tr> <td>Angular 13</td> <td>Application framework</td></p>
</tr>
<p><tr> <td>TypeScript</td> <td>Type-safe JavaScript</td></p>
</tr>
<p><tr> <td>RxJS</td> <td>Reactive state management</td></p>
</tr>
<p><tr> <td>Angular Router</td> <td>Navigation</td></p>
</tr>
<p><tr> <td>HttpClient</td> <td>API communication</td></p>
</tr>
<p><tr> <td>BroadcastChannel</td> <td>Pop-out communication</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Architecture matters</strong> — The URL-First pattern made state management simple and predictable</li>
<p><li><strong>Generics enable reuse</strong> — Framework components work with any domain configuration</li> <li><strong>Separation of concerns</strong> — Framework, domain, and feature code have clear boundaries</li> <li><strong>TypeScript is your friend</strong> — Type safety caught errors before runtime</li> <li><strong>RxJS is powerful</strong> — Reactive streams simplified complex async operations</li></p>
</ul>
<hr>

<h2>Acceptance Criteria</h2>

<ul><li>[ ] Production build completes without errors</li>
<p><li>[ ] All navigation paths work correctly</li> <li>[ ] URL state persistence works (refresh preserves state)</li> <li>[ ] Data loads and displays correctly</li> <li>[ ] Charts are interactive</li> <li>[ ] Pop-out windows sync with main window</li> <li>[ ] Error handling shows appropriate messages</li> <li>[ ] Performance is acceptable (no jank, reasonable load times)</li> <li>[ ] Code passes linting</li></ul></p></div><div class="page-content"><hr>

<h2>Where to Go from Here</h2>

<p>You've built a complete application, but there's always more to learn:</p>

<h3>Immediate Extensions</h3>
<ul><li>Add more filter types (date ranges, multi-select)</li>
<p><li>Implement data export (CSV, Excel)</li> <li>Add user preferences persistence</li> <li>Create custom chart types</li></p>
</ul>
<h3>Advanced Topics</h3>
<ul><li>Unit testing with Jest</li>
<p><li>E2E testing with Playwright</li> <li>State management with NgRx</li> <li>Server-side rendering with Angular Universal</li> <li>Progressive Web App (PWA) features</li></p>
</ul>
<h3>Architecture Evolution</h3>
<ul><li>Micro-frontends</li>
<p><li>Module federation</li> <li>GraphQL integration</li> <li>Real-time updates with WebSockets</li></p>
</ul>
<h3>The Companion Book Opportunity</h3>

<p>Because you followed strict naming conventions and separated framework from domain code, expanding vvroom to support additional domains is straightforward. A companion book could cover:</p>

<ul><li>"Adding Agriculture to Vvroom" (just domain configuration)</li>
<p><li>"Adding Chemistry to Vvroom" (just domain configuration)</li></p>
</ul>
<p>The framework code you wrote is truly reusable.</p>

<hr>

<h2>Final Words</h2>

<p>Congratulations. You've done something remarkable.</p>

<p>You didn't just copy code from a tutorial. You didn't rely on magic you don't understand. You built a production-quality Angular application from the ground up, and you know why every line is there.</p>

<p>This knowledge will serve you well. Whether you're building your own applications, contributing to enterprise projects, or teaching others, you now have a deep understanding of Angular architecture that most developers never achieve.</p>

<p>The URL-First pattern, the generic component architecture, the service layer design — these patterns will apply to projects far beyond vvroom.</p>

<p>Thank you for taking this journey. Now go build something amazing.</p>

<hr>

<h2>The Complete Journey</h2>

<pre class="code-block text"><code>Phase 0: API Contract          ──→  "The API defines everything"
<p>│ Phase 1: Foundation            ──→  "Routes are the skeleton" │ Interlude A: Generics          ──→  "Type safety without duplication" │ Phase 2: Framework Models      ──→  "Interfaces are documentation" │ Interlude B: RxJS              ──→  "Observables model change" │ Phase 3: Framework Services    ──→  "The URL is the source of truth" │ Phase 4: Domain Models         ──→  "Models shaped by the API" │ Phase 5: Domain Adapters       ──→  "Adapters isolate change" │ Phase 6: Domain Configs        ──→  "Configuration is code" │ Phase 7: Chart Sources         ──→  "Transform data for visualization" │ Phase 8: Framework Components  ──→  "Generic + specific = reusable" │ Phase 9: Feature Components    ──→  "I understand every line"</p>
</code></pre>

<p><strong>Welcome to the club of Angular architects.</strong></p></div></div>
    <div class="chapter" id="section-951">
        <div class="chapter-header">
            <div class="chapter-category">Reference</div>
            <h1>951: RxJS Operator Reference</h1>
        </div>
<div class="page-content"><h1>951: RxJS Operator Reference</h1>

<p><strong>Status:</strong> Reference Document <strong>Type:</strong> Appendix</p>

<hr>

<h2>Learning Objectives</h2>

<p>After reading this reference, you will:</p>
<ul><li>Have a quick reference for all RxJS operators used in vvroom</li>
<p><li>Understand when to use each operator</li> <li>Be able to look up operator behavior without leaving the book</li></p>
</ul>
<hr>

<h2>Overview</h2>

<p>This appendix provides a quick reference for every RxJS operator used in the vvroom application. Operators are grouped by category for easy lookup.</p>

<hr>

<h2>Creation Operators</h2>

<h3><code class="inline">of()</code></h3>

<p>Creates an Observable that emits the provided values synchronously.</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';

<p>of('a', 'b', 'c').subscribe(x =&gt; console.log(x)); // Output: 'a', 'b', 'c' (then completes)</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Error handling fallbacks, mock data</p>

<hr>

<h3><code class="inline">Subject</code></h3>

<p>A Subject is both an Observable and an Observer. You can push values into it and subscribe to it.</p>

<pre class="code-block typescript"><code>import { Subject } from 'rxjs';

<p>const subject = new Subject&lt;string&gt;();</p>

<p>subject.subscribe(x =&gt; console.log(x)); subject.next('hello'); // Output: 'hello'</p>
</code></pre>

<p><strong>Used in vvroom:</strong> <code class="inline">destroy$</code> for cleanup, event buses</p>

<hr>

<h3><code class="inline">BehaviorSubject</code></h3>

<p>A Subject that requires an initial value and emits the current value to new subscribers.</p>

<pre class="code-block typescript"><code>import { BehaviorSubject } from 'rxjs';

<p>const subject = new BehaviorSubject&lt;number&gt;(0);</p>

<p>subject.subscribe(x =&gt; console.log('A:', x)); // Output: 'A: 0' subject.next(1);                               // Output: 'A: 1' subject.subscribe(x =&gt; console.log('B:', x)); // Output: 'B: 1'</p>
</code></pre>

<p><strong>Used in vvroom:</strong> <code class="inline">stateSubject</code> in ResourceManagementService, <code class="inline">paramsSubject</code> in UrlStateService</p>

<hr>

<h3><code class="inline">ReplaySubject</code></h3>

<p>A Subject that replays a specified number of previous values to new subscribers.</p>

<pre class="code-block typescript"><code>import { ReplaySubject } from 'rxjs';

<p>const subject = new ReplaySubject&lt;number&gt;(2); // Buffer last 2 values</p>

<p>subject.next(1); subject.next(2); subject.next(3);</p>

<p>subject.subscribe(x =&gt; console.log(x)); // Output: 2, 3</p>
</code></pre>

<p><strong>Used in vvroom:</strong> PopOutContextService for message replay</p></div><div class="page-content"><hr>

<h3><code class="inline">timer()</code></h3>

<p>Creates an Observable that emits after a delay.</p>

<pre class="code-block typescript"><code>import { timer } from 'rxjs';

<p>timer(1000).subscribe(() =&gt; console.log('1 second passed'));</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Request debouncing</p>

<hr>

<h3><code class="inline">throwError()</code></h3>

<p>Creates an Observable that immediately emits an error.</p>

<pre class="code-block typescript"><code>import { throwError } from 'rxjs';

<p>throwError(() =&gt; new Error('Something went wrong')) .subscribe({ error: err =&gt; console.error(err.message) });</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Error propagation in services</p>

<hr>

<h2>Transformation Operators</h2>

<h3><code class="inline">map()</code></h3>

<p>Transforms each emitted value using a projection function.</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { map } from 'rxjs/operators';</p>

<p>of(1, 2, 3).pipe( map(x =&gt; x * 10) ).subscribe(x =&gt; console.log(x)); // Output: 10, 20, 30</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Transforming API responses, extracting state properties</p>

<hr>

<h3><code class="inline">switchMap()</code></h3>

<p>Maps to an inner Observable and cancels the previous inner Observable on each emission.</p>

<pre class="code-block typescript"><code>import { of, interval } from 'rxjs';
<p>import { switchMap, take } from 'rxjs/operators';</p>

<p>of('A', 'B').pipe( switchMap(letter =&gt; interval(100).pipe( take(3), map(i =&gt; letter + i) )) ).subscribe(x =&gt; console.log(x)); // Only 'B' values emit (A is cancelled) // Output: B0, B1, B2</p>
</code></pre>

<p><strong>Used in vvroom:</strong> API calls that cancel previous requests when filters change</p>

<p><strong>When to use:</strong> When only the latest request matters (search, autocomplete)</p>

<hr>

<h3><code class="inline">mergeMap()</code></h3>

<p>Maps to an inner Observable and runs all inner Observables concurrently.</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { mergeMap, delay } from 'rxjs/operators';</p>

<p>of(1, 2, 3).pipe( mergeMap(x =&gt; of(x).pipe(delay(100))) ).subscribe(x =&gt; console.log(x)); // Output: 1, 2, 3 (all run in parallel)</p>
</code></pre>

<p><strong>When to use:</strong> When all requests should complete (batch operations)</p>

<hr>

<h3><code class="inline">concatMap()</code></h3>

<p>Maps to an inner Observable and waits for each to complete before starting the next.</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { concatMap, delay } from 'rxjs/operators';</p>

<p>of(1, 2, 3).pipe( concatMap(x =&gt; of(x).pipe(delay(100))) ).subscribe(x =&gt; console.log(x)); // Output: 1 (wait) 2 (wait) 3 (sequential)</p>
</code></pre>

<p><strong>When to use:</strong> When order matters and each request must complete first</p></div><div class="page-content"><hr>

<h2>Filtering Operators</h2>

<h3><code class="inline">filter()</code></h3>

<p>Emits only values that pass the predicate function.</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { filter } from 'rxjs/operators';</p>

<p>of(1, 2, 3, 4, 5).pipe( filter(x =&gt; x % 2 === 0) ).subscribe(x =&gt; console.log(x)); // Output: 2, 4</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Filtering router events to NavigationEnd</p>

<hr>

<h3><code class="inline">distinctUntilChanged()</code></h3>

<p>Emits only when the current value differs from the previous.</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { distinctUntilChanged } from 'rxjs/operators';</p>

<p>of(1, 1, 2, 2, 3, 1).pipe( distinctUntilChanged() ).subscribe(x =&gt; console.log(x)); // Output: 1, 2, 3, 1</p>
</code></pre>

<p><strong>With comparator:</strong></p>

<pre class="code-block typescript"><code>of({ id: 1 }, { id: 1 }, { id: 2 }).pipe(
<p>distinctUntilChanged((a, b) =&gt; a.id === b.id) ).subscribe(x =&gt; console.log(x)); // Output: { id: 1 }, { id: 2 }</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Preventing duplicate API calls when state hasn't changed</p>

<hr>

<h3><code class="inline">take()</code></h3>

<p>Emits only the first N values then completes.</p>

<pre class="code-block typescript"><code>import { interval } from 'rxjs';
<p>import { take } from 'rxjs/operators';</p>

<p>interval(100).pipe( take(3) ).subscribe(x =&gt; console.log(x)); // Output: 0, 1, 2 (then completes)</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Taking single values from streams</p>

<hr>

<h3><code class="inline">takeUntil()</code></h3>

<p>Emits values until a notifier Observable emits.</p>

<pre class="code-block typescript"><code>import { interval, Subject } from 'rxjs';
<p>import { takeUntil } from 'rxjs/operators';</p>

<p>const stop$ = new Subject&lt;void&gt;();</p>

<p>interval(100).pipe( takeUntil(stop$) ).subscribe(x =&gt; console.log(x));</p>

<p>setTimeout(() =&gt; stop$.next(), 350); // Output: 0, 1, 2 (then stops)</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Component cleanup pattern with <code class="inline">destroy$</code></p>

<hr>

<h3><code class="inline">debounceTime()</code></h3>

<p>Emits a value only after a specified time has passed without new emissions.</p>

<pre class="code-block typescript"><code>import { Subject } from 'rxjs';
<p>import { debounceTime } from 'rxjs/operators';</p>

<p>const search$ = new Subject&lt;string&gt;();</p>

<p>search$.pipe( debounceTime(300) ).subscribe(x =&gt; console.log('Search:', x));</p>

<p>search$.next('h'); search$.next('he'); search$.next('hel'); search$.next('help'); // Output: 'Search: help' (after 300ms pause)</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Search input debouncing</p></div><div class="page-content"><hr>

<h2>Error Handling Operators</h2>

<h3><code class="inline">catchError()</code></h3>

<p>Catches errors on the Observable and returns a new Observable or throws.</p>

<pre class="code-block typescript"><code>import { of, throwError } from 'rxjs';
<p>import { catchError } from 'rxjs/operators';</p>

<p>throwError(() =&gt; new Error('Oops!')).pipe( catchError(err =&gt; { console.error(err.message); return of('fallback value'); }) ).subscribe(x =&gt; console.log(x)); // Output: 'Oops!' (error), 'fallback value'</p>
</code></pre>

<p><strong>Used in vvroom:</strong> API error handling, graceful degradation</p>

<hr>

<h3><code class="inline">retry()</code></h3>

<p>Retries the source Observable a specified number of times on error.</p>

<pre class="code-block typescript"><code>import { interval, throwError } from 'rxjs';
<p>import { mergeMap, retry } from 'rxjs/operators';</p>

<p>let attempts = 0;</p>

<p>interval(100).pipe( mergeMap(() =&gt; { attempts++; if (attempts &lt; 3) { return throwError(() =&gt; new Error('Retry')); } return of('success'); }), retry(2) ).subscribe(x =&gt; console.log(x));</p>
</code></pre>

<p><strong>Used in vvroom:</strong> HTTP request retry in interceptor</p>

<hr>

<h2>Utility Operators</h2>

<h3><code class="inline">tap()</code></h3>

<p>Performs side effects without modifying the stream.</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { tap, map } from 'rxjs/operators';</p>

<p>of(1, 2, 3).pipe( tap(x =&gt; console.log('Before:', x)), map(x =&gt; x * 10), tap(x =&gt; console.log('After:', x)) ).subscribe(); // Output: Before: 1, After: 10, Before: 2, After: 20, ...</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Logging, debugging, caching side effects</p>

<hr>

<h3><code class="inline">finalize()</code></h3>

<p>Performs an action when the Observable completes or errors.</p>

<pre class="code-block typescript"><code>import { of, throwError } from 'rxjs';
<p>import { finalize } from 'rxjs/operators';</p>

<p>of(1, 2, 3).pipe( finalize(() =&gt; console.log('Done!')) ).subscribe(x =&gt; console.log(x)); // Output: 1, 2, 3, 'Done!'</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Resetting loading state after API calls</p>

<hr>

<h3><code class="inline">delay()</code></h3>

<p>Delays emission by a specified time.</p>

<pre class="code-block typescript"><code>import { of } from 'rxjs';
<p>import { delay } from 'rxjs/operators';</p>

<p>of('delayed').pipe( delay(1000) ).subscribe(x =&gt; console.log(x)); // Output: 'delayed' (after 1 second)</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Testing, simulated network latency</p></div><div class="page-content"><hr>

<h3><code class="inline">timeout()</code></h3>

<p>Errors if no value is emitted within a specified time.</p>

<pre class="code-block typescript"><code>import { of, NEVER } from 'rxjs';
<p>import { timeout, catchError } from 'rxjs/operators';</p>

<p>NEVER.pipe( timeout(1000), catchError(err =&gt; of('Timeout!')) ).subscribe(x =&gt; console.log(x)); // Output: 'Timeout!' (after 1 second)</p>
</code></pre>

<p><strong>Used in vvroom:</strong> API request timeouts</p>

<hr>

<h2>Combination Operators</h2>

<h3><code class="inline">combineLatest()</code></h3>

<p>Combines multiple Observables and emits when any source emits (after all have emitted at least once).</p>

<pre class="code-block typescript"><code>import { combineLatest, of, interval } from 'rxjs';
<p>import { take, map } from 'rxjs/operators';</p>

<p>combineLatest([ of('A'), interval(100).pipe(take(3)) ]).subscribe(([letter, num]) =&gt; console.log(letter, num)); // Output: A 0, A 1, A 2</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Combining filters from multiple sources</p>

<hr>

<h3><code class="inline">merge()</code></h3>

<p>Merges multiple Observables into a single stream.</p>

<pre class="code-block typescript"><code>import { merge, interval } from 'rxjs';
<p>import { take, map } from 'rxjs/operators';</p>

<p>merge( interval(100).pipe(take(2), map(x =&gt; 'A' + x)), interval(150).pipe(take(2), map(x =&gt; 'B' + x)) ).subscribe(x =&gt; console.log(x)); // Output: A0, B0, A1, B1 (interleaved by timing)</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Merging event streams</p>

<hr>

<h3><code class="inline">forkJoin()</code></h3>

<p>Waits for all Observables to complete, then emits an array of the last values.</p>

<pre class="code-block typescript"><code>import { forkJoin, of } from 'rxjs';
<p>import { delay } from 'rxjs/operators';</p>

<p>forkJoin([ of('A').pipe(delay(100)), of('B').pipe(delay(200)), of('C').pipe(delay(300)) ]).subscribe(x =&gt; console.log(x)); // Output: ['A', 'B', 'C'] (after 300ms)</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Parallel API requests that must all complete</p>

<hr>

<h2>Quick Reference Table</h2>

<table>
<p><thead><tr> <th>Operator</th> <th>Category</th> <th>Purpose</th> <th>Cancels Previous?</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">of</code></td> <td>Creation</td> <td>Emit static values</td> <td>N/A</td></p>
</tr>
<p><tr> <td><code class="inline">Subject</code></td> <td>Creation</td> <td>Observable + Observer</td> <td>N/A</td></p>
</tr>
<p><tr> <td><code class="inline">BehaviorSubject</code></td> <td>Creation</td> <td>Subject with initial value</td> <td>N/A</td></p>
</tr>
<p><tr> <td><code class="inline">map</code></td> <td>Transform</td> <td>Transform values</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">switchMap</code></td> <td>Transform</td> <td>Map + cancel previous</td> <td>Yes</td></p>
</tr>
<p><tr> <td><code class="inline">mergeMap</code></td> <td>Transform</td> <td>Map + run concurrent</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">concatMap</code></td> <td>Transform</td> <td>Map + run sequential</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">filter</code></td> <td>Filter</td> <td>Emit matching values</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">distinctUntilChanged</code></td> <td>Filter</td> <td>Skip duplicates</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">take</code></td> <td>Filter</td> <td>Emit first N</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">takeUntil</code></td> <td>Filter</td> <td>Emit until notifier</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">debounceTime</code></td> <td>Filter</td> <td>Delay until pause</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">catchError</code></td> <td>Error</td> <td>Handle errors</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">retry</code></td> <td>Error</td> <td>Retry on error</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">tap</code></td> <td>Utility</td> <td>Side effects</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">finalize</code></td> <td>Utility</td> <td>Cleanup on complete</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">combineLatest</code></td> <td>Combine</td> <td>Combine latest values</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">merge</code></td> <td>Combine</td> <td>Merge streams</td> <td>No</td></p>
</tr>
<p><tr> <td><code class="inline">forkJoin</code></td> <td>Combine</td> <td>Wait for all</td> <td>No</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Use <code class="inline">switchMap</code> for search/filter operations</strong> — Cancels outdated requests</li>
<p><li><strong>Use <code class="inline">BehaviorSubject</code> for state</strong> — Always has a current value</li> <li><strong>Use <code class="inline">takeUntil(destroy$)</code> for cleanup</strong> — Prevents memory leaks</li> <li><strong>Use <code class="inline">distinctUntilChanged</code> to prevent duplicate work</strong> — Especially with API calls</li> <li><strong>Use <code class="inline">catchError</code> to handle errors gracefully</strong> — Don't let streams die unexpectedly</li></p>
</ul>
<hr>

<h2>Further Reading</h2>

<ul><li><a href="https://rxjs.dev/">RxJS Official Documentation</a></li>
<p><li><a href="https://www.learnrxjs.io/">Learn RxJS</a></li> <li><a href="https://rxmarbles.com/">RxJS Marbles</a> — Interactive marble diagrams</li></ul></p></div></div>
    <div class="chapter" id="section-952">
        <div class="chapter-header">
            <div class="chapter-category">Reference</div>
            <h1>952: TypeScript Generics Reference</h1>
        </div>
<div class="page-content"><h1>952: TypeScript Generics Reference</h1>

<p><strong>Status:</strong> Reference Document <strong>Type:</strong> Appendix</p>

<hr>

<h2>Learning Objectives</h2>

<p>After reading this reference, you will:</p>
<ul><li>Have a quick reference for generic patterns used in vvroom</li>
<p><li>Understand advanced generic techniques beyond the primer</li> <li>Be able to look up type utilities without leaving the book</li></p>
</ul>
<hr>

<h2>Overview</h2>

<p>This appendix extends the TypeScript Generics Primer (document 150) with advanced patterns and a complete reference of generic types used in the vvroom application.</p>

<hr>

<h2>Quick Reference: Generic Syntax</h2>

<h3>Declaration Syntax</h3>

<table>
<p><thead><tr> <th>Syntax</th> <th>Meaning</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">&lt;T&gt;</code></td> <td>Single type parameter</td></p>
</tr>
<p><tr> <td><code class="inline">&lt;T, U&gt;</code></td> <td>Multiple type parameters</td></p>
</tr>
<p><tr> <td><code class="inline">&lt;T extends Base&gt;</code></td> <td>Constrained type parameter</td></p>
</tr>
<p><tr> <td><code class="inline">&lt;T = Default&gt;</code></td> <td>Type parameter with default</td></p>
</tr>
<p><tr> <td><code class="inline">&lt;T extends Base = Default&gt;</code></td> <td>Constrained with default</td></p>
</tr>
</tbody>
</table>

<h3>Usage Syntax</h3>

<table>
<p><thead><tr> <th>Syntax</th> <th>Meaning</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">Array&lt;string&gt;</code></td> <td>Concrete instantiation</td></p>
</tr>
<p><tr> <td><code class="inline">Partial&lt;User&gt;</code></td> <td>Utility type application</td></p>
</tr>
<p><tr> <td><code class="inline">keyof T</code></td> <td>Get keys of T as union</td></p>
</tr>
<p><tr> <td><code class="inline">T[K]</code></td> <td>Indexed access type</td></p>
</tr>
<p><tr> <td><code class="inline">T extends U ? X : Y</code></td> <td>Conditional type</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Vvroom Generic Patterns</h2>

<h3>The Domain Config Pattern</h3>

<p>The central generic pattern in vvroom:</p>

<pre class="code-block typescript"><code>interface DomainConfig&lt;TFilters, TData, TStatistics&gt; {
<p>domainKey: string; displayName: string; urlMapper: IFilterUrlMapper&lt;TFilters&gt;; apiAdapter: IApiAdapter&lt;TFilters, TData, TStatistics&gt;; tableConfig: TableConfig&lt;TData&gt;; chartDataSources?: Record&lt;string, ChartDataSource&lt;TStatistics&gt;&gt;; }</p>
</code></pre>

<p><strong>Type flow:</strong></p>

<pre class="code-block text"><code>DomainConfig&lt;AutomobileFilters, VehicleResult, VehicleStatistics&gt;
<p>│                │                │                │ │                │                │                └─► chartDataSources value types │                │                └─► apiAdapter, tableConfig │                └─► apiAdapter, urlMapper └─► The whole thing</p>
</code></pre>

<h3>The Adapter Pattern</h3>

<p>Adapters connect framework code to domain-specific implementations:</p>

<pre class="code-block typescript"><code>interface IApiAdapter&lt;TFilters, TData, TStatistics&gt; {
<p>fetchData(filters: TFilters): Observable&lt;ApiResponse&lt;TData&gt;&gt;; fetchStatistics(filters: TFilters): Observable&lt;TStatistics&gt;; }</p>

<p>// Concrete implementation class AutomobileApiAdapter implements IApiAdapter&lt; AutomobileFilters, VehicleResult, VehicleStatistics &gt; { fetchData(filters: AutomobileFilters): Observable&lt;ApiResponse&lt;VehicleResult&gt;&gt; { // Implementation } }</p>
</code></pre></div><div class="page-content"><h3>The Service Generic Pattern</h3>

<p>Services that work with any domain use type parameters:</p>

<pre class="code-block typescript"><code>class ResourceManagementService&lt;TFilters, TData, TStatistics&gt; {
<p>private readonly state$ = new BehaviorSubject&lt;ResourceState&lt;TFilters, TData, TStatistics&gt;&gt;( initialState );</p>

<p>get data$(): Observable&lt;TData[] | undefined&gt; { return this.state$.pipe(map(s =&gt; s.data)); } }</p>
</code></pre>

<hr>

<h2>Built-in Utility Types</h2>

<h3>Partial&lt;T&gt;</h3>

<p>Makes all properties optional:</p>

<pre class="code-block typescript"><code>interface User {
<p>id: number; name: string; email: string; }</p>

<p>// All properties optional type PartialUser = Partial&lt;User&gt;; // { id?: number; name?: string; email?: string; }</p>

<p>// Use case: Update operations function updateUser(id: number, updates: Partial&lt;User&gt;) { // Only changed fields are required }</p>

<p>updateUser(1, { name: 'New Name' }); // OK - only name provided</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Filter updates, partial state changes</p>

<hr>

<h3>Required&lt;T&gt;</h3>

<p>Makes all properties required (opposite of Partial):</p>

<pre class="code-block typescript"><code>interface Config {
<p>debug?: boolean; timeout?: number; }</p>

<p>type RequiredConfig = Required&lt;Config&gt;; // { debug: boolean; timeout: number; }</p>
</code></pre>

<hr>

<h3>Readonly&lt;T&gt;</h3>

<p>Makes all properties readonly:</p>

<pre class="code-block typescript"><code>interface State {
<p>count: number; items: string[]; }</p>

<p>type ReadonlyState = Readonly&lt;State&gt;; // { readonly count: number; readonly items: string[]; }</p>

<p>const state: ReadonlyState = { count: 0, items: [] }; state.count = 1; // Error: Cannot assign to 'count'</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Immutable state patterns</p>

<hr>

<h3>Pick&lt;T, K&gt;</h3>

<p>Creates a type with only the specified properties:</p>

<pre class="code-block typescript"><code>interface Vehicle {
<p>vin: string; make: string; model: string; year: number; color: string; }</p>

<p>type VehicleIdentity = Pick&lt;Vehicle, 'vin' | 'make' | 'model'&gt;; // { vin: string; make: string; model: string; }</p>
</code></pre>

<p><strong>Used in vvroom:</strong> Extracting subsets for display or API calls</p>

<hr>

<h3>Omit&lt;T, K&gt;</h3>

<p>Creates a type without the specified properties:</p>

<pre class="code-block typescript"><code>interface Vehicle {
<p>vin: string; make: string; model: string; year: number; internalId: string; // Don't send to API }</p>

<p>type VehicleForApi = Omit&lt;Vehicle, 'internalId'&gt;; // { vin: string; make: string; model: string; year: number; }</p>
</code></pre></div><div class="page-content"><hr>

<h3>Record&lt;K, V&gt;</h3>

<p>Creates an object type with keys of type K and values of type V:</p>

<pre class="code-block typescript"><code>type ChartSourceMap = Record&lt;string, ChartDataSource&gt;;
<p>// { [key: string]: ChartDataSource }</p>

<p>const sources: ChartSourceMap = { 'manufacturer': new ManufacturerChartSource(), 'year': new YearChartSource() };</p>
</code></pre>

<p><strong>Used in vvroom:</strong> <code class="inline">chartDataSources</code>, URL parameters</p>

<hr>

<h3>Extract&lt;T, U&gt;</h3>

<p>Extracts types from T that are assignable to U:</p>

<pre class="code-block typescript"><code>type EventTypes = 'click' | 'focus' | 'blur' | 'scroll' | 'resize';
<p>type MouseEvents = Extract&lt;EventTypes, 'click' | 'scroll'&gt;; // 'click' | 'scroll'</p>
</code></pre>

<hr>

<h3>Exclude&lt;T, U&gt;</h3>

<p>Excludes types from T that are assignable to U:</p>

<pre class="code-block typescript"><code>type EventTypes = 'click' | 'focus' | 'blur' | 'scroll' | 'resize';
<p>type KeyboardEvents = Exclude&lt;EventTypes, 'click' | 'scroll' | 'resize'&gt;; // 'focus' | 'blur'</p>
</code></pre>

<hr>

<h3>NonNullable&lt;T&gt;</h3>

<p>Removes null and undefined from T:</p>

<pre class="code-block typescript"><code>type MaybeString = string | null | undefined;
<p>type DefinitelyString = NonNullable&lt;MaybeString&gt;; // string</p>
</code></pre>

<hr>

<h3>ReturnType&lt;T&gt;</h3>

<p>Gets the return type of a function type:</p>

<pre class="code-block typescript"><code>function createFilters(): AutomobileFilters {
<p>return new AutomobileFilters(); }</p>

<p>type Filters = ReturnType&lt;typeof createFilters&gt;; // AutomobileFilters</p>
</code></pre>

<hr>

<h3>Parameters&lt;T&gt;</h3>

<p>Gets the parameter types of a function as a tuple:</p>

<pre class="code-block typescript"><code>function fetchData(filters: AutomobileFilters, page: number): Promise&lt;VehicleResult[]&gt; {
<p>// ... }</p>

<p>type FetchParams = Parameters&lt;typeof fetchData&gt;; // [AutomobileFilters, number]</p>
</code></pre>

<hr>

<h2>Advanced Patterns</h2>

<h3>Mapped Types</h3>

<p>Transform properties of a type:</p>

<pre class="code-block typescript"><code>// Make all properties nullable
<p>type Nullable&lt;T&gt; = { [P in keyof T]: T[P] | null; };</p>

<p>interface User { name: string; age: number; }</p>

<p>type NullableUser = Nullable&lt;User&gt;; // { name: string | null; age: number | null; }</p>
</code></pre>

<h3>Conditional Types</h3>

<p>Types that depend on conditions:</p>

<pre class="code-block typescript"><code>type IsArray&lt;T&gt; = T extends any[] ? true : false;

<p>type A = IsArray&lt;string[]&gt;;  // true type B = IsArray&lt;string&gt;;    // false</p>
</code></pre>

<p><strong>Practical example:</strong></p>

<pre class="code-block typescript"><code>// Unwrap array types, leave others alone
<p>type Unwrap&lt;T&gt; = T extends (infer U)[] ? U : T;</p>

<p>type A = Unwrap&lt;string[]&gt;;  // string type B = Unwrap&lt;number&gt;;    // number</p>
</code></pre></div><div class="page-content"><h3>Template Literal Types</h3>

<p>Create types from string patterns:</p>

<pre class="code-block typescript"><code>type FilterKey = 'manufacturer' | 'year' | 'model';
<p>type HighlightKey = <code class="inline">h_${FilterKey}</code>; // 'h_manufacturer' | 'h_year' | 'h_model'</p>

<p>// Used in URL state management function isHighlightParam(key: string): key is HighlightKey { return key.startsWith('h_'); }</p>
</code></pre>

<hr>

<h2>Type Guards with Generics</h2>

<h3>User-Defined Type Guards</h3>

<p>Narrow types safely:</p>

<pre class="code-block typescript"><code>interface ApiError {
<p>code: number; message: string; }</p>

<p>interface ApiSuccess&lt;T&gt; { data: T; }</p>

<p>type ApiResponse&lt;T&gt; = ApiError | ApiSuccess&lt;T&gt;;</p>

<p>function isSuccess&lt;T&gt;(response: ApiResponse&lt;T&gt;): response is ApiSuccess&lt;T&gt; { return 'data' in response; }</p>

<p>// Usage function handleResponse&lt;T&gt;(response: ApiResponse&lt;T&gt;): T | null { if (isSuccess(response)) { return response.data;  // TypeScript knows this is ApiSuccess&lt;T&gt; } console.error(response.message);  // TypeScript knows this is ApiError return null; }</p>
</code></pre>

<hr>

<h2>Generic Constraints in Vvroom</h2>

<h3>Constraining to Interfaces</h3>

<pre class="code-block typescript"><code>interface HasId {
<p>id: string; }</p>

<p>function findById&lt;T extends HasId&gt;(items: T[], id: string): T | undefined { return items.find(item =&gt; item.id === id); }</p>

<p>// Works with any type that has an 'id' property const vehicle = findById(vehicles, 'VIN123'); const user = findById(users, 'USER456');</p>
</code></pre>

<h3>Constraining to Keys</h3>

<pre class="code-block typescript"><code>function getProperty&lt;T, K extends keyof T&gt;(obj: T, key: K): T[K] {
<p>return obj[key]; }</p>

<p>const vehicle = { make: 'Toyota', year: 2022 }; const make = getProperty(vehicle, 'make');  // string const year = getProperty(vehicle, 'year');  // number const bad = getProperty(vehicle, 'color');  // Error: 'color' not in keyof vehicle</p>
</code></pre>

<hr>

<h2>Observable Generic Patterns</h2>

<p>RxJS uses generics extensively:</p>

<pre class="code-block typescript"><code>// Observable of specific type
<p>statistics$: Observable&lt;VehicleStatistics&gt;;</p>

<p>// Subject with type parameter private readonly state$ = new BehaviorSubject&lt;ResourceState&lt;TFilters, TData&gt;&gt;(initial);</p>

<p>// Operators preserve/transform types this.state$.pipe( map(state =&gt; state.data),      // Observable&lt;TData[] | undefined&gt; filter((data): data is TData[] =&gt; data !== undefined),  // Observable&lt;TData[]&gt; map(data =&gt; data.length)       // Observable&lt;number&gt; );</p>
</code></pre></div><div class="page-content"><hr>

<h2>Common Mistakes</h2>

<h3>Mistake 1: Missing Type Arguments</h3>

<pre class="code-block typescript"><code>// Wrong - Map needs type arguments
<p>const cache = new Map();  // Map&lt;any, any&gt;</p>

<p>// Right const cache = new Map&lt;string, VehicleResult&gt;();</p>
</code></pre>

<h3>Mistake 2: Overly Narrow Constraints</h3>

<pre class="code-block typescript"><code>// Too restrictive - only works with AutomobileFilters
<p>function process&lt;T extends AutomobileFilters&gt;(filters: T) { }</p>

<p>// Better - works with any filter type function process&lt;T&gt;(filters: T) { }</p>

<p>// Or if you need specific properties function process&lt;T extends { page?: number }&gt;(filters: T) { }</p>
</code></pre>

<h3>Mistake 3: Ignoring Inference</h3>

<pre class="code-block typescript"><code>// Unnecessary - TypeScript infers T
<p>const result = identity&lt;string&gt;('hello');</p>

<p>// Let TypeScript infer const result = identity('hello');  // T is inferred as string</p>
</code></pre>

<h3>Mistake 4: Using <code class="inline">any</code> Instead of Generics</h3>

<pre class="code-block typescript"><code>// Bad - loses type safety
<p>function firstElement(arr: any[]): any { return arr[0]; }</p>

<p>// Good - preserves type function firstElement&lt;T&gt;(arr: T[]): T | undefined { return arr[0]; }</p>
</code></pre>

<hr>

<h2>Quick Reference Table: Vvroom Generic Types</h2>

<table>
<p><thead><tr> <th>Type</th> <th>Purpose</th> <th>Type Parameters</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">DomainConfig&lt;F, D, S&gt;</code></td> <td>Domain configuration</td> <td>Filters, Data, Statistics</td></p>
</tr>
<p><tr> <td><code class="inline">IApiAdapter&lt;F, D, S&gt;</code></td> <td>API adapter interface</td> <td>Filters, Data, Statistics</td></p>
</tr>
<p><tr> <td><code class="inline">IFilterUrlMapper&lt;F&gt;</code></td> <td>URL mapping interface</td> <td>Filters</td></p>
</tr>
<p><tr> <td><code class="inline">TableConfig&lt;D&gt;</code></td> <td>Table configuration</td> <td>Data row type</td></p>
</tr>
<p><tr> <td><code class="inline">ChartDataSource&lt;S&gt;</code></td> <td>Chart data transformation</td> <td>Statistics type</td></p>
</tr>
<p><tr> <td><code class="inline">ResourceState&lt;F, D, S&gt;</code></td> <td>Service state</td> <td>Filters, Data, Statistics</td></p>
</tr>
<p><tr> <td><code class="inline">ApiResponse&lt;D&gt;</code></td> <td>API response wrapper</td> <td>Data type</td></p>
</tr>
<p><tr> <td><code class="inline">Observable&lt;T&gt;</code></td> <td>RxJS observable</td> <td>Emitted value type</td></p>
</tr>
<p><tr> <td><code class="inline">BehaviorSubject&lt;T&gt;</code></td> <td>RxJS subject with initial value</td> <td>Value type</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Generics flow through the architecture</strong> — From DomainConfig through services to components</li>
<p><li><strong>Utility types reduce boilerplate</strong> — Use Partial, Pick, Omit instead of redefining</li> <li><strong>Constraints ensure type safety</strong> — Use <code class="inline">extends</code> to require specific properties</li> <li><strong>Let TypeScript infer when possible</strong> — Don't over-annotate</li></ul></p></div><div class="page-content"><hr>

<h2>Further Reading</h2>

<ul><li><a href="https://www.typescriptlang.org/docs/handbook/2/generics.html">TypeScript Handbook: Generics</a></li>
<p><li><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html">TypeScript Handbook: Utility Types</a></li> <li><a href="https://www.typescriptlang.org/docs/handbook/2/conditional-types.html">TypeScript Handbook: Conditional Types</a></li></ul></p></div></div>
    <div class="chapter" id="section-953">
        <div class="chapter-header">
            <div class="chapter-category">Reference</div>
            <h1>953: Debugging Guide</h1>
        </div>
<div class="page-content"><h1>953: Debugging Guide</h1>

<p><strong>Status:</strong> Reference Document <strong>Type:</strong> Appendix</p>

<hr>

<h2>Learning Objectives</h2>

<p>After reading this guide, you will:</p>
<ul><li>Know how to diagnose common Angular and RxJS issues</li>
<p><li>Understand how to use browser DevTools effectively</li> <li>Be able to debug URL-First state management problems</li></p>
</ul>
<hr>

<h2>Overview</h2>

<p>This appendix provides debugging strategies for the vvroom application. It covers Angular-specific debugging, RxJS observable debugging, and URL-First architecture troubleshooting.</p>

<hr>

<h2>Browser DevTools Essentials</h2>

<h3>Opening DevTools</h3>

<table>
<p><thead><tr> <th>Browser</th> <th>Shortcut</th></p>
</tr></thead>
<p><tbody> <tr> <td>Chrome/Edge</td> <td><code class="inline">F12</code> or <code class="inline">Ctrl+Shift+I</code> (Windows) / <code class="inline">Cmd+Option+I</code> (Mac)</td></p>
</tr>
<p><tr> <td>Firefox</td> <td><code class="inline">F12</code> or <code class="inline">Ctrl+Shift+I</code> (Windows) / <code class="inline">Cmd+Option+I</code> (Mac)</td></p>
</tr>
<p><tr> <td>Safari</td> <td><code class="inline">Cmd+Option+I</code> (enable in Preferences → Advanced first)</td></p>
</tr>
</tbody>
</table>

<h3>Essential Panels</h3>

<table>
<p><thead><tr> <th>Panel</th> <th>Use For</th></p>
</tr></thead>
<p><tbody> <tr> <td>Console</td> <td>Error messages, <code class="inline">console.log</code> output</td></p>
</tr>
<p><tr> <td>Network</td> <td>API requests, response data, timing</td></p>
</tr>
<p><tr> <td>Elements</td> <td>DOM inspection, CSS debugging</td></p>
</tr>
<p><tr> <td>Sources</td> <td>Breakpoints, step debugging</td></p>
</tr>
<p><tr> <td>Application</td> <td>localStorage, sessionStorage, cookies</td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Console Debugging</h2>

<h3>Strategic Console Logging</h3>

<pre class="code-block typescript"><code>// Bad - vague
<p>console.log(filters);</p>

<p>// Good - contextual console.log('[UrlStateService] Parsed filters:', filters);</p>

<p>// Better - with timestamp for async flows console.log(<code class="inline">[${Date.now()}] [ResourceService] Fetching data for:</code>, filters);</p>
</code></pre>

<h3>Console Methods</h3>

<table>
<p><thead><tr> <th>Method</th> <th>Use Case</th></p>
</tr></thead>
<p><tbody> <tr> <td><code class="inline">console.log()</code></td> <td>General output</td></p>
</tr>
<p><tr> <td><code class="inline">console.error()</code></td> <td>Errors (red in console)</td></p>
</tr>
<p><tr> <td><code class="inline">console.warn()</code></td> <td>Warnings (yellow in console)</td></p>
</tr>
<p><tr> <td><code class="inline">console.table()</code></td> <td>Display arrays/objects as table</td></p>
</tr>
<p><tr> <td><code class="inline">console.group()</code> / <code class="inline">console.groupEnd()</code></td> <td>Group related logs</td></p>
</tr>
<p><tr> <td><code class="inline">console.time()</code> / <code class="inline">console.timeEnd()</code></td> <td>Measure execution time</td></p>
</tr>
</tbody>
</table>

<h3>Debugging Objects</h3>

<pre class="code-block typescript"><code>// See full object structure
<p>console.dir(complexObject);</p>

<p>// Table view for arrays console.table(vehicles);</p>

<p>// Group related logs console.group('Filter Processing'); console.log('Input:', rawParams); console.log('Parsed:', parsedFilters); console.log('Validated:', validatedFilters); console.groupEnd();</p>
</code></pre></div><div class="page-content"><hr>

<h2>Angular-Specific Debugging</h2>

<h3>Angular DevTools Extension</h3>

<p>Install the <a href="https://angular.io/guide/devtools">Angular DevTools</a> browser extension for:</p>

<ul><li>Component tree inspection</li>
<p><li>Change detection profiling</li> <li>Dependency injection debugging</li></p>
</ul>
<h3>Common Angular Errors</h3>

<h4>"Can't bind to 'X' since it isn't a known property"</h4>

<p><strong>Cause:</strong> Component/directive not imported in the module.</p>

<p><strong>Solution:</strong></p>
<pre class="code-block typescript"><code>// Check the module imports
<p>@NgModule({ imports: [ CommonModule,      // For <em>ngIf, </em>ngFor FormsModule,       // For [(ngModel)] RouterModule,      // For routerLink SomeComponent      // For standalone components ] })</p>
</code></pre>

<h4>"No provider for X"</h4>

<p><strong>Cause:</strong> Service not provided in module or component.</p>

<p><strong>Solution:</strong></p>
<pre class="code-block typescript"><code>// Option 1: providedIn root (preferred)
<p>@Injectable({ providedIn: 'root' }) export class MyService { }</p>

<p>// Option 2: Provide in module @NgModule({ providers: [MyService] })</p>

<p>// Option 3: Provide in component @Component({ providers: [MyService] })</p>
</code></pre>

<h4>"ExpressionChangedAfterItHasBeenCheckedError"</h4>

<p><strong>Cause:</strong> Value changed during change detection cycle.</p>

<p><strong>Solution:</strong></p>
<pre class="code-block typescript"><code>// Wrap in setTimeout or use ChangeDetectorRef
<p>constructor(private cdr: ChangeDetectorRef) {}</p>

<p>ngAfterViewInit(): void { // Defer the change setTimeout(() =&gt; { this.value = newValue; this.cdr.markForCheck(); }, 0); }</p>
</code></pre>

<h4>Template Binding Errors</h4>

<p>Debug with JSON pipe:</p>
<pre class="code-block html"><code>&lt;!-- See what the value actually is --&gt;
<p>&lt;pre&gt;{{ someValue | json }}&lt;/pre&gt;</p>

<p>&lt;!-- Check if observable has emitted --&gt; &lt;pre&gt;{{ observable$ | async | json }}&lt;/pre&gt;</p>
</code></pre>

<hr>

<h2>RxJS Debugging</h2>

<h3>The tap() Operator</h3>

<p>Insert <code class="inline">tap()</code> to inspect stream values without modifying them:</p>

<pre class="code-block typescript"><code>this.urlState.params$.pipe(
<p>tap(params =&gt; console.log('[1] Raw params:', params)), map(params =&gt; this.parseFilters(params)), tap(filters =&gt; console.log('[2] Parsed filters:', filters)), switchMap(filters =&gt; this.apiService.fetch(filters)), tap(response =&gt; console.log('[3] API response:', response)) ).subscribe();</p>
</code></pre></div><div class="page-content"><h3>Debugging Subscription Issues</h3>

<h4>"Observable not emitting"</h4>

<p>Check these in order:</p>

<ul><li><strong>Is it subscribed?</strong></li>
</ul><pre class="code-block typescript"><code>// Cold observables don't run without subscription
<p>observable$.subscribe();  // or use | async in template</p>
</code></pre>

<ul><li><strong>Has the source emitted?</strong></li>
</ul><pre class="code-block typescript"><code>source$.pipe(
<p>tap(v =&gt; console.log('Source emitted:', v)) ).subscribe();</p>
</code></pre>

<ul><li><strong>Is it filtered out?</strong></li>
</ul><pre class="code-block typescript"><code>source$.pipe(
<p>tap(v =&gt; console.log('Before filter:', v)), filter(v =&gt; v.isValid), tap(v =&gt; console.log('After filter:', v)) ).subscribe();</p>
</code></pre>

<ul><li><strong>Is switchMap cancelling it?</strong></li>
</ul><pre class="code-block typescript"><code>// switchMap cancels previous inner observables
<p>// Use mergeMap if you need all to complete</p>
</code></pre>

<h4>"Observable emitting too many times"</h4>

<pre class="code-block typescript"><code>// Add distinctUntilChanged to prevent duplicates
<p>source$.pipe( tap(v =&gt; console.log('Before distinct:', v)), distinctUntilChanged(), tap(v =&gt; console.log('After distinct:', v)) ).subscribe();</p>
</code></pre>

<h4>Memory Leaks</h4>

<p>Check for missing unsubscribe:</p>

<pre class="code-block typescript"><code>// Bad - leaks on component destroy
<p>ngOnInit() { this.service.data$.subscribe(data =&gt; this.data = data); }</p>

<p>// Good - uses takeUntil pattern private destroy$ = new Subject&lt;void&gt;();</p>

<p>ngOnInit() { this.service.data$.pipe( takeUntil(this.destroy$) ).subscribe(data =&gt; this.data = data); }</p>

<p>ngOnDestroy() { this.destroy$.next(); this.destroy$.complete(); }</p>
</code></pre>

<hr>

<h2>URL-First Debugging</h2>

<h3>Verifying URL State</h3>

<ul><li><strong>Check the URL directly:</strong></li>
</ul>   <ul><li>Look at the browser address bar</li>
</ul>   <ul><li>Compare expected vs actual query parameters</li>
</ul>
<ul><li><strong>Log URL changes:</strong></li>
</ul><pre class="code-block typescript"><code>// In UrlStateService or component
<p>this.router.events.pipe( filter(event =&gt; event instanceof NavigationEnd), tap(event =&gt; console.log('[Router] Navigation:', event.url)) ).subscribe();</p>
</code></pre>

<ul><li><strong>Log parsed parameters:</strong></li>
</ul><pre class="code-block typescript"><code>this.route.queryParams.pipe(
<p>tap(params =&gt; console.log('[Route] Query params:', params)) ).subscribe();</p>
</code></pre>

<h3>Common URL-First Issues</h3>

<h4>Filters not updating URL</h4>

<p>Check the URL mapper:</p>
<pre class="code-block typescript"><code>console.log('[UrlMapper] toParams input:', filters);
<p>const params = this.urlMapper.toParams(filters); console.log('[UrlMapper] toParams output:', params);</p>
</code></pre></div><div class="page-content"><h4>URL not updating view</h4>

<p>Check the filter parsing:</p>
<pre class="code-block typescript"><code>console.log('[UrlMapper] fromParams input:', params);
<p>const filters = this.urlMapper.fromParams(params); console.log('[UrlMapper] fromParams output:', filters);</p>
</code></pre>

<h4>Circular updates (infinite loop)</h4>

<p>Add distinctUntilChanged with deep comparison:</p>
<pre class="code-block typescript"><code>this.route.queryParams.pipe(
<p>distinctUntilChanged((a, b) =&gt; JSON.stringify(a) === JSON.stringify(b)), tap(params =&gt; console.log('Params changed:', params)) ).subscribe();</p>
</code></pre>

<hr>

<h2>Network Debugging</h2>

<h3>Inspecting API Calls</h3>

<p>In DevTools Network panel:</p>

<ul><li>Filter by "XHR" or "Fetch" to see only API calls</li>
<p><li>Click a request to see:</li></p>
</ul>   <ul><li><strong>Headers</strong>: Request/response headers</li>
</ul>   <ul><li><strong>Payload</strong>: Request body (POST/PUT)</li>
</ul>   <ul><li><strong>Preview</strong>: Response data (formatted)</li>
</ul>   <ul><li><strong>Response</strong>: Raw response</li>
</ul>   <ul><li><strong>Timing</strong>: How long each phase took</li>
</ul>
<h3>Common API Issues</h3>

<h4>CORS Errors</h4>

<pre class="code-block text"><code>Access to XMLHttpRequest at 'http://api.example.com' from origin 'http://localhost:4200'
<p>has been blocked by CORS policy</p>
</code></pre>

<p><strong>Solution:</strong> API server must include CORS headers, or use Angular proxy:</p>

<pre class="code-block json"><code>// proxy.conf.json
<p>{ "/api": { "target": "http://api.example.com", "secure": false, "changeOrigin": true } }</p>
</code></pre>

<h4>401 Unauthorized</h4>

<p>Check:</p>
<ul><li>Is the auth token being sent?</li>
<p><li>Is the token expired?</li> <li>Is the token in the correct header format?</li></p>
</ul>
<pre class="code-block typescript"><code>// Log request headers in interceptor
<p>intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler) { console.log('[HTTP] Request headers:', req.headers.keys()); console.log('[HTTP] Auth header:', req.headers.get('Authorization')); return next.handle(req); }</p>
</code></pre>

<h4>404 Not Found</h4>

<p>Check:</p>
<ul><li>Is the URL correct? (log it)</li>
<p><li>Is the API endpoint deployed?</li> <li>Are path parameters correct?</li></p>
</ul>
<hr>

<h2>Plotly.js Chart Debugging</h2>

<h3>Chart Not Rendering</h3>

<ul><li><strong>Check container dimensions:</strong></li>
</ul><pre class="code-block typescript"><code>const container = this.chartContainer.nativeElement;
<p>console.log('Container size:', container.clientWidth, 'x', container.clientHeight); // Must be &gt; 0</p>
</code></pre>

<ul><li><strong>Check data format:</strong></li>
</ul><pre class="code-block typescript"><code>console.log('Traces:', JSON.stringify(chartData.traces, null, 2));
<p>console.log('Layout:', JSON.stringify(chartData.layout, null, 2));</p>
</code></pre>

<ul><li><strong>Check for Plotly errors:</strong></li>
</ul><pre class="code-block typescript"><code>Plotly.newPlot(element, traces, layout)
<p>.then(() =&gt; console.log('Plot created successfully')) .catch(err =&gt; console.error('Plotly error:', err));</p>
</code></pre></div><div class="page-content"><h3>Chart Not Updating</h3>

<p>Ensure you're calling react, not newPlot:</p>
<pre class="code-block typescript"><code>// newPlot creates a new chart (slower)
<p>// react updates existing chart (faster) if (this.plotlyElement) { Plotly.react(this.plotlyElement, traces, layout); } else { Plotly.newPlot(element, traces, layout); }</p>
</code></pre>

<hr>

<h2>Pop-out Window Debugging</h2>

<h3>Messages Not Received</h3>

<ul><li><strong>Check message posting:</strong></li>
</ul><pre class="code-block typescript"><code>// In parent window
<p>console.log('[Parent] Sending message:', message); popoutWindow.postMessage(message, '*');</p>
</code></pre>

<ul><li><strong>Check message receiving:</strong></li>
</ul><pre class="code-block typescript"><code>// In pop-out window
<p>window.addEventListener('message', event =&gt; { console.log('[Popout] Received message:', event.data); console.log('[Popout] Origin:', event.origin); });</p>
</code></pre>

<ul><li><strong>Check window reference:</strong></li>
</ul><pre class="code-block typescript"><code>console.log('[Parent] Popout window:', popoutWindow);
<p>console.log('[Parent] Window closed?:', popoutWindow.closed);</p>
</code></pre>

<h3>Pop-out Styling Issues</h3>

<p>The pop-out window may not load all styles:</p>
<ul><li>Check that global styles are linked in pop-out index.html</li>
<p><li>Verify component styles are loaded (not lazy-loaded)</li> <li>Use browser DevTools in the pop-out window itself</li></p>
</ul>
<hr>

<h2>Performance Debugging</h2>

<h3>Change Detection Issues</h3>

<pre class="code-block typescript"><code>// Log change detection runs
<p>constructor(private zone: NgZone) { zone.onStable.subscribe(() =&gt; { console.log('[Zone] Change detection complete'); }); }</p>
</code></pre>

<h3>Identifying Slow Operations</h3>

<pre class="code-block typescript"><code>console.time('expensiveOperation');
<p>// ... operation console.timeEnd('expensiveOperation'); // Output: expensiveOperation: 234.56ms</p>
</code></pre>

<h3>Memory Leaks</h3>

<ul><li>Open DevTools → Memory panel</li>
<p><li>Take heap snapshot before and after suspected leak</li> <li>Compare snapshots to find retained objects</li></p>
</ul>
<hr>

<h2>Debugging Checklist</h2>

<p>When something doesn't work:</p>

<ul><li><strong>Check the console</strong> for errors</li>
<p><li><strong>Check the network</strong> for failed requests</li> <li><strong>Add console.log</strong> at key points</li> <li><strong>Verify data</strong> with <code class="inline">| json</code> pipe</li> <li><strong>Check subscriptions</strong> are active</li> <li><strong>Verify imports</strong> in modules</li> <li><strong>Check the URL</strong> for state issues</li> <li><strong>Use breakpoints</strong> for complex logic</li></ul></p></div><div class="page-content"><hr>

<h2>Key Takeaways</h2>

<ul><li><strong>Console.log strategically</strong> — Add context, use groups, remove when done</li>
<p><li><strong>Use tap() for RxJS</strong> — Inspect streams without modifying them</li> <li><strong>Check the Network panel</strong> — API issues often hide there</li> <li><strong>Angular DevTools helps</strong> — Especially for component tree and DI issues</li> <li><strong>URL-First means URL-First</strong> — When in doubt, check the URL</li></p>
</ul>
<hr>

<h2>Further Reading</h2>

<ul><li><a href="https://angular.io/guide/debugging">Angular Debugging Guide</a></li>
<p><li><a href="https://developer.chrome.com/docs/devtools/">Chrome DevTools Documentation</a></li> <li><a href="https://rxjs.dev/guide/testing/marble-testing">RxJS Debugging</a></li></ul></p></div></div>
    <div class="chapter" id="section-954">
        <div class="chapter-header">
            <div class="chapter-category">Reference</div>
            <h1>954: Glossary</h1>
        </div>
<div class="page-content"><h1>954: Glossary</h1>

<p><strong>Status:</strong> Reference Document <strong>Type:</strong> Appendix</p>

<hr>

<h2>Overview</h2>

<p>This glossary defines terms used throughout the vvroom book. Terms are organized alphabetically within categories.</p>

<hr>

<h2>Angular Terms</h2>

<h3>Change Detection</h3>
<p>The process by which Angular checks component properties for changes and updates the DOM accordingly. Can be triggered manually via <code class="inline">ChangeDetectorRef.markForCheck()</code> or <code class="inline">detectChanges()</code>.</p>

<h3>Component</h3>
<p>A building block of Angular applications consisting of a TypeScript class, HTML template, and optional CSS styles. Decorated with <code class="inline">@Component()</code>.</p>

<h3>Decorator</h3>
<p>A TypeScript feature that adds metadata to classes, properties, or methods. Angular uses decorators like <code class="inline">@Component()</code>, <code class="inline">@Injectable()</code>, <code class="inline">@Input()</code>, and <code class="inline">@Output()</code>.</p>

<h3>Dependency Injection (DI)</h3>
<p>A design pattern where a class receives its dependencies from external sources rather than creating them. Angular's DI system provides services to components.</p>

<h3>Directive</h3>
<p>A class that modifies DOM elements or component behavior. Structural directives (<code class="inline"><em>ngIf</code>, <code class="inline"></em>ngFor</code>) change DOM structure; attribute directives modify appearance or behavior.</p>

<h3>Guard</h3>
<p>A service that controls route access. Can prevent navigation (<code class="inline">CanActivate</code>), leaving (<code class="inline">CanDeactivate</code>), or loading (<code class="inline">CanLoad</code>).</p>

<h3>Interceptor</h3>
<p>A service that intercepts HTTP requests and responses. Used for adding headers, handling errors, or transforming data globally.</p>

<h3>Lifecycle Hook</h3>
<p>Methods that Angular calls at specific points in a component's lifecycle: <code class="inline">ngOnInit</code>, <code class="inline">ngOnChanges</code>, <code class="inline">ngAfterViewInit</code>, <code class="inline">ngOnDestroy</code>, etc.</p>

<h3>Module (NgModule)</h3>
<p>A container for related components, directives, pipes, and services. Decorated with <code class="inline">@NgModule()</code>. Angular 13 uses NgModules (not standalone components).</p>

<h3>Observable</h3>
<p>An RxJS type representing a stream of values over time. Components subscribe to observables to receive data. See also: RxJS Terms.</p>

<h3>Pipe</h3>
<p>A function that transforms data in templates. Built-in examples: <code class="inline">| json</code>, <code class="inline">| async</code>, <code class="inline">| date</code>. Custom pipes transform domain-specific data.</p></div><div class="page-content"><h3>Route</h3>
<p>A URL path mapped to a component. Defined in routing modules with path, component, and optional guards.</p>

<h3>Service</h3>
<p>A class that provides functionality across components. Typically decorated with <code class="inline">@Injectable()</code> and provided at root level.</p>

<h3>Template</h3>
<p>The HTML portion of a component that defines its view. Can include Angular syntax like interpolation (<code class="inline">{{ }}</code>), property binding (<code class="inline">[prop]</code>), and event binding (<code class="inline">(event)</code>).</p>

<hr>

<h2>RxJS Terms</h2>

<h3>BehaviorSubject</h3>
<p>A Subject that requires an initial value and emits the current value to new subscribers. Used for state that always has a value.</p>

<h3>combineLatest</h3>
<p>An operator that combines the latest values from multiple observables. Emits whenever any source emits (after all have emitted at least once).</p>

<h3>distinctUntilChanged</h3>
<p>An operator that only emits when the current value differs from the previous value. Prevents duplicate emissions.</p>

<h3>filter</h3>
<p>An operator that emits only values that pass a predicate function.</p>

<h3>map</h3>
<p>An operator that transforms each emitted value using a projection function.</p>

<h3>Observable</h3>
<p>A lazy push collection that can emit zero or more values over time. Must be subscribed to for values to flow.</p>

<h3>Operator</h3>
<p>A function that transforms an observable stream. Applied via the <code class="inline">pipe()</code> method. Examples: <code class="inline">map</code>, <code class="inline">filter</code>, <code class="inline">switchMap</code>.</p>

<h3>pipe</h3>
<p>A method that chains operators together. <code class="inline">source$.pipe(op1, op2, op3)</code> applies operators in sequence.</p>

<h3>ReplaySubject</h3>
<p>A Subject that replays a specified number of previous values to new subscribers. Useful for late subscribers.</p>

<h3>shareReplay</h3>
<p>An operator that multicasts an observable and replays the last N values to new subscribers. Prevents duplicate API calls.</p>

<h3>Subject</h3>
<p>An observable that is also an observer. Can push values with <code class="inline">next()</code> and be subscribed to.</p>

<h3>subscribe</h3>
<p>The method that activates an observable and receives its values. Returns a Subscription that should be cleaned up.</p>

<h3>Subscription</h3>
<p>An object representing the execution of an observable. Call <code class="inline">unsubscribe()</code> to stop receiving values and prevent memory leaks.</p></div><div class="page-content"><h3>switchMap</h3>
<p>An operator that maps to an inner observable and cancels the previous inner observable on each new emission. Ideal for search/filter operations.</p>

<h3>takeUntil</h3>
<p>An operator that emits values until a notifier observable emits. Used for component cleanup with a <code class="inline">destroy$</code> subject.</p>

<h3>tap</h3>
<p>An operator that performs side effects (like logging) without modifying the stream.</p>

<hr>

<h2>URL-First Architecture Terms</h2>

<h3>Adapter</h3>
<p>A class that converts between framework types and domain-specific types. Examples: <code class="inline">AutomobileUrlMapper</code>, <code class="inline">AutomobileApiAdapter</code>.</p>

<h3>API Adapter</h3>
<p>An adapter that handles API communication for a specific domain. Implements <code class="inline">IApiAdapter&lt;TFilters, TData, TStatistics&gt;</code>.</p>

<h3>Cache Key Builder</h3>
<p>A class that generates unique cache keys from filter objects. Ensures API responses are cached correctly.</p>

<h3>Chart Data Source</h3>
<p>A class that transforms domain statistics into chart-ready data (Plotly traces). Each chart type has its own data source.</p>

<h3>Domain</h3>
<p>A specific area of functionality in the application. In vvroom, "automobile" is the domain. Other books might add "agriculture" or "real estate".</p>

<h3>Domain Config</h3>
<p>The central configuration object for a domain. Contains adapters, UI configs, and type references. Type: <code class="inline">DomainConfig&lt;TFilters, TData, TStatistics&gt;</code>.</p>

<h3>Domain Config Registry</h3>
<p>A service that stores and retrieves domain configurations. Allows framework code to access the active domain's config.</p>

<h3>Filter</h3>
<p>A set of criteria that narrow search results. In vvroom: manufacturer, model, year, body class, etc.</p>

<h3>Framework Code</h3>
<p>Domain-agnostic code that works with any domain through interfaces. Located in <code class="inline">src/app/framework/</code>.</p>

<h3>Highlight</h3>
<p>A visual emphasis on data that matches specific criteria. Highlights don't filter data; they color-code matching items.</p>

<h3>Pop-out Window</h3>
<p>A separate browser window displaying part of the application. Communicates with the main window via <code class="inline">postMessage</code>.</p>

<h3>Resource Management Service</h3>
<p>The central service managing data fetching, caching, and state. Coordinates URL state with API calls.</p></div><div class="page-content"><h3>Single Source of Truth</h3>
<p>A principle where one authoritative location stores each piece of state. In URL-First, the URL is the single source of truth for filter state.</p>

<h3>URL Mapper</h3>
<p>An adapter that converts between filter objects and URL query parameters. Bidirectional: <code class="inline">toParams()</code> and <code class="inline">fromParams()</code>.</p>

<h3>URL State Service</h3>
<p>A service that manages reading from and writing to URL query parameters. Provides reactive streams of URL state.</p>

<hr>

<h2>TypeScript Terms</h2>

<h3>Concrete Type</h3>
<p>A specific, known type like <code class="inline">string</code>, <code class="inline">number</code>, or <code class="inline">AutomobileFilters</code>. Contrast with type parameters.</p>

<h3>Constraint</h3>
<p>A limit on what types can be used as a type parameter. Syntax: <code class="inline">&lt;T extends SomeInterface&gt;</code>.</p>

<h3>Generic</h3>
<p>A type or function that works with multiple types through type parameters. Provides type safety without code duplication.</p>

<h3>Interface</h3>
<p>A TypeScript structure defining a contract for objects. Does not exist at runtime; only provides compile-time type checking.</p>

<h3>keyof</h3>
<p>A TypeScript operator that returns a union of an object's property names as string literal types.</p>

<h3>Partial&lt;T&gt;</h3>
<p>A utility type that makes all properties of T optional.</p>

<h3>Pick&lt;T, K&gt;</h3>
<p>A utility type that creates a new type with only the specified properties from T.</p>

<h3>Record&lt;K, V&gt;</h3>
<p>A utility type representing an object with keys of type K and values of type V.</p>

<h3>Type Guard</h3>
<p>A function that narrows a type within a conditional block. Uses <code class="inline">is</code> return type syntax.</p>

<h3>Type Parameter</h3>
<p>A placeholder type in a generic definition, filled in when the generic is used. Conventionally named <code class="inline">T</code>, <code class="inline">U</code>, or descriptively like <code class="inline">TFilters</code>.</p>

<h3>Union Type</h3>
<p>A type that can be one of several types. Syntax: <code class="inline">string | number | null</code>.</p>

<h3>Utility Type</h3>
<p>Built-in TypeScript types that transform other types. Examples: <code class="inline">Partial</code>, <code class="inline">Required</code>, <code class="inline">Pick</code>, <code class="inline">Omit</code>, <code class="inline">Record</code>.</p>

<hr>

<h2>UI Component Terms</h2>

<h3>Base Chart Component</h3>
<p>A reusable Plotly.js wrapper that works with any <code class="inline">ChartDataSource</code>. Handles rendering, resizing, and click events.</p>

<h3>Base Picker Component</h3>
<p>A reusable multi-select dropdown that works with any <code class="inline">PickerConfig</code>. Handles option loading and selection.</p></div><div class="page-content"><h3>CDK (Component Dev Kit)</h3>
<p>Angular's set of behavior primitives for building UI components. Used for drag-drop functionality.</p>

<h3>Dockview</h3>
<p>A third-party library providing tabbed, resizable, dockable panel layouts. Framework-agnostic.</p>

<h3>PrimeNG</h3>
<p>The UI component library used in vvroom. Provides styled components like tables, buttons, dialogs, etc.</p>

<h3>Query Panel</h3>
<p>A component displaying filter inputs for user-adjustable search criteria.</p>

<h3>Results Table</h3>
<p>A component displaying paginated search results in a table format.</p>

<h3>Statistics Panel</h3>
<p>A component displaying multiple charts showing data distributions.</p>

<hr>

<h2>API Terms</h2>

<h3>Base URL</h3>
<p>The root URL for all API endpoints. Configured in <code class="inline">environment.ts</code>.</p>

<h3>Endpoint</h3>
<p>A specific API URL path that accepts requests and returns responses. Example: <code class="inline">/api/specs/v1/search</code>.</p>

<h3>Pagination</h3>
<p>The practice of returning data in pages rather than all at once. API returns <code class="inline">page</code>, <code class="inline">size</code>, <code class="inline">totalItems</code>, <code class="inline">totalPages</code>.</p>

<h3>Query Parameter</h3>
<p>A key-value pair in a URL after the <code class="inline">?</code>. Example: <code class="inline">?manufacturer=Toyota&amp;year=2022</code>.</p>

<h3>Request</h3>
<p>An HTTP call to an API endpoint. Includes method (GET, POST), headers, and optional body.</p>

<h3>Response</h3>
<p>Data returned by an API. Includes status code, headers, and body (usually JSON).</p>

<hr>

<h2>Development Terms</h2>

<h3>Barrel Export</h3>
<p>An <code class="inline">index.ts</code> file that re-exports symbols from a directory, simplifying imports.</p>

<h3>Build</h3>
<p>The process of compiling TypeScript and bundling the application for deployment. Command: <code class="inline">ng build</code>.</p>

<h3>Hot Module Replacement (HMR)</h3>
<p>A development feature that updates modules without full page reload.</p>

<h3>Lazy Loading</h3>
<p>Loading modules on demand rather than at startup. Improves initial load time.</p>

<h3>Linting</h3>
<p>Static code analysis to catch errors and enforce style. Tool: ESLint.</p>

<h3>Serve</h3>
<p>Running the application in development mode with live reload. Command: <code class="inline">ng serve</code>.</p>

<h3>Tree Shaking</h3>
<p>Removing unused code during the build process. Reduces bundle size.</p>

<hr>

<h2>Key Acronyms</h2>

<table>
<p><thead><tr> <th>Acronym</th> <th>Meaning</th></p>
</tr></thead>
<p><tbody> <tr> <td>API</td> <td>Application Programming Interface</td></p>
</tr>
<p><tr> <td>CDK</td> <td>Component Dev Kit</td></p>
</tr>
<p><tr> <td>CLI</td> <td>Command Line Interface</td></p>
</tr>
<p><tr> <td>CORS</td> <td>Cross-Origin Resource Sharing</td></p>
</tr>
<p><tr> <td>CSS</td> <td>Cascading Style Sheets</td></p>
</tr>
<p><tr> <td>DI</td> <td>Dependency Injection</td></p>
</tr>
<p><tr> <td>DOM</td> <td>Document Object Model</td></p>
</tr>
<p><tr> <td>HTML</td> <td>HyperText Markup Language</td></p>
</tr>
<p><tr> <td>HTTP</td> <td>HyperText Transfer Protocol</td></p>
</tr>
<p><tr> <td>JSON</td> <td>JavaScript Object Notation</td></p>
</tr>
<p><tr> <td>RxJS</td> <td>Reactive Extensions for JavaScript</td></p>
</tr>
<p><tr> <td>SCSS</td> <td>Sassy CSS (CSS preprocessor)</td></p>
</tr>
<p><tr> <td>SPA</td> <td>Single Page Application</td></p>
</tr>
<p><tr> <td>URL</td> <td>Uniform Resource Locator</td></p>
</tr>
<p><tr> <td>VIN</td> <td>Vehicle Identification Number</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Further Reading</h2>

<p>For deeper understanding of these terms, refer to:</p>

<ul><li><a href="https://angular.io/guide/glossary">Angular Glossary</a></li>
<p><li><a href="https://www.typescriptlang.org/docs/handbook/">TypeScript Handbook</a></li> <li><a href="https://rxjs.dev/">RxJS Documentation</a></li> <li><a href="https://developer.mozilla.org/">MDN Web Docs</a></li></ul></p></div></div>
    <div class="chapter" id="section-A01">
        <div class="chapter-header">
            <div class="chapter-category">Appendix</div>
            <h1>A01: Styling and Branding</h1>
        </div>
<div class="page-content"><h1>Appendix A01: Styling and Branding</h1>

<h2>Overview</h2>

<p>This appendix documents the styling system and branding configuration for the vvroom application. The visual design follows the dark theme pattern established in generic-prime while applying vvroom-specific branding.</p>

<h2>Theme Configuration</h2>

<h3>PrimeNG Theme</h3>

<p>The application uses PrimeNG's <strong>lara-dark-blue</strong> theme as the base, providing:</p>
<ul><li>Dark background colors (#2a2a2a, #3c3c3c)</li>
<p><li>Blue accent colors (#64B5F6, #64c8ff)</li> <li>Consistent component styling</li></p>
</ul>
<h3>Global Styles (styles.scss)</h3>

<pre class="code-block scss"><code>/<em> PrimeNG Theme and Component Styles </em>/
<p>@import "primeng/resources/themes/lara-dark-blue/theme.css"; @import "primeng/resources/primeng.min.css"; @import "primeicons/primeicons.css";</p>

<p>/<em> KaTeX CSS for LaTeX rendering </em>/ @import "katex/dist/katex.min.css";</p>

<p>/<em> Global Styles </em>/</p>
<ul><li>{</li>
</ul>  box-sizing: border-box;
<p>}</p>

<p>body { margin: 0; font-family: var(--font-family); background-color: #3c3c3c; color: #ffffff; }</p>
</code></pre>

<h3>Color Palette</h3>

<table>
<p><thead><tr> <th>Purpose</th> <th>Color</th> <th>Usage</th></p>
</tr></thead>
<p><tbody> <tr> <td>Background (dark)</td> <td><code class="inline">#2a2a2a</code></td> <td>Header, panels</td></p>
</tr>
<p><tr> <td>Background (main)</td> <td><code class="inline">#3c3c3c</code></td> <td>Page background</td></p>
</tr>
<p><tr> <td>Text primary</td> <td><code class="inline">#ffffff</code></td> <td>Main text</td></p>
</tr>
<p><tr> <td>Text secondary</td> <td><code class="inline">#888888</code></td> <td>Version labels, hints</td></p>
</tr>
<p><tr> <td>Accent</td> <td><code class="inline">#64B5F6</code></td> <td>Interactive elements</td></p>
</tr>
<p><tr> <td>Accent hover</td> <td><code class="inline">#64c8ff</code></td> <td>Hover states</td></p>
</tr>
<p><tr> <td>Border</td> <td><code class="inline">#444444</code></td> <td>Dividers, separators</td></p>
</tr>
</tbody>
</table>

<h2>App Component Styling</h2>

<h3>Header Structure</h3>

<pre class="code-block scss"><code>.app-header {
<p>background-color: #2a2a2a; padding: 0.5rem 1rem; display: flex; justify-content: flex-start; align-items: center; gap: 2rem; border-bottom: 1px solid #444; height: 60px; }</p>
</code></pre>

<h3>Navigation Links</h3>

<pre class="code-block scss"><code>.home-link,
<p>.discover-link { color: #ffffff; text-decoration: none; font-size: 1.2rem; font-weight: bold; white-space: nowrap; cursor: pointer;</p>

<p>&amp;:hover { color: #64c8ff; } }</p>
</code></pre>

<h2>Branding Configuration</h2>

<h3>Domain Label</h3>

<p>The primary branding appears in the <strong>domain configuration</strong> (<code class="inline">domainLabel</code> property):</p>

<p><strong>File</strong>: <code class="inline">src/app/domain-config/automobile/automobile.domain-config.ts</code></p>

<pre class="code-block typescript"><code>return {
<p>domainName: 'automobile', domainLabel: 'Vvroom Discovery',  // Branding displayed in discover header apiBaseUrl: apiBaseUrl, // ... };</p>
</code></pre></div><div class="page-content"><h3>Application Title</h3>

<p><strong>File</strong>: <code class="inline">src/app/app.component.ts</code></p>

<pre class="code-block typescript"><code>@Component({ ... })
<p>export class AppComponent { title = 'vvroom'; // ... }</p>
</code></pre>

<h3>HTML Title</h3>

<p><strong>File</strong>: <code class="inline">src/index.html</code></p>

<pre class="code-block html"><code>&lt;title&gt;Vvroom - Automobile Discovery&lt;/title&gt;
</code></pre>

<h2>Pop-Out Window Styling</h2>

<p>Pop-out windows require special handling to hide scrollbars:</p>

<pre class="code-block scss"><code>body.popout-body {
<p>overflow: hidden; height: 100vh; width: 100vw; }</p>

<p>html.popout-html { overflow: hidden; height: 100vh; width: 100vw;</p>

<p>.app-content { overflow: hidden !important; height: 100vh !important; } }</p>
</code></pre>

<h2>Component Style Files</h2>

<p>Each component has its own SCSS file for component-specific styles:</p>

<table>
<p><thead><tr> <th>Component</th> <th>Style File</th></p>
</tr></thead>
<p><tbody> <tr> <td>App Shell</td> <td><code class="inline">app.component.scss</code></td></p>
</tr>
<p><tr> <td>Discover</td> <td><code class="inline">features/discover/discover.component.scss</code></td></p>
</tr>
<p><tr> <td>Home</td> <td><code class="inline">features/home/home.component.scss</code></td></p>
</tr>
<p><tr> <td>Query Control</td> <td><code class="inline">framework/components/query-control/query-control.component.scss</code></td></p>
</tr>
<p><tr> <td>Query Panel</td> <td><code class="inline">framework/components/query-panel/query-panel.component.scss</code></td></p>
</tr>
<p><tr> <td>Base Chart</td> <td><code class="inline">framework/components/base-chart/base-chart.component.scss</code></td></p>
</tr>
<p><tr> <td>Base Picker</td> <td><code class="inline">framework/components/base-picker/base-picker.component.scss</code></td></p>
</tr>
<p><tr> <td>Results Table</td> <td><code class="inline">framework/components/results-table/results-table.component.scss</code></td></p>
</tr>
<p><tr> <td>Statistics Panel</td> <td><code class="inline">framework/components/statistics-panel-2/statistics-panel-2.component.scss</code></td></p>
</tr>
</tbody>
</table>

<h2>Implementation Checklist</h2>

<ul><li>[ ] Import PrimeNG lara-dark-blue theme in styles.scss</li>
<p><li>[ ] Set body background to #3c3c3c</li> <li>[ ] Configure header with #2a2a2a background</li> <li>[ ] Update domainLabel to "Vvroom Discovery"</li> <li>[ ] Set app component title to "vvroom"</li> <li>[ ] Update index.html title tag</li> <li>[ ] Apply hover colors (#64c8ff) to interactive elements</li></p>
</ul>
<h2>Reference</h2>

<ul><li><strong>PrimeNG Themes</strong>: https://primeng.org/theming</li>
<p><li><strong>Source Reference</strong>: generic-prime/frontend/src/styles.scss</li> <li><strong>Color System</strong>: VS Code Dark Theme inspired</li></ul></p></div></div>
    <div class="chapter" id="section-A02">
        <div class="chapter-header">
            <div class="chapter-category">Appendix</div>
            <h1>A02: URL-First Testing Rubric</h1>
        </div>
<div class="page-content"><h1>Appendix A02: URL-First Testing Rubric</h1>

<h2>Overview</h2>

<p>This rubric provides a systematic method for verifying URL-First State Management compliance across popped-in and popped-out controls. The URL is the single source of truth; all state changes must flow through URL updates.</p>

<hr>

<h2>Test Categories</h2>

<h3>Category 1: Main Window (Popped-In) Control Changes</h3>

<p>Test that changes in the main window controls are reflected in:</p>
<ul><li>The browser URL parameters</li>
<p><li>All other controls in the main window</li> <li>Any open pop-out windows</li></p>
</ul>
<table>
<p><thead><tr> <th>Test ID</th> <th>Test Description</th> <th>Expected Behavior</th> <th>Pass/Fail</th></p>
</tr></thead>
<p><tbody> <tr> <td>M1.1</td> <td>Change a query control filter (e.g., manufacturer dropdown)</td> <td>URL updates with filter param; results table updates; statistics update</td> <td></td></p>
</tr>
<p><tr> <td>M1.2</td> <td>Change a highlight filter (e.g., year range)</td> <td>URL updates with <code class="inline">h_</code> prefixed param; highlighted rows change; pop-outs receive update</td> <td></td></p>
</tr>
<p><tr> <td>M1.3</td> <td>Change pagination (page number)</td> <td>URL updates with <code class="inline">page</code> param; table shows correct page</td> <td></td></p>
</tr>
<p><tr> <td>M1.4</td> <td>Change page size</td> <td>URL updates with <code class="inline">size</code> param; table row count matches</td> <td></td></p>
</tr>
<p><tr> <td>M1.5</td> <td>Change sort column</td> <td>URL updates with <code class="inline">sort</code> param; table re-sorts</td> <td></td></p>
</tr>
<p><tr> <td>M1.6</td> <td>Change sort direction</td> <td>URL updates with <code class="inline">sortDirection</code> param; table order reverses</td> <td></td></p>
</tr>
<p><tr> <td>M1.7</td> <td>Clear all filters</td> <td>URL params removed; controls reset to defaults; full dataset shown</td> <td></td></p>
</tr>
<p><tr> <td>M1.8</td> <td>Apply multiple filters simultaneously</td> <td>All filter params appear in URL; results reflect intersection</td> <td></td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Category 2: Pop-Out Window Control Changes</h3>

<p>Test that changes in pop-out windows are communicated to the main window and reflected appropriately.</p>

<table>
<p><thead><tr> <th>Test ID</th> <th>Test Description</th> <th>Expected Behavior</th> <th>Pass/Fail</th></p>
</tr></thead>
<p><tbody> <tr> <td>P2.1</td> <td>Change highlight filter in pop-out</td> <td>Main window URL updates with <code class="inline">h_</code> param; main window highlights update</td> <td></td></p>
</tr>
<p><tr> <td>P2.2</td> <td>Pop-out sends filter change message</td> <td>BroadcastChannel message received by main window</td> <td></td></p>
</tr>
<p><tr> <td>P2.3</td> <td>Pop-out does NOT update its own URL</td> <td>Pop-out URL remains static (initial state only)</td> <td></td></p>
</tr>
<p><tr> <td>P2.4</td> <td>Pop-out does NOT make its own API calls</td> <td>Network tab shows no API requests from pop-out after initial load</td> <td></td></p>
</tr>
<p><tr> <td>P2.5</td> <td>Pop-out receives state via BroadcastChannel</td> <td><code class="inline">syncStateFromExternal()</code> called; no API fetch triggered</td> <td></td></p>
</tr>
<p><tr> <td>P2.6</td> <td>Multiple pop-outs stay synchronized</td> <td>Change in one pop-out reflects in main window and all other pop-outs</td> <td></td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h3>Category 3: URL Paste Tests (Without Highlight Filters)</h3>

<p>Test that pasting a URL with standard filters correctly restores application state.</p>

<table>
<p><thead><tr> <th>Test ID</th> <th>Test Description</th> <th>Expected Behavior</th> <th>Pass/Fail</th></p>
</tr></thead>
<p><tbody> <tr> <td>U3.1</td> <td>Paste URL with single filter param</td> <td>Filter control shows correct value; results match filter</td> <td></td></p>
</tr>
<p><tr> <td>U3.2</td> <td>Paste URL with multiple filter params</td> <td>All filter controls populated; results show intersection</td> <td></td></p>
</tr>
<p><tr> <td>U3.3</td> <td>Paste URL with pagination params</td> <td>Correct page displayed; pagination control shows correct page</td> <td></td></p>
</tr>
<p><tr> <td>U3.4</td> <td>Paste URL with sort params</td> <td>Table sorted correctly; sort indicators match URL</td> <td></td></p>
</tr>
<p><tr> <td>U3.5</td> <td>Paste URL with all param types combined</td> <td>All controls reflect URL state; results correct</td> <td></td></p>
</tr>
<p><tr> <td>U3.6</td> <td>Paste URL with invalid filter value</td> <td>Graceful handling; invalid param ignored or defaulted</td> <td></td></p>
</tr>
<p><tr> <td>U3.7</td> <td>Share URL to another browser/session</td> <td>New session shows identical state to original</td> <td></td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Category 4: URL Paste Tests (With Highlight Filters)</h3>

<p>Test that pasting a URL with highlight filters (<code class="inline">h_</code> prefix) correctly applies highlighting.</p>

<table>
<p><thead><tr> <th>Test ID</th> <th>Test Description</th> <th>Expected Behavior</th> <th>Pass/Fail</th></p>
</tr></thead>
<p><tbody> <tr> <td>H4.1</td> <td>Paste URL with <code class="inline">h_yearMin</code> param</td> <td>Year highlight filter populated; matching rows highlighted</td> <td></td></p>
</tr>
<p><tr> <td>H4.2</td> <td>Paste URL with <code class="inline">h_manufacturer</code> param</td> <td>Manufacturer highlight populated; matching rows highlighted</td> <td></td></p>
</tr>
<p><tr> <td>H4.3</td> <td>Paste URL with multiple highlight params</td> <td>All highlight filters populated; rows matching ALL highlighted</td> <td></td></p>
</tr>
<p><tr> <td>H4.4</td> <td>Paste URL mixing query and highlight params</td> <td>Query filters filter data; highlight filters highlight within results</td> <td></td></p>
</tr>
<p><tr> <td>H4.5</td> <td>Paste URL with highlight param into pop-out</td> <td>Pop-out shows initial highlights; syncs with main window</td> <td></td></p>
</tr>
<p><tr> <td>H4.6</td> <td>Clear highlight via URL (remove <code class="inline">h_</code> param)</td> <td>Highlights removed; highlight controls cleared</td> <td></td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Category 5: Pop-Out Window Presentation</h3>

<p>Test that pop-out windows display correctly without main window chrome.</p>

<table>
<p><thead><tr> <th>Test ID</th> <th>Test Description</th> <th>Expected Behavior</th> <th>Pass/Fail</th></p>
</tr></thead>
<p><tbody> <tr> <td>W5.1</td> <td>Pop-out hides site banner/header</td> <td>No navigation header visible in pop-out</td> <td></td></p>
</tr>
<p><tr> <td>W5.2</td> <td>Pop-out shows query control panel</td> <td>Filter controls visible and functional</td> <td></td></p>
</tr>
<p><tr> <td>W5.3</td> <td>Pop-out URL contains <code class="inline">popout=true</code> param</td> <td>URL includes pop-out indicator</td> <td></td></p>
</tr>
<p><tr> <td>W5.4</td> <td>Pop-out title reflects content</td> <td>Window title indicates popped-out component</td> <td></td></p>
</tr>
<p><tr> <td>W5.5</td> <td>Pop-out respects <code class="inline">autoFetch = false</code></td> <td>No initial API call; waits for main window data</td> <td></td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h3>Category 6: Cross-Window Synchronization</h3>

<p>Test bidirectional communication between main window and pop-outs.</p>

<table>
<p><thead><tr> <th>Test ID</th> <th>Test Description</th> <th>Expected Behavior</th> <th>Pass/Fail</th></p>
</tr></thead>
<p><tbody> <tr> <td>S6.1</td> <td>Main window filter change updates all pop-outs</td> <td>All pop-outs receive BroadcastChannel message and update</td> <td></td></p>
</tr>
<p><tr> <td>S6.2</td> <td>Pop-out filter change updates main window URL</td> <td>Main window URL reflects pop-out's requested change</td> <td></td></p>
</tr>
<p><tr> <td>S6.3</td> <td>Main window data refresh updates pop-outs</td> <td>New API data propagated to all pop-outs</td> <td></td></p>
</tr>
<p><tr> <td>S6.4</td> <td>Close pop-out does not affect main window state</td> <td>Main window continues functioning normally</td> <td></td></p>
</tr>
<p><tr> <td>S6.5</td> <td>Open multiple pop-outs of same type</td> <td>Each pop-out shows consistent state</td> <td></td></p>
</tr>
<p><tr> <td>S6.6</td> <td>Open pop-outs of different types</td> <td>Each receives relevant state updates</td> <td></td></p>
</tr>
</tbody>
</table>

<hr>

<h3>Category 7: Router Navigate Encapsulation</h3>

<p>Verify that <code class="inline">router.navigate()</code> is only called from <code class="inline">UrlStateService</code>.</p>

<table>
<p><thead><tr> <th>Test ID</th> <th>Test Description</th> <th>Expected Behavior</th> <th>Pass/Fail</th></p>
</tr></thead>
<p><tbody> <tr> <td>R7.1</td> <td>Grep codebase for <code class="inline">router.navigate</code></td> <td>Only appears in <code class="inline">url-state.service.ts</code></td> <td></td></p>
</tr>
<p><tr> <td>R7.2</td> <td>Components call <code class="inline">updateFilters()</code> method</td> <td>Components never call <code class="inline">router.navigate()</code> directly</td> <td></td></p>
</tr>
<p><tr> <td>R7.3</td> <td>Pop-out components call parent messaging</td> <td>No <code class="inline">router.navigate()</code> in pop-out components</td> <td></td></p>
</tr>
</tbody>
</table>

<hr>

<h2>Anti-Pattern Checklist</h2>

<p>These patterns indicate URL-First violations and should fail testing:</p>

<table>
<p><thead><tr> <th>Anti-Pattern</th> <th>How to Detect</th> <th>Severity</th></p>
</tr></thead>
<p><tbody> <tr> <td>Direct state mutation bypassing URL</td> <td>State changes without URL param update</td> <td>Critical</td></p>
</tr>
<p><tr> <td><code class="inline">router.navigate()</code> in components</td> <td>Grep for <code class="inline">router.navigate</code> outside UrlStateService</td> <td>Critical</td></p>
</tr>
<p><tr> <td>Pop-out making API calls</td> <td>Network tab shows fetch from pop-out window</td> <td>Critical</td></p>
</tr>
<p><tr> <td>Pop-out updating its own URL</td> <td>Pop-out URL changes after initial load</td> <td>Critical</td></p>
</tr>
<p><tr> <td>State not in URL that should be shareable</td> <td>Filter applied but not in URL; refresh loses state</td> <td>High</td></p>
</tr>
<p><tr> <td>Highlight state without <code class="inline">h_</code> prefix</td> <td>Highlight params using wrong naming convention</td> <td>Medium</td></p>
</tr>
</tbody>
</table></div><div class="page-content"><hr>

<h2>Test Execution Checklist</h2>

<p>Before running tests:</p>
<ul><li>[ ] Development server running on port 4207</li>
<p><li>[ ] Browser DevTools Network tab open (to verify API calls)</li> <li>[ ] Browser DevTools Console open (to catch errors)</li> <li>[ ] At least one pop-out window open for cross-window tests</li></p>
</ul>
<p>After each test:</p>
<ul><li>[ ] Verify URL params match expected state</li>
<p><li>[ ] Verify all controls reflect URL state</li> <li>[ ] Verify pop-out windows synchronized (if applicable)</li> <li>[ ] Check console for errors</li></p>
</ul>
<hr>

<h2>Known Issues (Observed)</h2>

<p>The following issues were observed during initial inspection and should be addressed:</p>

<ul><li><strong>Pop-out URL incorrect</strong> - Pop-out window URL does not reflect expected state</li>
<p><li><strong>Pop-out shows site banner</strong> - Header/navigation visible in pop-out (should be hidden)</li> <li><strong>Query control not visible in pop-out</strong> - Filter panel missing from pop-out view</li></p>
</ul>
<hr>

<h2>References</h2>

<ul><li><a href="../instructions.md">instructions.md</a> - URL-First Compliance Checklist</li>
<p><li><a href="A01-styling-and-branding.md">A01-styling-and-branding.md</a> - Theme configuration</li> <li><code class="inline">~/projects/vroom/docs/STATE-MANAGEMENT-SPECIFICATION.md</code> - Complete specification</li> <li><code class="inline">~/projects/vroom/docs/POPOUT-ARCHITECTURE.md</code> - Cross-window communication</li></ul></p></div></div>
</body>
</html>
